/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/index.ts");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/dat.gui/build/dat.gui.module.js":
/*!******************************************************!*\
  !*** ./node_modules/dat.gui/build/dat.gui.module.js ***!
  \******************************************************/
/*! exports provided: color, controllers, dom, gui, GUI, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "color", function() { return color; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "controllers", function() { return controllers; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dom", function() { return dom$1; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "gui", function() { return gui; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GUI", function() { return GUI$1; });
/**
 * dat-gui JavaScript Controller Library
 * http://code.google.com/p/dat-gui
 *
 * Copyright 2011 Data Arts Team, Google Creative Lab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 */

function ___$insertStyle(css) {
  if (!css) {
    return;
  }
  if (typeof window === 'undefined') {
    return;
  }

  var style = document.createElement('style');

  style.setAttribute('type', 'text/css');
  style.innerHTML = css;
  document.head.appendChild(style);

  return css;
}

function colorToString (color, forceCSSHex) {
  var colorFormat = color.__state.conversionName.toString();
  var r = Math.round(color.r);
  var g = Math.round(color.g);
  var b = Math.round(color.b);
  var a = color.a;
  var h = Math.round(color.h);
  var s = color.s.toFixed(1);
  var v = color.v.toFixed(1);
  if (forceCSSHex || colorFormat === 'THREE_CHAR_HEX' || colorFormat === 'SIX_CHAR_HEX') {
    var str = color.hex.toString(16);
    while (str.length < 6) {
      str = '0' + str;
    }
    return '#' + str;
  } else if (colorFormat === 'CSS_RGB') {
    return 'rgb(' + r + ',' + g + ',' + b + ')';
  } else if (colorFormat === 'CSS_RGBA') {
    return 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';
  } else if (colorFormat === 'HEX') {
    return '0x' + color.hex.toString(16);
  } else if (colorFormat === 'RGB_ARRAY') {
    return '[' + r + ',' + g + ',' + b + ']';
  } else if (colorFormat === 'RGBA_ARRAY') {
    return '[' + r + ',' + g + ',' + b + ',' + a + ']';
  } else if (colorFormat === 'RGB_OBJ') {
    return '{r:' + r + ',g:' + g + ',b:' + b + '}';
  } else if (colorFormat === 'RGBA_OBJ') {
    return '{r:' + r + ',g:' + g + ',b:' + b + ',a:' + a + '}';
  } else if (colorFormat === 'HSV_OBJ') {
    return '{h:' + h + ',s:' + s + ',v:' + v + '}';
  } else if (colorFormat === 'HSVA_OBJ') {
    return '{h:' + h + ',s:' + s + ',v:' + v + ',a:' + a + '}';
  }
  return 'unknown format';
}

var ARR_EACH = Array.prototype.forEach;
var ARR_SLICE = Array.prototype.slice;
var Common = {
  BREAK: {},
  extend: function extend(target) {
    this.each(ARR_SLICE.call(arguments, 1), function (obj) {
      var keys = this.isObject(obj) ? Object.keys(obj) : [];
      keys.forEach(function (key) {
        if (!this.isUndefined(obj[key])) {
          target[key] = obj[key];
        }
      }.bind(this));
    }, this);
    return target;
  },
  defaults: function defaults(target) {
    this.each(ARR_SLICE.call(arguments, 1), function (obj) {
      var keys = this.isObject(obj) ? Object.keys(obj) : [];
      keys.forEach(function (key) {
        if (this.isUndefined(target[key])) {
          target[key] = obj[key];
        }
      }.bind(this));
    }, this);
    return target;
  },
  compose: function compose() {
    var toCall = ARR_SLICE.call(arguments);
    return function () {
      var args = ARR_SLICE.call(arguments);
      for (var i = toCall.length - 1; i >= 0; i--) {
        args = [toCall[i].apply(this, args)];
      }
      return args[0];
    };
  },
  each: function each(obj, itr, scope) {
    if (!obj) {
      return;
    }
    if (ARR_EACH && obj.forEach && obj.forEach === ARR_EACH) {
      obj.forEach(itr, scope);
    } else if (obj.length === obj.length + 0) {
      var key = void 0;
      var l = void 0;
      for (key = 0, l = obj.length; key < l; key++) {
        if (key in obj && itr.call(scope, obj[key], key) === this.BREAK) {
          return;
        }
      }
    } else {
      for (var _key in obj) {
        if (itr.call(scope, obj[_key], _key) === this.BREAK) {
          return;
        }
      }
    }
  },
  defer: function defer(fnc) {
    setTimeout(fnc, 0);
  },
  debounce: function debounce(func, threshold, callImmediately) {
    var timeout = void 0;
    return function () {
      var obj = this;
      var args = arguments;
      function delayed() {
        timeout = null;
        if (!callImmediately) func.apply(obj, args);
      }
      var callNow = callImmediately || !timeout;
      clearTimeout(timeout);
      timeout = setTimeout(delayed, threshold);
      if (callNow) {
        func.apply(obj, args);
      }
    };
  },
  toArray: function toArray(obj) {
    if (obj.toArray) return obj.toArray();
    return ARR_SLICE.call(obj);
  },
  isUndefined: function isUndefined(obj) {
    return obj === undefined;
  },
  isNull: function isNull(obj) {
    return obj === null;
  },
  isNaN: function (_isNaN) {
    function isNaN(_x) {
      return _isNaN.apply(this, arguments);
    }
    isNaN.toString = function () {
      return _isNaN.toString();
    };
    return isNaN;
  }(function (obj) {
    return isNaN(obj);
  }),
  isArray: Array.isArray || function (obj) {
    return obj.constructor === Array;
  },
  isObject: function isObject(obj) {
    return obj === Object(obj);
  },
  isNumber: function isNumber(obj) {
    return obj === obj + 0;
  },
  isString: function isString(obj) {
    return obj === obj + '';
  },
  isBoolean: function isBoolean(obj) {
    return obj === false || obj === true;
  },
  isFunction: function isFunction(obj) {
    return obj instanceof Function;
  }
};

var INTERPRETATIONS = [
{
  litmus: Common.isString,
  conversions: {
    THREE_CHAR_HEX: {
      read: function read(original) {
        var test = original.match(/^#([A-F0-9])([A-F0-9])([A-F0-9])$/i);
        if (test === null) {
          return false;
        }
        return {
          space: 'HEX',
          hex: parseInt('0x' + test[1].toString() + test[1].toString() + test[2].toString() + test[2].toString() + test[3].toString() + test[3].toString(), 0)
        };
      },
      write: colorToString
    },
    SIX_CHAR_HEX: {
      read: function read(original) {
        var test = original.match(/^#([A-F0-9]{6})$/i);
        if (test === null) {
          return false;
        }
        return {
          space: 'HEX',
          hex: parseInt('0x' + test[1].toString(), 0)
        };
      },
      write: colorToString
    },
    CSS_RGB: {
      read: function read(original) {
        var test = original.match(/^rgb\(\s*(.+)\s*,\s*(.+)\s*,\s*(.+)\s*\)/);
        if (test === null) {
          return false;
        }
        return {
          space: 'RGB',
          r: parseFloat(test[1]),
          g: parseFloat(test[2]),
          b: parseFloat(test[3])
        };
      },
      write: colorToString
    },
    CSS_RGBA: {
      read: function read(original) {
        var test = original.match(/^rgba\(\s*(.+)\s*,\s*(.+)\s*,\s*(.+)\s*,\s*(.+)\s*\)/);
        if (test === null) {
          return false;
        }
        return {
          space: 'RGB',
          r: parseFloat(test[1]),
          g: parseFloat(test[2]),
          b: parseFloat(test[3]),
          a: parseFloat(test[4])
        };
      },
      write: colorToString
    }
  }
},
{
  litmus: Common.isNumber,
  conversions: {
    HEX: {
      read: function read(original) {
        return {
          space: 'HEX',
          hex: original,
          conversionName: 'HEX'
        };
      },
      write: function write(color) {
        return color.hex;
      }
    }
  }
},
{
  litmus: Common.isArray,
  conversions: {
    RGB_ARRAY: {
      read: function read(original) {
        if (original.length !== 3) {
          return false;
        }
        return {
          space: 'RGB',
          r: original[0],
          g: original[1],
          b: original[2]
        };
      },
      write: function write(color) {
        return [color.r, color.g, color.b];
      }
    },
    RGBA_ARRAY: {
      read: function read(original) {
        if (original.length !== 4) return false;
        return {
          space: 'RGB',
          r: original[0],
          g: original[1],
          b: original[2],
          a: original[3]
        };
      },
      write: function write(color) {
        return [color.r, color.g, color.b, color.a];
      }
    }
  }
},
{
  litmus: Common.isObject,
  conversions: {
    RGBA_OBJ: {
      read: function read(original) {
        if (Common.isNumber(original.r) && Common.isNumber(original.g) && Common.isNumber(original.b) && Common.isNumber(original.a)) {
          return {
            space: 'RGB',
            r: original.r,
            g: original.g,
            b: original.b,
            a: original.a
          };
        }
        return false;
      },
      write: function write(color) {
        return {
          r: color.r,
          g: color.g,
          b: color.b,
          a: color.a
        };
      }
    },
    RGB_OBJ: {
      read: function read(original) {
        if (Common.isNumber(original.r) && Common.isNumber(original.g) && Common.isNumber(original.b)) {
          return {
            space: 'RGB',
            r: original.r,
            g: original.g,
            b: original.b
          };
        }
        return false;
      },
      write: function write(color) {
        return {
          r: color.r,
          g: color.g,
          b: color.b
        };
      }
    },
    HSVA_OBJ: {
      read: function read(original) {
        if (Common.isNumber(original.h) && Common.isNumber(original.s) && Common.isNumber(original.v) && Common.isNumber(original.a)) {
          return {
            space: 'HSV',
            h: original.h,
            s: original.s,
            v: original.v,
            a: original.a
          };
        }
        return false;
      },
      write: function write(color) {
        return {
          h: color.h,
          s: color.s,
          v: color.v,
          a: color.a
        };
      }
    },
    HSV_OBJ: {
      read: function read(original) {
        if (Common.isNumber(original.h) && Common.isNumber(original.s) && Common.isNumber(original.v)) {
          return {
            space: 'HSV',
            h: original.h,
            s: original.s,
            v: original.v
          };
        }
        return false;
      },
      write: function write(color) {
        return {
          h: color.h,
          s: color.s,
          v: color.v
        };
      }
    }
  }
}];
var result = void 0;
var toReturn = void 0;
var interpret = function interpret() {
  toReturn = false;
  var original = arguments.length > 1 ? Common.toArray(arguments) : arguments[0];
  Common.each(INTERPRETATIONS, function (family) {
    if (family.litmus(original)) {
      Common.each(family.conversions, function (conversion, conversionName) {
        result = conversion.read(original);
        if (toReturn === false && result !== false) {
          toReturn = result;
          result.conversionName = conversionName;
          result.conversion = conversion;
          return Common.BREAK;
        }
      });
      return Common.BREAK;
    }
  });
  return toReturn;
};

var tmpComponent = void 0;
var ColorMath = {
  hsv_to_rgb: function hsv_to_rgb(h, s, v) {
    var hi = Math.floor(h / 60) % 6;
    var f = h / 60 - Math.floor(h / 60);
    var p = v * (1.0 - s);
    var q = v * (1.0 - f * s);
    var t = v * (1.0 - (1.0 - f) * s);
    var c = [[v, t, p], [q, v, p], [p, v, t], [p, q, v], [t, p, v], [v, p, q]][hi];
    return {
      r: c[0] * 255,
      g: c[1] * 255,
      b: c[2] * 255
    };
  },
  rgb_to_hsv: function rgb_to_hsv(r, g, b) {
    var min = Math.min(r, g, b);
    var max = Math.max(r, g, b);
    var delta = max - min;
    var h = void 0;
    var s = void 0;
    if (max !== 0) {
      s = delta / max;
    } else {
      return {
        h: NaN,
        s: 0,
        v: 0
      };
    }
    if (r === max) {
      h = (g - b) / delta;
    } else if (g === max) {
      h = 2 + (b - r) / delta;
    } else {
      h = 4 + (r - g) / delta;
    }
    h /= 6;
    if (h < 0) {
      h += 1;
    }
    return {
      h: h * 360,
      s: s,
      v: max / 255
    };
  },
  rgb_to_hex: function rgb_to_hex(r, g, b) {
    var hex = this.hex_with_component(0, 2, r);
    hex = this.hex_with_component(hex, 1, g);
    hex = this.hex_with_component(hex, 0, b);
    return hex;
  },
  component_from_hex: function component_from_hex(hex, componentIndex) {
    return hex >> componentIndex * 8 & 0xFF;
  },
  hex_with_component: function hex_with_component(hex, componentIndex, value) {
    return value << (tmpComponent = componentIndex * 8) | hex & ~(0xFF << tmpComponent);
  }
};

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
  return typeof obj;
} : function (obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
};











var classCallCheck = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

var createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();







var get = function get(object, property, receiver) {
  if (object === null) object = Function.prototype;
  var desc = Object.getOwnPropertyDescriptor(object, property);

  if (desc === undefined) {
    var parent = Object.getPrototypeOf(object);

    if (parent === null) {
      return undefined;
    } else {
      return get(parent, property, receiver);
    }
  } else if ("value" in desc) {
    return desc.value;
  } else {
    var getter = desc.get;

    if (getter === undefined) {
      return undefined;
    }

    return getter.call(receiver);
  }
};

var inherits = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
};











var possibleConstructorReturn = function (self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && (typeof call === "object" || typeof call === "function") ? call : self;
};

var Color = function () {
  function Color() {
    classCallCheck(this, Color);
    this.__state = interpret.apply(this, arguments);
    if (this.__state === false) {
      throw new Error('Failed to interpret color arguments');
    }
    this.__state.a = this.__state.a || 1;
  }
  createClass(Color, [{
    key: 'toString',
    value: function toString() {
      return colorToString(this);
    }
  }, {
    key: 'toHexString',
    value: function toHexString() {
      return colorToString(this, true);
    }
  }, {
    key: 'toOriginal',
    value: function toOriginal() {
      return this.__state.conversion.write(this);
    }
  }]);
  return Color;
}();
function defineRGBComponent(target, component, componentHexIndex) {
  Object.defineProperty(target, component, {
    get: function get$$1() {
      if (this.__state.space === 'RGB') {
        return this.__state[component];
      }
      Color.recalculateRGB(this, component, componentHexIndex);
      return this.__state[component];
    },
    set: function set$$1(v) {
      if (this.__state.space !== 'RGB') {
        Color.recalculateRGB(this, component, componentHexIndex);
        this.__state.space = 'RGB';
      }
      this.__state[component] = v;
    }
  });
}
function defineHSVComponent(target, component) {
  Object.defineProperty(target, component, {
    get: function get$$1() {
      if (this.__state.space === 'HSV') {
        return this.__state[component];
      }
      Color.recalculateHSV(this);
      return this.__state[component];
    },
    set: function set$$1(v) {
      if (this.__state.space !== 'HSV') {
        Color.recalculateHSV(this);
        this.__state.space = 'HSV';
      }
      this.__state[component] = v;
    }
  });
}
Color.recalculateRGB = function (color, component, componentHexIndex) {
  if (color.__state.space === 'HEX') {
    color.__state[component] = ColorMath.component_from_hex(color.__state.hex, componentHexIndex);
  } else if (color.__state.space === 'HSV') {
    Common.extend(color.__state, ColorMath.hsv_to_rgb(color.__state.h, color.__state.s, color.__state.v));
  } else {
    throw new Error('Corrupted color state');
  }
};
Color.recalculateHSV = function (color) {
  var result = ColorMath.rgb_to_hsv(color.r, color.g, color.b);
  Common.extend(color.__state, {
    s: result.s,
    v: result.v
  });
  if (!Common.isNaN(result.h)) {
    color.__state.h = result.h;
  } else if (Common.isUndefined(color.__state.h)) {
    color.__state.h = 0;
  }
};
Color.COMPONENTS = ['r', 'g', 'b', 'h', 's', 'v', 'hex', 'a'];
defineRGBComponent(Color.prototype, 'r', 2);
defineRGBComponent(Color.prototype, 'g', 1);
defineRGBComponent(Color.prototype, 'b', 0);
defineHSVComponent(Color.prototype, 'h');
defineHSVComponent(Color.prototype, 's');
defineHSVComponent(Color.prototype, 'v');
Object.defineProperty(Color.prototype, 'a', {
  get: function get$$1() {
    return this.__state.a;
  },
  set: function set$$1(v) {
    this.__state.a = v;
  }
});
Object.defineProperty(Color.prototype, 'hex', {
  get: function get$$1() {
    if (this.__state.space !== 'HEX') {
      this.__state.hex = ColorMath.rgb_to_hex(this.r, this.g, this.b);
      this.__state.space = 'HEX';
    }
    return this.__state.hex;
  },
  set: function set$$1(v) {
    this.__state.space = 'HEX';
    this.__state.hex = v;
  }
});

var Controller = function () {
  function Controller(object, property) {
    classCallCheck(this, Controller);
    this.initialValue = object[property];
    this.domElement = document.createElement('div');
    this.object = object;
    this.property = property;
    this.__onChange = undefined;
    this.__onFinishChange = undefined;
  }
  createClass(Controller, [{
    key: 'onChange',
    value: function onChange(fnc) {
      this.__onChange = fnc;
      return this;
    }
  }, {
    key: 'onFinishChange',
    value: function onFinishChange(fnc) {
      this.__onFinishChange = fnc;
      return this;
    }
  }, {
    key: 'setValue',
    value: function setValue(newValue) {
      this.object[this.property] = newValue;
      if (this.__onChange) {
        this.__onChange.call(this, newValue);
      }
      this.updateDisplay();
      return this;
    }
  }, {
    key: 'getValue',
    value: function getValue() {
      return this.object[this.property];
    }
  }, {
    key: 'updateDisplay',
    value: function updateDisplay() {
      return this;
    }
  }, {
    key: 'isModified',
    value: function isModified() {
      return this.initialValue !== this.getValue();
    }
  }]);
  return Controller;
}();

var EVENT_MAP = {
  HTMLEvents: ['change'],
  MouseEvents: ['click', 'mousemove', 'mousedown', 'mouseup', 'mouseover'],
  KeyboardEvents: ['keydown']
};
var EVENT_MAP_INV = {};
Common.each(EVENT_MAP, function (v, k) {
  Common.each(v, function (e) {
    EVENT_MAP_INV[e] = k;
  });
});
var CSS_VALUE_PIXELS = /(\d+(\.\d+)?)px/;
function cssValueToPixels(val) {
  if (val === '0' || Common.isUndefined(val)) {
    return 0;
  }
  var match = val.match(CSS_VALUE_PIXELS);
  if (!Common.isNull(match)) {
    return parseFloat(match[1]);
  }
  return 0;
}
var dom = {
  makeSelectable: function makeSelectable(elem, selectable) {
    if (elem === undefined || elem.style === undefined) return;
    elem.onselectstart = selectable ? function () {
      return false;
    } : function () {};
    elem.style.MozUserSelect = selectable ? 'auto' : 'none';
    elem.style.KhtmlUserSelect = selectable ? 'auto' : 'none';
    elem.unselectable = selectable ? 'on' : 'off';
  },
  makeFullscreen: function makeFullscreen(elem, hor, vert) {
    var vertical = vert;
    var horizontal = hor;
    if (Common.isUndefined(horizontal)) {
      horizontal = true;
    }
    if (Common.isUndefined(vertical)) {
      vertical = true;
    }
    elem.style.position = 'absolute';
    if (horizontal) {
      elem.style.left = 0;
      elem.style.right = 0;
    }
    if (vertical) {
      elem.style.top = 0;
      elem.style.bottom = 0;
    }
  },
  fakeEvent: function fakeEvent(elem, eventType, pars, aux) {
    var params = pars || {};
    var className = EVENT_MAP_INV[eventType];
    if (!className) {
      throw new Error('Event type ' + eventType + ' not supported.');
    }
    var evt = document.createEvent(className);
    switch (className) {
      case 'MouseEvents':
        {
          var clientX = params.x || params.clientX || 0;
          var clientY = params.y || params.clientY || 0;
          evt.initMouseEvent(eventType, params.bubbles || false, params.cancelable || true, window, params.clickCount || 1, 0,
          0,
          clientX,
          clientY,
          false, false, false, false, 0, null);
          break;
        }
      case 'KeyboardEvents':
        {
          var init = evt.initKeyboardEvent || evt.initKeyEvent;
          Common.defaults(params, {
            cancelable: true,
            ctrlKey: false,
            altKey: false,
            shiftKey: false,
            metaKey: false,
            keyCode: undefined,
            charCode: undefined
          });
          init(eventType, params.bubbles || false, params.cancelable, window, params.ctrlKey, params.altKey, params.shiftKey, params.metaKey, params.keyCode, params.charCode);
          break;
        }
      default:
        {
          evt.initEvent(eventType, params.bubbles || false, params.cancelable || true);
          break;
        }
    }
    Common.defaults(evt, aux);
    elem.dispatchEvent(evt);
  },
  bind: function bind(elem, event, func, newBool) {
    var bool = newBool || false;
    if (elem.addEventListener) {
      elem.addEventListener(event, func, bool);
    } else if (elem.attachEvent) {
      elem.attachEvent('on' + event, func);
    }
    return dom;
  },
  unbind: function unbind(elem, event, func, newBool) {
    var bool = newBool || false;
    if (elem.removeEventListener) {
      elem.removeEventListener(event, func, bool);
    } else if (elem.detachEvent) {
      elem.detachEvent('on' + event, func);
    }
    return dom;
  },
  addClass: function addClass(elem, className) {
    if (elem.className === undefined) {
      elem.className = className;
    } else if (elem.className !== className) {
      var classes = elem.className.split(/ +/);
      if (classes.indexOf(className) === -1) {
        classes.push(className);
        elem.className = classes.join(' ').replace(/^\s+/, '').replace(/\s+$/, '');
      }
    }
    return dom;
  },
  removeClass: function removeClass(elem, className) {
    if (className) {
      if (elem.className === className) {
        elem.removeAttribute('class');
      } else {
        var classes = elem.className.split(/ +/);
        var index = classes.indexOf(className);
        if (index !== -1) {
          classes.splice(index, 1);
          elem.className = classes.join(' ');
        }
      }
    } else {
      elem.className = undefined;
    }
    return dom;
  },
  hasClass: function hasClass(elem, className) {
    return new RegExp('(?:^|\\s+)' + className + '(?:\\s+|$)').test(elem.className) || false;
  },
  getWidth: function getWidth(elem) {
    var style = getComputedStyle(elem);
    return cssValueToPixels(style['border-left-width']) + cssValueToPixels(style['border-right-width']) + cssValueToPixels(style['padding-left']) + cssValueToPixels(style['padding-right']) + cssValueToPixels(style.width);
  },
  getHeight: function getHeight(elem) {
    var style = getComputedStyle(elem);
    return cssValueToPixels(style['border-top-width']) + cssValueToPixels(style['border-bottom-width']) + cssValueToPixels(style['padding-top']) + cssValueToPixels(style['padding-bottom']) + cssValueToPixels(style.height);
  },
  getOffset: function getOffset(el) {
    var elem = el;
    var offset = { left: 0, top: 0 };
    if (elem.offsetParent) {
      do {
        offset.left += elem.offsetLeft;
        offset.top += elem.offsetTop;
        elem = elem.offsetParent;
      } while (elem);
    }
    return offset;
  },
  isActive: function isActive(elem) {
    return elem === document.activeElement && (elem.type || elem.href);
  }
};

var BooleanController = function (_Controller) {
  inherits(BooleanController, _Controller);
  function BooleanController(object, property) {
    classCallCheck(this, BooleanController);
    var _this2 = possibleConstructorReturn(this, (BooleanController.__proto__ || Object.getPrototypeOf(BooleanController)).call(this, object, property));
    var _this = _this2;
    _this2.__prev = _this2.getValue();
    _this2.__checkbox = document.createElement('input');
    _this2.__checkbox.setAttribute('type', 'checkbox');
    function onChange() {
      _this.setValue(!_this.__prev);
    }
    dom.bind(_this2.__checkbox, 'change', onChange, false);
    _this2.domElement.appendChild(_this2.__checkbox);
    _this2.updateDisplay();
    return _this2;
  }
  createClass(BooleanController, [{
    key: 'setValue',
    value: function setValue(v) {
      var toReturn = get(BooleanController.prototype.__proto__ || Object.getPrototypeOf(BooleanController.prototype), 'setValue', this).call(this, v);
      if (this.__onFinishChange) {
        this.__onFinishChange.call(this, this.getValue());
      }
      this.__prev = this.getValue();
      return toReturn;
    }
  }, {
    key: 'updateDisplay',
    value: function updateDisplay() {
      if (this.getValue() === true) {
        this.__checkbox.setAttribute('checked', 'checked');
        this.__checkbox.checked = true;
        this.__prev = true;
      } else {
        this.__checkbox.checked = false;
        this.__prev = false;
      }
      return get(BooleanController.prototype.__proto__ || Object.getPrototypeOf(BooleanController.prototype), 'updateDisplay', this).call(this);
    }
  }]);
  return BooleanController;
}(Controller);

var OptionController = function (_Controller) {
  inherits(OptionController, _Controller);
  function OptionController(object, property, opts) {
    classCallCheck(this, OptionController);
    var _this2 = possibleConstructorReturn(this, (OptionController.__proto__ || Object.getPrototypeOf(OptionController)).call(this, object, property));
    var options = opts;
    var _this = _this2;
    _this2.__select = document.createElement('select');
    if (Common.isArray(options)) {
      var map = {};
      Common.each(options, function (element) {
        map[element] = element;
      });
      options = map;
    }
    Common.each(options, function (value, key) {
      var opt = document.createElement('option');
      opt.innerHTML = key;
      opt.setAttribute('value', value);
      _this.__select.appendChild(opt);
    });
    _this2.updateDisplay();
    dom.bind(_this2.__select, 'change', function () {
      var desiredValue = this.options[this.selectedIndex].value;
      _this.setValue(desiredValue);
    });
    _this2.domElement.appendChild(_this2.__select);
    return _this2;
  }
  createClass(OptionController, [{
    key: 'setValue',
    value: function setValue(v) {
      var toReturn = get(OptionController.prototype.__proto__ || Object.getPrototypeOf(OptionController.prototype), 'setValue', this).call(this, v);
      if (this.__onFinishChange) {
        this.__onFinishChange.call(this, this.getValue());
      }
      return toReturn;
    }
  }, {
    key: 'updateDisplay',
    value: function updateDisplay() {
      if (dom.isActive(this.__select)) return this;
      this.__select.value = this.getValue();
      return get(OptionController.prototype.__proto__ || Object.getPrototypeOf(OptionController.prototype), 'updateDisplay', this).call(this);
    }
  }]);
  return OptionController;
}(Controller);

var StringController = function (_Controller) {
  inherits(StringController, _Controller);
  function StringController(object, property) {
    classCallCheck(this, StringController);
    var _this2 = possibleConstructorReturn(this, (StringController.__proto__ || Object.getPrototypeOf(StringController)).call(this, object, property));
    var _this = _this2;
    function onChange() {
      _this.setValue(_this.__input.value);
    }
    function onBlur() {
      if (_this.__onFinishChange) {
        _this.__onFinishChange.call(_this, _this.getValue());
      }
    }
    _this2.__input = document.createElement('input');
    _this2.__input.setAttribute('type', 'text');
    dom.bind(_this2.__input, 'keyup', onChange);
    dom.bind(_this2.__input, 'change', onChange);
    dom.bind(_this2.__input, 'blur', onBlur);
    dom.bind(_this2.__input, 'keydown', function (e) {
      if (e.keyCode === 13) {
        this.blur();
      }
    });
    _this2.updateDisplay();
    _this2.domElement.appendChild(_this2.__input);
    return _this2;
  }
  createClass(StringController, [{
    key: 'updateDisplay',
    value: function updateDisplay() {
      if (!dom.isActive(this.__input)) {
        this.__input.value = this.getValue();
      }
      return get(StringController.prototype.__proto__ || Object.getPrototypeOf(StringController.prototype), 'updateDisplay', this).call(this);
    }
  }]);
  return StringController;
}(Controller);

function numDecimals(x) {
  var _x = x.toString();
  if (_x.indexOf('.') > -1) {
    return _x.length - _x.indexOf('.') - 1;
  }
  return 0;
}
var NumberController = function (_Controller) {
  inherits(NumberController, _Controller);
  function NumberController(object, property, params) {
    classCallCheck(this, NumberController);
    var _this = possibleConstructorReturn(this, (NumberController.__proto__ || Object.getPrototypeOf(NumberController)).call(this, object, property));
    var _params = params || {};
    _this.__min = _params.min;
    _this.__max = _params.max;
    _this.__step = _params.step;
    if (Common.isUndefined(_this.__step)) {
      if (_this.initialValue === 0) {
        _this.__impliedStep = 1;
      } else {
        _this.__impliedStep = Math.pow(10, Math.floor(Math.log(Math.abs(_this.initialValue)) / Math.LN10)) / 10;
      }
    } else {
      _this.__impliedStep = _this.__step;
    }
    _this.__precision = numDecimals(_this.__impliedStep);
    return _this;
  }
  createClass(NumberController, [{
    key: 'setValue',
    value: function setValue(v) {
      var _v = v;
      if (this.__min !== undefined && _v < this.__min) {
        _v = this.__min;
      } else if (this.__max !== undefined && _v > this.__max) {
        _v = this.__max;
      }
      if (this.__step !== undefined && _v % this.__step !== 0) {
        _v = Math.round(_v / this.__step) * this.__step;
      }
      return get(NumberController.prototype.__proto__ || Object.getPrototypeOf(NumberController.prototype), 'setValue', this).call(this, _v);
    }
  }, {
    key: 'min',
    value: function min(minValue) {
      this.__min = minValue;
      return this;
    }
  }, {
    key: 'max',
    value: function max(maxValue) {
      this.__max = maxValue;
      return this;
    }
  }, {
    key: 'step',
    value: function step(stepValue) {
      this.__step = stepValue;
      this.__impliedStep = stepValue;
      this.__precision = numDecimals(stepValue);
      return this;
    }
  }]);
  return NumberController;
}(Controller);

function roundToDecimal(value, decimals) {
  var tenTo = Math.pow(10, decimals);
  return Math.round(value * tenTo) / tenTo;
}
var NumberControllerBox = function (_NumberController) {
  inherits(NumberControllerBox, _NumberController);
  function NumberControllerBox(object, property, params) {
    classCallCheck(this, NumberControllerBox);
    var _this2 = possibleConstructorReturn(this, (NumberControllerBox.__proto__ || Object.getPrototypeOf(NumberControllerBox)).call(this, object, property, params));
    _this2.__truncationSuspended = false;
    var _this = _this2;
    var prevY = void 0;
    function onChange() {
      var attempted = parseFloat(_this.__input.value);
      if (!Common.isNaN(attempted)) {
        _this.setValue(attempted);
      }
    }
    function onFinish() {
      if (_this.__onFinishChange) {
        _this.__onFinishChange.call(_this, _this.getValue());
      }
    }
    function onBlur() {
      onFinish();
    }
    function onMouseDrag(e) {
      var diff = prevY - e.clientY;
      _this.setValue(_this.getValue() + diff * _this.__impliedStep);
      prevY = e.clientY;
    }
    function onMouseUp() {
      dom.unbind(window, 'mousemove', onMouseDrag);
      dom.unbind(window, 'mouseup', onMouseUp);
      onFinish();
    }
    function onMouseDown(e) {
      dom.bind(window, 'mousemove', onMouseDrag);
      dom.bind(window, 'mouseup', onMouseUp);
      prevY = e.clientY;
    }
    _this2.__input = document.createElement('input');
    _this2.__input.setAttribute('type', 'text');
    dom.bind(_this2.__input, 'change', onChange);
    dom.bind(_this2.__input, 'blur', onBlur);
    dom.bind(_this2.__input, 'mousedown', onMouseDown);
    dom.bind(_this2.__input, 'keydown', function (e) {
      if (e.keyCode === 13) {
        _this.__truncationSuspended = true;
        this.blur();
        _this.__truncationSuspended = false;
        onFinish();
      }
    });
    _this2.updateDisplay();
    _this2.domElement.appendChild(_this2.__input);
    return _this2;
  }
  createClass(NumberControllerBox, [{
    key: 'updateDisplay',
    value: function updateDisplay() {
      this.__input.value = this.__truncationSuspended ? this.getValue() : roundToDecimal(this.getValue(), this.__precision);
      return get(NumberControllerBox.prototype.__proto__ || Object.getPrototypeOf(NumberControllerBox.prototype), 'updateDisplay', this).call(this);
    }
  }]);
  return NumberControllerBox;
}(NumberController);

function map(v, i1, i2, o1, o2) {
  return o1 + (o2 - o1) * ((v - i1) / (i2 - i1));
}
var NumberControllerSlider = function (_NumberController) {
  inherits(NumberControllerSlider, _NumberController);
  function NumberControllerSlider(object, property, min, max, step) {
    classCallCheck(this, NumberControllerSlider);
    var _this2 = possibleConstructorReturn(this, (NumberControllerSlider.__proto__ || Object.getPrototypeOf(NumberControllerSlider)).call(this, object, property, { min: min, max: max, step: step }));
    var _this = _this2;
    _this2.__background = document.createElement('div');
    _this2.__foreground = document.createElement('div');
    dom.bind(_this2.__background, 'mousedown', onMouseDown);
    dom.bind(_this2.__background, 'touchstart', onTouchStart);
    dom.addClass(_this2.__background, 'slider');
    dom.addClass(_this2.__foreground, 'slider-fg');
    function onMouseDown(e) {
      document.activeElement.blur();
      dom.bind(window, 'mousemove', onMouseDrag);
      dom.bind(window, 'mouseup', onMouseUp);
      onMouseDrag(e);
    }
    function onMouseDrag(e) {
      e.preventDefault();
      var bgRect = _this.__background.getBoundingClientRect();
      _this.setValue(map(e.clientX, bgRect.left, bgRect.right, _this.__min, _this.__max));
      return false;
    }
    function onMouseUp() {
      dom.unbind(window, 'mousemove', onMouseDrag);
      dom.unbind(window, 'mouseup', onMouseUp);
      if (_this.__onFinishChange) {
        _this.__onFinishChange.call(_this, _this.getValue());
      }
    }
    function onTouchStart(e) {
      if (e.touches.length !== 1) {
        return;
      }
      dom.bind(window, 'touchmove', onTouchMove);
      dom.bind(window, 'touchend', onTouchEnd);
      onTouchMove(e);
    }
    function onTouchMove(e) {
      var clientX = e.touches[0].clientX;
      var bgRect = _this.__background.getBoundingClientRect();
      _this.setValue(map(clientX, bgRect.left, bgRect.right, _this.__min, _this.__max));
    }
    function onTouchEnd() {
      dom.unbind(window, 'touchmove', onTouchMove);
      dom.unbind(window, 'touchend', onTouchEnd);
      if (_this.__onFinishChange) {
        _this.__onFinishChange.call(_this, _this.getValue());
      }
    }
    _this2.updateDisplay();
    _this2.__background.appendChild(_this2.__foreground);
    _this2.domElement.appendChild(_this2.__background);
    return _this2;
  }
  createClass(NumberControllerSlider, [{
    key: 'updateDisplay',
    value: function updateDisplay() {
      var pct = (this.getValue() - this.__min) / (this.__max - this.__min);
      this.__foreground.style.width = pct * 100 + '%';
      return get(NumberControllerSlider.prototype.__proto__ || Object.getPrototypeOf(NumberControllerSlider.prototype), 'updateDisplay', this).call(this);
    }
  }]);
  return NumberControllerSlider;
}(NumberController);

var FunctionController = function (_Controller) {
  inherits(FunctionController, _Controller);
  function FunctionController(object, property, text) {
    classCallCheck(this, FunctionController);
    var _this2 = possibleConstructorReturn(this, (FunctionController.__proto__ || Object.getPrototypeOf(FunctionController)).call(this, object, property));
    var _this = _this2;
    _this2.__button = document.createElement('div');
    _this2.__button.innerHTML = text === undefined ? 'Fire' : text;
    dom.bind(_this2.__button, 'click', function (e) {
      e.preventDefault();
      _this.fire();
      return false;
    });
    dom.addClass(_this2.__button, 'button');
    _this2.domElement.appendChild(_this2.__button);
    return _this2;
  }
  createClass(FunctionController, [{
    key: 'fire',
    value: function fire() {
      if (this.__onChange) {
        this.__onChange.call(this);
      }
      this.getValue().call(this.object);
      if (this.__onFinishChange) {
        this.__onFinishChange.call(this, this.getValue());
      }
    }
  }]);
  return FunctionController;
}(Controller);

var ColorController = function (_Controller) {
  inherits(ColorController, _Controller);
  function ColorController(object, property) {
    classCallCheck(this, ColorController);
    var _this2 = possibleConstructorReturn(this, (ColorController.__proto__ || Object.getPrototypeOf(ColorController)).call(this, object, property));
    _this2.__color = new Color(_this2.getValue());
    _this2.__temp = new Color(0);
    var _this = _this2;
    _this2.domElement = document.createElement('div');
    dom.makeSelectable(_this2.domElement, false);
    _this2.__selector = document.createElement('div');
    _this2.__selector.className = 'selector';
    _this2.__saturation_field = document.createElement('div');
    _this2.__saturation_field.className = 'saturation-field';
    _this2.__field_knob = document.createElement('div');
    _this2.__field_knob.className = 'field-knob';
    _this2.__field_knob_border = '2px solid ';
    _this2.__hue_knob = document.createElement('div');
    _this2.__hue_knob.className = 'hue-knob';
    _this2.__hue_field = document.createElement('div');
    _this2.__hue_field.className = 'hue-field';
    _this2.__input = document.createElement('input');
    _this2.__input.type = 'text';
    _this2.__input_textShadow = '0 1px 1px ';
    dom.bind(_this2.__input, 'keydown', function (e) {
      if (e.keyCode === 13) {
        onBlur.call(this);
      }
    });
    dom.bind(_this2.__input, 'blur', onBlur);
    dom.bind(_this2.__selector, 'mousedown', function ()        {
      dom.addClass(this, 'drag').bind(window, 'mouseup', function ()        {
        dom.removeClass(_this.__selector, 'drag');
      });
    });
    dom.bind(_this2.__selector, 'touchstart', function ()        {
      dom.addClass(this, 'drag').bind(window, 'touchend', function ()        {
        dom.removeClass(_this.__selector, 'drag');
      });
    });
    var valueField = document.createElement('div');
    Common.extend(_this2.__selector.style, {
      width: '122px',
      height: '102px',
      padding: '3px',
      backgroundColor: '#222',
      boxShadow: '0px 1px 3px rgba(0,0,0,0.3)'
    });
    Common.extend(_this2.__field_knob.style, {
      position: 'absolute',
      width: '12px',
      height: '12px',
      border: _this2.__field_knob_border + (_this2.__color.v < 0.5 ? '#fff' : '#000'),
      boxShadow: '0px 1px 3px rgba(0,0,0,0.5)',
      borderRadius: '12px',
      zIndex: 1
    });
    Common.extend(_this2.__hue_knob.style, {
      position: 'absolute',
      width: '15px',
      height: '2px',
      borderRight: '4px solid #fff',
      zIndex: 1
    });
    Common.extend(_this2.__saturation_field.style, {
      width: '100px',
      height: '100px',
      border: '1px solid #555',
      marginRight: '3px',
      display: 'inline-block',
      cursor: 'pointer'
    });
    Common.extend(valueField.style, {
      width: '100%',
      height: '100%',
      background: 'none'
    });
    linearGradient(valueField, 'top', 'rgba(0,0,0,0)', '#000');
    Common.extend(_this2.__hue_field.style, {
      width: '15px',
      height: '100px',
      border: '1px solid #555',
      cursor: 'ns-resize',
      position: 'absolute',
      top: '3px',
      right: '3px'
    });
    hueGradient(_this2.__hue_field);
    Common.extend(_this2.__input.style, {
      outline: 'none',
      textAlign: 'center',
      color: '#fff',
      border: 0,
      fontWeight: 'bold',
      textShadow: _this2.__input_textShadow + 'rgba(0,0,0,0.7)'
    });
    dom.bind(_this2.__saturation_field, 'mousedown', fieldDown);
    dom.bind(_this2.__saturation_field, 'touchstart', fieldDown);
    dom.bind(_this2.__field_knob, 'mousedown', fieldDown);
    dom.bind(_this2.__field_knob, 'touchstart', fieldDown);
    dom.bind(_this2.__hue_field, 'mousedown', fieldDownH);
    dom.bind(_this2.__hue_field, 'touchstart', fieldDownH);
    function fieldDown(e) {
      setSV(e);
      dom.bind(window, 'mousemove', setSV);
      dom.bind(window, 'touchmove', setSV);
      dom.bind(window, 'mouseup', fieldUpSV);
      dom.bind(window, 'touchend', fieldUpSV);
    }
    function fieldDownH(e) {
      setH(e);
      dom.bind(window, 'mousemove', setH);
      dom.bind(window, 'touchmove', setH);
      dom.bind(window, 'mouseup', fieldUpH);
      dom.bind(window, 'touchend', fieldUpH);
    }
    function fieldUpSV() {
      dom.unbind(window, 'mousemove', setSV);
      dom.unbind(window, 'touchmove', setSV);
      dom.unbind(window, 'mouseup', fieldUpSV);
      dom.unbind(window, 'touchend', fieldUpSV);
      onFinish();
    }
    function fieldUpH() {
      dom.unbind(window, 'mousemove', setH);
      dom.unbind(window, 'touchmove', setH);
      dom.unbind(window, 'mouseup', fieldUpH);
      dom.unbind(window, 'touchend', fieldUpH);
      onFinish();
    }
    function onBlur() {
      var i = interpret(this.value);
      if (i !== false) {
        _this.__color.__state = i;
        _this.setValue(_this.__color.toOriginal());
      } else {
        this.value = _this.__color.toString();
      }
    }
    function onFinish() {
      if (_this.__onFinishChange) {
        _this.__onFinishChange.call(_this, _this.__color.toOriginal());
      }
    }
    _this2.__saturation_field.appendChild(valueField);
    _this2.__selector.appendChild(_this2.__field_knob);
    _this2.__selector.appendChild(_this2.__saturation_field);
    _this2.__selector.appendChild(_this2.__hue_field);
    _this2.__hue_field.appendChild(_this2.__hue_knob);
    _this2.domElement.appendChild(_this2.__input);
    _this2.domElement.appendChild(_this2.__selector);
    _this2.updateDisplay();
    function setSV(e) {
      if (e.type.indexOf('touch') === -1) {
        e.preventDefault();
      }
      var fieldRect = _this.__saturation_field.getBoundingClientRect();
      var _ref = e.touches && e.touches[0] || e,
          clientX = _ref.clientX,
          clientY = _ref.clientY;
      var s = (clientX - fieldRect.left) / (fieldRect.right - fieldRect.left);
      var v = 1 - (clientY - fieldRect.top) / (fieldRect.bottom - fieldRect.top);
      if (v > 1) {
        v = 1;
      } else if (v < 0) {
        v = 0;
      }
      if (s > 1) {
        s = 1;
      } else if (s < 0) {
        s = 0;
      }
      _this.__color.v = v;
      _this.__color.s = s;
      _this.setValue(_this.__color.toOriginal());
      return false;
    }
    function setH(e) {
      if (e.type.indexOf('touch') === -1) {
        e.preventDefault();
      }
      var fieldRect = _this.__hue_field.getBoundingClientRect();
      var _ref2 = e.touches && e.touches[0] || e,
          clientY = _ref2.clientY;
      var h = 1 - (clientY - fieldRect.top) / (fieldRect.bottom - fieldRect.top);
      if (h > 1) {
        h = 1;
      } else if (h < 0) {
        h = 0;
      }
      _this.__color.h = h * 360;
      _this.setValue(_this.__color.toOriginal());
      return false;
    }
    return _this2;
  }
  createClass(ColorController, [{
    key: 'updateDisplay',
    value: function updateDisplay() {
      var i = interpret(this.getValue());
      if (i !== false) {
        var mismatch = false;
        Common.each(Color.COMPONENTS, function (component) {
          if (!Common.isUndefined(i[component]) && !Common.isUndefined(this.__color.__state[component]) && i[component] !== this.__color.__state[component]) {
            mismatch = true;
            return {};
          }
        }, this);
        if (mismatch) {
          Common.extend(this.__color.__state, i);
        }
      }
      Common.extend(this.__temp.__state, this.__color.__state);
      this.__temp.a = 1;
      var flip = this.__color.v < 0.5 || this.__color.s > 0.5 ? 255 : 0;
      var _flip = 255 - flip;
      Common.extend(this.__field_knob.style, {
        marginLeft: 100 * this.__color.s - 7 + 'px',
        marginTop: 100 * (1 - this.__color.v) - 7 + 'px',
        backgroundColor: this.__temp.toHexString(),
        border: this.__field_knob_border + 'rgb(' + flip + ',' + flip + ',' + flip + ')'
      });
      this.__hue_knob.style.marginTop = (1 - this.__color.h / 360) * 100 + 'px';
      this.__temp.s = 1;
      this.__temp.v = 1;
      linearGradient(this.__saturation_field, 'left', '#fff', this.__temp.toHexString());
      this.__input.value = this.__color.toString();
      Common.extend(this.__input.style, {
        backgroundColor: this.__color.toHexString(),
        color: 'rgb(' + flip + ',' + flip + ',' + flip + ')',
        textShadow: this.__input_textShadow + 'rgba(' + _flip + ',' + _flip + ',' + _flip + ',.7)'
      });
    }
  }]);
  return ColorController;
}(Controller);
var vendors = ['-moz-', '-o-', '-webkit-', '-ms-', ''];
function linearGradient(elem, x, a, b) {
  elem.style.background = '';
  Common.each(vendors, function (vendor) {
    elem.style.cssText += 'background: ' + vendor + 'linear-gradient(' + x + ', ' + a + ' 0%, ' + b + ' 100%); ';
  });
}
function hueGradient(elem) {
  elem.style.background = '';
  elem.style.cssText += 'background: -moz-linear-gradient(top,  #ff0000 0%, #ff00ff 17%, #0000ff 34%, #00ffff 50%, #00ff00 67%, #ffff00 84%, #ff0000 100%);';
  elem.style.cssText += 'background: -webkit-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);';
  elem.style.cssText += 'background: -o-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);';
  elem.style.cssText += 'background: -ms-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);';
  elem.style.cssText += 'background: linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);';
}

var css = {
  load: function load(url, indoc) {
    var doc = indoc || document;
    var link = doc.createElement('link');
    link.type = 'text/css';
    link.rel = 'stylesheet';
    link.href = url;
    doc.getElementsByTagName('head')[0].appendChild(link);
  },
  inject: function inject(cssContent, indoc) {
    var doc = indoc || document;
    var injected = document.createElement('style');
    injected.type = 'text/css';
    injected.innerHTML = cssContent;
    var head = doc.getElementsByTagName('head')[0];
    try {
      head.appendChild(injected);
    } catch (e) {
    }
  }
};

var saveDialogContents = "<div id=\"dg-save\" class=\"dg dialogue\">\n\n  Here's the new load parameter for your <code>GUI</code>'s constructor:\n\n  <textarea id=\"dg-new-constructor\"></textarea>\n\n  <div id=\"dg-save-locally\">\n\n    <input id=\"dg-local-storage\" type=\"checkbox\"/> Automatically save\n    values to <code>localStorage</code> on exit.\n\n    <div id=\"dg-local-explain\">The values saved to <code>localStorage</code> will\n      override those passed to <code>dat.GUI</code>'s constructor. This makes it\n      easier to work incrementally, but <code>localStorage</code> is fragile,\n      and your friends may not see the same values you do.\n\n    </div>\n\n  </div>\n\n</div>";

var ControllerFactory = function ControllerFactory(object, property) {
  var initialValue = object[property];
  if (Common.isArray(arguments[2]) || Common.isObject(arguments[2])) {
    return new OptionController(object, property, arguments[2]);
  }
  if (Common.isNumber(initialValue)) {
    if (Common.isNumber(arguments[2]) && Common.isNumber(arguments[3])) {
      if (Common.isNumber(arguments[4])) {
        return new NumberControllerSlider(object, property, arguments[2], arguments[3], arguments[4]);
      }
      return new NumberControllerSlider(object, property, arguments[2], arguments[3]);
    }
    if (Common.isNumber(arguments[4])) {
      return new NumberControllerBox(object, property, { min: arguments[2], max: arguments[3], step: arguments[4] });
    }
    return new NumberControllerBox(object, property, { min: arguments[2], max: arguments[3] });
  }
  if (Common.isString(initialValue)) {
    return new StringController(object, property);
  }
  if (Common.isFunction(initialValue)) {
    return new FunctionController(object, property, '');
  }
  if (Common.isBoolean(initialValue)) {
    return new BooleanController(object, property);
  }
  return null;
};

function requestAnimationFrame(callback) {
  setTimeout(callback, 1000 / 60);
}
var requestAnimationFrame$1 = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || requestAnimationFrame;

var CenteredDiv = function () {
  function CenteredDiv() {
    classCallCheck(this, CenteredDiv);
    this.backgroundElement = document.createElement('div');
    Common.extend(this.backgroundElement.style, {
      backgroundColor: 'rgba(0,0,0,0.8)',
      top: 0,
      left: 0,
      display: 'none',
      zIndex: '1000',
      opacity: 0,
      WebkitTransition: 'opacity 0.2s linear',
      transition: 'opacity 0.2s linear'
    });
    dom.makeFullscreen(this.backgroundElement);
    this.backgroundElement.style.position = 'fixed';
    this.domElement = document.createElement('div');
    Common.extend(this.domElement.style, {
      position: 'fixed',
      display: 'none',
      zIndex: '1001',
      opacity: 0,
      WebkitTransition: '-webkit-transform 0.2s ease-out, opacity 0.2s linear',
      transition: 'transform 0.2s ease-out, opacity 0.2s linear'
    });
    document.body.appendChild(this.backgroundElement);
    document.body.appendChild(this.domElement);
    var _this = this;
    dom.bind(this.backgroundElement, 'click', function () {
      _this.hide();
    });
  }
  createClass(CenteredDiv, [{
    key: 'show',
    value: function show() {
      var _this = this;
      this.backgroundElement.style.display = 'block';
      this.domElement.style.display = 'block';
      this.domElement.style.opacity = 0;
      this.domElement.style.webkitTransform = 'scale(1.1)';
      this.layout();
      Common.defer(function () {
        _this.backgroundElement.style.opacity = 1;
        _this.domElement.style.opacity = 1;
        _this.domElement.style.webkitTransform = 'scale(1)';
      });
    }
  }, {
    key: 'hide',
    value: function hide() {
      var _this = this;
      var hide = function hide() {
        _this.domElement.style.display = 'none';
        _this.backgroundElement.style.display = 'none';
        dom.unbind(_this.domElement, 'webkitTransitionEnd', hide);
        dom.unbind(_this.domElement, 'transitionend', hide);
        dom.unbind(_this.domElement, 'oTransitionEnd', hide);
      };
      dom.bind(this.domElement, 'webkitTransitionEnd', hide);
      dom.bind(this.domElement, 'transitionend', hide);
      dom.bind(this.domElement, 'oTransitionEnd', hide);
      this.backgroundElement.style.opacity = 0;
      this.domElement.style.opacity = 0;
      this.domElement.style.webkitTransform = 'scale(1.1)';
    }
  }, {
    key: 'layout',
    value: function layout() {
      this.domElement.style.left = window.innerWidth / 2 - dom.getWidth(this.domElement) / 2 + 'px';
      this.domElement.style.top = window.innerHeight / 2 - dom.getHeight(this.domElement) / 2 + 'px';
    }
  }]);
  return CenteredDiv;
}();

var styleSheet = ___$insertStyle(".dg ul{list-style:none;margin:0;padding:0;width:100%;clear:both}.dg.ac{position:fixed;top:0;left:0;right:0;height:0;z-index:0}.dg:not(.ac) .main{overflow:hidden}.dg.main{-webkit-transition:opacity .1s linear;-o-transition:opacity .1s linear;-moz-transition:opacity .1s linear;transition:opacity .1s linear}.dg.main.taller-than-window{overflow-y:auto}.dg.main.taller-than-window .close-button{opacity:1;margin-top:-1px;border-top:1px solid #2c2c2c}.dg.main ul.closed .close-button{opacity:1 !important}.dg.main:hover .close-button,.dg.main .close-button.drag{opacity:1}.dg.main .close-button{-webkit-transition:opacity .1s linear;-o-transition:opacity .1s linear;-moz-transition:opacity .1s linear;transition:opacity .1s linear;border:0;line-height:19px;height:20px;cursor:pointer;text-align:center;background-color:#000}.dg.main .close-button.close-top{position:relative}.dg.main .close-button.close-bottom{position:absolute}.dg.main .close-button:hover{background-color:#111}.dg.a{float:right;margin-right:15px;overflow-y:visible}.dg.a.has-save>ul.close-top{margin-top:0}.dg.a.has-save>ul.close-bottom{margin-top:27px}.dg.a.has-save>ul.closed{margin-top:0}.dg.a .save-row{top:0;z-index:1002}.dg.a .save-row.close-top{position:relative}.dg.a .save-row.close-bottom{position:fixed}.dg li{-webkit-transition:height .1s ease-out;-o-transition:height .1s ease-out;-moz-transition:height .1s ease-out;transition:height .1s ease-out;-webkit-transition:overflow .1s linear;-o-transition:overflow .1s linear;-moz-transition:overflow .1s linear;transition:overflow .1s linear}.dg li:not(.folder){cursor:auto;height:27px;line-height:27px;padding:0 4px 0 5px}.dg li.folder{padding:0;border-left:4px solid rgba(0,0,0,0)}.dg li.title{cursor:pointer;margin-left:-4px}.dg .closed li:not(.title),.dg .closed ul li,.dg .closed ul li>*{height:0;overflow:hidden;border:0}.dg .cr{clear:both;padding-left:3px;height:27px;overflow:hidden}.dg .property-name{cursor:default;float:left;clear:left;width:40%;overflow:hidden;text-overflow:ellipsis}.dg .c{float:left;width:60%;position:relative}.dg .c input[type=text]{border:0;margin-top:4px;padding:3px;width:100%;float:right}.dg .has-slider input[type=text]{width:30%;margin-left:0}.dg .slider{float:left;width:66%;margin-left:-5px;margin-right:0;height:19px;margin-top:4px}.dg .slider-fg{height:100%}.dg .c input[type=checkbox]{margin-top:7px}.dg .c select{margin-top:5px}.dg .cr.function,.dg .cr.function .property-name,.dg .cr.function *,.dg .cr.boolean,.dg .cr.boolean *{cursor:pointer}.dg .cr.color{overflow:visible}.dg .selector{display:none;position:absolute;margin-left:-9px;margin-top:23px;z-index:10}.dg .c:hover .selector,.dg .selector.drag{display:block}.dg li.save-row{padding:0}.dg li.save-row .button{display:inline-block;padding:0px 6px}.dg.dialogue{background-color:#222;width:460px;padding:15px;font-size:13px;line-height:15px}#dg-new-constructor{padding:10px;color:#222;font-family:Monaco, monospace;font-size:10px;border:0;resize:none;box-shadow:inset 1px 1px 1px #888;word-wrap:break-word;margin:12px 0;display:block;width:440px;overflow-y:scroll;height:100px;position:relative}#dg-local-explain{display:none;font-size:11px;line-height:17px;border-radius:3px;background-color:#333;padding:8px;margin-top:10px}#dg-local-explain code{font-size:10px}#dat-gui-save-locally{display:none}.dg{color:#eee;font:11px 'Lucida Grande', sans-serif;text-shadow:0 -1px 0 #111}.dg.main::-webkit-scrollbar{width:5px;background:#1a1a1a}.dg.main::-webkit-scrollbar-corner{height:0;display:none}.dg.main::-webkit-scrollbar-thumb{border-radius:5px;background:#676767}.dg li:not(.folder){background:#1a1a1a;border-bottom:1px solid #2c2c2c}.dg li.save-row{line-height:25px;background:#dad5cb;border:0}.dg li.save-row select{margin-left:5px;width:108px}.dg li.save-row .button{margin-left:5px;margin-top:1px;border-radius:2px;font-size:9px;line-height:7px;padding:4px 4px 5px 4px;background:#c5bdad;color:#fff;text-shadow:0 1px 0 #b0a58f;box-shadow:0 -1px 0 #b0a58f;cursor:pointer}.dg li.save-row .button.gears{background:#c5bdad url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAsAAAANCAYAAAB/9ZQ7AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAQJJREFUeNpiYKAU/P//PwGIC/ApCABiBSAW+I8AClAcgKxQ4T9hoMAEUrxx2QSGN6+egDX+/vWT4e7N82AMYoPAx/evwWoYoSYbACX2s7KxCxzcsezDh3evFoDEBYTEEqycggWAzA9AuUSQQgeYPa9fPv6/YWm/Acx5IPb7ty/fw+QZblw67vDs8R0YHyQhgObx+yAJkBqmG5dPPDh1aPOGR/eugW0G4vlIoTIfyFcA+QekhhHJhPdQxbiAIguMBTQZrPD7108M6roWYDFQiIAAv6Aow/1bFwXgis+f2LUAynwoIaNcz8XNx3Dl7MEJUDGQpx9gtQ8YCueB+D26OECAAQDadt7e46D42QAAAABJRU5ErkJggg==) 2px 1px no-repeat;height:7px;width:8px}.dg li.save-row .button:hover{background-color:#bab19e;box-shadow:0 -1px 0 #b0a58f}.dg li.folder{border-bottom:0}.dg li.title{padding-left:16px;background:#000 url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlI+hKgFxoCgAOw==) 6px 10px no-repeat;cursor:pointer;border-bottom:1px solid rgba(255,255,255,0.2)}.dg .closed li.title{background-image:url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlGIWqMCbWAEAOw==)}.dg .cr.boolean{border-left:3px solid #806787}.dg .cr.color{border-left:3px solid}.dg .cr.function{border-left:3px solid #e61d5f}.dg .cr.number{border-left:3px solid #2FA1D6}.dg .cr.number input[type=text]{color:#2FA1D6}.dg .cr.string{border-left:3px solid #1ed36f}.dg .cr.string input[type=text]{color:#1ed36f}.dg .cr.function:hover,.dg .cr.boolean:hover{background:#111}.dg .c input[type=text]{background:#303030;outline:none}.dg .c input[type=text]:hover{background:#3c3c3c}.dg .c input[type=text]:focus{background:#494949;color:#fff}.dg .c .slider{background:#303030;cursor:ew-resize}.dg .c .slider-fg{background:#2FA1D6;max-width:100%}.dg .c .slider:hover{background:#3c3c3c}.dg .c .slider:hover .slider-fg{background:#44abda}\n");

css.inject(styleSheet);
var CSS_NAMESPACE = 'dg';
var HIDE_KEY_CODE = 72;
var CLOSE_BUTTON_HEIGHT = 20;
var DEFAULT_DEFAULT_PRESET_NAME = 'Default';
var SUPPORTS_LOCAL_STORAGE = function () {
  try {
    return !!window.localStorage;
  } catch (e) {
    return false;
  }
}();
var SAVE_DIALOGUE = void 0;
var autoPlaceVirgin = true;
var autoPlaceContainer = void 0;
var hide = false;
var hideableGuis = [];
var GUI = function GUI(pars) {
  var _this = this;
  var params = pars || {};
  this.domElement = document.createElement('div');
  this.__ul = document.createElement('ul');
  this.domElement.appendChild(this.__ul);
  dom.addClass(this.domElement, CSS_NAMESPACE);
  this.__folders = {};
  this.__controllers = [];
  this.__rememberedObjects = [];
  this.__rememberedObjectIndecesToControllers = [];
  this.__listening = [];
  params = Common.defaults(params, {
    closeOnTop: false,
    autoPlace: true,
    width: GUI.DEFAULT_WIDTH
  });
  params = Common.defaults(params, {
    resizable: params.autoPlace,
    hideable: params.autoPlace
  });
  if (!Common.isUndefined(params.load)) {
    if (params.preset) {
      params.load.preset = params.preset;
    }
  } else {
    params.load = { preset: DEFAULT_DEFAULT_PRESET_NAME };
  }
  if (Common.isUndefined(params.parent) && params.hideable) {
    hideableGuis.push(this);
  }
  params.resizable = Common.isUndefined(params.parent) && params.resizable;
  if (params.autoPlace && Common.isUndefined(params.scrollable)) {
    params.scrollable = true;
  }
  var useLocalStorage = SUPPORTS_LOCAL_STORAGE && localStorage.getItem(getLocalStorageHash(this, 'isLocal')) === 'true';
  var saveToLocalStorage = void 0;
  var titleRow = void 0;
  Object.defineProperties(this,
  {
    parent: {
      get: function get$$1() {
        return params.parent;
      }
    },
    scrollable: {
      get: function get$$1() {
        return params.scrollable;
      }
    },
    autoPlace: {
      get: function get$$1() {
        return params.autoPlace;
      }
    },
    closeOnTop: {
      get: function get$$1() {
        return params.closeOnTop;
      }
    },
    preset: {
      get: function get$$1() {
        if (_this.parent) {
          return _this.getRoot().preset;
        }
        return params.load.preset;
      },
      set: function set$$1(v) {
        if (_this.parent) {
          _this.getRoot().preset = v;
        } else {
          params.load.preset = v;
        }
        setPresetSelectIndex(this);
        _this.revert();
      }
    },
    width: {
      get: function get$$1() {
        return params.width;
      },
      set: function set$$1(v) {
        params.width = v;
        setWidth(_this, v);
      }
    },
    name: {
      get: function get$$1() {
        return params.name;
      },
      set: function set$$1(v) {
        params.name = v;
        if (titleRow) {
          titleRow.innerHTML = params.name;
        }
      }
    },
    closed: {
      get: function get$$1() {
        return params.closed;
      },
      set: function set$$1(v) {
        params.closed = v;
        if (params.closed) {
          dom.addClass(_this.__ul, GUI.CLASS_CLOSED);
        } else {
          dom.removeClass(_this.__ul, GUI.CLASS_CLOSED);
        }
        this.onResize();
        if (_this.__closeButton) {
          _this.__closeButton.innerHTML = v ? GUI.TEXT_OPEN : GUI.TEXT_CLOSED;
        }
      }
    },
    load: {
      get: function get$$1() {
        return params.load;
      }
    },
    useLocalStorage: {
      get: function get$$1() {
        return useLocalStorage;
      },
      set: function set$$1(bool) {
        if (SUPPORTS_LOCAL_STORAGE) {
          useLocalStorage = bool;
          if (bool) {
            dom.bind(window, 'unload', saveToLocalStorage);
          } else {
            dom.unbind(window, 'unload', saveToLocalStorage);
          }
          localStorage.setItem(getLocalStorageHash(_this, 'isLocal'), bool);
        }
      }
    }
  });
  if (Common.isUndefined(params.parent)) {
    this.closed = params.closed || false;
    dom.addClass(this.domElement, GUI.CLASS_MAIN);
    dom.makeSelectable(this.domElement, false);
    if (SUPPORTS_LOCAL_STORAGE) {
      if (useLocalStorage) {
        _this.useLocalStorage = true;
        var savedGui = localStorage.getItem(getLocalStorageHash(this, 'gui'));
        if (savedGui) {
          params.load = JSON.parse(savedGui);
        }
      }
    }
    this.__closeButton = document.createElement('div');
    this.__closeButton.innerHTML = GUI.TEXT_CLOSED;
    dom.addClass(this.__closeButton, GUI.CLASS_CLOSE_BUTTON);
    if (params.closeOnTop) {
      dom.addClass(this.__closeButton, GUI.CLASS_CLOSE_TOP);
      this.domElement.insertBefore(this.__closeButton, this.domElement.childNodes[0]);
    } else {
      dom.addClass(this.__closeButton, GUI.CLASS_CLOSE_BOTTOM);
      this.domElement.appendChild(this.__closeButton);
    }
    dom.bind(this.__closeButton, 'click', function () {
      _this.closed = !_this.closed;
    });
  } else {
    if (params.closed === undefined) {
      params.closed = true;
    }
    var titleRowName = document.createTextNode(params.name);
    dom.addClass(titleRowName, 'controller-name');
    titleRow = addRow(_this, titleRowName);
    var onClickTitle = function onClickTitle(e) {
      e.preventDefault();
      _this.closed = !_this.closed;
      return false;
    };
    dom.addClass(this.__ul, GUI.CLASS_CLOSED);
    dom.addClass(titleRow, 'title');
    dom.bind(titleRow, 'click', onClickTitle);
    if (!params.closed) {
      this.closed = false;
    }
  }
  if (params.autoPlace) {
    if (Common.isUndefined(params.parent)) {
      if (autoPlaceVirgin) {
        autoPlaceContainer = document.createElement('div');
        dom.addClass(autoPlaceContainer, CSS_NAMESPACE);
        dom.addClass(autoPlaceContainer, GUI.CLASS_AUTO_PLACE_CONTAINER);
        document.body.appendChild(autoPlaceContainer);
        autoPlaceVirgin = false;
      }
      autoPlaceContainer.appendChild(this.domElement);
      dom.addClass(this.domElement, GUI.CLASS_AUTO_PLACE);
    }
    if (!this.parent) {
      setWidth(_this, params.width);
    }
  }
  this.__resizeHandler = function () {
    _this.onResizeDebounced();
  };
  dom.bind(window, 'resize', this.__resizeHandler);
  dom.bind(this.__ul, 'webkitTransitionEnd', this.__resizeHandler);
  dom.bind(this.__ul, 'transitionend', this.__resizeHandler);
  dom.bind(this.__ul, 'oTransitionEnd', this.__resizeHandler);
  this.onResize();
  if (params.resizable) {
    addResizeHandle(this);
  }
  saveToLocalStorage = function saveToLocalStorage() {
    if (SUPPORTS_LOCAL_STORAGE && localStorage.getItem(getLocalStorageHash(_this, 'isLocal')) === 'true') {
      localStorage.setItem(getLocalStorageHash(_this, 'gui'), JSON.stringify(_this.getSaveObject()));
    }
  };
  this.saveToLocalStorageIfPossible = saveToLocalStorage;
  function resetWidth() {
    var root = _this.getRoot();
    root.width += 1;
    Common.defer(function () {
      root.width -= 1;
    });
  }
  if (!params.parent) {
    resetWidth();
  }
};
GUI.toggleHide = function () {
  hide = !hide;
  Common.each(hideableGuis, function (gui) {
    gui.domElement.style.display = hide ? 'none' : '';
  });
};
GUI.CLASS_AUTO_PLACE = 'a';
GUI.CLASS_AUTO_PLACE_CONTAINER = 'ac';
GUI.CLASS_MAIN = 'main';
GUI.CLASS_CONTROLLER_ROW = 'cr';
GUI.CLASS_TOO_TALL = 'taller-than-window';
GUI.CLASS_CLOSED = 'closed';
GUI.CLASS_CLOSE_BUTTON = 'close-button';
GUI.CLASS_CLOSE_TOP = 'close-top';
GUI.CLASS_CLOSE_BOTTOM = 'close-bottom';
GUI.CLASS_DRAG = 'drag';
GUI.DEFAULT_WIDTH = 245;
GUI.TEXT_CLOSED = 'Close Controls';
GUI.TEXT_OPEN = 'Open Controls';
GUI._keydownHandler = function (e) {
  if (document.activeElement.type !== 'text' && (e.which === HIDE_KEY_CODE || e.keyCode === HIDE_KEY_CODE)) {
    GUI.toggleHide();
  }
};
dom.bind(window, 'keydown', GUI._keydownHandler, false);
Common.extend(GUI.prototype,
{
  add: function add(object, property) {
    return _add(this, object, property, {
      factoryArgs: Array.prototype.slice.call(arguments, 2)
    });
  },
  addColor: function addColor(object, property) {
    return _add(this, object, property, {
      color: true
    });
  },
  remove: function remove(controller) {
    this.__ul.removeChild(controller.__li);
    this.__controllers.splice(this.__controllers.indexOf(controller), 1);
    var _this = this;
    Common.defer(function () {
      _this.onResize();
    });
  },
  destroy: function destroy() {
    if (this.parent) {
      throw new Error('Only the root GUI should be removed with .destroy(). ' + 'For subfolders, use gui.removeFolder(folder) instead.');
    }
    if (this.autoPlace) {
      autoPlaceContainer.removeChild(this.domElement);
    }
    var _this = this;
    Common.each(this.__folders, function (subfolder) {
      _this.removeFolder(subfolder);
    });
    dom.unbind(window, 'keydown', GUI._keydownHandler, false);
    removeListeners(this);
  },
  addFolder: function addFolder(name) {
    if (this.__folders[name] !== undefined) {
      throw new Error('You already have a folder in this GUI by the' + ' name "' + name + '"');
    }
    var newGuiParams = { name: name, parent: this };
    newGuiParams.autoPlace = this.autoPlace;
    if (this.load &&
    this.load.folders &&
    this.load.folders[name]) {
      newGuiParams.closed = this.load.folders[name].closed;
      newGuiParams.load = this.load.folders[name];
    }
    var gui = new GUI(newGuiParams);
    this.__folders[name] = gui;
    var li = addRow(this, gui.domElement);
    dom.addClass(li, 'folder');
    return gui;
  },
  removeFolder: function removeFolder(folder) {
    this.__ul.removeChild(folder.domElement.parentElement);
    delete this.__folders[folder.name];
    if (this.load &&
    this.load.folders &&
    this.load.folders[folder.name]) {
      delete this.load.folders[folder.name];
    }
    removeListeners(folder);
    var _this = this;
    Common.each(folder.__folders, function (subfolder) {
      folder.removeFolder(subfolder);
    });
    Common.defer(function () {
      _this.onResize();
    });
  },
  open: function open() {
    this.closed = false;
  },
  close: function close() {
    this.closed = true;
  },
  hide: function hide() {
    this.domElement.style.display = 'none';
  },
  show: function show() {
    this.domElement.style.display = '';
  },
  onResize: function onResize() {
    var root = this.getRoot();
    if (root.scrollable) {
      var top = dom.getOffset(root.__ul).top;
      var h = 0;
      Common.each(root.__ul.childNodes, function (node) {
        if (!(root.autoPlace && node === root.__save_row)) {
          h += dom.getHeight(node);
        }
      });
      if (window.innerHeight - top - CLOSE_BUTTON_HEIGHT < h) {
        dom.addClass(root.domElement, GUI.CLASS_TOO_TALL);
        root.__ul.style.height = window.innerHeight - top - CLOSE_BUTTON_HEIGHT + 'px';
      } else {
        dom.removeClass(root.domElement, GUI.CLASS_TOO_TALL);
        root.__ul.style.height = 'auto';
      }
    }
    if (root.__resize_handle) {
      Common.defer(function () {
        root.__resize_handle.style.height = root.__ul.offsetHeight + 'px';
      });
    }
    if (root.__closeButton) {
      root.__closeButton.style.width = root.width + 'px';
    }
  },
  onResizeDebounced: Common.debounce(function () {
    this.onResize();
  }, 50),
  remember: function remember() {
    if (Common.isUndefined(SAVE_DIALOGUE)) {
      SAVE_DIALOGUE = new CenteredDiv();
      SAVE_DIALOGUE.domElement.innerHTML = saveDialogContents;
    }
    if (this.parent) {
      throw new Error('You can only call remember on a top level GUI.');
    }
    var _this = this;
    Common.each(Array.prototype.slice.call(arguments), function (object) {
      if (_this.__rememberedObjects.length === 0) {
        addSaveMenu(_this);
      }
      if (_this.__rememberedObjects.indexOf(object) === -1) {
        _this.__rememberedObjects.push(object);
      }
    });
    if (this.autoPlace) {
      setWidth(this, this.width);
    }
  },
  getRoot: function getRoot() {
    var gui = this;
    while (gui.parent) {
      gui = gui.parent;
    }
    return gui;
  },
  getSaveObject: function getSaveObject() {
    var toReturn = this.load;
    toReturn.closed = this.closed;
    if (this.__rememberedObjects.length > 0) {
      toReturn.preset = this.preset;
      if (!toReturn.remembered) {
        toReturn.remembered = {};
      }
      toReturn.remembered[this.preset] = getCurrentPreset(this);
    }
    toReturn.folders = {};
    Common.each(this.__folders, function (element, key) {
      toReturn.folders[key] = element.getSaveObject();
    });
    return toReturn;
  },
  save: function save() {
    if (!this.load.remembered) {
      this.load.remembered = {};
    }
    this.load.remembered[this.preset] = getCurrentPreset(this);
    markPresetModified(this, false);
    this.saveToLocalStorageIfPossible();
  },
  saveAs: function saveAs(presetName) {
    if (!this.load.remembered) {
      this.load.remembered = {};
      this.load.remembered[DEFAULT_DEFAULT_PRESET_NAME] = getCurrentPreset(this, true);
    }
    this.load.remembered[presetName] = getCurrentPreset(this);
    this.preset = presetName;
    addPresetOption(this, presetName, true);
    this.saveToLocalStorageIfPossible();
  },
  revert: function revert(gui) {
    Common.each(this.__controllers, function (controller) {
      if (!this.getRoot().load.remembered) {
        controller.setValue(controller.initialValue);
      } else {
        recallSavedValue(gui || this.getRoot(), controller);
      }
      if (controller.__onFinishChange) {
        controller.__onFinishChange.call(controller, controller.getValue());
      }
    }, this);
    Common.each(this.__folders, function (folder) {
      folder.revert(folder);
    });
    if (!gui) {
      markPresetModified(this.getRoot(), false);
    }
  },
  listen: function listen(controller) {
    var init = this.__listening.length === 0;
    this.__listening.push(controller);
    if (init) {
      updateDisplays(this.__listening);
    }
  },
  updateDisplay: function updateDisplay() {
    Common.each(this.__controllers, function (controller) {
      controller.updateDisplay();
    });
    Common.each(this.__folders, function (folder) {
      folder.updateDisplay();
    });
  }
});
function addRow(gui, newDom, liBefore) {
  var li = document.createElement('li');
  if (newDom) {
    li.appendChild(newDom);
  }
  if (liBefore) {
    gui.__ul.insertBefore(li, liBefore);
  } else {
    gui.__ul.appendChild(li);
  }
  gui.onResize();
  return li;
}
function removeListeners(gui) {
  dom.unbind(window, 'resize', gui.__resizeHandler);
  if (gui.saveToLocalStorageIfPossible) {
    dom.unbind(window, 'unload', gui.saveToLocalStorageIfPossible);
  }
}
function markPresetModified(gui, modified) {
  var opt = gui.__preset_select[gui.__preset_select.selectedIndex];
  if (modified) {
    opt.innerHTML = opt.value + '*';
  } else {
    opt.innerHTML = opt.value;
  }
}
function augmentController(gui, li, controller) {
  controller.__li = li;
  controller.__gui = gui;
  Common.extend(controller,                                   {
    options: function options(_options) {
      if (arguments.length > 1) {
        var nextSibling = controller.__li.nextElementSibling;
        controller.remove();
        return _add(gui, controller.object, controller.property, {
          before: nextSibling,
          factoryArgs: [Common.toArray(arguments)]
        });
      }
      if (Common.isArray(_options) || Common.isObject(_options)) {
        var _nextSibling = controller.__li.nextElementSibling;
        controller.remove();
        return _add(gui, controller.object, controller.property, {
          before: _nextSibling,
          factoryArgs: [_options]
        });
      }
    },
    name: function name(_name) {
      controller.__li.firstElementChild.firstElementChild.innerHTML = _name;
      return controller;
    },
    listen: function listen() {
      controller.__gui.listen(controller);
      return controller;
    },
    remove: function remove() {
      controller.__gui.remove(controller);
      return controller;
    }
  });
  if (controller instanceof NumberControllerSlider) {
    var box = new NumberControllerBox(controller.object, controller.property, { min: controller.__min, max: controller.__max, step: controller.__step });
    Common.each(['updateDisplay', 'onChange', 'onFinishChange', 'step', 'min', 'max'], function (method) {
      var pc = controller[method];
      var pb = box[method];
      controller[method] = box[method] = function () {
        var args = Array.prototype.slice.call(arguments);
        pb.apply(box, args);
        return pc.apply(controller, args);
      };
    });
    dom.addClass(li, 'has-slider');
    controller.domElement.insertBefore(box.domElement, controller.domElement.firstElementChild);
  } else if (controller instanceof NumberControllerBox) {
    var r = function r(returned) {
      if (Common.isNumber(controller.__min) && Common.isNumber(controller.__max)) {
        var oldName = controller.__li.firstElementChild.firstElementChild.innerHTML;
        var wasListening = controller.__gui.__listening.indexOf(controller) > -1;
        controller.remove();
        var newController = _add(gui, controller.object, controller.property, {
          before: controller.__li.nextElementSibling,
          factoryArgs: [controller.__min, controller.__max, controller.__step]
        });
        newController.name(oldName);
        if (wasListening) newController.listen();
        return newController;
      }
      return returned;
    };
    controller.min = Common.compose(r, controller.min);
    controller.max = Common.compose(r, controller.max);
  } else if (controller instanceof BooleanController) {
    dom.bind(li, 'click', function () {
      dom.fakeEvent(controller.__checkbox, 'click');
    });
    dom.bind(controller.__checkbox, 'click', function (e) {
      e.stopPropagation();
    });
  } else if (controller instanceof FunctionController) {
    dom.bind(li, 'click', function () {
      dom.fakeEvent(controller.__button, 'click');
    });
    dom.bind(li, 'mouseover', function () {
      dom.addClass(controller.__button, 'hover');
    });
    dom.bind(li, 'mouseout', function () {
      dom.removeClass(controller.__button, 'hover');
    });
  } else if (controller instanceof ColorController) {
    dom.addClass(li, 'color');
    controller.updateDisplay = Common.compose(function (val) {
      li.style.borderLeftColor = controller.__color.toString();
      return val;
    }, controller.updateDisplay);
    controller.updateDisplay();
  }
  controller.setValue = Common.compose(function (val) {
    if (gui.getRoot().__preset_select && controller.isModified()) {
      markPresetModified(gui.getRoot(), true);
    }
    return val;
  }, controller.setValue);
}
function recallSavedValue(gui, controller) {
  var root = gui.getRoot();
  var matchedIndex = root.__rememberedObjects.indexOf(controller.object);
  if (matchedIndex !== -1) {
    var controllerMap = root.__rememberedObjectIndecesToControllers[matchedIndex];
    if (controllerMap === undefined) {
      controllerMap = {};
      root.__rememberedObjectIndecesToControllers[matchedIndex] = controllerMap;
    }
    controllerMap[controller.property] = controller;
    if (root.load && root.load.remembered) {
      var presetMap = root.load.remembered;
      var preset = void 0;
      if (presetMap[gui.preset]) {
        preset = presetMap[gui.preset];
      } else if (presetMap[DEFAULT_DEFAULT_PRESET_NAME]) {
        preset = presetMap[DEFAULT_DEFAULT_PRESET_NAME];
      } else {
        return;
      }
      if (preset[matchedIndex] && preset[matchedIndex][controller.property] !== undefined) {
        var value = preset[matchedIndex][controller.property];
        controller.initialValue = value;
        controller.setValue(value);
      }
    }
  }
}
function _add(gui, object, property, params) {
  if (object[property] === undefined) {
    throw new Error('Object "' + object + '" has no property "' + property + '"');
  }
  var controller = void 0;
  if (params.color) {
    controller = new ColorController(object, property);
  } else {
    var factoryArgs = [object, property].concat(params.factoryArgs);
    controller = ControllerFactory.apply(gui, factoryArgs);
  }
  if (params.before instanceof Controller) {
    params.before = params.before.__li;
  }
  recallSavedValue(gui, controller);
  dom.addClass(controller.domElement, 'c');
  var name = document.createElement('span');
  dom.addClass(name, 'property-name');
  name.innerHTML = controller.property;
  var container = document.createElement('div');
  container.appendChild(name);
  container.appendChild(controller.domElement);
  var li = addRow(gui, container, params.before);
  dom.addClass(li, GUI.CLASS_CONTROLLER_ROW);
  if (controller instanceof ColorController) {
    dom.addClass(li, 'color');
  } else {
    dom.addClass(li, _typeof(controller.getValue()));
  }
  augmentController(gui, li, controller);
  gui.__controllers.push(controller);
  return controller;
}
function getLocalStorageHash(gui, key) {
  return document.location.href + '.' + key;
}
function addPresetOption(gui, name, setSelected) {
  var opt = document.createElement('option');
  opt.innerHTML = name;
  opt.value = name;
  gui.__preset_select.appendChild(opt);
  if (setSelected) {
    gui.__preset_select.selectedIndex = gui.__preset_select.length - 1;
  }
}
function showHideExplain(gui, explain) {
  explain.style.display = gui.useLocalStorage ? 'block' : 'none';
}
function addSaveMenu(gui) {
  var div = gui.__save_row = document.createElement('li');
  dom.addClass(gui.domElement, 'has-save');
  gui.__ul.insertBefore(div, gui.__ul.firstChild);
  dom.addClass(div, 'save-row');
  var gears = document.createElement('span');
  gears.innerHTML = '&nbsp;';
  dom.addClass(gears, 'button gears');
  var button = document.createElement('span');
  button.innerHTML = 'Save';
  dom.addClass(button, 'button');
  dom.addClass(button, 'save');
  var button2 = document.createElement('span');
  button2.innerHTML = 'New';
  dom.addClass(button2, 'button');
  dom.addClass(button2, 'save-as');
  var button3 = document.createElement('span');
  button3.innerHTML = 'Revert';
  dom.addClass(button3, 'button');
  dom.addClass(button3, 'revert');
  var select = gui.__preset_select = document.createElement('select');
  if (gui.load && gui.load.remembered) {
    Common.each(gui.load.remembered, function (value, key) {
      addPresetOption(gui, key, key === gui.preset);
    });
  } else {
    addPresetOption(gui, DEFAULT_DEFAULT_PRESET_NAME, false);
  }
  dom.bind(select, 'change', function () {
    for (var index = 0; index < gui.__preset_select.length; index++) {
      gui.__preset_select[index].innerHTML = gui.__preset_select[index].value;
    }
    gui.preset = this.value;
  });
  div.appendChild(select);
  div.appendChild(gears);
  div.appendChild(button);
  div.appendChild(button2);
  div.appendChild(button3);
  if (SUPPORTS_LOCAL_STORAGE) {
    var explain = document.getElementById('dg-local-explain');
    var localStorageCheckBox = document.getElementById('dg-local-storage');
    var saveLocally = document.getElementById('dg-save-locally');
    saveLocally.style.display = 'block';
    if (localStorage.getItem(getLocalStorageHash(gui, 'isLocal')) === 'true') {
      localStorageCheckBox.setAttribute('checked', 'checked');
    }
    showHideExplain(gui, explain);
    dom.bind(localStorageCheckBox, 'change', function () {
      gui.useLocalStorage = !gui.useLocalStorage;
      showHideExplain(gui, explain);
    });
  }
  var newConstructorTextArea = document.getElementById('dg-new-constructor');
  dom.bind(newConstructorTextArea, 'keydown', function (e) {
    if (e.metaKey && (e.which === 67 || e.keyCode === 67)) {
      SAVE_DIALOGUE.hide();
    }
  });
  dom.bind(gears, 'click', function () {
    newConstructorTextArea.innerHTML = JSON.stringify(gui.getSaveObject(), undefined, 2);
    SAVE_DIALOGUE.show();
    newConstructorTextArea.focus();
    newConstructorTextArea.select();
  });
  dom.bind(button, 'click', function () {
    gui.save();
  });
  dom.bind(button2, 'click', function () {
    var presetName = prompt('Enter a new preset name.');
    if (presetName) {
      gui.saveAs(presetName);
    }
  });
  dom.bind(button3, 'click', function () {
    gui.revert();
  });
}
function addResizeHandle(gui) {
  var pmouseX = void 0;
  gui.__resize_handle = document.createElement('div');
  Common.extend(gui.__resize_handle.style, {
    width: '6px',
    marginLeft: '-3px',
    height: '200px',
    cursor: 'ew-resize',
    position: 'absolute'
  });
  function drag(e) {
    e.preventDefault();
    gui.width += pmouseX - e.clientX;
    gui.onResize();
    pmouseX = e.clientX;
    return false;
  }
  function dragStop() {
    dom.removeClass(gui.__closeButton, GUI.CLASS_DRAG);
    dom.unbind(window, 'mousemove', drag);
    dom.unbind(window, 'mouseup', dragStop);
  }
  function dragStart(e) {
    e.preventDefault();
    pmouseX = e.clientX;
    dom.addClass(gui.__closeButton, GUI.CLASS_DRAG);
    dom.bind(window, 'mousemove', drag);
    dom.bind(window, 'mouseup', dragStop);
    return false;
  }
  dom.bind(gui.__resize_handle, 'mousedown', dragStart);
  dom.bind(gui.__closeButton, 'mousedown', dragStart);
  gui.domElement.insertBefore(gui.__resize_handle, gui.domElement.firstElementChild);
}
function setWidth(gui, w) {
  gui.domElement.style.width = w + 'px';
  if (gui.__save_row && gui.autoPlace) {
    gui.__save_row.style.width = w + 'px';
  }
  if (gui.__closeButton) {
    gui.__closeButton.style.width = w + 'px';
  }
}
function getCurrentPreset(gui, useInitialValues) {
  var toReturn = {};
  Common.each(gui.__rememberedObjects, function (val, index) {
    var savedValues = {};
    var controllerMap = gui.__rememberedObjectIndecesToControllers[index];
    Common.each(controllerMap, function (controller, property) {
      savedValues[property] = useInitialValues ? controller.initialValue : controller.getValue();
    });
    toReturn[index] = savedValues;
  });
  return toReturn;
}
function setPresetSelectIndex(gui) {
  for (var index = 0; index < gui.__preset_select.length; index++) {
    if (gui.__preset_select[index].value === gui.preset) {
      gui.__preset_select.selectedIndex = index;
    }
  }
}
function updateDisplays(controllerArray) {
  if (controllerArray.length !== 0) {
    requestAnimationFrame$1.call(window, function () {
      updateDisplays(controllerArray);
    });
  }
  Common.each(controllerArray, function (c) {
    c.updateDisplay();
  });
}

var color = {
  Color: Color,
  math: ColorMath,
  interpret: interpret
};
var controllers = {
  Controller: Controller,
  BooleanController: BooleanController,
  OptionController: OptionController,
  StringController: StringController,
  NumberController: NumberController,
  NumberControllerBox: NumberControllerBox,
  NumberControllerSlider: NumberControllerSlider,
  FunctionController: FunctionController,
  ColorController: ColorController
};
var dom$1 = { dom: dom };
var gui = { GUI: GUI };
var GUI$1 = GUI;
var index = {
  color: color,
  controllers: controllers,
  dom: dom$1,
  gui: gui,
  GUI: GUI$1
};


/* harmony default export */ __webpack_exports__["default"] = (index);
//# sourceMappingURL=dat.gui.module.js.map


/***/ }),

/***/ "./node_modules/gpu.js/dist/gpu-browser.js":
/*!*************************************************!*\
  !*** ./node_modules/gpu.js/dist/gpu-browser.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var require;var require;/**
 * gpu.js
 * http://gpu.rocks/
 *
 * GPU Accelerated JavaScript
 *
 * @version 2.11.2
 * @date Tue Jan 19 2021 11:27:02 GMT-0500 (Eastern Standard Time)
 *
 * @license MIT
 * The MIT License
 *
 * Copyright (c) 2021 gpu.js Team
 */(function(f){if(true){module.exports=f()}else { var g; }})(function(){var define,module,exports;return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return require(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (global = global || self, factory(global.acorn = {}));
}(this, function (exports) { 'use strict';


  var reservedWords = {
    3: "abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile",
    5: "class enum extends super const export import",
    6: "enum",
    strict: "implements interface let package private protected public static yield",
    strictBind: "eval arguments"
  };


  var ecma5AndLessKeywords = "break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this";

  var keywords = {
    5: ecma5AndLessKeywords,
    "5module": ecma5AndLessKeywords + " export import",
    6: ecma5AndLessKeywords + " const class extends export import super"
  };

  var keywordRelationalOperator = /^in(stanceof)?$/;


  var nonASCIIidentifierStartChars = "\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376\u0377\u037a-\u037d\u037f\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u052f\u0531-\u0556\u0559\u0560-\u0588\u05d0-\u05ea\u05ef-\u05f2\u0620-\u064a\u066e\u066f\u0671-\u06d3\u06d5\u06e5\u06e6\u06ee\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u0860-\u086a\u08a0-\u08b4\u08b6-\u08bd\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc\u09dd\u09df-\u09e1\u09f0\u09f1\u09fc\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0\u0ae1\u0af9\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3d\u0b5c\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c39\u0c3d\u0c58-\u0c5a\u0c60\u0c61\u0c80\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cde\u0ce0\u0ce1\u0cf1\u0cf2\u0d05-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d54-\u0d56\u0d5f-\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32\u0e33\u0e40-\u0e46\u0e81\u0e82\u0e84\u0e86-\u0e8a\u0e8c-\u0ea3\u0ea5\u0ea7-\u0eb0\u0eb2\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065\u1066\u106e-\u1070\u1075-\u1081\u108e\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f5\u13f8-\u13fd\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f8\u1700-\u170c\u170e-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u1820-\u1878\u1880-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191e\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19b0-\u19c9\u1a00-\u1a16\u1a20-\u1a54\u1aa7\u1b05-\u1b33\u1b45-\u1b4b\u1b83-\u1ba0\u1bae\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1c80-\u1c88\u1c90-\u1cba\u1cbd-\u1cbf\u1ce9-\u1cec\u1cee-\u1cf3\u1cf5\u1cf6\u1cfa\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2118-\u211d\u2124\u2126\u2128\u212a-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cee\u2cf2\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303c\u3041-\u3096\u309b-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312f\u3131-\u318e\u31a0-\u31ba\u31f0-\u31ff\u3400-\u4db5\u4e00-\u9fef\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a\ua62b\ua640-\ua66e\ua67f-\ua69d\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua7bf\ua7c2-\ua7c6\ua7f7-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua8fd\ua8fe\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\ua9e0-\ua9e4\ua9e6-\ua9ef\ua9fa-\ua9fe\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa76\uaa7a\uaa7e-\uaaaf\uaab1\uaab5\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadd\uaae0-\uaaea\uaaf2-\uaaf4\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uab30-\uab5a\uab5c-\uab67\uab70-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc";
  var nonASCIIidentifierChars = "\u200c\u200d\xb7\u0300-\u036f\u0387\u0483-\u0487\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u0669\u0670\u06d6-\u06dc\u06df-\u06e4\u06e7\u06e8\u06ea-\u06ed\u06f0-\u06f9\u0711\u0730-\u074a\u07a6-\u07b0\u07c0-\u07c9\u07eb-\u07f3\u07fd\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0859-\u085b\u08d3-\u08e1\u08e3-\u0903\u093a-\u093c\u093e-\u094f\u0951-\u0957\u0962\u0963\u0966-\u096f\u0981-\u0983\u09bc\u09be-\u09c4\u09c7\u09c8\u09cb-\u09cd\u09d7\u09e2\u09e3\u09e6-\u09ef\u09fe\u0a01-\u0a03\u0a3c\u0a3e-\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a66-\u0a71\u0a75\u0a81-\u0a83\u0abc\u0abe-\u0ac5\u0ac7-\u0ac9\u0acb-\u0acd\u0ae2\u0ae3\u0ae6-\u0aef\u0afa-\u0aff\u0b01-\u0b03\u0b3c\u0b3e-\u0b44\u0b47\u0b48\u0b4b-\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b66-\u0b6f\u0b82\u0bbe-\u0bc2\u0bc6-\u0bc8\u0bca-\u0bcd\u0bd7\u0be6-\u0bef\u0c00-\u0c04\u0c3e-\u0c44\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0c66-\u0c6f\u0c81-\u0c83\u0cbc\u0cbe-\u0cc4\u0cc6-\u0cc8\u0cca-\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0ce6-\u0cef\u0d00-\u0d03\u0d3b\u0d3c\u0d3e-\u0d44\u0d46-\u0d48\u0d4a-\u0d4d\u0d57\u0d62\u0d63\u0d66-\u0d6f\u0d82\u0d83\u0dca\u0dcf-\u0dd4\u0dd6\u0dd8-\u0ddf\u0de6-\u0def\u0df2\u0df3\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0e50-\u0e59\u0eb1\u0eb4-\u0ebc\u0ec8-\u0ecd\u0ed0-\u0ed9\u0f18\u0f19\u0f20-\u0f29\u0f35\u0f37\u0f39\u0f3e\u0f3f\u0f71-\u0f84\u0f86\u0f87\u0f8d-\u0f97\u0f99-\u0fbc\u0fc6\u102b-\u103e\u1040-\u1049\u1056-\u1059\u105e-\u1060\u1062-\u1064\u1067-\u106d\u1071-\u1074\u1082-\u108d\u108f-\u109d\u135d-\u135f\u1369-\u1371\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b4-\u17d3\u17dd\u17e0-\u17e9\u180b-\u180d\u1810-\u1819\u18a9\u1920-\u192b\u1930-\u193b\u1946-\u194f\u19d0-\u19da\u1a17-\u1a1b\u1a55-\u1a5e\u1a60-\u1a7c\u1a7f-\u1a89\u1a90-\u1a99\u1ab0-\u1abd\u1b00-\u1b04\u1b34-\u1b44\u1b50-\u1b59\u1b6b-\u1b73\u1b80-\u1b82\u1ba1-\u1bad\u1bb0-\u1bb9\u1be6-\u1bf3\u1c24-\u1c37\u1c40-\u1c49\u1c50-\u1c59\u1cd0-\u1cd2\u1cd4-\u1ce8\u1ced\u1cf4\u1cf7-\u1cf9\u1dc0-\u1df9\u1dfb-\u1dff\u203f\u2040\u2054\u20d0-\u20dc\u20e1\u20e5-\u20f0\u2cef-\u2cf1\u2d7f\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua620-\ua629\ua66f\ua674-\ua67d\ua69e\ua69f\ua6f0\ua6f1\ua802\ua806\ua80b\ua823-\ua827\ua880\ua881\ua8b4-\ua8c5\ua8d0-\ua8d9\ua8e0-\ua8f1\ua8ff-\ua909\ua926-\ua92d\ua947-\ua953\ua980-\ua983\ua9b3-\ua9c0\ua9d0-\ua9d9\ua9e5\ua9f0-\ua9f9\uaa29-\uaa36\uaa43\uaa4c\uaa4d\uaa50-\uaa59\uaa7b-\uaa7d\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uaaeb-\uaaef\uaaf5\uaaf6\uabe3-\uabea\uabec\uabed\uabf0-\uabf9\ufb1e\ufe00-\ufe0f\ufe20-\ufe2f\ufe33\ufe34\ufe4d-\ufe4f\uff10-\uff19\uff3f";

  var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
  var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");

  nonASCIIidentifierStartChars = nonASCIIidentifierChars = null;


  var astralIdentifierStartCodes = [0,11,2,25,2,18,2,1,2,14,3,13,35,122,70,52,268,28,4,48,48,31,14,29,6,37,11,29,3,35,5,7,2,4,43,157,19,35,5,35,5,39,9,51,157,310,10,21,11,7,153,5,3,0,2,43,2,1,4,0,3,22,11,22,10,30,66,18,2,1,11,21,11,25,71,55,7,1,65,0,16,3,2,2,2,28,43,28,4,28,36,7,2,27,28,53,11,21,11,18,14,17,111,72,56,50,14,50,14,35,477,28,11,0,9,21,155,22,13,52,76,44,33,24,27,35,30,0,12,34,4,0,13,47,15,3,22,0,2,0,36,17,2,24,85,6,2,0,2,3,2,14,2,9,8,46,39,7,3,1,3,21,2,6,2,1,2,4,4,0,19,0,13,4,159,52,19,3,21,0,33,47,21,1,2,0,185,46,42,3,37,47,21,0,60,42,14,0,72,26,230,43,117,63,32,0,161,7,3,38,17,0,2,0,29,0,11,39,8,0,22,0,12,45,20,0,35,56,264,8,2,36,18,0,50,29,113,6,2,1,2,37,22,0,26,5,2,1,2,31,15,0,328,18,270,921,103,110,18,195,2749,1070,4050,582,8634,568,8,30,114,29,19,47,17,3,32,20,6,18,689,63,129,74,6,0,67,12,65,1,2,0,29,6135,9,754,9486,286,50,2,18,3,9,395,2309,106,6,12,4,8,8,9,5991,84,2,70,2,1,3,0,3,1,3,3,2,11,2,0,2,6,2,64,2,3,3,7,2,6,2,27,2,3,2,4,2,0,4,6,2,339,3,24,2,24,2,30,2,24,2,30,2,24,2,30,2,24,2,30,2,24,2,7,2357,44,11,6,17,0,370,43,1301,196,60,67,8,0,1205,3,2,26,2,1,2,0,3,0,2,9,2,3,2,0,2,0,7,0,5,0,2,0,2,0,2,2,2,1,2,0,3,0,2,0,2,0,2,0,2,0,2,1,2,0,3,3,2,6,2,3,2,3,2,0,2,9,2,16,6,2,2,4,2,16,4421,42710,42,4148,12,221,3,5761,15,7472,3104,541];

  var astralIdentifierCodes = [509,0,227,0,150,4,294,9,1368,2,2,1,6,3,41,2,5,0,166,1,574,3,9,9,525,10,176,2,54,14,32,9,16,3,46,10,54,9,7,2,37,13,2,9,6,1,45,0,13,2,49,13,9,3,4,9,83,11,7,0,161,11,6,9,7,3,56,1,2,6,3,1,3,2,10,0,11,1,3,6,4,4,193,17,10,9,5,0,82,19,13,9,214,6,3,8,28,1,83,16,16,9,82,12,9,9,84,14,5,9,243,14,166,9,232,6,3,6,4,0,29,9,41,6,2,3,9,0,10,10,47,15,406,7,2,7,17,9,57,21,2,13,123,5,4,0,2,1,2,6,2,0,9,9,49,4,2,1,2,4,9,9,330,3,19306,9,135,4,60,6,26,9,1014,0,2,54,8,3,19723,1,5319,4,4,5,9,7,3,6,31,3,149,2,1418,49,513,54,5,49,9,0,15,0,23,4,2,14,1361,6,2,16,3,6,2,1,2,4,262,6,10,9,419,13,1495,6,110,6,6,9,792487,239];

  function isInAstralSet(code, set) {
    var pos = 0x10000;
    for (var i = 0; i < set.length; i += 2) {
      pos += set[i];
      if (pos > code) { return false }
      pos += set[i + 1];
      if (pos >= code) { return true }
    }
  }


  function isIdentifierStart(code, astral) {
    if (code < 65) { return code === 36 }
    if (code < 91) { return true }
    if (code < 97) { return code === 95 }
    if (code < 123) { return true }
    if (code <= 0xffff) { return code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code)) }
    if (astral === false) { return false }
    return isInAstralSet(code, astralIdentifierStartCodes)
  }


  function isIdentifierChar(code, astral) {
    if (code < 48) { return code === 36 }
    if (code < 58) { return true }
    if (code < 65) { return false }
    if (code < 91) { return true }
    if (code < 97) { return code === 95 }
    if (code < 123) { return true }
    if (code <= 0xffff) { return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code)) }
    if (astral === false) { return false }
    return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes)
  }





  var TokenType = function TokenType(label, conf) {
    if ( conf === void 0 ) conf = {};

    this.label = label;
    this.keyword = conf.keyword;
    this.beforeExpr = !!conf.beforeExpr;
    this.startsExpr = !!conf.startsExpr;
    this.isLoop = !!conf.isLoop;
    this.isAssign = !!conf.isAssign;
    this.prefix = !!conf.prefix;
    this.postfix = !!conf.postfix;
    this.binop = conf.binop || null;
    this.updateContext = null;
  };

  function binop(name, prec) {
    return new TokenType(name, {beforeExpr: true, binop: prec})
  }
  var beforeExpr = {beforeExpr: true}, startsExpr = {startsExpr: true};


  var keywords$1 = {};

  function kw(name, options) {
    if ( options === void 0 ) options = {};

    options.keyword = name;
    return keywords$1[name] = new TokenType(name, options)
  }

  var types = {
    num: new TokenType("num", startsExpr),
    regexp: new TokenType("regexp", startsExpr),
    string: new TokenType("string", startsExpr),
    name: new TokenType("name", startsExpr),
    eof: new TokenType("eof"),

    bracketL: new TokenType("[", {beforeExpr: true, startsExpr: true}),
    bracketR: new TokenType("]"),
    braceL: new TokenType("{", {beforeExpr: true, startsExpr: true}),
    braceR: new TokenType("}"),
    parenL: new TokenType("(", {beforeExpr: true, startsExpr: true}),
    parenR: new TokenType(")"),
    comma: new TokenType(",", beforeExpr),
    semi: new TokenType(";", beforeExpr),
    colon: new TokenType(":", beforeExpr),
    dot: new TokenType("."),
    question: new TokenType("?", beforeExpr),
    arrow: new TokenType("=>", beforeExpr),
    template: new TokenType("template"),
    invalidTemplate: new TokenType("invalidTemplate"),
    ellipsis: new TokenType("...", beforeExpr),
    backQuote: new TokenType("`", startsExpr),
    dollarBraceL: new TokenType("${", {beforeExpr: true, startsExpr: true}),


    eq: new TokenType("=", {beforeExpr: true, isAssign: true}),
    assign: new TokenType("_=", {beforeExpr: true, isAssign: true}),
    incDec: new TokenType("++/--", {prefix: true, postfix: true, startsExpr: true}),
    prefix: new TokenType("!/~", {beforeExpr: true, prefix: true, startsExpr: true}),
    logicalOR: binop("||", 1),
    logicalAND: binop("&&", 2),
    bitwiseOR: binop("|", 3),
    bitwiseXOR: binop("^", 4),
    bitwiseAND: binop("&", 5),
    equality: binop("==/!=/===/!==", 6),
    relational: binop("</>/<=/>=", 7),
    bitShift: binop("<</>>/>>>", 8),
    plusMin: new TokenType("+/-", {beforeExpr: true, binop: 9, prefix: true, startsExpr: true}),
    modulo: binop("%", 10),
    star: binop("*", 10),
    slash: binop("/", 10),
    starstar: new TokenType("**", {beforeExpr: true}),

    _break: kw("break"),
    _case: kw("case", beforeExpr),
    _catch: kw("catch"),
    _continue: kw("continue"),
    _debugger: kw("debugger"),
    _default: kw("default", beforeExpr),
    _do: kw("do", {isLoop: true, beforeExpr: true}),
    _else: kw("else", beforeExpr),
    _finally: kw("finally"),
    _for: kw("for", {isLoop: true}),
    _function: kw("function", startsExpr),
    _if: kw("if"),
    _return: kw("return", beforeExpr),
    _switch: kw("switch"),
    _throw: kw("throw", beforeExpr),
    _try: kw("try"),
    _var: kw("var"),
    _const: kw("const"),
    _while: kw("while", {isLoop: true}),
    _with: kw("with"),
    _new: kw("new", {beforeExpr: true, startsExpr: true}),
    _this: kw("this", startsExpr),
    _super: kw("super", startsExpr),
    _class: kw("class", startsExpr),
    _extends: kw("extends", beforeExpr),
    _export: kw("export"),
    _import: kw("import", startsExpr),
    _null: kw("null", startsExpr),
    _true: kw("true", startsExpr),
    _false: kw("false", startsExpr),
    _in: kw("in", {beforeExpr: true, binop: 7}),
    _instanceof: kw("instanceof", {beforeExpr: true, binop: 7}),
    _typeof: kw("typeof", {beforeExpr: true, prefix: true, startsExpr: true}),
    _void: kw("void", {beforeExpr: true, prefix: true, startsExpr: true}),
    _delete: kw("delete", {beforeExpr: true, prefix: true, startsExpr: true})
  };


  var lineBreak = /\r\n?|\n|\u2028|\u2029/;
  var lineBreakG = new RegExp(lineBreak.source, "g");

  function isNewLine(code, ecma2019String) {
    return code === 10 || code === 13 || (!ecma2019String && (code === 0x2028 || code === 0x2029))
  }

  var nonASCIIwhitespace = /[\u1680\u2000-\u200a\u202f\u205f\u3000\ufeff]/;

  var skipWhiteSpace = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;

  var ref = Object.prototype;
  var hasOwnProperty = ref.hasOwnProperty;
  var toString = ref.toString;


  function has(obj, propName) {
    return hasOwnProperty.call(obj, propName)
  }

  var isArray = Array.isArray || (function (obj) { return (
    toString.call(obj) === "[object Array]"
  ); });

  function wordsRegexp(words) {
    return new RegExp("^(?:" + words.replace(/ /g, "|") + ")$")
  }


  var Position = function Position(line, col) {
    this.line = line;
    this.column = col;
  };

  Position.prototype.offset = function offset (n) {
    return new Position(this.line, this.column + n)
  };

  var SourceLocation = function SourceLocation(p, start, end) {
    this.start = start;
    this.end = end;
    if (p.sourceFile !== null) { this.source = p.sourceFile; }
  };


  function getLineInfo(input, offset) {
    for (var line = 1, cur = 0;;) {
      lineBreakG.lastIndex = cur;
      var match = lineBreakG.exec(input);
      if (match && match.index < offset) {
        ++line;
        cur = match.index + match[0].length;
      } else {
        return new Position(line, offset - cur)
      }
    }
  }


  var defaultOptions = {
    ecmaVersion: 10,
    sourceType: "script",
    onInsertedSemicolon: null,
    onTrailingComma: null,
    allowReserved: null,
    allowReturnOutsideFunction: false,
    allowImportExportEverywhere: false,
    allowAwaitOutsideFunction: false,
    allowHashBang: false,
    locations: false,
    onToken: null,
    onComment: null,
    ranges: false,
    program: null,
    sourceFile: null,
    directSourceFile: null,
    preserveParens: false
  };


  function getOptions(opts) {
    var options = {};

    for (var opt in defaultOptions)
      { options[opt] = opts && has(opts, opt) ? opts[opt] : defaultOptions[opt]; }

    if (options.ecmaVersion >= 2015)
      { options.ecmaVersion -= 2009; }

    if (options.allowReserved == null)
      { options.allowReserved = options.ecmaVersion < 5; }

    if (isArray(options.onToken)) {
      var tokens = options.onToken;
      options.onToken = function (token) { return tokens.push(token); };
    }
    if (isArray(options.onComment))
      { options.onComment = pushComment(options, options.onComment); }

    return options
  }

  function pushComment(options, array) {
    return function(block, text, start, end, startLoc, endLoc) {
      var comment = {
        type: block ? "Block" : "Line",
        value: text,
        start: start,
        end: end
      };
      if (options.locations)
        { comment.loc = new SourceLocation(this, startLoc, endLoc); }
      if (options.ranges)
        { comment.range = [start, end]; }
      array.push(comment);
    }
  }

  var
      SCOPE_TOP = 1,
      SCOPE_FUNCTION = 2,
      SCOPE_VAR = SCOPE_TOP | SCOPE_FUNCTION,
      SCOPE_ASYNC = 4,
      SCOPE_GENERATOR = 8,
      SCOPE_ARROW = 16,
      SCOPE_SIMPLE_CATCH = 32,
      SCOPE_SUPER = 64,
      SCOPE_DIRECT_SUPER = 128;

  function functionFlags(async, generator) {
    return SCOPE_FUNCTION | (async ? SCOPE_ASYNC : 0) | (generator ? SCOPE_GENERATOR : 0)
  }

  var
      BIND_NONE = 0, 
      BIND_VAR = 1, 
      BIND_LEXICAL = 2, 
      BIND_FUNCTION = 3, 
      BIND_SIMPLE_CATCH = 4, 
      BIND_OUTSIDE = 5; 

  var Parser = function Parser(options, input, startPos) {
    this.options = options = getOptions(options);
    this.sourceFile = options.sourceFile;
    this.keywords = wordsRegexp(keywords[options.ecmaVersion >= 6 ? 6 : options.sourceType === "module" ? "5module" : 5]);
    var reserved = "";
    if (options.allowReserved !== true) {
      for (var v = options.ecmaVersion;; v--)
        { if (reserved = reservedWords[v]) { break } }
      if (options.sourceType === "module") { reserved += " await"; }
    }
    this.reservedWords = wordsRegexp(reserved);
    var reservedStrict = (reserved ? reserved + " " : "") + reservedWords.strict;
    this.reservedWordsStrict = wordsRegexp(reservedStrict);
    this.reservedWordsStrictBind = wordsRegexp(reservedStrict + " " + reservedWords.strictBind);
    this.input = String(input);

    this.containsEsc = false;


    if (startPos) {
      this.pos = startPos;
      this.lineStart = this.input.lastIndexOf("\n", startPos - 1) + 1;
      this.curLine = this.input.slice(0, this.lineStart).split(lineBreak).length;
    } else {
      this.pos = this.lineStart = 0;
      this.curLine = 1;
    }

    this.type = types.eof;
    this.value = null;
    this.start = this.end = this.pos;
    this.startLoc = this.endLoc = this.curPosition();

    this.lastTokEndLoc = this.lastTokStartLoc = null;
    this.lastTokStart = this.lastTokEnd = this.pos;

    this.context = this.initialContext();
    this.exprAllowed = true;

    this.inModule = options.sourceType === "module";
    this.strict = this.inModule || this.strictDirective(this.pos);

    this.potentialArrowAt = -1;

    this.yieldPos = this.awaitPos = this.awaitIdentPos = 0;
    this.labels = [];
    this.undefinedExports = {};

    if (this.pos === 0 && options.allowHashBang && this.input.slice(0, 2) === "#!")
      { this.skipLineComment(2); }

    this.scopeStack = [];
    this.enterScope(SCOPE_TOP);

    this.regexpState = null;
  };

  var prototypeAccessors = { inFunction: { configurable: true },inGenerator: { configurable: true },inAsync: { configurable: true },allowSuper: { configurable: true },allowDirectSuper: { configurable: true },treatFunctionsAsVar: { configurable: true } };

  Parser.prototype.parse = function parse () {
    var node = this.options.program || this.startNode();
    this.nextToken();
    return this.parseTopLevel(node)
  };

  prototypeAccessors.inFunction.get = function () { return (this.currentVarScope().flags & SCOPE_FUNCTION) > 0 };
  prototypeAccessors.inGenerator.get = function () { return (this.currentVarScope().flags & SCOPE_GENERATOR) > 0 };
  prototypeAccessors.inAsync.get = function () { return (this.currentVarScope().flags & SCOPE_ASYNC) > 0 };
  prototypeAccessors.allowSuper.get = function () { return (this.currentThisScope().flags & SCOPE_SUPER) > 0 };
  prototypeAccessors.allowDirectSuper.get = function () { return (this.currentThisScope().flags & SCOPE_DIRECT_SUPER) > 0 };
  prototypeAccessors.treatFunctionsAsVar.get = function () { return this.treatFunctionsAsVarInScope(this.currentScope()) };

  Parser.prototype.inNonArrowFunction = function inNonArrowFunction () { return (this.currentThisScope().flags & SCOPE_FUNCTION) > 0 };

  Parser.extend = function extend () {
      var plugins = [], len = arguments.length;
      while ( len-- ) plugins[ len ] = arguments[ len ];

    var cls = this;
    for (var i = 0; i < plugins.length; i++) { cls = plugins[i](cls); }
    return cls
  };

  Parser.parse = function parse (input, options) {
    return new this(options, input).parse()
  };

  Parser.parseExpressionAt = function parseExpressionAt (input, pos, options) {
    var parser = new this(options, input, pos);
    parser.nextToken();
    return parser.parseExpression()
  };

  Parser.tokenizer = function tokenizer (input, options) {
    return new this(options, input)
  };

  Object.defineProperties( Parser.prototype, prototypeAccessors );

  var pp = Parser.prototype;


  var literal = /^(?:'((?:\\.|[^'])*?)'|"((?:\\.|[^"])*?)")/;
  pp.strictDirective = function(start) {
    for (;;) {
      skipWhiteSpace.lastIndex = start;
      start += skipWhiteSpace.exec(this.input)[0].length;
      var match = literal.exec(this.input.slice(start));
      if (!match) { return false }
      if ((match[1] || match[2]) === "use strict") { return true }
      start += match[0].length;

      skipWhiteSpace.lastIndex = start;
      start += skipWhiteSpace.exec(this.input)[0].length;
      if (this.input[start] === ";")
        { start++; }
    }
  };


  pp.eat = function(type) {
    if (this.type === type) {
      this.next();
      return true
    } else {
      return false
    }
  };


  pp.isContextual = function(name) {
    return this.type === types.name && this.value === name && !this.containsEsc
  };


  pp.eatContextual = function(name) {
    if (!this.isContextual(name)) { return false }
    this.next();
    return true
  };


  pp.expectContextual = function(name) {
    if (!this.eatContextual(name)) { this.unexpected(); }
  };


  pp.canInsertSemicolon = function() {
    return this.type === types.eof ||
      this.type === types.braceR ||
      lineBreak.test(this.input.slice(this.lastTokEnd, this.start))
  };

  pp.insertSemicolon = function() {
    if (this.canInsertSemicolon()) {
      if (this.options.onInsertedSemicolon)
        { this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc); }
      return true
    }
  };


  pp.semicolon = function() {
    if (!this.eat(types.semi) && !this.insertSemicolon()) { this.unexpected(); }
  };

  pp.afterTrailingComma = function(tokType, notNext) {
    if (this.type === tokType) {
      if (this.options.onTrailingComma)
        { this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc); }
      if (!notNext)
        { this.next(); }
      return true
    }
  };


  pp.expect = function(type) {
    this.eat(type) || this.unexpected();
  };


  pp.unexpected = function(pos) {
    this.raise(pos != null ? pos : this.start, "Unexpected token");
  };

  function DestructuringErrors() {
    this.shorthandAssign =
    this.trailingComma =
    this.parenthesizedAssign =
    this.parenthesizedBind =
    this.doubleProto =
      -1;
  }

  pp.checkPatternErrors = function(refDestructuringErrors, isAssign) {
    if (!refDestructuringErrors) { return }
    if (refDestructuringErrors.trailingComma > -1)
      { this.raiseRecoverable(refDestructuringErrors.trailingComma, "Comma is not permitted after the rest element"); }
    var parens = isAssign ? refDestructuringErrors.parenthesizedAssign : refDestructuringErrors.parenthesizedBind;
    if (parens > -1) { this.raiseRecoverable(parens, "Parenthesized pattern"); }
  };

  pp.checkExpressionErrors = function(refDestructuringErrors, andThrow) {
    if (!refDestructuringErrors) { return false }
    var shorthandAssign = refDestructuringErrors.shorthandAssign;
    var doubleProto = refDestructuringErrors.doubleProto;
    if (!andThrow) { return shorthandAssign >= 0 || doubleProto >= 0 }
    if (shorthandAssign >= 0)
      { this.raise(shorthandAssign, "Shorthand property assignments are valid only in destructuring patterns"); }
    if (doubleProto >= 0)
      { this.raiseRecoverable(doubleProto, "Redefinition of __proto__ property"); }
  };

  pp.checkYieldAwaitInDefaultParams = function() {
    if (this.yieldPos && (!this.awaitPos || this.yieldPos < this.awaitPos))
      { this.raise(this.yieldPos, "Yield expression cannot be a default value"); }
    if (this.awaitPos)
      { this.raise(this.awaitPos, "Await expression cannot be a default value"); }
  };

  pp.isSimpleAssignTarget = function(expr) {
    if (expr.type === "ParenthesizedExpression")
      { return this.isSimpleAssignTarget(expr.expression) }
    return expr.type === "Identifier" || expr.type === "MemberExpression"
  };

  var pp$1 = Parser.prototype;



  pp$1.parseTopLevel = function(node) {
    var exports = {};
    if (!node.body) { node.body = []; }
    while (this.type !== types.eof) {
      var stmt = this.parseStatement(null, true, exports);
      node.body.push(stmt);
    }
    if (this.inModule)
      { for (var i = 0, list = Object.keys(this.undefinedExports); i < list.length; i += 1)
        {
          var name = list[i];

          this.raiseRecoverable(this.undefinedExports[name].start, ("Export '" + name + "' is not defined"));
        } }
    this.adaptDirectivePrologue(node.body);
    this.next();
    node.sourceType = this.options.sourceType;
    return this.finishNode(node, "Program")
  };

  var loopLabel = {kind: "loop"}, switchLabel = {kind: "switch"};

  pp$1.isLet = function(context) {
    if (this.options.ecmaVersion < 6 || !this.isContextual("let")) { return false }
    skipWhiteSpace.lastIndex = this.pos;
    var skip = skipWhiteSpace.exec(this.input);
    var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);
    if (nextCh === 91) { return true } 
    if (context) { return false }

    if (nextCh === 123) { return true } 
    if (isIdentifierStart(nextCh, true)) {
      var pos = next + 1;
      while (isIdentifierChar(this.input.charCodeAt(pos), true)) { ++pos; }
      var ident = this.input.slice(next, pos);
      if (!keywordRelationalOperator.test(ident)) { return true }
    }
    return false
  };

  pp$1.isAsyncFunction = function() {
    if (this.options.ecmaVersion < 8 || !this.isContextual("async"))
      { return false }

    skipWhiteSpace.lastIndex = this.pos;
    var skip = skipWhiteSpace.exec(this.input);
    var next = this.pos + skip[0].length;
    return !lineBreak.test(this.input.slice(this.pos, next)) &&
      this.input.slice(next, next + 8) === "function" &&
      (next + 8 === this.input.length || !isIdentifierChar(this.input.charAt(next + 8)))
  };


  pp$1.parseStatement = function(context, topLevel, exports) {
    var starttype = this.type, node = this.startNode(), kind;

    if (this.isLet(context)) {
      starttype = types._var;
      kind = "let";
    }


    switch (starttype) {
    case types._break: case types._continue: return this.parseBreakContinueStatement(node, starttype.keyword)
    case types._debugger: return this.parseDebuggerStatement(node)
    case types._do: return this.parseDoStatement(node)
    case types._for: return this.parseForStatement(node)
    case types._function:
      if ((context && (this.strict || context !== "if" && context !== "label")) && this.options.ecmaVersion >= 6) { this.unexpected(); }
      return this.parseFunctionStatement(node, false, !context)
    case types._class:
      if (context) { this.unexpected(); }
      return this.parseClass(node, true)
    case types._if: return this.parseIfStatement(node)
    case types._return: return this.parseReturnStatement(node)
    case types._switch: return this.parseSwitchStatement(node)
    case types._throw: return this.parseThrowStatement(node)
    case types._try: return this.parseTryStatement(node)
    case types._const: case types._var:
      kind = kind || this.value;
      if (context && kind !== "var") { this.unexpected(); }
      return this.parseVarStatement(node, kind)
    case types._while: return this.parseWhileStatement(node)
    case types._with: return this.parseWithStatement(node)
    case types.braceL: return this.parseBlock(true, node)
    case types.semi: return this.parseEmptyStatement(node)
    case types._export:
    case types._import:
      if (this.options.ecmaVersion > 10 && starttype === types._import) {
        skipWhiteSpace.lastIndex = this.pos;
        var skip = skipWhiteSpace.exec(this.input);
        var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);
        if (nextCh === 40) 
          { return this.parseExpressionStatement(node, this.parseExpression()) }
      }

      if (!this.options.allowImportExportEverywhere) {
        if (!topLevel)
          { this.raise(this.start, "'import' and 'export' may only appear at the top level"); }
        if (!this.inModule)
          { this.raise(this.start, "'import' and 'export' may appear only with 'sourceType: module'"); }
      }
      return starttype === types._import ? this.parseImport(node) : this.parseExport(node, exports)

    default:
      if (this.isAsyncFunction()) {
        if (context) { this.unexpected(); }
        this.next();
        return this.parseFunctionStatement(node, true, !context)
      }

      var maybeName = this.value, expr = this.parseExpression();
      if (starttype === types.name && expr.type === "Identifier" && this.eat(types.colon))
        { return this.parseLabeledStatement(node, maybeName, expr, context) }
      else { return this.parseExpressionStatement(node, expr) }
    }
  };

  pp$1.parseBreakContinueStatement = function(node, keyword) {
    var isBreak = keyword === "break";
    this.next();
    if (this.eat(types.semi) || this.insertSemicolon()) { node.label = null; }
    else if (this.type !== types.name) { this.unexpected(); }
    else {
      node.label = this.parseIdent();
      this.semicolon();
    }

    var i = 0;
    for (; i < this.labels.length; ++i) {
      var lab = this.labels[i];
      if (node.label == null || lab.name === node.label.name) {
        if (lab.kind != null && (isBreak || lab.kind === "loop")) { break }
        if (node.label && isBreak) { break }
      }
    }
    if (i === this.labels.length) { this.raise(node.start, "Unsyntactic " + keyword); }
    return this.finishNode(node, isBreak ? "BreakStatement" : "ContinueStatement")
  };

  pp$1.parseDebuggerStatement = function(node) {
    this.next();
    this.semicolon();
    return this.finishNode(node, "DebuggerStatement")
  };

  pp$1.parseDoStatement = function(node) {
    this.next();
    this.labels.push(loopLabel);
    node.body = this.parseStatement("do");
    this.labels.pop();
    this.expect(types._while);
    node.test = this.parseParenExpression();
    if (this.options.ecmaVersion >= 6)
      { this.eat(types.semi); }
    else
      { this.semicolon(); }
    return this.finishNode(node, "DoWhileStatement")
  };


  pp$1.parseForStatement = function(node) {
    this.next();
    var awaitAt = (this.options.ecmaVersion >= 9 && (this.inAsync || (!this.inFunction && this.options.allowAwaitOutsideFunction)) && this.eatContextual("await")) ? this.lastTokStart : -1;
    this.labels.push(loopLabel);
    this.enterScope(0);
    this.expect(types.parenL);
    if (this.type === types.semi) {
      if (awaitAt > -1) { this.unexpected(awaitAt); }
      return this.parseFor(node, null)
    }
    var isLet = this.isLet();
    if (this.type === types._var || this.type === types._const || isLet) {
      var init$1 = this.startNode(), kind = isLet ? "let" : this.value;
      this.next();
      this.parseVar(init$1, true, kind);
      this.finishNode(init$1, "VariableDeclaration");
      if ((this.type === types._in || (this.options.ecmaVersion >= 6 && this.isContextual("of"))) && init$1.declarations.length === 1) {
        if (this.options.ecmaVersion >= 9) {
          if (this.type === types._in) {
            if (awaitAt > -1) { this.unexpected(awaitAt); }
          } else { node.await = awaitAt > -1; }
        }
        return this.parseForIn(node, init$1)
      }
      if (awaitAt > -1) { this.unexpected(awaitAt); }
      return this.parseFor(node, init$1)
    }
    var refDestructuringErrors = new DestructuringErrors;
    var init = this.parseExpression(true, refDestructuringErrors);
    if (this.type === types._in || (this.options.ecmaVersion >= 6 && this.isContextual("of"))) {
      if (this.options.ecmaVersion >= 9) {
        if (this.type === types._in) {
          if (awaitAt > -1) { this.unexpected(awaitAt); }
        } else { node.await = awaitAt > -1; }
      }
      this.toAssignable(init, false, refDestructuringErrors);
      this.checkLVal(init);
      return this.parseForIn(node, init)
    } else {
      this.checkExpressionErrors(refDestructuringErrors, true);
    }
    if (awaitAt > -1) { this.unexpected(awaitAt); }
    return this.parseFor(node, init)
  };

  pp$1.parseFunctionStatement = function(node, isAsync, declarationPosition) {
    this.next();
    return this.parseFunction(node, FUNC_STATEMENT | (declarationPosition ? 0 : FUNC_HANGING_STATEMENT), false, isAsync)
  };

  pp$1.parseIfStatement = function(node) {
    this.next();
    node.test = this.parseParenExpression();
    node.consequent = this.parseStatement("if");
    node.alternate = this.eat(types._else) ? this.parseStatement("if") : null;
    return this.finishNode(node, "IfStatement")
  };

  pp$1.parseReturnStatement = function(node) {
    if (!this.inFunction && !this.options.allowReturnOutsideFunction)
      { this.raise(this.start, "'return' outside of function"); }
    this.next();


    if (this.eat(types.semi) || this.insertSemicolon()) { node.argument = null; }
    else { node.argument = this.parseExpression(); this.semicolon(); }
    return this.finishNode(node, "ReturnStatement")
  };

  pp$1.parseSwitchStatement = function(node) {
    this.next();
    node.discriminant = this.parseParenExpression();
    node.cases = [];
    this.expect(types.braceL);
    this.labels.push(switchLabel);
    this.enterScope(0);


    var cur;
    for (var sawDefault = false; this.type !== types.braceR;) {
      if (this.type === types._case || this.type === types._default) {
        var isCase = this.type === types._case;
        if (cur) { this.finishNode(cur, "SwitchCase"); }
        node.cases.push(cur = this.startNode());
        cur.consequent = [];
        this.next();
        if (isCase) {
          cur.test = this.parseExpression();
        } else {
          if (sawDefault) { this.raiseRecoverable(this.lastTokStart, "Multiple default clauses"); }
          sawDefault = true;
          cur.test = null;
        }
        this.expect(types.colon);
      } else {
        if (!cur) { this.unexpected(); }
        cur.consequent.push(this.parseStatement(null));
      }
    }
    this.exitScope();
    if (cur) { this.finishNode(cur, "SwitchCase"); }
    this.next(); 
    this.labels.pop();
    return this.finishNode(node, "SwitchStatement")
  };

  pp$1.parseThrowStatement = function(node) {
    this.next();
    if (lineBreak.test(this.input.slice(this.lastTokEnd, this.start)))
      { this.raise(this.lastTokEnd, "Illegal newline after throw"); }
    node.argument = this.parseExpression();
    this.semicolon();
    return this.finishNode(node, "ThrowStatement")
  };


  var empty = [];

  pp$1.parseTryStatement = function(node) {
    this.next();
    node.block = this.parseBlock();
    node.handler = null;
    if (this.type === types._catch) {
      var clause = this.startNode();
      this.next();
      if (this.eat(types.parenL)) {
        clause.param = this.parseBindingAtom();
        var simple = clause.param.type === "Identifier";
        this.enterScope(simple ? SCOPE_SIMPLE_CATCH : 0);
        this.checkLVal(clause.param, simple ? BIND_SIMPLE_CATCH : BIND_LEXICAL);
        this.expect(types.parenR);
      } else {
        if (this.options.ecmaVersion < 10) { this.unexpected(); }
        clause.param = null;
        this.enterScope(0);
      }
      clause.body = this.parseBlock(false);
      this.exitScope();
      node.handler = this.finishNode(clause, "CatchClause");
    }
    node.finalizer = this.eat(types._finally) ? this.parseBlock() : null;
    if (!node.handler && !node.finalizer)
      { this.raise(node.start, "Missing catch or finally clause"); }
    return this.finishNode(node, "TryStatement")
  };

  pp$1.parseVarStatement = function(node, kind) {
    this.next();
    this.parseVar(node, false, kind);
    this.semicolon();
    return this.finishNode(node, "VariableDeclaration")
  };

  pp$1.parseWhileStatement = function(node) {
    this.next();
    node.test = this.parseParenExpression();
    this.labels.push(loopLabel);
    node.body = this.parseStatement("while");
    this.labels.pop();
    return this.finishNode(node, "WhileStatement")
  };

  pp$1.parseWithStatement = function(node) {
    if (this.strict) { this.raise(this.start, "'with' in strict mode"); }
    this.next();
    node.object = this.parseParenExpression();
    node.body = this.parseStatement("with");
    return this.finishNode(node, "WithStatement")
  };

  pp$1.parseEmptyStatement = function(node) {
    this.next();
    return this.finishNode(node, "EmptyStatement")
  };

  pp$1.parseLabeledStatement = function(node, maybeName, expr, context) {
    for (var i$1 = 0, list = this.labels; i$1 < list.length; i$1 += 1)
      {
      var label = list[i$1];

      if (label.name === maybeName)
        { this.raise(expr.start, "Label '" + maybeName + "' is already declared");
    } }
    var kind = this.type.isLoop ? "loop" : this.type === types._switch ? "switch" : null;
    for (var i = this.labels.length - 1; i >= 0; i--) {
      var label$1 = this.labels[i];
      if (label$1.statementStart === node.start) {
        label$1.statementStart = this.start;
        label$1.kind = kind;
      } else { break }
    }
    this.labels.push({name: maybeName, kind: kind, statementStart: this.start});
    node.body = this.parseStatement(context ? context.indexOf("label") === -1 ? context + "label" : context : "label");
    this.labels.pop();
    node.label = expr;
    return this.finishNode(node, "LabeledStatement")
  };

  pp$1.parseExpressionStatement = function(node, expr) {
    node.expression = expr;
    this.semicolon();
    return this.finishNode(node, "ExpressionStatement")
  };


  pp$1.parseBlock = function(createNewLexicalScope, node) {
    if ( createNewLexicalScope === void 0 ) createNewLexicalScope = true;
    if ( node === void 0 ) node = this.startNode();

    node.body = [];
    this.expect(types.braceL);
    if (createNewLexicalScope) { this.enterScope(0); }
    while (!this.eat(types.braceR)) {
      var stmt = this.parseStatement(null);
      node.body.push(stmt);
    }
    if (createNewLexicalScope) { this.exitScope(); }
    return this.finishNode(node, "BlockStatement")
  };


  pp$1.parseFor = function(node, init) {
    node.init = init;
    this.expect(types.semi);
    node.test = this.type === types.semi ? null : this.parseExpression();
    this.expect(types.semi);
    node.update = this.type === types.parenR ? null : this.parseExpression();
    this.expect(types.parenR);
    node.body = this.parseStatement("for");
    this.exitScope();
    this.labels.pop();
    return this.finishNode(node, "ForStatement")
  };


  pp$1.parseForIn = function(node, init) {
    var isForIn = this.type === types._in;
    this.next();

    if (
      init.type === "VariableDeclaration" &&
      init.declarations[0].init != null &&
      (
        !isForIn ||
        this.options.ecmaVersion < 8 ||
        this.strict ||
        init.kind !== "var" ||
        init.declarations[0].id.type !== "Identifier"
      )
    ) {
      this.raise(
        init.start,
        ((isForIn ? "for-in" : "for-of") + " loop variable declaration may not have an initializer")
      );
    } else if (init.type === "AssignmentPattern") {
      this.raise(init.start, "Invalid left-hand side in for-loop");
    }
    node.left = init;
    node.right = isForIn ? this.parseExpression() : this.parseMaybeAssign();
    this.expect(types.parenR);
    node.body = this.parseStatement("for");
    this.exitScope();
    this.labels.pop();
    return this.finishNode(node, isForIn ? "ForInStatement" : "ForOfStatement")
  };


  pp$1.parseVar = function(node, isFor, kind) {
    node.declarations = [];
    node.kind = kind;
    for (;;) {
      var decl = this.startNode();
      this.parseVarId(decl, kind);
      if (this.eat(types.eq)) {
        decl.init = this.parseMaybeAssign(isFor);
      } else if (kind === "const" && !(this.type === types._in || (this.options.ecmaVersion >= 6 && this.isContextual("of")))) {
        this.unexpected();
      } else if (decl.id.type !== "Identifier" && !(isFor && (this.type === types._in || this.isContextual("of")))) {
        this.raise(this.lastTokEnd, "Complex binding patterns require an initialization value");
      } else {
        decl.init = null;
      }
      node.declarations.push(this.finishNode(decl, "VariableDeclarator"));
      if (!this.eat(types.comma)) { break }
    }
    return node
  };

  pp$1.parseVarId = function(decl, kind) {
    decl.id = this.parseBindingAtom();
    this.checkLVal(decl.id, kind === "var" ? BIND_VAR : BIND_LEXICAL, false);
  };

  var FUNC_STATEMENT = 1, FUNC_HANGING_STATEMENT = 2, FUNC_NULLABLE_ID = 4;


  pp$1.parseFunction = function(node, statement, allowExpressionBody, isAsync) {
    this.initFunction(node);
    if (this.options.ecmaVersion >= 9 || this.options.ecmaVersion >= 6 && !isAsync) {
      if (this.type === types.star && (statement & FUNC_HANGING_STATEMENT))
        { this.unexpected(); }
      node.generator = this.eat(types.star);
    }
    if (this.options.ecmaVersion >= 8)
      { node.async = !!isAsync; }

    if (statement & FUNC_STATEMENT) {
      node.id = (statement & FUNC_NULLABLE_ID) && this.type !== types.name ? null : this.parseIdent();
      if (node.id && !(statement & FUNC_HANGING_STATEMENT))
        { this.checkLVal(node.id, (this.strict || node.generator || node.async) ? this.treatFunctionsAsVar ? BIND_VAR : BIND_LEXICAL : BIND_FUNCTION); }
    }

    var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
    this.yieldPos = 0;
    this.awaitPos = 0;
    this.awaitIdentPos = 0;
    this.enterScope(functionFlags(node.async, node.generator));

    if (!(statement & FUNC_STATEMENT))
      { node.id = this.type === types.name ? this.parseIdent() : null; }

    this.parseFunctionParams(node);
    this.parseFunctionBody(node, allowExpressionBody, false);

    this.yieldPos = oldYieldPos;
    this.awaitPos = oldAwaitPos;
    this.awaitIdentPos = oldAwaitIdentPos;
    return this.finishNode(node, (statement & FUNC_STATEMENT) ? "FunctionDeclaration" : "FunctionExpression")
  };

  pp$1.parseFunctionParams = function(node) {
    this.expect(types.parenL);
    node.params = this.parseBindingList(types.parenR, false, this.options.ecmaVersion >= 8);
    this.checkYieldAwaitInDefaultParams();
  };


  pp$1.parseClass = function(node, isStatement) {
    this.next();

    var oldStrict = this.strict;
    this.strict = true;

    this.parseClassId(node, isStatement);
    this.parseClassSuper(node);
    var classBody = this.startNode();
    var hadConstructor = false;
    classBody.body = [];
    this.expect(types.braceL);
    while (!this.eat(types.braceR)) {
      var element = this.parseClassElement(node.superClass !== null);
      if (element) {
        classBody.body.push(element);
        if (element.type === "MethodDefinition" && element.kind === "constructor") {
          if (hadConstructor) { this.raise(element.start, "Duplicate constructor in the same class"); }
          hadConstructor = true;
        }
      }
    }
    node.body = this.finishNode(classBody, "ClassBody");
    this.strict = oldStrict;
    return this.finishNode(node, isStatement ? "ClassDeclaration" : "ClassExpression")
  };

  pp$1.parseClassElement = function(constructorAllowsSuper) {
    var this$1 = this;

    if (this.eat(types.semi)) { return null }

    var method = this.startNode();
    var tryContextual = function (k, noLineBreak) {
      if ( noLineBreak === void 0 ) noLineBreak = false;

      var start = this$1.start, startLoc = this$1.startLoc;
      if (!this$1.eatContextual(k)) { return false }
      if (this$1.type !== types.parenL && (!noLineBreak || !this$1.canInsertSemicolon())) { return true }
      if (method.key) { this$1.unexpected(); }
      method.computed = false;
      method.key = this$1.startNodeAt(start, startLoc);
      method.key.name = k;
      this$1.finishNode(method.key, "Identifier");
      return false
    };

    method.kind = "method";
    method.static = tryContextual("static");
    var isGenerator = this.eat(types.star);
    var isAsync = false;
    if (!isGenerator) {
      if (this.options.ecmaVersion >= 8 && tryContextual("async", true)) {
        isAsync = true;
        isGenerator = this.options.ecmaVersion >= 9 && this.eat(types.star);
      } else if (tryContextual("get")) {
        method.kind = "get";
      } else if (tryContextual("set")) {
        method.kind = "set";
      }
    }
    if (!method.key) { this.parsePropertyName(method); }
    var key = method.key;
    var allowsDirectSuper = false;
    if (!method.computed && !method.static && (key.type === "Identifier" && key.name === "constructor" ||
        key.type === "Literal" && key.value === "constructor")) {
      if (method.kind !== "method") { this.raise(key.start, "Constructor can't have get/set modifier"); }
      if (isGenerator) { this.raise(key.start, "Constructor can't be a generator"); }
      if (isAsync) { this.raise(key.start, "Constructor can't be an async method"); }
      method.kind = "constructor";
      allowsDirectSuper = constructorAllowsSuper;
    } else if (method.static && key.type === "Identifier" && key.name === "prototype") {
      this.raise(key.start, "Classes may not have a static property named prototype");
    }
    this.parseClassMethod(method, isGenerator, isAsync, allowsDirectSuper);
    if (method.kind === "get" && method.value.params.length !== 0)
      { this.raiseRecoverable(method.value.start, "getter should have no params"); }
    if (method.kind === "set" && method.value.params.length !== 1)
      { this.raiseRecoverable(method.value.start, "setter should have exactly one param"); }
    if (method.kind === "set" && method.value.params[0].type === "RestElement")
      { this.raiseRecoverable(method.value.params[0].start, "Setter cannot use rest params"); }
    return method
  };

  pp$1.parseClassMethod = function(method, isGenerator, isAsync, allowsDirectSuper) {
    method.value = this.parseMethod(isGenerator, isAsync, allowsDirectSuper);
    return this.finishNode(method, "MethodDefinition")
  };

  pp$1.parseClassId = function(node, isStatement) {
    if (this.type === types.name) {
      node.id = this.parseIdent();
      if (isStatement)
        { this.checkLVal(node.id, BIND_LEXICAL, false); }
    } else {
      if (isStatement === true)
        { this.unexpected(); }
      node.id = null;
    }
  };

  pp$1.parseClassSuper = function(node) {
    node.superClass = this.eat(types._extends) ? this.parseExprSubscripts() : null;
  };


  pp$1.parseExport = function(node, exports) {
    this.next();
    if (this.eat(types.star)) {
      this.expectContextual("from");
      if (this.type !== types.string) { this.unexpected(); }
      node.source = this.parseExprAtom();
      this.semicolon();
      return this.finishNode(node, "ExportAllDeclaration")
    }
    if (this.eat(types._default)) { 
      this.checkExport(exports, "default", this.lastTokStart);
      var isAsync;
      if (this.type === types._function || (isAsync = this.isAsyncFunction())) {
        var fNode = this.startNode();
        this.next();
        if (isAsync) { this.next(); }
        node.declaration = this.parseFunction(fNode, FUNC_STATEMENT | FUNC_NULLABLE_ID, false, isAsync);
      } else if (this.type === types._class) {
        var cNode = this.startNode();
        node.declaration = this.parseClass(cNode, "nullableID");
      } else {
        node.declaration = this.parseMaybeAssign();
        this.semicolon();
      }
      return this.finishNode(node, "ExportDefaultDeclaration")
    }
    if (this.shouldParseExportStatement()) {
      node.declaration = this.parseStatement(null);
      if (node.declaration.type === "VariableDeclaration")
        { this.checkVariableExport(exports, node.declaration.declarations); }
      else
        { this.checkExport(exports, node.declaration.id.name, node.declaration.id.start); }
      node.specifiers = [];
      node.source = null;
    } else { 
      node.declaration = null;
      node.specifiers = this.parseExportSpecifiers(exports);
      if (this.eatContextual("from")) {
        if (this.type !== types.string) { this.unexpected(); }
        node.source = this.parseExprAtom();
      } else {
        for (var i = 0, list = node.specifiers; i < list.length; i += 1) {
          var spec = list[i];

          this.checkUnreserved(spec.local);
          this.checkLocalExport(spec.local);
        }

        node.source = null;
      }
      this.semicolon();
    }
    return this.finishNode(node, "ExportNamedDeclaration")
  };

  pp$1.checkExport = function(exports, name, pos) {
    if (!exports) { return }
    if (has(exports, name))
      { this.raiseRecoverable(pos, "Duplicate export '" + name + "'"); }
    exports[name] = true;
  };

  pp$1.checkPatternExport = function(exports, pat) {
    var type = pat.type;
    if (type === "Identifier")
      { this.checkExport(exports, pat.name, pat.start); }
    else if (type === "ObjectPattern")
      { for (var i = 0, list = pat.properties; i < list.length; i += 1)
        {
          var prop = list[i];

          this.checkPatternExport(exports, prop);
        } }
    else if (type === "ArrayPattern")
      { for (var i$1 = 0, list$1 = pat.elements; i$1 < list$1.length; i$1 += 1) {
        var elt = list$1[i$1];

          if (elt) { this.checkPatternExport(exports, elt); }
      } }
    else if (type === "Property")
      { this.checkPatternExport(exports, pat.value); }
    else if (type === "AssignmentPattern")
      { this.checkPatternExport(exports, pat.left); }
    else if (type === "RestElement")
      { this.checkPatternExport(exports, pat.argument); }
    else if (type === "ParenthesizedExpression")
      { this.checkPatternExport(exports, pat.expression); }
  };

  pp$1.checkVariableExport = function(exports, decls) {
    if (!exports) { return }
    for (var i = 0, list = decls; i < list.length; i += 1)
      {
      var decl = list[i];

      this.checkPatternExport(exports, decl.id);
    }
  };

  pp$1.shouldParseExportStatement = function() {
    return this.type.keyword === "var" ||
      this.type.keyword === "const" ||
      this.type.keyword === "class" ||
      this.type.keyword === "function" ||
      this.isLet() ||
      this.isAsyncFunction()
  };


  pp$1.parseExportSpecifiers = function(exports) {
    var nodes = [], first = true;
    this.expect(types.braceL);
    while (!this.eat(types.braceR)) {
      if (!first) {
        this.expect(types.comma);
        if (this.afterTrailingComma(types.braceR)) { break }
      } else { first = false; }

      var node = this.startNode();
      node.local = this.parseIdent(true);
      node.exported = this.eatContextual("as") ? this.parseIdent(true) : node.local;
      this.checkExport(exports, node.exported.name, node.exported.start);
      nodes.push(this.finishNode(node, "ExportSpecifier"));
    }
    return nodes
  };


  pp$1.parseImport = function(node) {
    this.next();
    if (this.type === types.string) {
      node.specifiers = empty;
      node.source = this.parseExprAtom();
    } else {
      node.specifiers = this.parseImportSpecifiers();
      this.expectContextual("from");
      node.source = this.type === types.string ? this.parseExprAtom() : this.unexpected();
    }
    this.semicolon();
    return this.finishNode(node, "ImportDeclaration")
  };


  pp$1.parseImportSpecifiers = function() {
    var nodes = [], first = true;
    if (this.type === types.name) {
      var node = this.startNode();
      node.local = this.parseIdent();
      this.checkLVal(node.local, BIND_LEXICAL);
      nodes.push(this.finishNode(node, "ImportDefaultSpecifier"));
      if (!this.eat(types.comma)) { return nodes }
    }
    if (this.type === types.star) {
      var node$1 = this.startNode();
      this.next();
      this.expectContextual("as");
      node$1.local = this.parseIdent();
      this.checkLVal(node$1.local, BIND_LEXICAL);
      nodes.push(this.finishNode(node$1, "ImportNamespaceSpecifier"));
      return nodes
    }
    this.expect(types.braceL);
    while (!this.eat(types.braceR)) {
      if (!first) {
        this.expect(types.comma);
        if (this.afterTrailingComma(types.braceR)) { break }
      } else { first = false; }

      var node$2 = this.startNode();
      node$2.imported = this.parseIdent(true);
      if (this.eatContextual("as")) {
        node$2.local = this.parseIdent();
      } else {
        this.checkUnreserved(node$2.imported);
        node$2.local = node$2.imported;
      }
      this.checkLVal(node$2.local, BIND_LEXICAL);
      nodes.push(this.finishNode(node$2, "ImportSpecifier"));
    }
    return nodes
  };

  pp$1.adaptDirectivePrologue = function(statements) {
    for (var i = 0; i < statements.length && this.isDirectiveCandidate(statements[i]); ++i) {
      statements[i].directive = statements[i].expression.raw.slice(1, -1);
    }
  };
  pp$1.isDirectiveCandidate = function(statement) {
    return (
      statement.type === "ExpressionStatement" &&
      statement.expression.type === "Literal" &&
      typeof statement.expression.value === "string" &&
      (this.input[statement.start] === "\"" || this.input[statement.start] === "'")
    )
  };

  var pp$2 = Parser.prototype;


  pp$2.toAssignable = function(node, isBinding, refDestructuringErrors) {
    if (this.options.ecmaVersion >= 6 && node) {
      switch (node.type) {
      case "Identifier":
        if (this.inAsync && node.name === "await")
          { this.raise(node.start, "Cannot use 'await' as identifier inside an async function"); }
        break

      case "ObjectPattern":
      case "ArrayPattern":
      case "RestElement":
        break

      case "ObjectExpression":
        node.type = "ObjectPattern";
        if (refDestructuringErrors) { this.checkPatternErrors(refDestructuringErrors, true); }
        for (var i = 0, list = node.properties; i < list.length; i += 1) {
          var prop = list[i];

        this.toAssignable(prop, isBinding);
          if (
            prop.type === "RestElement" &&
            (prop.argument.type === "ArrayPattern" || prop.argument.type === "ObjectPattern")
          ) {
            this.raise(prop.argument.start, "Unexpected token");
          }
        }
        break

      case "Property":
        if (node.kind !== "init") { this.raise(node.key.start, "Object pattern can't contain getter or setter"); }
        this.toAssignable(node.value, isBinding);
        break

      case "ArrayExpression":
        node.type = "ArrayPattern";
        if (refDestructuringErrors) { this.checkPatternErrors(refDestructuringErrors, true); }
        this.toAssignableList(node.elements, isBinding);
        break

      case "SpreadElement":
        node.type = "RestElement";
        this.toAssignable(node.argument, isBinding);
        if (node.argument.type === "AssignmentPattern")
          { this.raise(node.argument.start, "Rest elements cannot have a default value"); }
        break

      case "AssignmentExpression":
        if (node.operator !== "=") { this.raise(node.left.end, "Only '=' operator can be used for specifying default value."); }
        node.type = "AssignmentPattern";
        delete node.operator;
        this.toAssignable(node.left, isBinding);

      case "AssignmentPattern":
        break

      case "ParenthesizedExpression":
        this.toAssignable(node.expression, isBinding, refDestructuringErrors);
        break

      case "MemberExpression":
        if (!isBinding) { break }

      default:
        this.raise(node.start, "Assigning to rvalue");
      }
    } else if (refDestructuringErrors) { this.checkPatternErrors(refDestructuringErrors, true); }
    return node
  };


  pp$2.toAssignableList = function(exprList, isBinding) {
    var end = exprList.length;
    for (var i = 0; i < end; i++) {
      var elt = exprList[i];
      if (elt) { this.toAssignable(elt, isBinding); }
    }
    if (end) {
      var last = exprList[end - 1];
      if (this.options.ecmaVersion === 6 && isBinding && last && last.type === "RestElement" && last.argument.type !== "Identifier")
        { this.unexpected(last.argument.start); }
    }
    return exprList
  };


  pp$2.parseSpread = function(refDestructuringErrors) {
    var node = this.startNode();
    this.next();
    node.argument = this.parseMaybeAssign(false, refDestructuringErrors);
    return this.finishNode(node, "SpreadElement")
  };

  pp$2.parseRestBinding = function() {
    var node = this.startNode();
    this.next();

    if (this.options.ecmaVersion === 6 && this.type !== types.name)
      { this.unexpected(); }

    node.argument = this.parseBindingAtom();

    return this.finishNode(node, "RestElement")
  };


  pp$2.parseBindingAtom = function() {
    if (this.options.ecmaVersion >= 6) {
      switch (this.type) {
      case types.bracketL:
        var node = this.startNode();
        this.next();
        node.elements = this.parseBindingList(types.bracketR, true, true);
        return this.finishNode(node, "ArrayPattern")

      case types.braceL:
        return this.parseObj(true)
      }
    }
    return this.parseIdent()
  };

  pp$2.parseBindingList = function(close, allowEmpty, allowTrailingComma) {
    var elts = [], first = true;
    while (!this.eat(close)) {
      if (first) { first = false; }
      else { this.expect(types.comma); }
      if (allowEmpty && this.type === types.comma) {
        elts.push(null);
      } else if (allowTrailingComma && this.afterTrailingComma(close)) {
        break
      } else if (this.type === types.ellipsis) {
        var rest = this.parseRestBinding();
        this.parseBindingListItem(rest);
        elts.push(rest);
        if (this.type === types.comma) { this.raise(this.start, "Comma is not permitted after the rest element"); }
        this.expect(close);
        break
      } else {
        var elem = this.parseMaybeDefault(this.start, this.startLoc);
        this.parseBindingListItem(elem);
        elts.push(elem);
      }
    }
    return elts
  };

  pp$2.parseBindingListItem = function(param) {
    return param
  };


  pp$2.parseMaybeDefault = function(startPos, startLoc, left) {
    left = left || this.parseBindingAtom();
    if (this.options.ecmaVersion < 6 || !this.eat(types.eq)) { return left }
    var node = this.startNodeAt(startPos, startLoc);
    node.left = left;
    node.right = this.parseMaybeAssign();
    return this.finishNode(node, "AssignmentPattern")
  };


  pp$2.checkLVal = function(expr, bindingType, checkClashes) {
    if ( bindingType === void 0 ) bindingType = BIND_NONE;

    switch (expr.type) {
    case "Identifier":
      if (bindingType === BIND_LEXICAL && expr.name === "let")
        { this.raiseRecoverable(expr.start, "let is disallowed as a lexically bound name"); }
      if (this.strict && this.reservedWordsStrictBind.test(expr.name))
        { this.raiseRecoverable(expr.start, (bindingType ? "Binding " : "Assigning to ") + expr.name + " in strict mode"); }
      if (checkClashes) {
        if (has(checkClashes, expr.name))
          { this.raiseRecoverable(expr.start, "Argument name clash"); }
        checkClashes[expr.name] = true;
      }
      if (bindingType !== BIND_NONE && bindingType !== BIND_OUTSIDE) { this.declareName(expr.name, bindingType, expr.start); }
      break

    case "MemberExpression":
      if (bindingType) { this.raiseRecoverable(expr.start, "Binding member expression"); }
      break

    case "ObjectPattern":
      for (var i = 0, list = expr.properties; i < list.length; i += 1)
        {
      var prop = list[i];

      this.checkLVal(prop, bindingType, checkClashes);
    }
      break

    case "Property":
      this.checkLVal(expr.value, bindingType, checkClashes);
      break

    case "ArrayPattern":
      for (var i$1 = 0, list$1 = expr.elements; i$1 < list$1.length; i$1 += 1) {
        var elem = list$1[i$1];

      if (elem) { this.checkLVal(elem, bindingType, checkClashes); }
      }
      break

    case "AssignmentPattern":
      this.checkLVal(expr.left, bindingType, checkClashes);
      break

    case "RestElement":
      this.checkLVal(expr.argument, bindingType, checkClashes);
      break

    case "ParenthesizedExpression":
      this.checkLVal(expr.expression, bindingType, checkClashes);
      break

    default:
      this.raise(expr.start, (bindingType ? "Binding" : "Assigning to") + " rvalue");
    }
  };


  var pp$3 = Parser.prototype;


  pp$3.checkPropClash = function(prop, propHash, refDestructuringErrors) {
    if (this.options.ecmaVersion >= 9 && prop.type === "SpreadElement")
      { return }
    if (this.options.ecmaVersion >= 6 && (prop.computed || prop.method || prop.shorthand))
      { return }
    var key = prop.key;
    var name;
    switch (key.type) {
    case "Identifier": name = key.name; break
    case "Literal": name = String(key.value); break
    default: return
    }
    var kind = prop.kind;
    if (this.options.ecmaVersion >= 6) {
      if (name === "__proto__" && kind === "init") {
        if (propHash.proto) {
          if (refDestructuringErrors) {
            if (refDestructuringErrors.doubleProto < 0)
              { refDestructuringErrors.doubleProto = key.start; }
          } else { this.raiseRecoverable(key.start, "Redefinition of __proto__ property"); }
        }
        propHash.proto = true;
      }
      return
    }
    name = "$" + name;
    var other = propHash[name];
    if (other) {
      var redefinition;
      if (kind === "init") {
        redefinition = this.strict && other.init || other.get || other.set;
      } else {
        redefinition = other.init || other[kind];
      }
      if (redefinition)
        { this.raiseRecoverable(key.start, "Redefinition of property"); }
    } else {
      other = propHash[name] = {
        init: false,
        get: false,
        set: false
      };
    }
    other[kind] = true;
  };




  pp$3.parseExpression = function(noIn, refDestructuringErrors) {
    var startPos = this.start, startLoc = this.startLoc;
    var expr = this.parseMaybeAssign(noIn, refDestructuringErrors);
    if (this.type === types.comma) {
      var node = this.startNodeAt(startPos, startLoc);
      node.expressions = [expr];
      while (this.eat(types.comma)) { node.expressions.push(this.parseMaybeAssign(noIn, refDestructuringErrors)); }
      return this.finishNode(node, "SequenceExpression")
    }
    return expr
  };


  pp$3.parseMaybeAssign = function(noIn, refDestructuringErrors, afterLeftParse) {
    if (this.isContextual("yield")) {
      if (this.inGenerator) { return this.parseYield(noIn) }
      else { this.exprAllowed = false; }
    }

    var ownDestructuringErrors = false, oldParenAssign = -1, oldTrailingComma = -1;
    if (refDestructuringErrors) {
      oldParenAssign = refDestructuringErrors.parenthesizedAssign;
      oldTrailingComma = refDestructuringErrors.trailingComma;
      refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = -1;
    } else {
      refDestructuringErrors = new DestructuringErrors;
      ownDestructuringErrors = true;
    }

    var startPos = this.start, startLoc = this.startLoc;
    if (this.type === types.parenL || this.type === types.name)
      { this.potentialArrowAt = this.start; }
    var left = this.parseMaybeConditional(noIn, refDestructuringErrors);
    if (afterLeftParse) { left = afterLeftParse.call(this, left, startPos, startLoc); }
    if (this.type.isAssign) {
      var node = this.startNodeAt(startPos, startLoc);
      node.operator = this.value;
      node.left = this.type === types.eq ? this.toAssignable(left, false, refDestructuringErrors) : left;
      if (!ownDestructuringErrors) {
        refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = refDestructuringErrors.doubleProto = -1;
      }
      if (refDestructuringErrors.shorthandAssign >= node.left.start)
        { refDestructuringErrors.shorthandAssign = -1; } 
      this.checkLVal(left);
      this.next();
      node.right = this.parseMaybeAssign(noIn);
      return this.finishNode(node, "AssignmentExpression")
    } else {
      if (ownDestructuringErrors) { this.checkExpressionErrors(refDestructuringErrors, true); }
    }
    if (oldParenAssign > -1) { refDestructuringErrors.parenthesizedAssign = oldParenAssign; }
    if (oldTrailingComma > -1) { refDestructuringErrors.trailingComma = oldTrailingComma; }
    return left
  };


  pp$3.parseMaybeConditional = function(noIn, refDestructuringErrors) {
    var startPos = this.start, startLoc = this.startLoc;
    var expr = this.parseExprOps(noIn, refDestructuringErrors);
    if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }
    if (this.eat(types.question)) {
      var node = this.startNodeAt(startPos, startLoc);
      node.test = expr;
      node.consequent = this.parseMaybeAssign();
      this.expect(types.colon);
      node.alternate = this.parseMaybeAssign(noIn);
      return this.finishNode(node, "ConditionalExpression")
    }
    return expr
  };


  pp$3.parseExprOps = function(noIn, refDestructuringErrors) {
    var startPos = this.start, startLoc = this.startLoc;
    var expr = this.parseMaybeUnary(refDestructuringErrors, false);
    if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }
    return expr.start === startPos && expr.type === "ArrowFunctionExpression" ? expr : this.parseExprOp(expr, startPos, startLoc, -1, noIn)
  };


  pp$3.parseExprOp = function(left, leftStartPos, leftStartLoc, minPrec, noIn) {
    var prec = this.type.binop;
    if (prec != null && (!noIn || this.type !== types._in)) {
      if (prec > minPrec) {
        var logical = this.type === types.logicalOR || this.type === types.logicalAND;
        var op = this.value;
        this.next();
        var startPos = this.start, startLoc = this.startLoc;
        var right = this.parseExprOp(this.parseMaybeUnary(null, false), startPos, startLoc, prec, noIn);
        var node = this.buildBinary(leftStartPos, leftStartLoc, left, right, op, logical);
        return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, noIn)
      }
    }
    return left
  };

  pp$3.buildBinary = function(startPos, startLoc, left, right, op, logical) {
    var node = this.startNodeAt(startPos, startLoc);
    node.left = left;
    node.operator = op;
    node.right = right;
    return this.finishNode(node, logical ? "LogicalExpression" : "BinaryExpression")
  };


  pp$3.parseMaybeUnary = function(refDestructuringErrors, sawUnary) {
    var startPos = this.start, startLoc = this.startLoc, expr;
    if (this.isContextual("await") && (this.inAsync || (!this.inFunction && this.options.allowAwaitOutsideFunction))) {
      expr = this.parseAwait();
      sawUnary = true;
    } else if (this.type.prefix) {
      var node = this.startNode(), update = this.type === types.incDec;
      node.operator = this.value;
      node.prefix = true;
      this.next();
      node.argument = this.parseMaybeUnary(null, true);
      this.checkExpressionErrors(refDestructuringErrors, true);
      if (update) { this.checkLVal(node.argument); }
      else if (this.strict && node.operator === "delete" &&
               node.argument.type === "Identifier")
        { this.raiseRecoverable(node.start, "Deleting local variable in strict mode"); }
      else { sawUnary = true; }
      expr = this.finishNode(node, update ? "UpdateExpression" : "UnaryExpression");
    } else {
      expr = this.parseExprSubscripts(refDestructuringErrors);
      if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }
      while (this.type.postfix && !this.canInsertSemicolon()) {
        var node$1 = this.startNodeAt(startPos, startLoc);
        node$1.operator = this.value;
        node$1.prefix = false;
        node$1.argument = expr;
        this.checkLVal(expr);
        this.next();
        expr = this.finishNode(node$1, "UpdateExpression");
      }
    }

    if (!sawUnary && this.eat(types.starstar))
      { return this.buildBinary(startPos, startLoc, expr, this.parseMaybeUnary(null, false), "**", false) }
    else
      { return expr }
  };


  pp$3.parseExprSubscripts = function(refDestructuringErrors) {
    var startPos = this.start, startLoc = this.startLoc;
    var expr = this.parseExprAtom(refDestructuringErrors);
    if (expr.type === "ArrowFunctionExpression" && this.input.slice(this.lastTokStart, this.lastTokEnd) !== ")")
      { return expr }
    var result = this.parseSubscripts(expr, startPos, startLoc);
    if (refDestructuringErrors && result.type === "MemberExpression") {
      if (refDestructuringErrors.parenthesizedAssign >= result.start) { refDestructuringErrors.parenthesizedAssign = -1; }
      if (refDestructuringErrors.parenthesizedBind >= result.start) { refDestructuringErrors.parenthesizedBind = -1; }
    }
    return result
  };

  pp$3.parseSubscripts = function(base, startPos, startLoc, noCalls) {
    var maybeAsyncArrow = this.options.ecmaVersion >= 8 && base.type === "Identifier" && base.name === "async" &&
        this.lastTokEnd === base.end && !this.canInsertSemicolon() && this.input.slice(base.start, base.end) === "async";
    while (true) {
      var element = this.parseSubscript(base, startPos, startLoc, noCalls, maybeAsyncArrow);
      if (element === base || element.type === "ArrowFunctionExpression") { return element }
      base = element;
    }
  };

  pp$3.parseSubscript = function(base, startPos, startLoc, noCalls, maybeAsyncArrow) {
    var computed = this.eat(types.bracketL);
    if (computed || this.eat(types.dot)) {
      var node = this.startNodeAt(startPos, startLoc);
      node.object = base;
      node.property = computed ? this.parseExpression() : this.parseIdent(this.options.allowReserved !== "never");
      node.computed = !!computed;
      if (computed) { this.expect(types.bracketR); }
      base = this.finishNode(node, "MemberExpression");
    } else if (!noCalls && this.eat(types.parenL)) {
      var refDestructuringErrors = new DestructuringErrors, oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
      this.yieldPos = 0;
      this.awaitPos = 0;
      this.awaitIdentPos = 0;
      var exprList = this.parseExprList(types.parenR, this.options.ecmaVersion >= 8, false, refDestructuringErrors);
      if (maybeAsyncArrow && !this.canInsertSemicolon() && this.eat(types.arrow)) {
        this.checkPatternErrors(refDestructuringErrors, false);
        this.checkYieldAwaitInDefaultParams();
        if (this.awaitIdentPos > 0)
          { this.raise(this.awaitIdentPos, "Cannot use 'await' as identifier inside an async function"); }
        this.yieldPos = oldYieldPos;
        this.awaitPos = oldAwaitPos;
        this.awaitIdentPos = oldAwaitIdentPos;
        return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, true)
      }
      this.checkExpressionErrors(refDestructuringErrors, true);
      this.yieldPos = oldYieldPos || this.yieldPos;
      this.awaitPos = oldAwaitPos || this.awaitPos;
      this.awaitIdentPos = oldAwaitIdentPos || this.awaitIdentPos;
      var node$1 = this.startNodeAt(startPos, startLoc);
      node$1.callee = base;
      node$1.arguments = exprList;
      base = this.finishNode(node$1, "CallExpression");
    } else if (this.type === types.backQuote) {
      var node$2 = this.startNodeAt(startPos, startLoc);
      node$2.tag = base;
      node$2.quasi = this.parseTemplate({isTagged: true});
      base = this.finishNode(node$2, "TaggedTemplateExpression");
    }
    return base
  };


  pp$3.parseExprAtom = function(refDestructuringErrors) {
    if (this.type === types.slash) { this.readRegexp(); }

    var node, canBeArrow = this.potentialArrowAt === this.start;
    switch (this.type) {
    case types._super:
      if (!this.allowSuper)
        { this.raise(this.start, "'super' keyword outside a method"); }
      node = this.startNode();
      this.next();
      if (this.type === types.parenL && !this.allowDirectSuper)
        { this.raise(node.start, "super() call outside constructor of a subclass"); }
      if (this.type !== types.dot && this.type !== types.bracketL && this.type !== types.parenL)
        { this.unexpected(); }
      return this.finishNode(node, "Super")

    case types._this:
      node = this.startNode();
      this.next();
      return this.finishNode(node, "ThisExpression")

    case types.name:
      var startPos = this.start, startLoc = this.startLoc, containsEsc = this.containsEsc;
      var id = this.parseIdent(false);
      if (this.options.ecmaVersion >= 8 && !containsEsc && id.name === "async" && !this.canInsertSemicolon() && this.eat(types._function))
        { return this.parseFunction(this.startNodeAt(startPos, startLoc), 0, false, true) }
      if (canBeArrow && !this.canInsertSemicolon()) {
        if (this.eat(types.arrow))
          { return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], false) }
        if (this.options.ecmaVersion >= 8 && id.name === "async" && this.type === types.name && !containsEsc) {
          id = this.parseIdent(false);
          if (this.canInsertSemicolon() || !this.eat(types.arrow))
            { this.unexpected(); }
          return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], true)
        }
      }
      return id

    case types.regexp:
      var value = this.value;
      node = this.parseLiteral(value.value);
      node.regex = {pattern: value.pattern, flags: value.flags};
      return node

    case types.num: case types.string:
      return this.parseLiteral(this.value)

    case types._null: case types._true: case types._false:
      node = this.startNode();
      node.value = this.type === types._null ? null : this.type === types._true;
      node.raw = this.type.keyword;
      this.next();
      return this.finishNode(node, "Literal")

    case types.parenL:
      var start = this.start, expr = this.parseParenAndDistinguishExpression(canBeArrow);
      if (refDestructuringErrors) {
        if (refDestructuringErrors.parenthesizedAssign < 0 && !this.isSimpleAssignTarget(expr))
          { refDestructuringErrors.parenthesizedAssign = start; }
        if (refDestructuringErrors.parenthesizedBind < 0)
          { refDestructuringErrors.parenthesizedBind = start; }
      }
      return expr

    case types.bracketL:
      node = this.startNode();
      this.next();
      node.elements = this.parseExprList(types.bracketR, true, true, refDestructuringErrors);
      return this.finishNode(node, "ArrayExpression")

    case types.braceL:
      return this.parseObj(false, refDestructuringErrors)

    case types._function:
      node = this.startNode();
      this.next();
      return this.parseFunction(node, 0)

    case types._class:
      return this.parseClass(this.startNode(), false)

    case types._new:
      return this.parseNew()

    case types.backQuote:
      return this.parseTemplate()

    case types._import:
      if (this.options.ecmaVersion >= 11) {
        return this.parseExprImport()
      } else {
        return this.unexpected()
      }

    default:
      this.unexpected();
    }
  };

  pp$3.parseExprImport = function() {
    var node = this.startNode();
    this.next(); 
    switch (this.type) {
    case types.parenL:
      return this.parseDynamicImport(node)
    default:
      this.unexpected();
    }
  };

  pp$3.parseDynamicImport = function(node) {
    this.next(); 

    node.source = this.parseMaybeAssign();

    if (!this.eat(types.parenR)) {
      var errorPos = this.start;
      if (this.eat(types.comma) && this.eat(types.parenR)) {
        this.raiseRecoverable(errorPos, "Trailing comma is not allowed in import()");
      } else {
        this.unexpected(errorPos);
      }
    }

    return this.finishNode(node, "ImportExpression")
  };

  pp$3.parseLiteral = function(value) {
    var node = this.startNode();
    node.value = value;
    node.raw = this.input.slice(this.start, this.end);
    if (node.raw.charCodeAt(node.raw.length - 1) === 110) { node.bigint = node.raw.slice(0, -1); }
    this.next();
    return this.finishNode(node, "Literal")
  };

  pp$3.parseParenExpression = function() {
    this.expect(types.parenL);
    var val = this.parseExpression();
    this.expect(types.parenR);
    return val
  };

  pp$3.parseParenAndDistinguishExpression = function(canBeArrow) {
    var startPos = this.start, startLoc = this.startLoc, val, allowTrailingComma = this.options.ecmaVersion >= 8;
    if (this.options.ecmaVersion >= 6) {
      this.next();

      var innerStartPos = this.start, innerStartLoc = this.startLoc;
      var exprList = [], first = true, lastIsComma = false;
      var refDestructuringErrors = new DestructuringErrors, oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, spreadStart;
      this.yieldPos = 0;
      this.awaitPos = 0;
      while (this.type !== types.parenR) {
        first ? first = false : this.expect(types.comma);
        if (allowTrailingComma && this.afterTrailingComma(types.parenR, true)) {
          lastIsComma = true;
          break
        } else if (this.type === types.ellipsis) {
          spreadStart = this.start;
          exprList.push(this.parseParenItem(this.parseRestBinding()));
          if (this.type === types.comma) { this.raise(this.start, "Comma is not permitted after the rest element"); }
          break
        } else {
          exprList.push(this.parseMaybeAssign(false, refDestructuringErrors, this.parseParenItem));
        }
      }
      var innerEndPos = this.start, innerEndLoc = this.startLoc;
      this.expect(types.parenR);

      if (canBeArrow && !this.canInsertSemicolon() && this.eat(types.arrow)) {
        this.checkPatternErrors(refDestructuringErrors, false);
        this.checkYieldAwaitInDefaultParams();
        this.yieldPos = oldYieldPos;
        this.awaitPos = oldAwaitPos;
        return this.parseParenArrowList(startPos, startLoc, exprList)
      }

      if (!exprList.length || lastIsComma) { this.unexpected(this.lastTokStart); }
      if (spreadStart) { this.unexpected(spreadStart); }
      this.checkExpressionErrors(refDestructuringErrors, true);
      this.yieldPos = oldYieldPos || this.yieldPos;
      this.awaitPos = oldAwaitPos || this.awaitPos;

      if (exprList.length > 1) {
        val = this.startNodeAt(innerStartPos, innerStartLoc);
        val.expressions = exprList;
        this.finishNodeAt(val, "SequenceExpression", innerEndPos, innerEndLoc);
      } else {
        val = exprList[0];
      }
    } else {
      val = this.parseParenExpression();
    }

    if (this.options.preserveParens) {
      var par = this.startNodeAt(startPos, startLoc);
      par.expression = val;
      return this.finishNode(par, "ParenthesizedExpression")
    } else {
      return val
    }
  };

  pp$3.parseParenItem = function(item) {
    return item
  };

  pp$3.parseParenArrowList = function(startPos, startLoc, exprList) {
    return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList)
  };


  var empty$1 = [];

  pp$3.parseNew = function() {
    if (this.containsEsc) { this.raiseRecoverable(this.start, "Escape sequence in keyword new"); }
    var node = this.startNode();
    var meta = this.parseIdent(true);
    if (this.options.ecmaVersion >= 6 && this.eat(types.dot)) {
      node.meta = meta;
      var containsEsc = this.containsEsc;
      node.property = this.parseIdent(true);
      if (node.property.name !== "target" || containsEsc)
        { this.raiseRecoverable(node.property.start, "The only valid meta property for new is new.target"); }
      if (!this.inNonArrowFunction())
        { this.raiseRecoverable(node.start, "new.target can only be used in functions"); }
      return this.finishNode(node, "MetaProperty")
    }
    var startPos = this.start, startLoc = this.startLoc, isImport = this.type === types._import;
    node.callee = this.parseSubscripts(this.parseExprAtom(), startPos, startLoc, true);
    if (isImport && node.callee.type === "ImportExpression") {
      this.raise(startPos, "Cannot use new with import()");
    }
    if (this.eat(types.parenL)) { node.arguments = this.parseExprList(types.parenR, this.options.ecmaVersion >= 8, false); }
    else { node.arguments = empty$1; }
    return this.finishNode(node, "NewExpression")
  };


  pp$3.parseTemplateElement = function(ref) {
    var isTagged = ref.isTagged;

    var elem = this.startNode();
    if (this.type === types.invalidTemplate) {
      if (!isTagged) {
        this.raiseRecoverable(this.start, "Bad escape sequence in untagged template literal");
      }
      elem.value = {
        raw: this.value,
        cooked: null
      };
    } else {
      elem.value = {
        raw: this.input.slice(this.start, this.end).replace(/\r\n?/g, "\n"),
        cooked: this.value
      };
    }
    this.next();
    elem.tail = this.type === types.backQuote;
    return this.finishNode(elem, "TemplateElement")
  };

  pp$3.parseTemplate = function(ref) {
    if ( ref === void 0 ) ref = {};
    var isTagged = ref.isTagged; if ( isTagged === void 0 ) isTagged = false;

    var node = this.startNode();
    this.next();
    node.expressions = [];
    var curElt = this.parseTemplateElement({isTagged: isTagged});
    node.quasis = [curElt];
    while (!curElt.tail) {
      if (this.type === types.eof) { this.raise(this.pos, "Unterminated template literal"); }
      this.expect(types.dollarBraceL);
      node.expressions.push(this.parseExpression());
      this.expect(types.braceR);
      node.quasis.push(curElt = this.parseTemplateElement({isTagged: isTagged}));
    }
    this.next();
    return this.finishNode(node, "TemplateLiteral")
  };

  pp$3.isAsyncProp = function(prop) {
    return !prop.computed && prop.key.type === "Identifier" && prop.key.name === "async" &&
      (this.type === types.name || this.type === types.num || this.type === types.string || this.type === types.bracketL || this.type.keyword || (this.options.ecmaVersion >= 9 && this.type === types.star)) &&
      !lineBreak.test(this.input.slice(this.lastTokEnd, this.start))
  };


  pp$3.parseObj = function(isPattern, refDestructuringErrors) {
    var node = this.startNode(), first = true, propHash = {};
    node.properties = [];
    this.next();
    while (!this.eat(types.braceR)) {
      if (!first) {
        this.expect(types.comma);
        if (this.options.ecmaVersion >= 5 && this.afterTrailingComma(types.braceR)) { break }
      } else { first = false; }

      var prop = this.parseProperty(isPattern, refDestructuringErrors);
      if (!isPattern) { this.checkPropClash(prop, propHash, refDestructuringErrors); }
      node.properties.push(prop);
    }
    return this.finishNode(node, isPattern ? "ObjectPattern" : "ObjectExpression")
  };

  pp$3.parseProperty = function(isPattern, refDestructuringErrors) {
    var prop = this.startNode(), isGenerator, isAsync, startPos, startLoc;
    if (this.options.ecmaVersion >= 9 && this.eat(types.ellipsis)) {
      if (isPattern) {
        prop.argument = this.parseIdent(false);
        if (this.type === types.comma) {
          this.raise(this.start, "Comma is not permitted after the rest element");
        }
        return this.finishNode(prop, "RestElement")
      }
      if (this.type === types.parenL && refDestructuringErrors) {
        if (refDestructuringErrors.parenthesizedAssign < 0) {
          refDestructuringErrors.parenthesizedAssign = this.start;
        }
        if (refDestructuringErrors.parenthesizedBind < 0) {
          refDestructuringErrors.parenthesizedBind = this.start;
        }
      }
      prop.argument = this.parseMaybeAssign(false, refDestructuringErrors);
      if (this.type === types.comma && refDestructuringErrors && refDestructuringErrors.trailingComma < 0) {
        refDestructuringErrors.trailingComma = this.start;
      }
      return this.finishNode(prop, "SpreadElement")
    }
    if (this.options.ecmaVersion >= 6) {
      prop.method = false;
      prop.shorthand = false;
      if (isPattern || refDestructuringErrors) {
        startPos = this.start;
        startLoc = this.startLoc;
      }
      if (!isPattern)
        { isGenerator = this.eat(types.star); }
    }
    var containsEsc = this.containsEsc;
    this.parsePropertyName(prop);
    if (!isPattern && !containsEsc && this.options.ecmaVersion >= 8 && !isGenerator && this.isAsyncProp(prop)) {
      isAsync = true;
      isGenerator = this.options.ecmaVersion >= 9 && this.eat(types.star);
      this.parsePropertyName(prop, refDestructuringErrors);
    } else {
      isAsync = false;
    }
    this.parsePropertyValue(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc);
    return this.finishNode(prop, "Property")
  };

  pp$3.parsePropertyValue = function(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc) {
    if ((isGenerator || isAsync) && this.type === types.colon)
      { this.unexpected(); }

    if (this.eat(types.colon)) {
      prop.value = isPattern ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(false, refDestructuringErrors);
      prop.kind = "init";
    } else if (this.options.ecmaVersion >= 6 && this.type === types.parenL) {
      if (isPattern) { this.unexpected(); }
      prop.kind = "init";
      prop.method = true;
      prop.value = this.parseMethod(isGenerator, isAsync);
    } else if (!isPattern && !containsEsc &&
               this.options.ecmaVersion >= 5 && !prop.computed && prop.key.type === "Identifier" &&
               (prop.key.name === "get" || prop.key.name === "set") &&
               (this.type !== types.comma && this.type !== types.braceR)) {
      if (isGenerator || isAsync) { this.unexpected(); }
      prop.kind = prop.key.name;
      this.parsePropertyName(prop);
      prop.value = this.parseMethod(false);
      var paramCount = prop.kind === "get" ? 0 : 1;
      if (prop.value.params.length !== paramCount) {
        var start = prop.value.start;
        if (prop.kind === "get")
          { this.raiseRecoverable(start, "getter should have no params"); }
        else
          { this.raiseRecoverable(start, "setter should have exactly one param"); }
      } else {
        if (prop.kind === "set" && prop.value.params[0].type === "RestElement")
          { this.raiseRecoverable(prop.value.params[0].start, "Setter cannot use rest params"); }
      }
    } else if (this.options.ecmaVersion >= 6 && !prop.computed && prop.key.type === "Identifier") {
      if (isGenerator || isAsync) { this.unexpected(); }
      this.checkUnreserved(prop.key);
      if (prop.key.name === "await" && !this.awaitIdentPos)
        { this.awaitIdentPos = startPos; }
      prop.kind = "init";
      if (isPattern) {
        prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key);
      } else if (this.type === types.eq && refDestructuringErrors) {
        if (refDestructuringErrors.shorthandAssign < 0)
          { refDestructuringErrors.shorthandAssign = this.start; }
        prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key);
      } else {
        prop.value = prop.key;
      }
      prop.shorthand = true;
    } else { this.unexpected(); }
  };

  pp$3.parsePropertyName = function(prop) {
    if (this.options.ecmaVersion >= 6) {
      if (this.eat(types.bracketL)) {
        prop.computed = true;
        prop.key = this.parseMaybeAssign();
        this.expect(types.bracketR);
        return prop.key
      } else {
        prop.computed = false;
      }
    }
    return prop.key = this.type === types.num || this.type === types.string ? this.parseExprAtom() : this.parseIdent(this.options.allowReserved !== "never")
  };


  pp$3.initFunction = function(node) {
    node.id = null;
    if (this.options.ecmaVersion >= 6) { node.generator = node.expression = false; }
    if (this.options.ecmaVersion >= 8) { node.async = false; }
  };


  pp$3.parseMethod = function(isGenerator, isAsync, allowDirectSuper) {
    var node = this.startNode(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;

    this.initFunction(node);
    if (this.options.ecmaVersion >= 6)
      { node.generator = isGenerator; }
    if (this.options.ecmaVersion >= 8)
      { node.async = !!isAsync; }

    this.yieldPos = 0;
    this.awaitPos = 0;
    this.awaitIdentPos = 0;
    this.enterScope(functionFlags(isAsync, node.generator) | SCOPE_SUPER | (allowDirectSuper ? SCOPE_DIRECT_SUPER : 0));

    this.expect(types.parenL);
    node.params = this.parseBindingList(types.parenR, false, this.options.ecmaVersion >= 8);
    this.checkYieldAwaitInDefaultParams();
    this.parseFunctionBody(node, false, true);

    this.yieldPos = oldYieldPos;
    this.awaitPos = oldAwaitPos;
    this.awaitIdentPos = oldAwaitIdentPos;
    return this.finishNode(node, "FunctionExpression")
  };


  pp$3.parseArrowExpression = function(node, params, isAsync) {
    var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;

    this.enterScope(functionFlags(isAsync, false) | SCOPE_ARROW);
    this.initFunction(node);
    if (this.options.ecmaVersion >= 8) { node.async = !!isAsync; }

    this.yieldPos = 0;
    this.awaitPos = 0;
    this.awaitIdentPos = 0;

    node.params = this.toAssignableList(params, true);
    this.parseFunctionBody(node, true, false);

    this.yieldPos = oldYieldPos;
    this.awaitPos = oldAwaitPos;
    this.awaitIdentPos = oldAwaitIdentPos;
    return this.finishNode(node, "ArrowFunctionExpression")
  };


  pp$3.parseFunctionBody = function(node, isArrowFunction, isMethod) {
    var isExpression = isArrowFunction && this.type !== types.braceL;
    var oldStrict = this.strict, useStrict = false;

    if (isExpression) {
      node.body = this.parseMaybeAssign();
      node.expression = true;
      this.checkParams(node, false);
    } else {
      var nonSimple = this.options.ecmaVersion >= 7 && !this.isSimpleParamList(node.params);
      if (!oldStrict || nonSimple) {
        useStrict = this.strictDirective(this.end);
        if (useStrict && nonSimple)
          { this.raiseRecoverable(node.start, "Illegal 'use strict' directive in function with non-simple parameter list"); }
      }
      var oldLabels = this.labels;
      this.labels = [];
      if (useStrict) { this.strict = true; }

      this.checkParams(node, !oldStrict && !useStrict && !isArrowFunction && !isMethod && this.isSimpleParamList(node.params));
      node.body = this.parseBlock(false);
      node.expression = false;
      this.adaptDirectivePrologue(node.body.body);
      this.labels = oldLabels;
    }
    this.exitScope();

    if (this.strict && node.id) { this.checkLVal(node.id, BIND_OUTSIDE); }
    this.strict = oldStrict;
  };

  pp$3.isSimpleParamList = function(params) {
    for (var i = 0, list = params; i < list.length; i += 1)
      {
      var param = list[i];

      if (param.type !== "Identifier") { return false
    } }
    return true
  };


  pp$3.checkParams = function(node, allowDuplicates) {
    var nameHash = {};
    for (var i = 0, list = node.params; i < list.length; i += 1)
      {
      var param = list[i];

      this.checkLVal(param, BIND_VAR, allowDuplicates ? null : nameHash);
    }
  };


  pp$3.parseExprList = function(close, allowTrailingComma, allowEmpty, refDestructuringErrors) {
    var elts = [], first = true;
    while (!this.eat(close)) {
      if (!first) {
        this.expect(types.comma);
        if (allowTrailingComma && this.afterTrailingComma(close)) { break }
      } else { first = false; }

      var elt = (void 0);
      if (allowEmpty && this.type === types.comma)
        { elt = null; }
      else if (this.type === types.ellipsis) {
        elt = this.parseSpread(refDestructuringErrors);
        if (refDestructuringErrors && this.type === types.comma && refDestructuringErrors.trailingComma < 0)
          { refDestructuringErrors.trailingComma = this.start; }
      } else {
        elt = this.parseMaybeAssign(false, refDestructuringErrors);
      }
      elts.push(elt);
    }
    return elts
  };

  pp$3.checkUnreserved = function(ref) {
    var start = ref.start;
    var end = ref.end;
    var name = ref.name;

    if (this.inGenerator && name === "yield")
      { this.raiseRecoverable(start, "Cannot use 'yield' as identifier inside a generator"); }
    if (this.inAsync && name === "await")
      { this.raiseRecoverable(start, "Cannot use 'await' as identifier inside an async function"); }
    if (this.keywords.test(name))
      { this.raise(start, ("Unexpected keyword '" + name + "'")); }
    if (this.options.ecmaVersion < 6 &&
      this.input.slice(start, end).indexOf("\\") !== -1) { return }
    var re = this.strict ? this.reservedWordsStrict : this.reservedWords;
    if (re.test(name)) {
      if (!this.inAsync && name === "await")
        { this.raiseRecoverable(start, "Cannot use keyword 'await' outside an async function"); }
      this.raiseRecoverable(start, ("The keyword '" + name + "' is reserved"));
    }
  };


  pp$3.parseIdent = function(liberal, isBinding) {
    var node = this.startNode();
    if (this.type === types.name) {
      node.name = this.value;
    } else if (this.type.keyword) {
      node.name = this.type.keyword;

      if ((node.name === "class" || node.name === "function") &&
          (this.lastTokEnd !== this.lastTokStart + 1 || this.input.charCodeAt(this.lastTokStart) !== 46)) {
        this.context.pop();
      }
    } else {
      this.unexpected();
    }
    this.next(!!liberal);
    this.finishNode(node, "Identifier");
    if (!liberal) {
      this.checkUnreserved(node);
      if (node.name === "await" && !this.awaitIdentPos)
        { this.awaitIdentPos = node.start; }
    }
    return node
  };


  pp$3.parseYield = function(noIn) {
    if (!this.yieldPos) { this.yieldPos = this.start; }

    var node = this.startNode();
    this.next();
    if (this.type === types.semi || this.canInsertSemicolon() || (this.type !== types.star && !this.type.startsExpr)) {
      node.delegate = false;
      node.argument = null;
    } else {
      node.delegate = this.eat(types.star);
      node.argument = this.parseMaybeAssign(noIn);
    }
    return this.finishNode(node, "YieldExpression")
  };

  pp$3.parseAwait = function() {
    if (!this.awaitPos) { this.awaitPos = this.start; }

    var node = this.startNode();
    this.next();
    node.argument = this.parseMaybeUnary(null, false);
    return this.finishNode(node, "AwaitExpression")
  };

  var pp$4 = Parser.prototype;


  pp$4.raise = function(pos, message) {
    var loc = getLineInfo(this.input, pos);
    message += " (" + loc.line + ":" + loc.column + ")";
    var err = new SyntaxError(message);
    err.pos = pos; err.loc = loc; err.raisedAt = this.pos;
    throw err
  };

  pp$4.raiseRecoverable = pp$4.raise;

  pp$4.curPosition = function() {
    if (this.options.locations) {
      return new Position(this.curLine, this.pos - this.lineStart)
    }
  };

  var pp$5 = Parser.prototype;

  var Scope = function Scope(flags) {
    this.flags = flags;
    this.var = [];
    this.lexical = [];
    this.functions = [];
  };


  pp$5.enterScope = function(flags) {
    this.scopeStack.push(new Scope(flags));
  };

  pp$5.exitScope = function() {
    this.scopeStack.pop();
  };

  pp$5.treatFunctionsAsVarInScope = function(scope) {
    return (scope.flags & SCOPE_FUNCTION) || !this.inModule && (scope.flags & SCOPE_TOP)
  };

  pp$5.declareName = function(name, bindingType, pos) {
    var redeclared = false;
    if (bindingType === BIND_LEXICAL) {
      var scope = this.currentScope();
      redeclared = scope.lexical.indexOf(name) > -1 || scope.functions.indexOf(name) > -1 || scope.var.indexOf(name) > -1;
      scope.lexical.push(name);
      if (this.inModule && (scope.flags & SCOPE_TOP))
        { delete this.undefinedExports[name]; }
    } else if (bindingType === BIND_SIMPLE_CATCH) {
      var scope$1 = this.currentScope();
      scope$1.lexical.push(name);
    } else if (bindingType === BIND_FUNCTION) {
      var scope$2 = this.currentScope();
      if (this.treatFunctionsAsVar)
        { redeclared = scope$2.lexical.indexOf(name) > -1; }
      else
        { redeclared = scope$2.lexical.indexOf(name) > -1 || scope$2.var.indexOf(name) > -1; }
      scope$2.functions.push(name);
    } else {
      for (var i = this.scopeStack.length - 1; i >= 0; --i) {
        var scope$3 = this.scopeStack[i];
        if (scope$3.lexical.indexOf(name) > -1 && !((scope$3.flags & SCOPE_SIMPLE_CATCH) && scope$3.lexical[0] === name) ||
            !this.treatFunctionsAsVarInScope(scope$3) && scope$3.functions.indexOf(name) > -1) {
          redeclared = true;
          break
        }
        scope$3.var.push(name);
        if (this.inModule && (scope$3.flags & SCOPE_TOP))
          { delete this.undefinedExports[name]; }
        if (scope$3.flags & SCOPE_VAR) { break }
      }
    }
    if (redeclared) { this.raiseRecoverable(pos, ("Identifier '" + name + "' has already been declared")); }
  };

  pp$5.checkLocalExport = function(id) {
    if (this.scopeStack[0].lexical.indexOf(id.name) === -1 &&
        this.scopeStack[0].var.indexOf(id.name) === -1) {
      this.undefinedExports[id.name] = id;
    }
  };

  pp$5.currentScope = function() {
    return this.scopeStack[this.scopeStack.length - 1]
  };

  pp$5.currentVarScope = function() {
    for (var i = this.scopeStack.length - 1;; i--) {
      var scope = this.scopeStack[i];
      if (scope.flags & SCOPE_VAR) { return scope }
    }
  };

  pp$5.currentThisScope = function() {
    for (var i = this.scopeStack.length - 1;; i--) {
      var scope = this.scopeStack[i];
      if (scope.flags & SCOPE_VAR && !(scope.flags & SCOPE_ARROW)) { return scope }
    }
  };

  var Node = function Node(parser, pos, loc) {
    this.type = "";
    this.start = pos;
    this.end = 0;
    if (parser.options.locations)
      { this.loc = new SourceLocation(parser, loc); }
    if (parser.options.directSourceFile)
      { this.sourceFile = parser.options.directSourceFile; }
    if (parser.options.ranges)
      { this.range = [pos, 0]; }
  };


  var pp$6 = Parser.prototype;

  pp$6.startNode = function() {
    return new Node(this, this.start, this.startLoc)
  };

  pp$6.startNodeAt = function(pos, loc) {
    return new Node(this, pos, loc)
  };


  function finishNodeAt(node, type, pos, loc) {
    node.type = type;
    node.end = pos;
    if (this.options.locations)
      { node.loc.end = loc; }
    if (this.options.ranges)
      { node.range[1] = pos; }
    return node
  }

  pp$6.finishNode = function(node, type) {
    return finishNodeAt.call(this, node, type, this.lastTokEnd, this.lastTokEndLoc)
  };


  pp$6.finishNodeAt = function(node, type, pos, loc) {
    return finishNodeAt.call(this, node, type, pos, loc)
  };


  var TokContext = function TokContext(token, isExpr, preserveSpace, override, generator) {
    this.token = token;
    this.isExpr = !!isExpr;
    this.preserveSpace = !!preserveSpace;
    this.override = override;
    this.generator = !!generator;
  };

  var types$1 = {
    b_stat: new TokContext("{", false),
    b_expr: new TokContext("{", true),
    b_tmpl: new TokContext("${", false),
    p_stat: new TokContext("(", false),
    p_expr: new TokContext("(", true),
    q_tmpl: new TokContext("`", true, true, function (p) { return p.tryReadTemplateToken(); }),
    f_stat: new TokContext("function", false),
    f_expr: new TokContext("function", true),
    f_expr_gen: new TokContext("function", true, false, null, true),
    f_gen: new TokContext("function", false, false, null, true)
  };

  var pp$7 = Parser.prototype;

  pp$7.initialContext = function() {
    return [types$1.b_stat]
  };

  pp$7.braceIsBlock = function(prevType) {
    var parent = this.curContext();
    if (parent === types$1.f_expr || parent === types$1.f_stat)
      { return true }
    if (prevType === types.colon && (parent === types$1.b_stat || parent === types$1.b_expr))
      { return !parent.isExpr }

    if (prevType === types._return || prevType === types.name && this.exprAllowed)
      { return lineBreak.test(this.input.slice(this.lastTokEnd, this.start)) }
    if (prevType === types._else || prevType === types.semi || prevType === types.eof || prevType === types.parenR || prevType === types.arrow)
      { return true }
    if (prevType === types.braceL)
      { return parent === types$1.b_stat }
    if (prevType === types._var || prevType === types._const || prevType === types.name)
      { return false }
    return !this.exprAllowed
  };

  pp$7.inGeneratorContext = function() {
    for (var i = this.context.length - 1; i >= 1; i--) {
      var context = this.context[i];
      if (context.token === "function")
        { return context.generator }
    }
    return false
  };

  pp$7.updateContext = function(prevType) {
    var update, type = this.type;
    if (type.keyword && prevType === types.dot)
      { this.exprAllowed = false; }
    else if (update = type.updateContext)
      { update.call(this, prevType); }
    else
      { this.exprAllowed = type.beforeExpr; }
  };


  types.parenR.updateContext = types.braceR.updateContext = function() {
    if (this.context.length === 1) {
      this.exprAllowed = true;
      return
    }
    var out = this.context.pop();
    if (out === types$1.b_stat && this.curContext().token === "function") {
      out = this.context.pop();
    }
    this.exprAllowed = !out.isExpr;
  };

  types.braceL.updateContext = function(prevType) {
    this.context.push(this.braceIsBlock(prevType) ? types$1.b_stat : types$1.b_expr);
    this.exprAllowed = true;
  };

  types.dollarBraceL.updateContext = function() {
    this.context.push(types$1.b_tmpl);
    this.exprAllowed = true;
  };

  types.parenL.updateContext = function(prevType) {
    var statementParens = prevType === types._if || prevType === types._for || prevType === types._with || prevType === types._while;
    this.context.push(statementParens ? types$1.p_stat : types$1.p_expr);
    this.exprAllowed = true;
  };

  types.incDec.updateContext = function() {
  };

  types._function.updateContext = types._class.updateContext = function(prevType) {
    if (prevType.beforeExpr && prevType !== types.semi && prevType !== types._else &&
        !(prevType === types._return && lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) &&
        !((prevType === types.colon || prevType === types.braceL) && this.curContext() === types$1.b_stat))
      { this.context.push(types$1.f_expr); }
    else
      { this.context.push(types$1.f_stat); }
    this.exprAllowed = false;
  };

  types.backQuote.updateContext = function() {
    if (this.curContext() === types$1.q_tmpl)
      { this.context.pop(); }
    else
      { this.context.push(types$1.q_tmpl); }
    this.exprAllowed = false;
  };

  types.star.updateContext = function(prevType) {
    if (prevType === types._function) {
      var index = this.context.length - 1;
      if (this.context[index] === types$1.f_expr)
        { this.context[index] = types$1.f_expr_gen; }
      else
        { this.context[index] = types$1.f_gen; }
    }
    this.exprAllowed = true;
  };

  types.name.updateContext = function(prevType) {
    var allowed = false;
    if (this.options.ecmaVersion >= 6 && prevType !== types.dot) {
      if (this.value === "of" && !this.exprAllowed ||
          this.value === "yield" && this.inGeneratorContext())
        { allowed = true; }
    }
    this.exprAllowed = allowed;
  };


  var ecma9BinaryProperties = "ASCII ASCII_Hex_Digit AHex Alphabetic Alpha Any Assigned Bidi_Control Bidi_C Bidi_Mirrored Bidi_M Case_Ignorable CI Cased Changes_When_Casefolded CWCF Changes_When_Casemapped CWCM Changes_When_Lowercased CWL Changes_When_NFKC_Casefolded CWKCF Changes_When_Titlecased CWT Changes_When_Uppercased CWU Dash Default_Ignorable_Code_Point DI Deprecated Dep Diacritic Dia Emoji Emoji_Component Emoji_Modifier Emoji_Modifier_Base Emoji_Presentation Extender Ext Grapheme_Base Gr_Base Grapheme_Extend Gr_Ext Hex_Digit Hex IDS_Binary_Operator IDSB IDS_Trinary_Operator IDST ID_Continue IDC ID_Start IDS Ideographic Ideo Join_Control Join_C Logical_Order_Exception LOE Lowercase Lower Math Noncharacter_Code_Point NChar Pattern_Syntax Pat_Syn Pattern_White_Space Pat_WS Quotation_Mark QMark Radical Regional_Indicator RI Sentence_Terminal STerm Soft_Dotted SD Terminal_Punctuation Term Unified_Ideograph UIdeo Uppercase Upper Variation_Selector VS White_Space space XID_Continue XIDC XID_Start XIDS";
  var ecma10BinaryProperties = ecma9BinaryProperties + " Extended_Pictographic";
  var ecma11BinaryProperties = ecma10BinaryProperties;
  var unicodeBinaryProperties = {
    9: ecma9BinaryProperties,
    10: ecma10BinaryProperties,
    11: ecma11BinaryProperties
  };

  var unicodeGeneralCategoryValues = "Cased_Letter LC Close_Punctuation Pe Connector_Punctuation Pc Control Cc cntrl Currency_Symbol Sc Dash_Punctuation Pd Decimal_Number Nd digit Enclosing_Mark Me Final_Punctuation Pf Format Cf Initial_Punctuation Pi Letter L Letter_Number Nl Line_Separator Zl Lowercase_Letter Ll Mark M Combining_Mark Math_Symbol Sm Modifier_Letter Lm Modifier_Symbol Sk Nonspacing_Mark Mn Number N Open_Punctuation Ps Other C Other_Letter Lo Other_Number No Other_Punctuation Po Other_Symbol So Paragraph_Separator Zp Private_Use Co Punctuation P punct Separator Z Space_Separator Zs Spacing_Mark Mc Surrogate Cs Symbol S Titlecase_Letter Lt Unassigned Cn Uppercase_Letter Lu";

  var ecma9ScriptValues = "Adlam Adlm Ahom Ahom Anatolian_Hieroglyphs Hluw Arabic Arab Armenian Armn Avestan Avst Balinese Bali Bamum Bamu Bassa_Vah Bass Batak Batk Bengali Beng Bhaiksuki Bhks Bopomofo Bopo Brahmi Brah Braille Brai Buginese Bugi Buhid Buhd Canadian_Aboriginal Cans Carian Cari Caucasian_Albanian Aghb Chakma Cakm Cham Cham Cherokee Cher Common Zyyy Coptic Copt Qaac Cuneiform Xsux Cypriot Cprt Cyrillic Cyrl Deseret Dsrt Devanagari Deva Duployan Dupl Egyptian_Hieroglyphs Egyp Elbasan Elba Ethiopic Ethi Georgian Geor Glagolitic Glag Gothic Goth Grantha Gran Greek Grek Gujarati Gujr Gurmukhi Guru Han Hani Hangul Hang Hanunoo Hano Hatran Hatr Hebrew Hebr Hiragana Hira Imperial_Aramaic Armi Inherited Zinh Qaai Inscriptional_Pahlavi Phli Inscriptional_Parthian Prti Javanese Java Kaithi Kthi Kannada Knda Katakana Kana Kayah_Li Kali Kharoshthi Khar Khmer Khmr Khojki Khoj Khudawadi Sind Lao Laoo Latin Latn Lepcha Lepc Limbu Limb Linear_A Lina Linear_B Linb Lisu Lisu Lycian Lyci Lydian Lydi Mahajani Mahj Malayalam Mlym Mandaic Mand Manichaean Mani Marchen Marc Masaram_Gondi Gonm Meetei_Mayek Mtei Mende_Kikakui Mend Meroitic_Cursive Merc Meroitic_Hieroglyphs Mero Miao Plrd Modi Modi Mongolian Mong Mro Mroo Multani Mult Myanmar Mymr Nabataean Nbat New_Tai_Lue Talu Newa Newa Nko Nkoo Nushu Nshu Ogham Ogam Ol_Chiki Olck Old_Hungarian Hung Old_Italic Ital Old_North_Arabian Narb Old_Permic Perm Old_Persian Xpeo Old_South_Arabian Sarb Old_Turkic Orkh Oriya Orya Osage Osge Osmanya Osma Pahawh_Hmong Hmng Palmyrene Palm Pau_Cin_Hau Pauc Phags_Pa Phag Phoenician Phnx Psalter_Pahlavi Phlp Rejang Rjng Runic Runr Samaritan Samr Saurashtra Saur Sharada Shrd Shavian Shaw Siddham Sidd SignWriting Sgnw Sinhala Sinh Sora_Sompeng Sora Soyombo Soyo Sundanese Sund Syloti_Nagri Sylo Syriac Syrc Tagalog Tglg Tagbanwa Tagb Tai_Le Tale Tai_Tham Lana Tai_Viet Tavt Takri Takr Tamil Taml Tangut Tang Telugu Telu Thaana Thaa Thai Thai Tibetan Tibt Tifinagh Tfng Tirhuta Tirh Ugaritic Ugar Vai Vaii Warang_Citi Wara Yi Yiii Zanabazar_Square Zanb";
  var ecma10ScriptValues = ecma9ScriptValues + " Dogra Dogr Gunjala_Gondi Gong Hanifi_Rohingya Rohg Makasar Maka Medefaidrin Medf Old_Sogdian Sogo Sogdian Sogd";
  var ecma11ScriptValues = ecma10ScriptValues + " Elymaic Elym Nandinagari Nand Nyiakeng_Puachue_Hmong Hmnp Wancho Wcho";
  var unicodeScriptValues = {
    9: ecma9ScriptValues,
    10: ecma10ScriptValues,
    11: ecma11ScriptValues
  };

  var data = {};
  function buildUnicodeData(ecmaVersion) {
    var d = data[ecmaVersion] = {
      binary: wordsRegexp(unicodeBinaryProperties[ecmaVersion] + " " + unicodeGeneralCategoryValues),
      nonBinary: {
        General_Category: wordsRegexp(unicodeGeneralCategoryValues),
        Script: wordsRegexp(unicodeScriptValues[ecmaVersion])
      }
    };
    d.nonBinary.Script_Extensions = d.nonBinary.Script;

    d.nonBinary.gc = d.nonBinary.General_Category;
    d.nonBinary.sc = d.nonBinary.Script;
    d.nonBinary.scx = d.nonBinary.Script_Extensions;
  }
  buildUnicodeData(9);
  buildUnicodeData(10);
  buildUnicodeData(11);

  var pp$8 = Parser.prototype;

  var RegExpValidationState = function RegExpValidationState(parser) {
    this.parser = parser;
    this.validFlags = "gim" + (parser.options.ecmaVersion >= 6 ? "uy" : "") + (parser.options.ecmaVersion >= 9 ? "s" : "");
    this.unicodeProperties = data[parser.options.ecmaVersion >= 11 ? 11 : parser.options.ecmaVersion];
    this.source = "";
    this.flags = "";
    this.start = 0;
    this.switchU = false;
    this.switchN = false;
    this.pos = 0;
    this.lastIntValue = 0;
    this.lastStringValue = "";
    this.lastAssertionIsQuantifiable = false;
    this.numCapturingParens = 0;
    this.maxBackReference = 0;
    this.groupNames = [];
    this.backReferenceNames = [];
  };

  RegExpValidationState.prototype.reset = function reset (start, pattern, flags) {
    var unicode = flags.indexOf("u") !== -1;
    this.start = start | 0;
    this.source = pattern + "";
    this.flags = flags;
    this.switchU = unicode && this.parser.options.ecmaVersion >= 6;
    this.switchN = unicode && this.parser.options.ecmaVersion >= 9;
  };

  RegExpValidationState.prototype.raise = function raise (message) {
    this.parser.raiseRecoverable(this.start, ("Invalid regular expression: /" + (this.source) + "/: " + message));
  };

  RegExpValidationState.prototype.at = function at (i) {
    var s = this.source;
    var l = s.length;
    if (i >= l) {
      return -1
    }
    var c = s.charCodeAt(i);
    if (!this.switchU || c <= 0xD7FF || c >= 0xE000 || i + 1 >= l) {
      return c
    }
    var next = s.charCodeAt(i + 1);
    return next >= 0xDC00 && next <= 0xDFFF ? (c << 10) + next - 0x35FDC00 : c
  };

  RegExpValidationState.prototype.nextIndex = function nextIndex (i) {
    var s = this.source;
    var l = s.length;
    if (i >= l) {
      return l
    }
    var c = s.charCodeAt(i), next;
    if (!this.switchU || c <= 0xD7FF || c >= 0xE000 || i + 1 >= l ||
        (next = s.charCodeAt(i + 1)) < 0xDC00 || next > 0xDFFF) {
      return i + 1
    }
    return i + 2
  };

  RegExpValidationState.prototype.current = function current () {
    return this.at(this.pos)
  };

  RegExpValidationState.prototype.lookahead = function lookahead () {
    return this.at(this.nextIndex(this.pos))
  };

  RegExpValidationState.prototype.advance = function advance () {
    this.pos = this.nextIndex(this.pos);
  };

  RegExpValidationState.prototype.eat = function eat (ch) {
    if (this.current() === ch) {
      this.advance();
      return true
    }
    return false
  };

  function codePointToString(ch) {
    if (ch <= 0xFFFF) { return String.fromCharCode(ch) }
    ch -= 0x10000;
    return String.fromCharCode((ch >> 10) + 0xD800, (ch & 0x03FF) + 0xDC00)
  }

  pp$8.validateRegExpFlags = function(state) {
    var validFlags = state.validFlags;
    var flags = state.flags;

    for (var i = 0; i < flags.length; i++) {
      var flag = flags.charAt(i);
      if (validFlags.indexOf(flag) === -1) {
        this.raise(state.start, "Invalid regular expression flag");
      }
      if (flags.indexOf(flag, i + 1) > -1) {
        this.raise(state.start, "Duplicate regular expression flag");
      }
    }
  };

  pp$8.validateRegExpPattern = function(state) {
    this.regexp_pattern(state);

    if (!state.switchN && this.options.ecmaVersion >= 9 && state.groupNames.length > 0) {
      state.switchN = true;
      this.regexp_pattern(state);
    }
  };

  pp$8.regexp_pattern = function(state) {
    state.pos = 0;
    state.lastIntValue = 0;
    state.lastStringValue = "";
    state.lastAssertionIsQuantifiable = false;
    state.numCapturingParens = 0;
    state.maxBackReference = 0;
    state.groupNames.length = 0;
    state.backReferenceNames.length = 0;

    this.regexp_disjunction(state);

    if (state.pos !== state.source.length) {
      if (state.eat(0x29 )) {
        state.raise("Unmatched ')'");
      }
      if (state.eat(0x5D ) || state.eat(0x7D )) {
        state.raise("Lone quantifier brackets");
      }
    }
    if (state.maxBackReference > state.numCapturingParens) {
      state.raise("Invalid escape");
    }
    for (var i = 0, list = state.backReferenceNames; i < list.length; i += 1) {
      var name = list[i];

      if (state.groupNames.indexOf(name) === -1) {
        state.raise("Invalid named capture referenced");
      }
    }
  };

  pp$8.regexp_disjunction = function(state) {
    this.regexp_alternative(state);
    while (state.eat(0x7C )) {
      this.regexp_alternative(state);
    }

    if (this.regexp_eatQuantifier(state, true)) {
      state.raise("Nothing to repeat");
    }
    if (state.eat(0x7B )) {
      state.raise("Lone quantifier brackets");
    }
  };

  pp$8.regexp_alternative = function(state) {
    while (state.pos < state.source.length && this.regexp_eatTerm(state))
      { }
  };

  pp$8.regexp_eatTerm = function(state) {
    if (this.regexp_eatAssertion(state)) {
      if (state.lastAssertionIsQuantifiable && this.regexp_eatQuantifier(state)) {
        if (state.switchU) {
          state.raise("Invalid quantifier");
        }
      }
      return true
    }

    if (state.switchU ? this.regexp_eatAtom(state) : this.regexp_eatExtendedAtom(state)) {
      this.regexp_eatQuantifier(state);
      return true
    }

    return false
  };

  pp$8.regexp_eatAssertion = function(state) {
    var start = state.pos;
    state.lastAssertionIsQuantifiable = false;

    if (state.eat(0x5E ) || state.eat(0x24 )) {
      return true
    }

    if (state.eat(0x5C )) {
      if (state.eat(0x42 ) || state.eat(0x62 )) {
        return true
      }
      state.pos = start;
    }

    if (state.eat(0x28 ) && state.eat(0x3F )) {
      var lookbehind = false;
      if (this.options.ecmaVersion >= 9) {
        lookbehind = state.eat(0x3C );
      }
      if (state.eat(0x3D ) || state.eat(0x21 )) {
        this.regexp_disjunction(state);
        if (!state.eat(0x29 )) {
          state.raise("Unterminated group");
        }
        state.lastAssertionIsQuantifiable = !lookbehind;
        return true
      }
    }

    state.pos = start;
    return false
  };

  pp$8.regexp_eatQuantifier = function(state, noError) {
    if ( noError === void 0 ) noError = false;

    if (this.regexp_eatQuantifierPrefix(state, noError)) {
      state.eat(0x3F );
      return true
    }
    return false
  };

  pp$8.regexp_eatQuantifierPrefix = function(state, noError) {
    return (
      state.eat(0x2A ) ||
      state.eat(0x2B ) ||
      state.eat(0x3F ) ||
      this.regexp_eatBracedQuantifier(state, noError)
    )
  };
  pp$8.regexp_eatBracedQuantifier = function(state, noError) {
    var start = state.pos;
    if (state.eat(0x7B )) {
      var min = 0, max = -1;
      if (this.regexp_eatDecimalDigits(state)) {
        min = state.lastIntValue;
        if (state.eat(0x2C ) && this.regexp_eatDecimalDigits(state)) {
          max = state.lastIntValue;
        }
        if (state.eat(0x7D )) {
          if (max !== -1 && max < min && !noError) {
            state.raise("numbers out of order in {} quantifier");
          }
          return true
        }
      }
      if (state.switchU && !noError) {
        state.raise("Incomplete quantifier");
      }
      state.pos = start;
    }
    return false
  };

  pp$8.regexp_eatAtom = function(state) {
    return (
      this.regexp_eatPatternCharacters(state) ||
      state.eat(0x2E ) ||
      this.regexp_eatReverseSolidusAtomEscape(state) ||
      this.regexp_eatCharacterClass(state) ||
      this.regexp_eatUncapturingGroup(state) ||
      this.regexp_eatCapturingGroup(state)
    )
  };
  pp$8.regexp_eatReverseSolidusAtomEscape = function(state) {
    var start = state.pos;
    if (state.eat(0x5C )) {
      if (this.regexp_eatAtomEscape(state)) {
        return true
      }
      state.pos = start;
    }
    return false
  };
  pp$8.regexp_eatUncapturingGroup = function(state) {
    var start = state.pos;
    if (state.eat(0x28 )) {
      if (state.eat(0x3F ) && state.eat(0x3A )) {
        this.regexp_disjunction(state);
        if (state.eat(0x29 )) {
          return true
        }
        state.raise("Unterminated group");
      }
      state.pos = start;
    }
    return false
  };
  pp$8.regexp_eatCapturingGroup = function(state) {
    if (state.eat(0x28 )) {
      if (this.options.ecmaVersion >= 9) {
        this.regexp_groupSpecifier(state);
      } else if (state.current() === 0x3F ) {
        state.raise("Invalid group");
      }
      this.regexp_disjunction(state);
      if (state.eat(0x29 )) {
        state.numCapturingParens += 1;
        return true
      }
      state.raise("Unterminated group");
    }
    return false
  };

  pp$8.regexp_eatExtendedAtom = function(state) {
    return (
      state.eat(0x2E ) ||
      this.regexp_eatReverseSolidusAtomEscape(state) ||
      this.regexp_eatCharacterClass(state) ||
      this.regexp_eatUncapturingGroup(state) ||
      this.regexp_eatCapturingGroup(state) ||
      this.regexp_eatInvalidBracedQuantifier(state) ||
      this.regexp_eatExtendedPatternCharacter(state)
    )
  };

  pp$8.regexp_eatInvalidBracedQuantifier = function(state) {
    if (this.regexp_eatBracedQuantifier(state, true)) {
      state.raise("Nothing to repeat");
    }
    return false
  };

  pp$8.regexp_eatSyntaxCharacter = function(state) {
    var ch = state.current();
    if (isSyntaxCharacter(ch)) {
      state.lastIntValue = ch;
      state.advance();
      return true
    }
    return false
  };
  function isSyntaxCharacter(ch) {
    return (
      ch === 0x24  ||
      ch >= 0x28  && ch <= 0x2B  ||
      ch === 0x2E  ||
      ch === 0x3F  ||
      ch >= 0x5B  && ch <= 0x5E  ||
      ch >= 0x7B  && ch <= 0x7D 
    )
  }

  pp$8.regexp_eatPatternCharacters = function(state) {
    var start = state.pos;
    var ch = 0;
    while ((ch = state.current()) !== -1 && !isSyntaxCharacter(ch)) {
      state.advance();
    }
    return state.pos !== start
  };

  pp$8.regexp_eatExtendedPatternCharacter = function(state) {
    var ch = state.current();
    if (
      ch !== -1 &&
      ch !== 0x24  &&
      !(ch >= 0x28  && ch <= 0x2B ) &&
      ch !== 0x2E  &&
      ch !== 0x3F  &&
      ch !== 0x5B  &&
      ch !== 0x5E  &&
      ch !== 0x7C 
    ) {
      state.advance();
      return true
    }
    return false
  };

  pp$8.regexp_groupSpecifier = function(state) {
    if (state.eat(0x3F )) {
      if (this.regexp_eatGroupName(state)) {
        if (state.groupNames.indexOf(state.lastStringValue) !== -1) {
          state.raise("Duplicate capture group name");
        }
        state.groupNames.push(state.lastStringValue);
        return
      }
      state.raise("Invalid group");
    }
  };

  pp$8.regexp_eatGroupName = function(state) {
    state.lastStringValue = "";
    if (state.eat(0x3C )) {
      if (this.regexp_eatRegExpIdentifierName(state) && state.eat(0x3E )) {
        return true
      }
      state.raise("Invalid capture group name");
    }
    return false
  };

  pp$8.regexp_eatRegExpIdentifierName = function(state) {
    state.lastStringValue = "";
    if (this.regexp_eatRegExpIdentifierStart(state)) {
      state.lastStringValue += codePointToString(state.lastIntValue);
      while (this.regexp_eatRegExpIdentifierPart(state)) {
        state.lastStringValue += codePointToString(state.lastIntValue);
      }
      return true
    }
    return false
  };

  pp$8.regexp_eatRegExpIdentifierStart = function(state) {
    var start = state.pos;
    var ch = state.current();
    state.advance();

    if (ch === 0x5C  && this.regexp_eatRegExpUnicodeEscapeSequence(state)) {
      ch = state.lastIntValue;
    }
    if (isRegExpIdentifierStart(ch)) {
      state.lastIntValue = ch;
      return true
    }

    state.pos = start;
    return false
  };
  function isRegExpIdentifierStart(ch) {
    return isIdentifierStart(ch, true) || ch === 0x24  || ch === 0x5F 
  }

  pp$8.regexp_eatRegExpIdentifierPart = function(state) {
    var start = state.pos;
    var ch = state.current();
    state.advance();

    if (ch === 0x5C  && this.regexp_eatRegExpUnicodeEscapeSequence(state)) {
      ch = state.lastIntValue;
    }
    if (isRegExpIdentifierPart(ch)) {
      state.lastIntValue = ch;
      return true
    }

    state.pos = start;
    return false
  };
  function isRegExpIdentifierPart(ch) {
    return isIdentifierChar(ch, true) || ch === 0x24  || ch === 0x5F  || ch === 0x200C  || ch === 0x200D 
  }

  pp$8.regexp_eatAtomEscape = function(state) {
    if (
      this.regexp_eatBackReference(state) ||
      this.regexp_eatCharacterClassEscape(state) ||
      this.regexp_eatCharacterEscape(state) ||
      (state.switchN && this.regexp_eatKGroupName(state))
    ) {
      return true
    }
    if (state.switchU) {
      if (state.current() === 0x63 ) {
        state.raise("Invalid unicode escape");
      }
      state.raise("Invalid escape");
    }
    return false
  };
  pp$8.regexp_eatBackReference = function(state) {
    var start = state.pos;
    if (this.regexp_eatDecimalEscape(state)) {
      var n = state.lastIntValue;
      if (state.switchU) {
        if (n > state.maxBackReference) {
          state.maxBackReference = n;
        }
        return true
      }
      if (n <= state.numCapturingParens) {
        return true
      }
      state.pos = start;
    }
    return false
  };
  pp$8.regexp_eatKGroupName = function(state) {
    if (state.eat(0x6B )) {
      if (this.regexp_eatGroupName(state)) {
        state.backReferenceNames.push(state.lastStringValue);
        return true
      }
      state.raise("Invalid named reference");
    }
    return false
  };

  pp$8.regexp_eatCharacterEscape = function(state) {
    return (
      this.regexp_eatControlEscape(state) ||
      this.regexp_eatCControlLetter(state) ||
      this.regexp_eatZero(state) ||
      this.regexp_eatHexEscapeSequence(state) ||
      this.regexp_eatRegExpUnicodeEscapeSequence(state) ||
      (!state.switchU && this.regexp_eatLegacyOctalEscapeSequence(state)) ||
      this.regexp_eatIdentityEscape(state)
    )
  };
  pp$8.regexp_eatCControlLetter = function(state) {
    var start = state.pos;
    if (state.eat(0x63 )) {
      if (this.regexp_eatControlLetter(state)) {
        return true
      }
      state.pos = start;
    }
    return false
  };
  pp$8.regexp_eatZero = function(state) {
    if (state.current() === 0x30  && !isDecimalDigit(state.lookahead())) {
      state.lastIntValue = 0;
      state.advance();
      return true
    }
    return false
  };

  pp$8.regexp_eatControlEscape = function(state) {
    var ch = state.current();
    if (ch === 0x74 ) {
      state.lastIntValue = 0x09; 
      state.advance();
      return true
    }
    if (ch === 0x6E ) {
      state.lastIntValue = 0x0A; 
      state.advance();
      return true
    }
    if (ch === 0x76 ) {
      state.lastIntValue = 0x0B; 
      state.advance();
      return true
    }
    if (ch === 0x66 ) {
      state.lastIntValue = 0x0C; 
      state.advance();
      return true
    }
    if (ch === 0x72 ) {
      state.lastIntValue = 0x0D; 
      state.advance();
      return true
    }
    return false
  };

  pp$8.regexp_eatControlLetter = function(state) {
    var ch = state.current();
    if (isControlLetter(ch)) {
      state.lastIntValue = ch % 0x20;
      state.advance();
      return true
    }
    return false
  };
  function isControlLetter(ch) {
    return (
      (ch >= 0x41  && ch <= 0x5A ) ||
      (ch >= 0x61  && ch <= 0x7A )
    )
  }

  pp$8.regexp_eatRegExpUnicodeEscapeSequence = function(state) {
    var start = state.pos;

    if (state.eat(0x75 )) {
      if (this.regexp_eatFixedHexDigits(state, 4)) {
        var lead = state.lastIntValue;
        if (state.switchU && lead >= 0xD800 && lead <= 0xDBFF) {
          var leadSurrogateEnd = state.pos;
          if (state.eat(0x5C ) && state.eat(0x75 ) && this.regexp_eatFixedHexDigits(state, 4)) {
            var trail = state.lastIntValue;
            if (trail >= 0xDC00 && trail <= 0xDFFF) {
              state.lastIntValue = (lead - 0xD800) * 0x400 + (trail - 0xDC00) + 0x10000;
              return true
            }
          }
          state.pos = leadSurrogateEnd;
          state.lastIntValue = lead;
        }
        return true
      }
      if (
        state.switchU &&
        state.eat(0x7B ) &&
        this.regexp_eatHexDigits(state) &&
        state.eat(0x7D ) &&
        isValidUnicode(state.lastIntValue)
      ) {
        return true
      }
      if (state.switchU) {
        state.raise("Invalid unicode escape");
      }
      state.pos = start;
    }

    return false
  };
  function isValidUnicode(ch) {
    return ch >= 0 && ch <= 0x10FFFF
  }

  pp$8.regexp_eatIdentityEscape = function(state) {
    if (state.switchU) {
      if (this.regexp_eatSyntaxCharacter(state)) {
        return true
      }
      if (state.eat(0x2F )) {
        state.lastIntValue = 0x2F; 
        return true
      }
      return false
    }

    var ch = state.current();
    if (ch !== 0x63  && (!state.switchN || ch !== 0x6B )) {
      state.lastIntValue = ch;
      state.advance();
      return true
    }

    return false
  };

  pp$8.regexp_eatDecimalEscape = function(state) {
    state.lastIntValue = 0;
    var ch = state.current();
    if (ch >= 0x31  && ch <= 0x39 ) {
      do {
        state.lastIntValue = 10 * state.lastIntValue + (ch - 0x30 );
        state.advance();
      } while ((ch = state.current()) >= 0x30  && ch <= 0x39 )
      return true
    }
    return false
  };

  pp$8.regexp_eatCharacterClassEscape = function(state) {
    var ch = state.current();

    if (isCharacterClassEscape(ch)) {
      state.lastIntValue = -1;
      state.advance();
      return true
    }

    if (
      state.switchU &&
      this.options.ecmaVersion >= 9 &&
      (ch === 0x50  || ch === 0x70 )
    ) {
      state.lastIntValue = -1;
      state.advance();
      if (
        state.eat(0x7B ) &&
        this.regexp_eatUnicodePropertyValueExpression(state) &&
        state.eat(0x7D )
      ) {
        return true
      }
      state.raise("Invalid property name");
    }

    return false
  };
  function isCharacterClassEscape(ch) {
    return (
      ch === 0x64  ||
      ch === 0x44  ||
      ch === 0x73  ||
      ch === 0x53  ||
      ch === 0x77  ||
      ch === 0x57 
    )
  }

  pp$8.regexp_eatUnicodePropertyValueExpression = function(state) {
    var start = state.pos;

    if (this.regexp_eatUnicodePropertyName(state) && state.eat(0x3D )) {
      var name = state.lastStringValue;
      if (this.regexp_eatUnicodePropertyValue(state)) {
        var value = state.lastStringValue;
        this.regexp_validateUnicodePropertyNameAndValue(state, name, value);
        return true
      }
    }
    state.pos = start;

    if (this.regexp_eatLoneUnicodePropertyNameOrValue(state)) {
      var nameOrValue = state.lastStringValue;
      this.regexp_validateUnicodePropertyNameOrValue(state, nameOrValue);
      return true
    }
    return false
  };
  pp$8.regexp_validateUnicodePropertyNameAndValue = function(state, name, value) {
    if (!has(state.unicodeProperties.nonBinary, name))
      { state.raise("Invalid property name"); }
    if (!state.unicodeProperties.nonBinary[name].test(value))
      { state.raise("Invalid property value"); }
  };
  pp$8.regexp_validateUnicodePropertyNameOrValue = function(state, nameOrValue) {
    if (!state.unicodeProperties.binary.test(nameOrValue))
      { state.raise("Invalid property name"); }
  };

  pp$8.regexp_eatUnicodePropertyName = function(state) {
    var ch = 0;
    state.lastStringValue = "";
    while (isUnicodePropertyNameCharacter(ch = state.current())) {
      state.lastStringValue += codePointToString(ch);
      state.advance();
    }
    return state.lastStringValue !== ""
  };
  function isUnicodePropertyNameCharacter(ch) {
    return isControlLetter(ch) || ch === 0x5F 
  }

  pp$8.regexp_eatUnicodePropertyValue = function(state) {
    var ch = 0;
    state.lastStringValue = "";
    while (isUnicodePropertyValueCharacter(ch = state.current())) {
      state.lastStringValue += codePointToString(ch);
      state.advance();
    }
    return state.lastStringValue !== ""
  };
  function isUnicodePropertyValueCharacter(ch) {
    return isUnicodePropertyNameCharacter(ch) || isDecimalDigit(ch)
  }

  pp$8.regexp_eatLoneUnicodePropertyNameOrValue = function(state) {
    return this.regexp_eatUnicodePropertyValue(state)
  };

  pp$8.regexp_eatCharacterClass = function(state) {
    if (state.eat(0x5B )) {
      state.eat(0x5E );
      this.regexp_classRanges(state);
      if (state.eat(0x5D )) {
        return true
      }
      state.raise("Unterminated character class");
    }
    return false
  };

  pp$8.regexp_classRanges = function(state) {
    while (this.regexp_eatClassAtom(state)) {
      var left = state.lastIntValue;
      if (state.eat(0x2D ) && this.regexp_eatClassAtom(state)) {
        var right = state.lastIntValue;
        if (state.switchU && (left === -1 || right === -1)) {
          state.raise("Invalid character class");
        }
        if (left !== -1 && right !== -1 && left > right) {
          state.raise("Range out of order in character class");
        }
      }
    }
  };

  pp$8.regexp_eatClassAtom = function(state) {
    var start = state.pos;

    if (state.eat(0x5C )) {
      if (this.regexp_eatClassEscape(state)) {
        return true
      }
      if (state.switchU) {
        var ch$1 = state.current();
        if (ch$1 === 0x63  || isOctalDigit(ch$1)) {
          state.raise("Invalid class escape");
        }
        state.raise("Invalid escape");
      }
      state.pos = start;
    }

    var ch = state.current();
    if (ch !== 0x5D ) {
      state.lastIntValue = ch;
      state.advance();
      return true
    }

    return false
  };

  pp$8.regexp_eatClassEscape = function(state) {
    var start = state.pos;

    if (state.eat(0x62 )) {
      state.lastIntValue = 0x08; 
      return true
    }

    if (state.switchU && state.eat(0x2D )) {
      state.lastIntValue = 0x2D; 
      return true
    }

    if (!state.switchU && state.eat(0x63 )) {
      if (this.regexp_eatClassControlLetter(state)) {
        return true
      }
      state.pos = start;
    }

    return (
      this.regexp_eatCharacterClassEscape(state) ||
      this.regexp_eatCharacterEscape(state)
    )
  };

  pp$8.regexp_eatClassControlLetter = function(state) {
    var ch = state.current();
    if (isDecimalDigit(ch) || ch === 0x5F ) {
      state.lastIntValue = ch % 0x20;
      state.advance();
      return true
    }
    return false
  };

  pp$8.regexp_eatHexEscapeSequence = function(state) {
    var start = state.pos;
    if (state.eat(0x78 )) {
      if (this.regexp_eatFixedHexDigits(state, 2)) {
        return true
      }
      if (state.switchU) {
        state.raise("Invalid escape");
      }
      state.pos = start;
    }
    return false
  };

  pp$8.regexp_eatDecimalDigits = function(state) {
    var start = state.pos;
    var ch = 0;
    state.lastIntValue = 0;
    while (isDecimalDigit(ch = state.current())) {
      state.lastIntValue = 10 * state.lastIntValue + (ch - 0x30 );
      state.advance();
    }
    return state.pos !== start
  };
  function isDecimalDigit(ch) {
    return ch >= 0x30  && ch <= 0x39 
  }

  pp$8.regexp_eatHexDigits = function(state) {
    var start = state.pos;
    var ch = 0;
    state.lastIntValue = 0;
    while (isHexDigit(ch = state.current())) {
      state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);
      state.advance();
    }
    return state.pos !== start
  };
  function isHexDigit(ch) {
    return (
      (ch >= 0x30  && ch <= 0x39 ) ||
      (ch >= 0x41  && ch <= 0x46 ) ||
      (ch >= 0x61  && ch <= 0x66 )
    )
  }
  function hexToInt(ch) {
    if (ch >= 0x41  && ch <= 0x46 ) {
      return 10 + (ch - 0x41 )
    }
    if (ch >= 0x61  && ch <= 0x66 ) {
      return 10 + (ch - 0x61 )
    }
    return ch - 0x30 
  }

  pp$8.regexp_eatLegacyOctalEscapeSequence = function(state) {
    if (this.regexp_eatOctalDigit(state)) {
      var n1 = state.lastIntValue;
      if (this.regexp_eatOctalDigit(state)) {
        var n2 = state.lastIntValue;
        if (n1 <= 3 && this.regexp_eatOctalDigit(state)) {
          state.lastIntValue = n1 * 64 + n2 * 8 + state.lastIntValue;
        } else {
          state.lastIntValue = n1 * 8 + n2;
        }
      } else {
        state.lastIntValue = n1;
      }
      return true
    }
    return false
  };

  pp$8.regexp_eatOctalDigit = function(state) {
    var ch = state.current();
    if (isOctalDigit(ch)) {
      state.lastIntValue = ch - 0x30; 
      state.advance();
      return true
    }
    state.lastIntValue = 0;
    return false
  };
  function isOctalDigit(ch) {
    return ch >= 0x30  && ch <= 0x37 
  }

  pp$8.regexp_eatFixedHexDigits = function(state, length) {
    var start = state.pos;
    state.lastIntValue = 0;
    for (var i = 0; i < length; ++i) {
      var ch = state.current();
      if (!isHexDigit(ch)) {
        state.pos = start;
        return false
      }
      state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);
      state.advance();
    }
    return true
  };


  var Token = function Token(p) {
    this.type = p.type;
    this.value = p.value;
    this.start = p.start;
    this.end = p.end;
    if (p.options.locations)
      { this.loc = new SourceLocation(p, p.startLoc, p.endLoc); }
    if (p.options.ranges)
      { this.range = [p.start, p.end]; }
  };


  var pp$9 = Parser.prototype;


  pp$9.next = function(ignoreEscapeSequenceInKeyword) {
    if (!ignoreEscapeSequenceInKeyword && this.type.keyword && this.containsEsc)
      { this.raiseRecoverable(this.start, "Escape sequence in keyword " + this.type.keyword); }
    if (this.options.onToken)
      { this.options.onToken(new Token(this)); }

    this.lastTokEnd = this.end;
    this.lastTokStart = this.start;
    this.lastTokEndLoc = this.endLoc;
    this.lastTokStartLoc = this.startLoc;
    this.nextToken();
  };

  pp$9.getToken = function() {
    this.next();
    return new Token(this)
  };

  if (typeof Symbol !== "undefined")
    { pp$9[Symbol.iterator] = function() {
      var this$1 = this;

      return {
        next: function () {
          var token = this$1.getToken();
          return {
            done: token.type === types.eof,
            value: token
          }
        }
      }
    }; }


  pp$9.curContext = function() {
    return this.context[this.context.length - 1]
  };


  pp$9.nextToken = function() {
    var curContext = this.curContext();
    if (!curContext || !curContext.preserveSpace) { this.skipSpace(); }

    this.start = this.pos;
    if (this.options.locations) { this.startLoc = this.curPosition(); }
    if (this.pos >= this.input.length) { return this.finishToken(types.eof) }

    if (curContext.override) { return curContext.override(this) }
    else { this.readToken(this.fullCharCodeAtPos()); }
  };

  pp$9.readToken = function(code) {
    if (isIdentifierStart(code, this.options.ecmaVersion >= 6) || code === 92 )
      { return this.readWord() }

    return this.getTokenFromCode(code)
  };

  pp$9.fullCharCodeAtPos = function() {
    var code = this.input.charCodeAt(this.pos);
    if (code <= 0xd7ff || code >= 0xe000) { return code }
    var next = this.input.charCodeAt(this.pos + 1);
    return (code << 10) + next - 0x35fdc00
  };

  pp$9.skipBlockComment = function() {
    var startLoc = this.options.onComment && this.curPosition();
    var start = this.pos, end = this.input.indexOf("*/", this.pos += 2);
    if (end === -1) { this.raise(this.pos - 2, "Unterminated comment"); }
    this.pos = end + 2;
    if (this.options.locations) {
      lineBreakG.lastIndex = start;
      var match;
      while ((match = lineBreakG.exec(this.input)) && match.index < this.pos) {
        ++this.curLine;
        this.lineStart = match.index + match[0].length;
      }
    }
    if (this.options.onComment)
      { this.options.onComment(true, this.input.slice(start + 2, end), start, this.pos,
                             startLoc, this.curPosition()); }
  };

  pp$9.skipLineComment = function(startSkip) {
    var start = this.pos;
    var startLoc = this.options.onComment && this.curPosition();
    var ch = this.input.charCodeAt(this.pos += startSkip);
    while (this.pos < this.input.length && !isNewLine(ch)) {
      ch = this.input.charCodeAt(++this.pos);
    }
    if (this.options.onComment)
      { this.options.onComment(false, this.input.slice(start + startSkip, this.pos), start, this.pos,
                             startLoc, this.curPosition()); }
  };


  pp$9.skipSpace = function() {
    loop: while (this.pos < this.input.length) {
      var ch = this.input.charCodeAt(this.pos);
      switch (ch) {
      case 32: case 160: 
        ++this.pos;
        break
      case 13:
        if (this.input.charCodeAt(this.pos + 1) === 10) {
          ++this.pos;
        }
      case 10: case 8232: case 8233:
        ++this.pos;
        if (this.options.locations) {
          ++this.curLine;
          this.lineStart = this.pos;
        }
        break
      case 47: 
        switch (this.input.charCodeAt(this.pos + 1)) {
        case 42: 
          this.skipBlockComment();
          break
        case 47:
          this.skipLineComment(2);
          break
        default:
          break loop
        }
        break
      default:
        if (ch > 8 && ch < 14 || ch >= 5760 && nonASCIIwhitespace.test(String.fromCharCode(ch))) {
          ++this.pos;
        } else {
          break loop
        }
      }
    }
  };


  pp$9.finishToken = function(type, val) {
    this.end = this.pos;
    if (this.options.locations) { this.endLoc = this.curPosition(); }
    var prevType = this.type;
    this.type = type;
    this.value = val;

    this.updateContext(prevType);
  };


  pp$9.readToken_dot = function() {
    var next = this.input.charCodeAt(this.pos + 1);
    if (next >= 48 && next <= 57) { return this.readNumber(true) }
    var next2 = this.input.charCodeAt(this.pos + 2);
    if (this.options.ecmaVersion >= 6 && next === 46 && next2 === 46) { 
      this.pos += 3;
      return this.finishToken(types.ellipsis)
    } else {
      ++this.pos;
      return this.finishToken(types.dot)
    }
  };

  pp$9.readToken_slash = function() { 
    var next = this.input.charCodeAt(this.pos + 1);
    if (this.exprAllowed) { ++this.pos; return this.readRegexp() }
    if (next === 61) { return this.finishOp(types.assign, 2) }
    return this.finishOp(types.slash, 1)
  };

  pp$9.readToken_mult_modulo_exp = function(code) { 
    var next = this.input.charCodeAt(this.pos + 1);
    var size = 1;
    var tokentype = code === 42 ? types.star : types.modulo;

    if (this.options.ecmaVersion >= 7 && code === 42 && next === 42) {
      ++size;
      tokentype = types.starstar;
      next = this.input.charCodeAt(this.pos + 2);
    }

    if (next === 61) { return this.finishOp(types.assign, size + 1) }
    return this.finishOp(tokentype, size)
  };

  pp$9.readToken_pipe_amp = function(code) { 
    var next = this.input.charCodeAt(this.pos + 1);
    if (next === code) { return this.finishOp(code === 124 ? types.logicalOR : types.logicalAND, 2) }
    if (next === 61) { return this.finishOp(types.assign, 2) }
    return this.finishOp(code === 124 ? types.bitwiseOR : types.bitwiseAND, 1)
  };

  pp$9.readToken_caret = function() { 
    var next = this.input.charCodeAt(this.pos + 1);
    if (next === 61) { return this.finishOp(types.assign, 2) }
    return this.finishOp(types.bitwiseXOR, 1)
  };

  pp$9.readToken_plus_min = function(code) { 
    var next = this.input.charCodeAt(this.pos + 1);
    if (next === code) {
      if (next === 45 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 62 &&
          (this.lastTokEnd === 0 || lineBreak.test(this.input.slice(this.lastTokEnd, this.pos)))) {
        this.skipLineComment(3);
        this.skipSpace();
        return this.nextToken()
      }
      return this.finishOp(types.incDec, 2)
    }
    if (next === 61) { return this.finishOp(types.assign, 2) }
    return this.finishOp(types.plusMin, 1)
  };

  pp$9.readToken_lt_gt = function(code) { 
    var next = this.input.charCodeAt(this.pos + 1);
    var size = 1;
    if (next === code) {
      size = code === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2;
      if (this.input.charCodeAt(this.pos + size) === 61) { return this.finishOp(types.assign, size + 1) }
      return this.finishOp(types.bitShift, size)
    }
    if (next === 33 && code === 60 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 45 &&
        this.input.charCodeAt(this.pos + 3) === 45) {
      this.skipLineComment(4);
      this.skipSpace();
      return this.nextToken()
    }
    if (next === 61) { size = 2; }
    return this.finishOp(types.relational, size)
  };

  pp$9.readToken_eq_excl = function(code) { 
    var next = this.input.charCodeAt(this.pos + 1);
    if (next === 61) { return this.finishOp(types.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2) }
    if (code === 61 && next === 62 && this.options.ecmaVersion >= 6) { 
      this.pos += 2;
      return this.finishToken(types.arrow)
    }
    return this.finishOp(code === 61 ? types.eq : types.prefix, 1)
  };

  pp$9.getTokenFromCode = function(code) {
    switch (code) {
    case 46: 
      return this.readToken_dot()

    case 40: ++this.pos; return this.finishToken(types.parenL)
    case 41: ++this.pos; return this.finishToken(types.parenR)
    case 59: ++this.pos; return this.finishToken(types.semi)
    case 44: ++this.pos; return this.finishToken(types.comma)
    case 91: ++this.pos; return this.finishToken(types.bracketL)
    case 93: ++this.pos; return this.finishToken(types.bracketR)
    case 123: ++this.pos; return this.finishToken(types.braceL)
    case 125: ++this.pos; return this.finishToken(types.braceR)
    case 58: ++this.pos; return this.finishToken(types.colon)
    case 63: ++this.pos; return this.finishToken(types.question)

    case 96: 
      if (this.options.ecmaVersion < 6) { break }
      ++this.pos;
      return this.finishToken(types.backQuote)

    case 48: 
      var next = this.input.charCodeAt(this.pos + 1);
      if (next === 120 || next === 88) { return this.readRadixNumber(16) } 
      if (this.options.ecmaVersion >= 6) {
        if (next === 111 || next === 79) { return this.readRadixNumber(8) } 
        if (next === 98 || next === 66) { return this.readRadixNumber(2) } 
      }

    case 49: case 50: case 51: case 52: case 53: case 54: case 55: case 56: case 57: 
      return this.readNumber(false)

    case 34: case 39: 
      return this.readString(code)


    case 47: 
      return this.readToken_slash()

    case 37: case 42: 
      return this.readToken_mult_modulo_exp(code)

    case 124: case 38: 
      return this.readToken_pipe_amp(code)

    case 94: 
      return this.readToken_caret()

    case 43: case 45: 
      return this.readToken_plus_min(code)

    case 60: case 62: 
      return this.readToken_lt_gt(code)

    case 61: case 33: 
      return this.readToken_eq_excl(code)

    case 126: 
      return this.finishOp(types.prefix, 1)
    }

    this.raise(this.pos, "Unexpected character '" + codePointToString$1(code) + "'");
  };

  pp$9.finishOp = function(type, size) {
    var str = this.input.slice(this.pos, this.pos + size);
    this.pos += size;
    return this.finishToken(type, str)
  };

  pp$9.readRegexp = function() {
    var escaped, inClass, start = this.pos;
    for (;;) {
      if (this.pos >= this.input.length) { this.raise(start, "Unterminated regular expression"); }
      var ch = this.input.charAt(this.pos);
      if (lineBreak.test(ch)) { this.raise(start, "Unterminated regular expression"); }
      if (!escaped) {
        if (ch === "[") { inClass = true; }
        else if (ch === "]" && inClass) { inClass = false; }
        else if (ch === "/" && !inClass) { break }
        escaped = ch === "\\";
      } else { escaped = false; }
      ++this.pos;
    }
    var pattern = this.input.slice(start, this.pos);
    ++this.pos;
    var flagsStart = this.pos;
    var flags = this.readWord1();
    if (this.containsEsc) { this.unexpected(flagsStart); }

    var state = this.regexpState || (this.regexpState = new RegExpValidationState(this));
    state.reset(start, pattern, flags);
    this.validateRegExpFlags(state);
    this.validateRegExpPattern(state);

    var value = null;
    try {
      value = new RegExp(pattern, flags);
    } catch (e) {
    }

    return this.finishToken(types.regexp, {pattern: pattern, flags: flags, value: value})
  };


  pp$9.readInt = function(radix, len) {
    var start = this.pos, total = 0;
    for (var i = 0, e = len == null ? Infinity : len; i < e; ++i) {
      var code = this.input.charCodeAt(this.pos), val = (void 0);
      if (code >= 97) { val = code - 97 + 10; } 
      else if (code >= 65) { val = code - 65 + 10; } 
      else if (code >= 48 && code <= 57) { val = code - 48; } 
      else { val = Infinity; }
      if (val >= radix) { break }
      ++this.pos;
      total = total * radix + val;
    }
    if (this.pos === start || len != null && this.pos - start !== len) { return null }

    return total
  };

  pp$9.readRadixNumber = function(radix) {
    var start = this.pos;
    this.pos += 2; 
    var val = this.readInt(radix);
    if (val == null) { this.raise(this.start + 2, "Expected number in radix " + radix); }
    if (this.options.ecmaVersion >= 11 && this.input.charCodeAt(this.pos) === 110) {
      val = typeof BigInt !== "undefined" ? BigInt(this.input.slice(start, this.pos)) : null;
      ++this.pos;
    } else if (isIdentifierStart(this.fullCharCodeAtPos())) { this.raise(this.pos, "Identifier directly after number"); }
    return this.finishToken(types.num, val)
  };


  pp$9.readNumber = function(startsWithDot) {
    var start = this.pos;
    if (!startsWithDot && this.readInt(10) === null) { this.raise(start, "Invalid number"); }
    var octal = this.pos - start >= 2 && this.input.charCodeAt(start) === 48;
    if (octal && this.strict) { this.raise(start, "Invalid number"); }
    var next = this.input.charCodeAt(this.pos);
    if (!octal && !startsWithDot && this.options.ecmaVersion >= 11 && next === 110) {
      var str$1 = this.input.slice(start, this.pos);
      var val$1 = typeof BigInt !== "undefined" ? BigInt(str$1) : null;
      ++this.pos;
      if (isIdentifierStart(this.fullCharCodeAtPos())) { this.raise(this.pos, "Identifier directly after number"); }
      return this.finishToken(types.num, val$1)
    }
    if (octal && /[89]/.test(this.input.slice(start, this.pos))) { octal = false; }
    if (next === 46 && !octal) { 
      ++this.pos;
      this.readInt(10);
      next = this.input.charCodeAt(this.pos);
    }
    if ((next === 69 || next === 101) && !octal) { 
      next = this.input.charCodeAt(++this.pos);
      if (next === 43 || next === 45) { ++this.pos; } 
      if (this.readInt(10) === null) { this.raise(start, "Invalid number"); }
    }
    if (isIdentifierStart(this.fullCharCodeAtPos())) { this.raise(this.pos, "Identifier directly after number"); }

    var str = this.input.slice(start, this.pos);
    var val = octal ? parseInt(str, 8) : parseFloat(str);
    return this.finishToken(types.num, val)
  };


  pp$9.readCodePoint = function() {
    var ch = this.input.charCodeAt(this.pos), code;

    if (ch === 123) { 
      if (this.options.ecmaVersion < 6) { this.unexpected(); }
      var codePos = ++this.pos;
      code = this.readHexChar(this.input.indexOf("}", this.pos) - this.pos);
      ++this.pos;
      if (code > 0x10FFFF) { this.invalidStringToken(codePos, "Code point out of bounds"); }
    } else {
      code = this.readHexChar(4);
    }
    return code
  };

  function codePointToString$1(code) {
    if (code <= 0xFFFF) { return String.fromCharCode(code) }
    code -= 0x10000;
    return String.fromCharCode((code >> 10) + 0xD800, (code & 1023) + 0xDC00)
  }

  pp$9.readString = function(quote) {
    var out = "", chunkStart = ++this.pos;
    for (;;) {
      if (this.pos >= this.input.length) { this.raise(this.start, "Unterminated string constant"); }
      var ch = this.input.charCodeAt(this.pos);
      if (ch === quote) { break }
      if (ch === 92) { 
        out += this.input.slice(chunkStart, this.pos);
        out += this.readEscapedChar(false);
        chunkStart = this.pos;
      } else {
        if (isNewLine(ch, this.options.ecmaVersion >= 10)) { this.raise(this.start, "Unterminated string constant"); }
        ++this.pos;
      }
    }
    out += this.input.slice(chunkStart, this.pos++);
    return this.finishToken(types.string, out)
  };


  var INVALID_TEMPLATE_ESCAPE_ERROR = {};

  pp$9.tryReadTemplateToken = function() {
    this.inTemplateElement = true;
    try {
      this.readTmplToken();
    } catch (err) {
      if (err === INVALID_TEMPLATE_ESCAPE_ERROR) {
        this.readInvalidTemplateToken();
      } else {
        throw err
      }
    }

    this.inTemplateElement = false;
  };

  pp$9.invalidStringToken = function(position, message) {
    if (this.inTemplateElement && this.options.ecmaVersion >= 9) {
      throw INVALID_TEMPLATE_ESCAPE_ERROR
    } else {
      this.raise(position, message);
    }
  };

  pp$9.readTmplToken = function() {
    var out = "", chunkStart = this.pos;
    for (;;) {
      if (this.pos >= this.input.length) { this.raise(this.start, "Unterminated template"); }
      var ch = this.input.charCodeAt(this.pos);
      if (ch === 96 || ch === 36 && this.input.charCodeAt(this.pos + 1) === 123) { 
        if (this.pos === this.start && (this.type === types.template || this.type === types.invalidTemplate)) {
          if (ch === 36) {
            this.pos += 2;
            return this.finishToken(types.dollarBraceL)
          } else {
            ++this.pos;
            return this.finishToken(types.backQuote)
          }
        }
        out += this.input.slice(chunkStart, this.pos);
        return this.finishToken(types.template, out)
      }
      if (ch === 92) { 
        out += this.input.slice(chunkStart, this.pos);
        out += this.readEscapedChar(true);
        chunkStart = this.pos;
      } else if (isNewLine(ch)) {
        out += this.input.slice(chunkStart, this.pos);
        ++this.pos;
        switch (ch) {
        case 13:
          if (this.input.charCodeAt(this.pos) === 10) { ++this.pos; }
        case 10:
          out += "\n";
          break
        default:
          out += String.fromCharCode(ch);
          break
        }
        if (this.options.locations) {
          ++this.curLine;
          this.lineStart = this.pos;
        }
        chunkStart = this.pos;
      } else {
        ++this.pos;
      }
    }
  };

  pp$9.readInvalidTemplateToken = function() {
    for (; this.pos < this.input.length; this.pos++) {
      switch (this.input[this.pos]) {
      case "\\":
        ++this.pos;
        break

      case "$":
        if (this.input[this.pos + 1] !== "{") {
          break
        }

      case "`":
        return this.finishToken(types.invalidTemplate, this.input.slice(this.start, this.pos))

      }
    }
    this.raise(this.start, "Unterminated template");
  };


  pp$9.readEscapedChar = function(inTemplate) {
    var ch = this.input.charCodeAt(++this.pos);
    ++this.pos;
    switch (ch) {
    case 110: return "\n" 
    case 114: return "\r" 
    case 120: return String.fromCharCode(this.readHexChar(2)) 
    case 117: return codePointToString$1(this.readCodePoint()) 
    case 116: return "\t" 
    case 98: return "\b" 
    case 118: return "\u000b" 
    case 102: return "\f" 
    case 13: if (this.input.charCodeAt(this.pos) === 10) { ++this.pos; } 
    case 10: 
      if (this.options.locations) { this.lineStart = this.pos; ++this.curLine; }
      return ""
    case 56:
    case 57:
      if (inTemplate) {
        var codePos = this.pos - 1;

        this.invalidStringToken(
          codePos,
          "Invalid escape sequence in template string"
        );

        return null
      }
    default:
      if (ch >= 48 && ch <= 55) {
        var octalStr = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0];
        var octal = parseInt(octalStr, 8);
        if (octal > 255) {
          octalStr = octalStr.slice(0, -1);
          octal = parseInt(octalStr, 8);
        }
        this.pos += octalStr.length - 1;
        ch = this.input.charCodeAt(this.pos);
        if ((octalStr !== "0" || ch === 56 || ch === 57) && (this.strict || inTemplate)) {
          this.invalidStringToken(
            this.pos - 1 - octalStr.length,
            inTemplate
              ? "Octal literal in template string"
              : "Octal literal in strict mode"
          );
        }
        return String.fromCharCode(octal)
      }
      if (isNewLine(ch)) {
        return ""
      }
      return String.fromCharCode(ch)
    }
  };


  pp$9.readHexChar = function(len) {
    var codePos = this.pos;
    var n = this.readInt(16, len);
    if (n === null) { this.invalidStringToken(codePos, "Bad character escape sequence"); }
    return n
  };


  pp$9.readWord1 = function() {
    this.containsEsc = false;
    var word = "", first = true, chunkStart = this.pos;
    var astral = this.options.ecmaVersion >= 6;
    while (this.pos < this.input.length) {
      var ch = this.fullCharCodeAtPos();
      if (isIdentifierChar(ch, astral)) {
        this.pos += ch <= 0xffff ? 1 : 2;
      } else if (ch === 92) { 
        this.containsEsc = true;
        word += this.input.slice(chunkStart, this.pos);
        var escStart = this.pos;
        if (this.input.charCodeAt(++this.pos) !== 117) 
          { this.invalidStringToken(this.pos, "Expecting Unicode escape sequence \\uXXXX"); }
        ++this.pos;
        var esc = this.readCodePoint();
        if (!(first ? isIdentifierStart : isIdentifierChar)(esc, astral))
          { this.invalidStringToken(escStart, "Invalid Unicode escape"); }
        word += codePointToString$1(esc);
        chunkStart = this.pos;
      } else {
        break
      }
      first = false;
    }
    return word + this.input.slice(chunkStart, this.pos)
  };


  pp$9.readWord = function() {
    var word = this.readWord1();
    var type = types.name;
    if (this.keywords.test(word)) {
      type = keywords$1[word];
    }
    return this.finishToken(type, word)
  };


  var version = "7.1.0";

  Parser.acorn = {
    Parser: Parser,
    version: version,
    defaultOptions: defaultOptions,
    Position: Position,
    SourceLocation: SourceLocation,
    getLineInfo: getLineInfo,
    Node: Node,
    TokenType: TokenType,
    tokTypes: types,
    keywordTypes: keywords$1,
    TokContext: TokContext,
    tokContexts: types$1,
    isIdentifierChar: isIdentifierChar,
    isIdentifierStart: isIdentifierStart,
    Token: Token,
    isNewLine: isNewLine,
    lineBreak: lineBreak,
    lineBreakG: lineBreakG,
    nonASCIIwhitespace: nonASCIIwhitespace
  };


  function parse(input, options) {
    return Parser.parse(input, options)
  }


  function parseExpressionAt(input, pos, options) {
    return Parser.parseExpressionAt(input, pos, options)
  }


  function tokenizer(input, options) {
    return Parser.tokenizer(input, options)
  }

  exports.Node = Node;
  exports.Parser = Parser;
  exports.Position = Position;
  exports.SourceLocation = SourceLocation;
  exports.TokContext = TokContext;
  exports.Token = Token;
  exports.TokenType = TokenType;
  exports.defaultOptions = defaultOptions;
  exports.getLineInfo = getLineInfo;
  exports.isIdentifierChar = isIdentifierChar;
  exports.isIdentifierStart = isIdentifierStart;
  exports.isNewLine = isNewLine;
  exports.keywordTypes = keywords$1;
  exports.lineBreak = lineBreak;
  exports.lineBreakG = lineBreakG;
  exports.nonASCIIwhitespace = nonASCIIwhitespace;
  exports.parse = parse;
  exports.parseExpressionAt = parseExpressionAt;
  exports.tokContexts = types$1;
  exports.tokTypes = types;
  exports.tokenizer = tokenizer;
  exports.version = version;

  Object.defineProperty(exports, '__esModule', { value: true });

}));

},{}],2:[function(require,module,exports){

},{}],3:[function(require,module,exports){
function glWiretap(gl, options = {}) {
  const {
    contextName = 'gl',
    throwGetError,
    useTrackablePrimitives,
    readPixelsFile,
    recording = [],
    variables = {},
    onReadPixels,
    onUnrecognizedArgumentLookup,
  } = options;
  const proxy = new Proxy(gl, { get: listen });
  const contextVariables = [];
  const entityNames = {};
  let imageCount = 0;
  let indent = '';
  let readPixelsVariableName;
  return proxy;
  function listen(obj, property) {
    switch (property) {
      case 'addComment': return addComment;
      case 'checkThrowError': return checkThrowError;
      case 'getReadPixelsVariableName': return readPixelsVariableName;
      case 'insertVariable': return insertVariable;
      case 'reset': return reset;
      case 'setIndent': return setIndent;
      case 'toString': return toString;
      case 'getContextVariableName': return getContextVariableName;
    }
    if (typeof gl[property] === 'function') {
      return function() { 
        switch (property) {
          case 'getError':
            if (throwGetError) {
              recording.push(`${indent}if (${contextName}.getError() !== ${contextName}.NONE) throw new Error('error');`);
            } else {
              recording.push(`${indent}${contextName}.getError();`); 
            }
            return gl.getError();
          case 'getExtension': {
            const variableName = `${contextName}Variables${contextVariables.length}`;
            recording.push(`${indent}const ${variableName} = ${contextName}.getExtension('${arguments[0]}');`);
            const extension = gl.getExtension(arguments[0]);
            if (extension && typeof extension === 'object') {
              const tappedExtension = glExtensionWiretap(extension, {
                getEntity,
                useTrackablePrimitives,
                recording,
                contextName: variableName,
                contextVariables,
                variables,
                indent,
                onUnrecognizedArgumentLookup,
              });
              contextVariables.push(tappedExtension);
              return tappedExtension;
            } else {
              contextVariables.push(null);
            }
            return extension;
          }
          case 'readPixels':
            const i = contextVariables.indexOf(arguments[6]);
            let targetVariableName;
            if (i === -1) {
              const variableName = getVariableName(arguments[6]);
              if (variableName) {
                targetVariableName = variableName;
                recording.push(`${indent}${variableName}`);
              } else {
                targetVariableName = `${contextName}Variable${contextVariables.length}`;
                contextVariables.push(arguments[6]);
                recording.push(`${indent}const ${targetVariableName} = new ${arguments[6].constructor.name}(${arguments[6].length});`);
              }
            } else {
              targetVariableName = `${contextName}Variable${i}`;
            }
            readPixelsVariableName = targetVariableName;
            const argumentAsStrings = [
              arguments[0],
              arguments[1],
              arguments[2],
              arguments[3],
              getEntity(arguments[4]),
              getEntity(arguments[5]),
              targetVariableName
            ];
            recording.push(`${indent}${contextName}.readPixels(${argumentAsStrings.join(', ')});`);
            if (readPixelsFile) {
              writePPM(arguments[2], arguments[3]);
            }
            if (onReadPixels) {
              onReadPixels(targetVariableName, argumentAsStrings);
            }
            return gl.readPixels.apply(gl, arguments);
          case 'drawBuffers':
            recording.push(`${indent}${contextName}.drawBuffers([${argumentsToString(arguments[0], { contextName, contextVariables, getEntity, addVariable, variables, onUnrecognizedArgumentLookup } )}]);`);
            return gl.drawBuffers(arguments[0]);
        }
        let result = gl[property].apply(gl, arguments);
        switch (typeof result) {
          case 'undefined':
            recording.push(`${indent}${methodCallToString(property, arguments)};`);
            return;
          case 'number':
          case 'boolean':
            if (useTrackablePrimitives && contextVariables.indexOf(trackablePrimitive(result)) === -1) {
              recording.push(`${indent}const ${contextName}Variable${contextVariables.length} = ${methodCallToString(property, arguments)};`);
              contextVariables.push(result = trackablePrimitive(result));
              break;
            }
          default:
            if (result === null) {
              recording.push(`${methodCallToString(property, arguments)};`);
            } else {
              recording.push(`${indent}const ${contextName}Variable${contextVariables.length} = ${methodCallToString(property, arguments)};`);
            }

            contextVariables.push(result);
        }
        return result;
      }
    }
    entityNames[gl[property]] = property;
    return gl[property];
  }
  function toString() {
    return recording.join('\n');
  }
  function reset() {
    while (recording.length > 0) {
      recording.pop();
    }
  }
  function insertVariable(name, value) {
    variables[name] = value;
  }
  function getEntity(value) {
    const name = entityNames[value];
    if (name) {
      return contextName + '.' + name;
    }
    return value;
  }
  function setIndent(spaces) {
    indent = ' '.repeat(spaces);
  }
  function addVariable(value, source) {
    const variableName = `${contextName}Variable${contextVariables.length}`;
    recording.push(`${indent}const ${variableName} = ${source};`);
    contextVariables.push(value);
    return variableName;
  }
  function writePPM(width, height) {
    const sourceVariable = `${contextName}Variable${contextVariables.length}`;
    const imageVariable = `imageDatum${imageCount}`;
    recording.push(`${indent}let ${imageVariable} = ["P3\\n# ${readPixelsFile}.ppm\\n", ${width}, ' ', ${height}, "\\n255\\n"].join("");`);
    recording.push(`${indent}for (let i = 0; i < ${imageVariable}.length; i += 4) {`);
    recording.push(`${indent}  ${imageVariable} += ${sourceVariable}[i] + ' ' + ${sourceVariable}[i + 1] + ' ' + ${sourceVariable}[i + 2] + ' ';`);
    recording.push(`${indent}}`);
    recording.push(`${indent}if (typeof require !== "undefined") {`);
    recording.push(`${indent}  require('fs').writeFileSync('./${readPixelsFile}.ppm', ${imageVariable});`);
    recording.push(`${indent}}`);
    imageCount++;
  }
  function addComment(value) {
    recording.push(`${indent}// ${value}`);
  }
  function checkThrowError() {
    recording.push(`${indent}(() => {
${indent}const error = ${contextName}.getError();
${indent}if (error !== ${contextName}.NONE) {
${indent}  const names = Object.getOwnPropertyNames(gl);
${indent}  for (let i = 0; i < names.length; i++) {
${indent}    const name = names[i];
${indent}    if (${contextName}[name] === error) {
${indent}      throw new Error('${contextName} threw ' + name);
${indent}    }
${indent}  }
${indent}}
${indent}})();`);
  }
  function methodCallToString(method, args) {
    return `${contextName}.${method}(${argumentsToString(args, { contextName, contextVariables, getEntity, addVariable, variables, onUnrecognizedArgumentLookup })})`;
  }

  function getVariableName(value) {
    if (variables) {
      for (const name in variables) {
        if (variables[name] === value) {
          return name;
        }
      }
    }
    return null;
  }

  function getContextVariableName(value) {
    const i = contextVariables.indexOf(value);
    if (i !== -1) {
      return `${contextName}Variable${i}`;
    }
    return null;
  }
}

function glExtensionWiretap(extension, options) {
  const proxy = new Proxy(extension, { get: listen });
  const extensionEntityNames = {};
  const {
    contextName,
    contextVariables,
    getEntity,
    useTrackablePrimitives,
    recording,
    variables,
    indent,
    onUnrecognizedArgumentLookup,
  } = options;
  return proxy;
  function listen(obj, property) {
    if (typeof obj[property] === 'function') {
      return function() {
        switch (property) {
          case 'drawBuffersWEBGL':
            recording.push(`${indent}${contextName}.drawBuffersWEBGL([${argumentsToString(arguments[0], { contextName, contextVariables, getEntity: getExtensionEntity, addVariable, variables, onUnrecognizedArgumentLookup })}]);`);
            return extension.drawBuffersWEBGL(arguments[0]);
        }
        let result = extension[property].apply(extension, arguments);
        switch (typeof result) {
          case 'undefined':
            recording.push(`${indent}${methodCallToString(property, arguments)};`);
            return;
          case 'number':
          case 'boolean':
            if (useTrackablePrimitives && contextVariables.indexOf(trackablePrimitive(result)) === -1) {
              recording.push(`${indent}const ${contextName}Variable${contextVariables.length} = ${methodCallToString(property, arguments)};`);
              contextVariables.push(result = trackablePrimitive(result));
            } else {
              recording.push(`${indent}const ${contextName}Variable${contextVariables.length} = ${methodCallToString(property, arguments)};`);
              contextVariables.push(result);
            }
            break;
          default:
            if (result === null) {
              recording.push(`${methodCallToString(property, arguments)};`);
            } else {
              recording.push(`${indent}const ${contextName}Variable${contextVariables.length} = ${methodCallToString(property, arguments)};`);
            }
            contextVariables.push(result);
        }
        return result;
      };
    }
    extensionEntityNames[extension[property]] = property;
    return extension[property];
  }

  function getExtensionEntity(value) {
    if (extensionEntityNames.hasOwnProperty(value)) {
      return `${contextName}.${extensionEntityNames[value]}`;
    }
    return getEntity(value);
  }

  function methodCallToString(method, args) {
    return `${contextName}.${method}(${argumentsToString(args, { contextName, contextVariables, getEntity: getExtensionEntity, addVariable, variables, onUnrecognizedArgumentLookup })})`;
  }

  function addVariable(value, source) {
    const variableName = `${contextName}Variable${contextVariables.length}`;
    contextVariables.push(value);
    recording.push(`${indent}const ${variableName} = ${source};`);
    return variableName;
  }
}

function argumentsToString(args, options) {
  const { variables, onUnrecognizedArgumentLookup } = options;
  return (Array.from(args).map((arg) => {
    const variableName = getVariableName(arg);
    if (variableName) {
      return variableName;
    }
    return argumentToString(arg, options);
  }).join(', '));

  function getVariableName(value) {
    if (variables) {
      for (const name in variables) {
        if (!variables.hasOwnProperty(name)) continue;
        if (variables[name] === value) {
          return name;
        }
      }
    }
    if (onUnrecognizedArgumentLookup) {
      return onUnrecognizedArgumentLookup(value);
    }
    return null;
  }
}

function argumentToString(arg, options) {
  const { contextName, contextVariables, getEntity, addVariable, onUnrecognizedArgumentLookup } = options;
  if (typeof arg === 'undefined') {
    return 'undefined';
  }
  if (arg === null) {
    return 'null';
  }
  const i = contextVariables.indexOf(arg);
  if (i > -1) {
    return `${contextName}Variable${i}`;
  }
  switch (arg.constructor.name) {
    case 'String':
      const hasLines = /\n/.test(arg);
      const hasSingleQuotes = /'/.test(arg);
      const hasDoubleQuotes = /"/.test(arg);
      if (hasLines) {
        return '`' + arg + '`';
      } else if (hasSingleQuotes && !hasDoubleQuotes) {
        return '"' + arg + '"';
      } else if (!hasSingleQuotes && hasDoubleQuotes) {
        return "'" + arg + "'";
      } else {
        return '\'' + arg + '\'';
      }
    case 'Number': return getEntity(arg);
    case 'Boolean': return getEntity(arg);
    case 'Array':
      return addVariable(arg, `new ${arg.constructor.name}([${Array.from(arg).join(',')}])`);
    case 'Float32Array':
    case 'Uint8Array':
    case 'Uint16Array':
    case 'Int32Array':
      return addVariable(arg, `new ${arg.constructor.name}(${JSON.stringify(Array.from(arg))})`);
    default:
      if (onUnrecognizedArgumentLookup) {
        const instantiationString = onUnrecognizedArgumentLookup(arg);
        if (instantiationString) {
          return instantiationString;
        }
      }
      throw new Error(`unrecognized argument type ${arg.constructor.name}`);
  }
}

function trackablePrimitive(value) {
  return new value.constructor(value);
}

if (typeof module !== 'undefined') {
  module.exports = { glWiretap, glExtensionWiretap };
}

if (typeof window !== 'undefined') {
  glWiretap.glExtensionWiretap = glExtensionWiretap;
  window.glWiretap = glWiretap;
}

},{}],4:[function(require,module,exports){
function setupArguments(args) {
  const newArguments = new Array(args.length);
  for (let i = 0; i < args.length; i++) {
    const arg = args[i];
    if (arg.toArray) {
      newArguments[i] = arg.toArray();
    } else {
      newArguments[i] = arg;
    }
  }
  return newArguments;
}

function mock1D() {
  const args = setupArguments(arguments);
  const row = new Float32Array(this.output.x);
  for (let x = 0; x < this.output.x; x++) {
    this.thread.x = x;
    this.thread.y = 0;
    this.thread.z = 0;
    row[x] = this._fn.apply(this, args);
  }
  return row;
}

function mock2D() {
  const args = setupArguments(arguments);
  const matrix = new Array(this.output.y);
  for (let y = 0; y < this.output.y; y++) {
    const row = new Float32Array(this.output.x);
    for (let x = 0; x < this.output.x; x++) {
      this.thread.x = x;
      this.thread.y = y;
      this.thread.z = 0;
      row[x] = this._fn.apply(this, args);
    }
    matrix[y] = row;
  }
  return matrix;
}

function mock2DGraphical() {
  const args = setupArguments(arguments);
  for (let y = 0; y < this.output.y; y++) {
    for (let x = 0; x < this.output.x; x++) {
      this.thread.x = x;
      this.thread.y = y;
      this.thread.z = 0;
      this._fn.apply(this, args);
    }
  }
}

function mock3D() {
  const args = setupArguments(arguments);
  const cube = new Array(this.output.z);
  for (let z = 0; z < this.output.z; z++) {
    const matrix = new Array(this.output.y);
    for (let y = 0; y < this.output.y; y++) {
      const row = new Float32Array(this.output.x);
      for (let x = 0; x < this.output.x; x++) {
        this.thread.x = x;
        this.thread.y = y;
        this.thread.z = z;
        row[x] = this._fn.apply(this, args);
      }
      matrix[y] = row;
    }
    cube[z] = matrix;
  }
  return cube;
}

function apiDecorate(kernel) {
  kernel.setOutput = (output) => {
    kernel.output = setupOutput(output);
    if (kernel.graphical) {
      setupGraphical(kernel);
    }
  };
  kernel.toJSON = () => {
    throw new Error('Not usable with gpuMock');
  };
  kernel.setConstants = (flag) => {
    kernel.constants = flag;
    return kernel;
  };
  kernel.setGraphical = (flag) => {
    kernel.graphical = flag;
    return kernel;
  };
  kernel.setCanvas = (flag) => {
    kernel.canvas = flag;
    return kernel;
  };
  kernel.setContext = (flag) => {
    kernel.context = flag;
    return kernel;
  };
  kernel.destroy = () => {};
  kernel.validateSettings = () => {};
  if (kernel.graphical && kernel.output) {
    setupGraphical(kernel);
  }
  kernel.exec = function() {
    return new Promise((resolve, reject) => {
      try {
        resolve(kernel.apply(kernel, arguments));
      } catch(e) {
        reject(e);
      }
    });
  };
  kernel.getPixels = (flip) => {
    const {x, y} = kernel.output;
    return flip ? flipPixels(kernel._imageData.data, x, y) : kernel._imageData.data.slice(0);
  };
  kernel.color = function(r, g, b, a) {
    if (typeof a === 'undefined') {
      a = 1;
    }

    r = Math.floor(r * 255);
    g = Math.floor(g * 255);
    b = Math.floor(b * 255);
    a = Math.floor(a * 255);

    const width = kernel.output.x;
    const height = kernel.output.y;

    const x = kernel.thread.x;
    const y = height - kernel.thread.y - 1;

    const index = x + y * width;

    kernel._colorData[index * 4 + 0] = r;
    kernel._colorData[index * 4 + 1] = g;
    kernel._colorData[index * 4 + 2] = b;
    kernel._colorData[index * 4 + 3] = a;
  };

  const mockMethod = () => kernel;
  const methods = [
    'setWarnVarUsage',
    'setArgumentTypes',
    'setTactic',
    'setOptimizeFloatMemory',
    'setDebug',
    'setLoopMaxIterations',
    'setConstantTypes',
    'setFunctions',
    'setNativeFunctions',
    'setInjectedNative',
    'setPipeline',
    'setPrecision',
    'setOutputToTexture',
    'setImmutable',
    'setStrictIntegers',
    'setDynamicOutput',
    'setHardcodeConstants',
    'setDynamicArguments',
    'setUseLegacyEncoder',
    'setWarnVarUsage',
    'addSubKernel',
  ];
  for (let i = 0; i < methods.length; i++) {
    kernel[methods[i]] = mockMethod;
  }
  return kernel;
}

function setupGraphical(kernel) {
  const {x, y} = kernel.output;
  if (kernel.context && kernel.context.createImageData) {
    const data = new Uint8ClampedArray(x * y * 4);
    kernel._imageData = kernel.context.createImageData(x, y);
    kernel._colorData = data;
  } else {
    const data = new Uint8ClampedArray(x * y * 4);
    kernel._imageData = { data };
    kernel._colorData = data;
  }
}

function setupOutput(output) {
  let result = null;
  if (output.length) {
    if (output.length === 3) {
      const [x,y,z] = output;
      result = { x, y, z };
    } else if (output.length === 2) {
      const [x,y] = output;
      result = { x, y };
    } else {
      const [x] = output;
      result = { x };
    }
  } else {
    result = output;
  }
  return result;
}

function gpuMock(fn, settings = {}) {
  const output = settings.output ? setupOutput(settings.output) : null;
  function kernel() {
    if (kernel.output.z) {
      return mock3D.apply(kernel, arguments);
    } else if (kernel.output.y) {
      if (kernel.graphical) {
        return mock2DGraphical.apply(kernel, arguments);
      }
      return mock2D.apply(kernel, arguments);
    } else {
      return mock1D.apply(kernel, arguments);
    }
  }
  kernel._fn = fn;
  kernel.constants = settings.constants || null;
  kernel.context = settings.context || null;
  kernel.canvas = settings.canvas || null;
  kernel.graphical = settings.graphical || false;
  kernel._imageData = null;
  kernel._colorData = null;
  kernel.output = output;
  kernel.thread = {
    x: 0,
    y: 0,
    z: 0
  };
  return apiDecorate(kernel);
}

function flipPixels(pixels, width, height) {
  const halfHeight = height / 2 | 0; 
  const bytesPerRow = width * 4;
  const temp = new Uint8ClampedArray(width * 4);
  const result = pixels.slice(0);
  for (let y = 0; y < halfHeight; ++y) {
    const topOffset = y * bytesPerRow;
    const bottomOffset = (height - y - 1) * bytesPerRow;

    temp.set(result.subarray(topOffset, topOffset + bytesPerRow));

    result.copyWithin(topOffset, bottomOffset, bottomOffset + bytesPerRow);

    result.set(temp, bottomOffset);
  }
  return result;
}

module.exports = {
  gpuMock
};

},{}],5:[function(require,module,exports){
const { utils } = require('./utils');

function alias(name, source) {
  const fnString = source.toString();
  return new Function(`return function ${ name } (${ utils.getArgumentNamesFromString(fnString).join(', ') }) {
  ${ utils.getFunctionBodyFromString(fnString) }
}`)();
}

module.exports = {
  alias
};
},{"./utils":114}],6:[function(require,module,exports){
const { FunctionNode } = require('../function-node');

class CPUFunctionNode extends FunctionNode {
  astFunction(ast, retArr) {

    if (!this.isRootKernel) {
      retArr.push('function');
      retArr.push(' ');
      retArr.push(this.name);
      retArr.push('(');

      for (let i = 0; i < this.argumentNames.length; ++i) {
        const argumentName = this.argumentNames[i];

        if (i > 0) {
          retArr.push(', ');
        }
        retArr.push('user_');
        retArr.push(argumentName);
      }

      retArr.push(') {\n');
    }

    for (let i = 0; i < ast.body.body.length; ++i) {
      this.astGeneric(ast.body.body[i], retArr);
      retArr.push('\n');
    }

    if (!this.isRootKernel) {
      retArr.push('}\n');
    }
    return retArr;
  }

  astReturnStatement(ast, retArr) {
    const type = this.returnType || this.getType(ast.argument);

    if (!this.returnType) {
      this.returnType = type;
    }

    if (this.isRootKernel) {
      retArr.push(this.leadingReturnStatement);
      this.astGeneric(ast.argument, retArr);
      retArr.push(';\n');
      retArr.push(this.followingReturnStatement);
      retArr.push('continue;\n');
    } else if (this.isSubKernel) {
      retArr.push(`subKernelResult_${ this.name } = `);
      this.astGeneric(ast.argument, retArr);
      retArr.push(';');
      retArr.push(`return subKernelResult_${ this.name };`);
    } else {
      retArr.push('return ');
      this.astGeneric(ast.argument, retArr);
      retArr.push(';');
    }
    return retArr;
  }

  astLiteral(ast, retArr) {

    if (isNaN(ast.value)) {
      throw this.astErrorOutput(
        'Non-numeric literal not supported : ' + ast.value,
        ast
      );
    }

    retArr.push(ast.value);

    return retArr;
  }

  astBinaryExpression(ast, retArr) {
    retArr.push('(');
    this.astGeneric(ast.left, retArr);
    retArr.push(ast.operator);
    this.astGeneric(ast.right, retArr);
    retArr.push(')');
    return retArr;
  }

  astIdentifierExpression(idtNode, retArr) {
    if (idtNode.type !== 'Identifier') {
      throw this.astErrorOutput(
        'IdentifierExpression - not an Identifier',
        idtNode
      );
    }

    switch (idtNode.name) {
      case 'Infinity':
        retArr.push('Infinity');
        break;
      default:
        if (this.constants && this.constants.hasOwnProperty(idtNode.name)) {
          retArr.push('constants_' + idtNode.name);
        } else {
          retArr.push('user_' + idtNode.name);
        }
    }

    return retArr;
  }

  astForStatement(forNode, retArr) {
    if (forNode.type !== 'ForStatement') {
      throw this.astErrorOutput('Invalid for statement', forNode);
    }

    const initArr = [];
    const testArr = [];
    const updateArr = [];
    const bodyArr = [];
    let isSafe = null;

    if (forNode.init) {
      this.pushState('in-for-loop-init');
      this.astGeneric(forNode.init, initArr);
      for (let i = 0; i < initArr.length; i++) {
        if (initArr[i].includes && initArr[i].includes(',')) {
          isSafe = false;
        }
      }
      this.popState('in-for-loop-init');
    } else {
      isSafe = false;
    }

    if (forNode.test) {
      this.astGeneric(forNode.test, testArr);
    } else {
      isSafe = false;
    }

    if (forNode.update) {
      this.astGeneric(forNode.update, updateArr);
    } else {
      isSafe = false;
    }

    if (forNode.body) {
      this.pushState('loop-body');
      this.astGeneric(forNode.body, bodyArr);
      this.popState('loop-body');
    }

    if (isSafe === null) {
      isSafe = this.isSafe(forNode.init) && this.isSafe(forNode.test);
    }

    if (isSafe) {
      retArr.push(`for (${initArr.join('')};${testArr.join('')};${updateArr.join('')}){\n`);
      retArr.push(bodyArr.join(''));
      retArr.push('}\n');
    } else {
      const iVariableName = this.getInternalVariableName('safeI');
      if (initArr.length > 0) {
        retArr.push(initArr.join(''), ';\n');
      }
      retArr.push(`for (let ${iVariableName}=0;${iVariableName}<LOOP_MAX;${iVariableName}++){\n`);
      if (testArr.length > 0) {
        retArr.push(`if (!${testArr.join('')}) break;\n`);
      }
      retArr.push(bodyArr.join(''));
      retArr.push(`\n${updateArr.join('')};`);
      retArr.push('}\n');
    }
    return retArr;
  }

  astWhileStatement(whileNode, retArr) {
    if (whileNode.type !== 'WhileStatement') {
      throw this.astErrorOutput(
        'Invalid while statement',
        whileNode
      );
    }

    retArr.push('for (let i = 0; i < LOOP_MAX; i++) {');
    retArr.push('if (');
    this.astGeneric(whileNode.test, retArr);
    retArr.push(') {\n');
    this.astGeneric(whileNode.body, retArr);
    retArr.push('} else {\n');
    retArr.push('break;\n');
    retArr.push('}\n');
    retArr.push('}\n');

    return retArr;
  }

  astDoWhileStatement(doWhileNode, retArr) {
    if (doWhileNode.type !== 'DoWhileStatement') {
      throw this.astErrorOutput(
        'Invalid while statement',
        doWhileNode
      );
    }

    retArr.push('for (let i = 0; i < LOOP_MAX; i++) {');
    this.astGeneric(doWhileNode.body, retArr);
    retArr.push('if (!');
    this.astGeneric(doWhileNode.test, retArr);
    retArr.push(') {\n');
    retArr.push('break;\n');
    retArr.push('}\n');
    retArr.push('}\n');

    return retArr;

  }

  astAssignmentExpression(assNode, retArr) {
    const declaration = this.getDeclaration(assNode.left);
    if (declaration && !declaration.assignable) {
      throw this.astErrorOutput(`Variable ${assNode.left.name} is not assignable here`, assNode);
    }
    this.astGeneric(assNode.left, retArr);
    retArr.push(assNode.operator);
    this.astGeneric(assNode.right, retArr);
    return retArr;
  }

  astBlockStatement(bNode, retArr) {
    if (this.isState('loop-body')) {
      this.pushState('block-body'); 
      for (let i = 0; i < bNode.body.length; i++) {
        this.astGeneric(bNode.body[i], retArr);
      }
      this.popState('block-body');
    } else {
      retArr.push('{\n');
      for (let i = 0; i < bNode.body.length; i++) {
        this.astGeneric(bNode.body[i], retArr);
      }
      retArr.push('}\n');
    }
    return retArr;
  }

  astVariableDeclaration(varDecNode, retArr) {
    retArr.push(`${varDecNode.kind} `);
    const { declarations } = varDecNode;
    for (let i = 0; i < declarations.length; i++) {
      if (i > 0) {
        retArr.push(',');
      }
      const declaration = declarations[i];
      const info = this.getDeclaration(declaration.id);
      if (!info.valueType) {
        info.valueType = this.getType(declaration.init);
      }
      this.astGeneric(declaration, retArr);
    }
    if (!this.isState('in-for-loop-init')) {
      retArr.push(';');
    }
    return retArr;
  }

  astIfStatement(ifNode, retArr) {
    retArr.push('if (');
    this.astGeneric(ifNode.test, retArr);
    retArr.push(')');
    if (ifNode.consequent.type === 'BlockStatement') {
      this.astGeneric(ifNode.consequent, retArr);
    } else {
      retArr.push(' {\n');
      this.astGeneric(ifNode.consequent, retArr);
      retArr.push('\n}\n');
    }

    if (ifNode.alternate) {
      retArr.push('else ');
      if (ifNode.alternate.type === 'BlockStatement' || ifNode.alternate.type === 'IfStatement') {
        this.astGeneric(ifNode.alternate, retArr);
      } else {
        retArr.push(' {\n');
        this.astGeneric(ifNode.alternate, retArr);
        retArr.push('\n}\n');
      }
    }
    return retArr;

  }

  astSwitchStatement(ast, retArr) {
    const { discriminant, cases } = ast;
    retArr.push('switch (');
    this.astGeneric(discriminant, retArr);
    retArr.push(') {\n');
    for (let i = 0; i < cases.length; i++) {
      if (cases[i].test === null) {
        retArr.push('default:\n');
        this.astGeneric(cases[i].consequent, retArr);
        if (cases[i].consequent && cases[i].consequent.length > 0) {
          retArr.push('break;\n');
        }
        continue;
      }
      retArr.push('case ');
      this.astGeneric(cases[i].test, retArr);
      retArr.push(':\n');
      if (cases[i].consequent && cases[i].consequent.length > 0) {
        this.astGeneric(cases[i].consequent, retArr);
        retArr.push('break;\n');
      }
    }
    retArr.push('\n}');
  }

  astThisExpression(tNode, retArr) {
    retArr.push('_this');
    return retArr;
  }

  astMemberExpression(mNode, retArr) {
    const {
      signature,
      type,
      property,
      xProperty,
      yProperty,
      zProperty,
      name,
      origin
    } = this.getMemberExpressionDetails(mNode);
    switch (signature) {
      case 'this.thread.value':
        retArr.push(`_this.thread.${ name }`);
        return retArr;
      case 'this.output.value':
        switch (name) {
          case 'x':
            retArr.push('outputX');
            break;
          case 'y':
            retArr.push('outputY');
            break;
          case 'z':
            retArr.push('outputZ');
            break;
          default:
            throw this.astErrorOutput('Unexpected expression', mNode);
        }
        return retArr;
      case 'value':
        throw this.astErrorOutput('Unexpected expression', mNode);
      case 'value[]':
      case 'value[][]':
      case 'value[][][]':
      case 'value.value':
        if (origin === 'Math') {
          retArr.push(Math[name]);
          return retArr;
        }
        switch (property) {
          case 'r':
            retArr.push(`user_${ name }[0]`);
            return retArr;
          case 'g':
            retArr.push(`user_${ name }[1]`);
            return retArr;
          case 'b':
            retArr.push(`user_${ name }[2]`);
            return retArr;
          case 'a':
            retArr.push(`user_${ name }[3]`);
            return retArr;
        }
        break;
      case 'this.constants.value':
      case 'this.constants.value[]':
      case 'this.constants.value[][]':
      case 'this.constants.value[][][]':
        break;
      case 'fn()[]':
        this.astGeneric(mNode.object, retArr);
        retArr.push('[');
        this.astGeneric(mNode.property, retArr);
        retArr.push(']');
        return retArr;
      case 'fn()[][]':
        this.astGeneric(mNode.object.object, retArr);
        retArr.push('[');
        this.astGeneric(mNode.object.property, retArr);
        retArr.push(']');
        retArr.push('[');
        this.astGeneric(mNode.property, retArr);
        retArr.push(']');
        return retArr;
      default:
        throw this.astErrorOutput('Unexpected expression', mNode);
    }

    if (!mNode.computed) {
      switch (type) {
        case 'Number':
        case 'Integer':
        case 'Float':
        case 'Boolean':
          retArr.push(`${origin}_${name}`);
          return retArr;
      }
    }

    const markupName = `${origin}_${name}`;

    switch (type) {
      case 'Array(2)':
      case 'Array(3)':
      case 'Array(4)':
      case 'Matrix(2)':
      case 'Matrix(3)':
      case 'Matrix(4)':
      case 'HTMLImageArray':
      case 'ArrayTexture(1)':
      case 'ArrayTexture(2)':
      case 'ArrayTexture(3)':
      case 'ArrayTexture(4)':
      case 'HTMLImage':
      default:
        let size;
        let isInput;
        if (origin === 'constants') {
          const constant = this.constants[name];
          isInput = this.constantTypes[name] === 'Input';
          size = isInput ? constant.size : null;
        } else {
          isInput = this.isInput(name);
          size = isInput ? this.argumentSizes[this.argumentNames.indexOf(name)] : null;
        }
        retArr.push(`${ markupName }`);
        if (zProperty && yProperty) {
          if (isInput) {
            retArr.push('[(');
            this.astGeneric(zProperty, retArr);
            retArr.push(`*${ this.dynamicArguments ? '(outputY * outputX)' : size[1] * size[0] })+(`);
            this.astGeneric(yProperty, retArr);
            retArr.push(`*${ this.dynamicArguments ? 'outputX' : size[0] })+`);
            this.astGeneric(xProperty, retArr);
            retArr.push(']');
          } else {
            retArr.push('[');
            this.astGeneric(zProperty, retArr);
            retArr.push(']');
            retArr.push('[');
            this.astGeneric(yProperty, retArr);
            retArr.push(']');
            retArr.push('[');
            this.astGeneric(xProperty, retArr);
            retArr.push(']');
          }
        } else if (yProperty) {
          if (isInput) {
            retArr.push('[(');
            this.astGeneric(yProperty, retArr);
            retArr.push(`*${ this.dynamicArguments ? 'outputX' : size[0] })+`);
            this.astGeneric(xProperty, retArr);
            retArr.push(']');
          } else {
            retArr.push('[');
            this.astGeneric(yProperty, retArr);
            retArr.push(']');
            retArr.push('[');
            this.astGeneric(xProperty, retArr);
            retArr.push(']');
          }
        } else if (typeof xProperty !== 'undefined') {
          retArr.push('[');
          this.astGeneric(xProperty, retArr);
          retArr.push(']');
        }
    }
    return retArr;
  }

  astCallExpression(ast, retArr) {
    if (ast.type !== 'CallExpression') {
      throw this.astErrorOutput('Unknown CallExpression', ast);
    }
    let functionName = this.astMemberExpressionUnroll(ast.callee);

    if (this.calledFunctions.indexOf(functionName) < 0) {
      this.calledFunctions.push(functionName);
    }

    const isMathFunction = this.isAstMathFunction(ast);

    if (this.onFunctionCall) {
      this.onFunctionCall(this.name, functionName, ast.arguments);
    }

    retArr.push(functionName);

    retArr.push('(');
    const targetTypes = this.lookupFunctionArgumentTypes(functionName) || [];
    for (let i = 0; i < ast.arguments.length; ++i) {
      const argument = ast.arguments[i];

      let argumentType = this.getType(argument);
      if (!targetTypes[i]) {
        this.triggerImplyArgumentType(functionName, i, argumentType, this);
      }

      if (i > 0) {
        retArr.push(', ');
      }
      this.astGeneric(argument, retArr);
    }
    retArr.push(')');

    return retArr;
  }

  astArrayExpression(arrNode, retArr) {
    const returnType = this.getType(arrNode);
    const arrLen = arrNode.elements.length;
    const elements = [];
    for (let i = 0; i < arrLen; ++i) {
      const element = [];
      this.astGeneric(arrNode.elements[i], element);
      elements.push(element.join(''));
    }
    switch (returnType) {
      case 'Matrix(2)':
      case 'Matrix(3)':
      case 'Matrix(4)':
        retArr.push(`[${elements.join(', ')}]`);
        break;
      default:
        retArr.push(`new Float32Array([${elements.join(', ')}])`);
    }
    return retArr;
  }

  astDebuggerStatement(arrNode, retArr) {
    retArr.push('debugger;');
    return retArr;
  }
}

module.exports = {
  CPUFunctionNode
};
},{"../function-node":10}],7:[function(require,module,exports){
const { utils } = require('../../utils');

function constantsToString(constants, types) {
  const results = [];
  for (const name in types) {
    if (!types.hasOwnProperty(name)) continue;
    const type = types[name];
    const constant = constants[name];
    switch (type) {
      case 'Number':
      case 'Integer':
      case 'Float':
      case 'Boolean':
        results.push(`${name}:${constant}`);
        break;
      case 'Array(2)':
      case 'Array(3)':
      case 'Array(4)':
      case 'Matrix(2)':
      case 'Matrix(3)':
      case 'Matrix(4)':
        results.push(`${name}:new ${constant.constructor.name}(${JSON.stringify(Array.from(constant))})`);
        break;
    }
  }
  return `{ ${ results.join() } }`;
}

function cpuKernelString(cpuKernel, name) {
  const header = [];
  const thisProperties = [];
  const beforeReturn = [];

  const useFunctionKeyword = !/^function/.test(cpuKernel.color.toString());

  header.push(
    '  const { context, canvas, constants: incomingConstants } = settings;',
    `  const output = new Int32Array(${JSON.stringify(Array.from(cpuKernel.output))});`,
    `  const _constantTypes = ${JSON.stringify(cpuKernel.constantTypes)};`,
    `  const _constants = ${constantsToString(cpuKernel.constants, cpuKernel.constantTypes)};`
  );

  thisProperties.push(
    '    constants: _constants,',
    '    context,',
    '    output,',
    '    thread: {x: 0, y: 0, z: 0},'
  );

  if (cpuKernel.graphical) {
    header.push(`  const _imageData = context.createImageData(${cpuKernel.output[0]}, ${cpuKernel.output[1]});`);
    header.push(`  const _colorData = new Uint8ClampedArray(${cpuKernel.output[0]} * ${cpuKernel.output[1]} * 4);`);

    const colorFn = utils.flattenFunctionToString((useFunctionKeyword ? 'function ' : '') + cpuKernel.color.toString(), {
      thisLookup: (propertyName) => {
        switch (propertyName) {
          case '_colorData':
            return '_colorData';
          case '_imageData':
            return '_imageData';
          case 'output':
            return 'output';
          case 'thread':
            return 'this.thread';
        }
        return JSON.stringify(cpuKernel[propertyName]);
      },
      findDependency: (object, name) => {
        return null;
      }
    });

    const getPixelsFn = utils.flattenFunctionToString((useFunctionKeyword ? 'function ' : '') + cpuKernel.getPixels.toString(), {
      thisLookup: (propertyName) => {
        switch (propertyName) {
          case '_colorData':
            return '_colorData';
          case '_imageData':
            return '_imageData';
          case 'output':
            return 'output';
          case 'thread':
            return 'this.thread';
        }
        return JSON.stringify(cpuKernel[propertyName]);
      },
      findDependency: () => {
        return null;
      }
    });

    thisProperties.push(
      '    _imageData,',
      '    _colorData,',
      `    color: ${colorFn},`
    );

    beforeReturn.push(
      `  kernel.getPixels = ${getPixelsFn};`
    );
  }

  const constantTypes = [];
  const constantKeys = Object.keys(cpuKernel.constantTypes);
  for (let i = 0; i < constantKeys.length; i++) {
    constantTypes.push(cpuKernel.constantTypes[constantKeys]);
  }
  if (cpuKernel.argumentTypes.indexOf('HTMLImageArray') !== -1 || constantTypes.indexOf('HTMLImageArray') !== -1) {
    const flattenedImageTo3DArray = utils.flattenFunctionToString((useFunctionKeyword ? 'function ' : '') + cpuKernel._imageTo3DArray.toString(), {
      doNotDefine: ['canvas'],
      findDependency: (object, name) => {
        if (object === 'this') {
          return (useFunctionKeyword ? 'function ' : '') + cpuKernel[name].toString();
        }
        return null;
      },
      thisLookup: (propertyName) => {
        switch (propertyName) {
          case 'canvas':
            return;
          case 'context':
            return 'context';
        }
      }
    });
    beforeReturn.push(flattenedImageTo3DArray);
    thisProperties.push(`    _mediaTo2DArray,`);
    thisProperties.push(`    _imageTo3DArray,`);
  } else if (cpuKernel.argumentTypes.indexOf('HTMLImage') !== -1 || constantTypes.indexOf('HTMLImage') !== -1) {
    const flattenedImageTo2DArray = utils.flattenFunctionToString((useFunctionKeyword ? 'function ' : '') + cpuKernel._mediaTo2DArray.toString(), {
      findDependency: (object, name) => {
        return null;
      },
      thisLookup: (propertyName) => {
        switch (propertyName) {
          case 'canvas':
            return 'settings.canvas';
          case 'context':
            return 'settings.context';
        }
        throw new Error('unhandled thisLookup');
      }
    });
    beforeReturn.push(flattenedImageTo2DArray);
    thisProperties.push(`    _mediaTo2DArray,`);
  }

  return `function(settings) {
${ header.join('\n') }
  for (const p in _constantTypes) {
    if (!_constantTypes.hasOwnProperty(p)) continue;
    const type = _constantTypes[p];
    switch (type) {
      case 'Number':
      case 'Integer':
      case 'Float':
      case 'Boolean':
      case 'Array(2)':
      case 'Array(3)':
      case 'Array(4)':
      case 'Matrix(2)':
      case 'Matrix(3)':
      case 'Matrix(4)':
        if (incomingConstants.hasOwnProperty(p)) {
          console.warn('constant ' + p + ' of type ' + type + ' cannot be resigned');
        }
        continue;
    }
    if (!incomingConstants.hasOwnProperty(p)) {
      throw new Error('constant ' + p + ' not found');
    }
    _constants[p] = incomingConstants[p];
  }
  const kernel = (function() {
${cpuKernel._kernelString}
  })
    .apply({ ${thisProperties.join('\n')} });
  ${ beforeReturn.join('\n') }
  return kernel;
}`;
}

module.exports = {
  cpuKernelString
};
},{"../../utils":114}],8:[function(require,module,exports){
const { Kernel } = require('../kernel');
const { FunctionBuilder } = require('../function-builder');
const { CPUFunctionNode } = require('./function-node');
const { utils } = require('../../utils');
const { cpuKernelString } = require('./kernel-string');

class CPUKernel extends Kernel {
  static getFeatures() {
    return this.features;
  }
  static get features() {
    return Object.freeze({
      kernelMap: true,
      isIntegerDivisionAccurate: true
    });
  }
  static get isSupported() {
    return true;
  }
  static isContextMatch(context) {
    return false;
  }
  static get mode() {
    return 'cpu';
  }

  static nativeFunctionArguments() {
    return null;
  }

  static nativeFunctionReturnType() {
    throw new Error(`Looking up native function return type not supported on ${this.name}`);
  }

  static combineKernels(combinedKernel) {
    return combinedKernel;
  }

  static getSignature(kernel, argumentTypes) {
    return 'cpu' + (argumentTypes.length > 0 ? ':' + argumentTypes.join(',') : '');
  }

  constructor(source, settings) {
    super(source, settings);
    this.mergeSettings(source.settings || settings);

    this._imageData = null;
    this._colorData = null;
    this._kernelString = null;
    this._prependedString = [];
    this.thread = {
      x: 0,
      y: 0,
      z: 0
    };
    this.translatedSources = null;
  }

  initCanvas() {
    if (typeof document !== 'undefined') {
      return document.createElement('canvas');
    } else if (typeof OffscreenCanvas !== 'undefined') {
      return new OffscreenCanvas(0, 0);
    }
  }

  initContext() {
    if (!this.canvas) return null;
    return this.canvas.getContext('2d');
  }

  initPlugins(settings) {
    return [];
  }

  validateSettings(args) {
    if (!this.output || this.output.length === 0) {
      if (args.length !== 1) {
        throw new Error('Auto output only supported for kernels with only one input');
      }

      const argType = utils.getVariableType(args[0], this.strictIntegers);
      if (argType === 'Array') {
        this.output = utils.getDimensions(argType);
      } else if (argType === 'NumberTexture' || argType === 'ArrayTexture(4)') {
        this.output = args[0].output;
      } else {
        throw new Error('Auto output not supported for input type: ' + argType);
      }
    }

    if (this.graphical) {
      if (this.output.length !== 2) {
        throw new Error('Output must have 2 dimensions on graphical mode');
      }
    }

    this.checkOutput();
  }

  translateSource() {
    this.leadingReturnStatement = this.output.length > 1 ? 'resultX[x] = ' : 'result[x] = ';
    if (this.subKernels) {
      const followingReturnStatement = [];
      for (let i = 0; i < this.subKernels.length; i++) {
        const {
          name
        } = this.subKernels[i];
        followingReturnStatement.push(this.output.length > 1 ? `resultX_${ name }[x] = subKernelResult_${ name };\n` : `result_${ name }[x] = subKernelResult_${ name };\n`);
      }
      this.followingReturnStatement = followingReturnStatement.join('');
    }
    const functionBuilder = FunctionBuilder.fromKernel(this, CPUFunctionNode);
    this.translatedSources = functionBuilder.getPrototypes('kernel');
    if (!this.graphical && !this.returnType) {
      this.returnType = functionBuilder.getKernelResultType();
    }
  }

  build() {
    if (this.built) return;
    this.setupConstants();
    this.setupArguments(arguments);
    this.validateSettings(arguments);
    this.translateSource();

    if (this.graphical) {
      const {
        canvas,
        output
      } = this;
      if (!canvas) {
        throw new Error('no canvas available for using graphical output');
      }
      const width = output[0];
      const height = output[1] || 1;
      canvas.width = width;
      canvas.height = height;
      this._imageData = this.context.createImageData(width, height);
      this._colorData = new Uint8ClampedArray(width * height * 4);
    }

    const kernelString = this.getKernelString();
    this.kernelString = kernelString;

    if (this.debug) {
      console.log('Function output:');
      console.log(kernelString);
    }

    try {
      this.run = new Function([], kernelString).bind(this)();
    } catch (e) {
      console.error('An error occurred compiling the javascript: ', e);
    }
    this.buildSignature(arguments);
    this.built = true;
  }

  color(r, g, b, a) {
    if (typeof a === 'undefined') {
      a = 1;
    }

    r = Math.floor(r * 255);
    g = Math.floor(g * 255);
    b = Math.floor(b * 255);
    a = Math.floor(a * 255);

    const width = this.output[0];
    const height = this.output[1];

    const x = this.thread.x;
    const y = height - this.thread.y - 1;

    const index = x + y * width;

    this._colorData[index * 4 + 0] = r;
    this._colorData[index * 4 + 1] = g;
    this._colorData[index * 4 + 2] = b;
    this._colorData[index * 4 + 3] = a;
  }

  getKernelString() {
    if (this._kernelString !== null) return this._kernelString;

    let kernelThreadString = null;
    let {
      translatedSources
    } = this;
    if (translatedSources.length > 1) {
      translatedSources = translatedSources.filter(fn => {
        if (/^function/.test(fn)) return fn;
        kernelThreadString = fn;
        return false;
      });
    } else {
      kernelThreadString = translatedSources.shift();
    }
    return this._kernelString = `  const LOOP_MAX = ${ this._getLoopMaxString() };
  ${ this.injectedNative || '' }
  const _this = this;
  ${ this._resultKernelHeader() }
  ${ this._processConstants() }
  return (${ this.argumentNames.map(argumentName => 'user_' + argumentName).join(', ') }) => {
    ${ this._prependedString.join('') }
    ${ this._earlyThrows() }
    ${ this._processArguments() }
    ${ this.graphical ? this._graphicalKernelBody(kernelThreadString) : this._resultKernelBody(kernelThreadString) }
    ${ translatedSources.length > 0 ? translatedSources.join('\n') : '' }
  };`;
  }

  toString() {
    return cpuKernelString(this);
  }

  _getLoopMaxString() {
    return (
      this.loopMaxIterations ?
      ` ${ parseInt(this.loopMaxIterations) };` :
      ' 1000;'
    );
  }

  _processConstants() {
    if (!this.constants) return '';

    const result = [];
    for (let p in this.constants) {
      const type = this.constantTypes[p];
      switch (type) {
        case 'HTMLCanvas':
        case 'HTMLImage':
        case 'HTMLVideo':
          result.push(`    const constants_${p} = this._mediaTo2DArray(this.constants.${p});\n`);
          break;
        case 'HTMLImageArray':
          result.push(`    const constants_${p} = this._imageTo3DArray(this.constants.${p});\n`);
          break;
        case 'Input':
          result.push(`    const constants_${p} = this.constants.${p}.value;\n`);
          break;
        default:
          result.push(`    const constants_${p} = this.constants.${p};\n`);
      }
    }
    return result.join('');
  }

  _earlyThrows() {
    if (this.graphical) return '';
    if (this.immutable) return '';
    if (!this.pipeline) return '';
    const arrayArguments = [];
    for (let i = 0; i < this.argumentTypes.length; i++) {
      if (this.argumentTypes[i] === 'Array') {
        arrayArguments.push(this.argumentNames[i]);
      }
    }
    if (arrayArguments.length === 0) return '';
    const checks = [];
    for (let i = 0; i < arrayArguments.length; i++) {
      const argumentName = arrayArguments[i];
      const checkSubKernels = this._mapSubKernels(subKernel => `user_${argumentName} === result_${subKernel.name}`).join(' || ');
      checks.push(`user_${argumentName} === result${checkSubKernels ? ` || ${checkSubKernels}` : ''}`);
    }
    return `if (${checks.join(' || ')}) throw new Error('Source and destination arrays are the same.  Use immutable = true');`;
  }

  _processArguments() {
    const result = [];
    for (let i = 0; i < this.argumentTypes.length; i++) {
      const variableName = `user_${this.argumentNames[i]}`;
      switch (this.argumentTypes[i]) {
        case 'HTMLCanvas':
        case 'HTMLImage':
        case 'HTMLVideo':
          result.push(`    ${variableName} = this._mediaTo2DArray(${variableName});\n`);
          break;
        case 'HTMLImageArray':
          result.push(`    ${variableName} = this._imageTo3DArray(${variableName});\n`);
          break;
        case 'Input':
          result.push(`    ${variableName} = ${variableName}.value;\n`);
          break;
        case 'ArrayTexture(1)':
        case 'ArrayTexture(2)':
        case 'ArrayTexture(3)':
        case 'ArrayTexture(4)':
        case 'NumberTexture':
        case 'MemoryOptimizedNumberTexture':
          result.push(`
    if (${variableName}.toArray) {
      if (!_this.textureCache) {
        _this.textureCache = [];
        _this.arrayCache = [];
      }
      const textureIndex = _this.textureCache.indexOf(${variableName});
      if (textureIndex !== -1) {
        ${variableName} = _this.arrayCache[textureIndex];
      } else {
        _this.textureCache.push(${variableName});
        ${variableName} = ${variableName}.toArray();
        _this.arrayCache.push(${variableName});
      }
    }`);
          break;
      }
    }
    return result.join('');
  }

  _mediaTo2DArray(media) {
    const canvas = this.canvas;
    const width = media.width > 0 ? media.width : media.videoWidth;
    const height = media.height > 0 ? media.height : media.videoHeight;
    if (canvas.width < width) {
      canvas.width = width;
    }
    if (canvas.height < height) {
      canvas.height = height;
    }
    const ctx = this.context;
    ctx.drawImage(media, 0, 0, width, height);
    const pixelsData = ctx.getImageData(0, 0, width, height).data;
    const imageArray = new Array(height);
    let index = 0;
    for (let y = height - 1; y >= 0; y--) {
      const row = imageArray[y] = new Array(width);
      for (let x = 0; x < width; x++) {
        const pixel = new Float32Array(4);
        pixel[0] = pixelsData[index++] / 255; 
        pixel[1] = pixelsData[index++] / 255; 
        pixel[2] = pixelsData[index++] / 255; 
        pixel[3] = pixelsData[index++] / 255; 
        row[x] = pixel;
      }
    }
    return imageArray;
  }

  getPixels(flip) {
    const [width, height] = this.output;
    return flip ? utils.flipPixels(this._imageData.data, width, height) : this._imageData.data.slice(0);
  }

  _imageTo3DArray(images) {
    const imagesArray = new Array(images.length);
    for (let i = 0; i < images.length; i++) {
      imagesArray[i] = this._mediaTo2DArray(images[i]);
    }
    return imagesArray;
  }

  _resultKernelHeader() {
    if (this.graphical) return '';
    if (this.immutable) return '';
    if (!this.pipeline) return '';
    switch (this.output.length) {
      case 1:
        return this._mutableKernel1DResults();
      case 2:
        return this._mutableKernel2DResults();
      case 3:
        return this._mutableKernel3DResults();
    }
  }

  _resultKernelBody(kernelString) {
    switch (this.output.length) {
      case 1:
        return (!this.immutable && this.pipeline ? this._resultMutableKernel1DLoop(kernelString) : this._resultImmutableKernel1DLoop(kernelString)) + this._kernelOutput();
      case 2:
        return (!this.immutable && this.pipeline ? this._resultMutableKernel2DLoop(kernelString) : this._resultImmutableKernel2DLoop(kernelString)) + this._kernelOutput();
      case 3:
        return (!this.immutable && this.pipeline ? this._resultMutableKernel3DLoop(kernelString) : this._resultImmutableKernel3DLoop(kernelString)) + this._kernelOutput();
      default:
        throw new Error('unsupported size kernel');
    }
  }

  _graphicalKernelBody(kernelThreadString) {
    switch (this.output.length) {
      case 2:
        return this._graphicalKernel2DLoop(kernelThreadString) + this._graphicalOutput();
      default:
        throw new Error('unsupported size kernel');
    }
  }

  _graphicalOutput() {
    return `
    this._imageData.data.set(this._colorData);
    this.context.putImageData(this._imageData, 0, 0);
    return;`
  }

  _getKernelResultTypeConstructorString() {
    switch (this.returnType) {
      case 'LiteralInteger':
      case 'Number':
      case 'Integer':
      case 'Float':
        return 'Float32Array';
      case 'Array(2)':
      case 'Array(3)':
      case 'Array(4)':
        return 'Array';
      default:
        if (this.graphical) {
          return 'Float32Array';
        }
        throw new Error(`unhandled returnType ${ this.returnType }`);
    }
  }

  _resultImmutableKernel1DLoop(kernelString) {
    const constructorString = this._getKernelResultTypeConstructorString();
    return `  const outputX = _this.output[0];
    const result = new ${constructorString}(outputX);
    ${ this._mapSubKernels(subKernel => `const result_${ subKernel.name } = new ${constructorString}(outputX);\n`).join('    ') }
    ${ this._mapSubKernels(subKernel => `let subKernelResult_${ subKernel.name };\n`).join('    ') }
    for (let x = 0; x < outputX; x++) {
      this.thread.x = x;
      this.thread.y = 0;
      this.thread.z = 0;
      ${ kernelString }
    }`;
  }

  _mutableKernel1DResults() {
    const constructorString = this._getKernelResultTypeConstructorString();
    return `  const outputX = _this.output[0];
    const result = new ${constructorString}(outputX);
    ${ this._mapSubKernels(subKernel => `const result_${ subKernel.name } = new ${constructorString}(outputX);\n`).join('    ') }
    ${ this._mapSubKernels(subKernel => `let subKernelResult_${ subKernel.name };\n`).join('    ') }`;
  }

  _resultMutableKernel1DLoop(kernelString) {
    return `  const outputX = _this.output[0];
    for (let x = 0; x < outputX; x++) {
      this.thread.x = x;
      this.thread.y = 0;
      this.thread.z = 0;
      ${ kernelString }
    }`;
  }

  _resultImmutableKernel2DLoop(kernelString) {
    const constructorString = this._getKernelResultTypeConstructorString();
    return `  const outputX = _this.output[0];
    const outputY = _this.output[1];
    const result = new Array(outputY);
    ${ this._mapSubKernels(subKernel => `const result_${ subKernel.name } = new Array(outputY);\n`).join('    ') }
    ${ this._mapSubKernels(subKernel => `let subKernelResult_${ subKernel.name };\n`).join('    ') }
    for (let y = 0; y < outputY; y++) {
      this.thread.z = 0;
      this.thread.y = y;
      const resultX = result[y] = new ${constructorString}(outputX);
      ${ this._mapSubKernels(subKernel => `const resultX_${ subKernel.name } = result_${subKernel.name}[y] = new ${constructorString}(outputX);\n`).join('') }
      for (let x = 0; x < outputX; x++) {
        this.thread.x = x;
        ${ kernelString }
      }
    }`;
  }

  _mutableKernel2DResults() {
    const constructorString = this._getKernelResultTypeConstructorString();
    return `  const outputX = _this.output[0];
    const outputY = _this.output[1];
    const result = new Array(outputY);
    ${ this._mapSubKernels(subKernel => `const result_${ subKernel.name } = new Array(outputY);\n`).join('    ') }
    ${ this._mapSubKernels(subKernel => `let subKernelResult_${ subKernel.name };\n`).join('    ') }
    for (let y = 0; y < outputY; y++) {
      const resultX = result[y] = new ${constructorString}(outputX);
      ${ this._mapSubKernels(subKernel => `const resultX_${ subKernel.name } = result_${subKernel.name}[y] = new ${constructorString}(outputX);\n`).join('') }
    }`;
  }

  _resultMutableKernel2DLoop(kernelString) {
    const constructorString = this._getKernelResultTypeConstructorString();
    return `  const outputX = _this.output[0];
    const outputY = _this.output[1];
    for (let y = 0; y < outputY; y++) {
      this.thread.z = 0;
      this.thread.y = y;
      const resultX = result[y];
      ${ this._mapSubKernels(subKernel => `const resultX_${ subKernel.name } = result_${subKernel.name}[y] = new ${constructorString}(outputX);\n`).join('') }
      for (let x = 0; x < outputX; x++) {
        this.thread.x = x;
        ${ kernelString }
      }
    }`;
  }

  _graphicalKernel2DLoop(kernelString) {
    return `  const outputX = _this.output[0];
    const outputY = _this.output[1];
    for (let y = 0; y < outputY; y++) {
      this.thread.z = 0;
      this.thread.y = y;
      for (let x = 0; x < outputX; x++) {
        this.thread.x = x;
        ${ kernelString }
      }
    }`;
  }

  _resultImmutableKernel3DLoop(kernelString) {
    const constructorString = this._getKernelResultTypeConstructorString();
    return `  const outputX = _this.output[0];
    const outputY = _this.output[1];
    const outputZ = _this.output[2];
    const result = new Array(outputZ);
    ${ this._mapSubKernels(subKernel => `const result_${ subKernel.name } = new Array(outputZ);\n`).join('    ') }
    ${ this._mapSubKernels(subKernel => `let subKernelResult_${ subKernel.name };\n`).join('    ') }
    for (let z = 0; z < outputZ; z++) {
      this.thread.z = z;
      const resultY = result[z] = new Array(outputY);
      ${ this._mapSubKernels(subKernel => `const resultY_${ subKernel.name } = result_${subKernel.name}[z] = new Array(outputY);\n`).join('      ') }
      for (let y = 0; y < outputY; y++) {
        this.thread.y = y;
        const resultX = resultY[y] = new ${constructorString}(outputX);
        ${ this._mapSubKernels(subKernel => `const resultX_${ subKernel.name } = resultY_${subKernel.name}[y] = new ${constructorString}(outputX);\n`).join('        ') }
        for (let x = 0; x < outputX; x++) {
          this.thread.x = x;
          ${ kernelString }
        }
      }
    }`;
  }

  _mutableKernel3DResults() {
    const constructorString = this._getKernelResultTypeConstructorString();
    return `  const outputX = _this.output[0];
    const outputY = _this.output[1];
    const outputZ = _this.output[2];
    const result = new Array(outputZ);
    ${ this._mapSubKernels(subKernel => `const result_${ subKernel.name } = new Array(outputZ);\n`).join('    ') }
    ${ this._mapSubKernels(subKernel => `let subKernelResult_${ subKernel.name };\n`).join('    ') }
    for (let z = 0; z < outputZ; z++) {
      const resultY = result[z] = new Array(outputY);
      ${ this._mapSubKernels(subKernel => `const resultY_${ subKernel.name } = result_${subKernel.name}[z] = new Array(outputY);\n`).join('      ') }
      for (let y = 0; y < outputY; y++) {
        const resultX = resultY[y] = new ${constructorString}(outputX);
        ${ this._mapSubKernels(subKernel => `const resultX_${ subKernel.name } = resultY_${subKernel.name}[y] = new ${constructorString}(outputX);\n`).join('        ') }
      }
    }`;
  }

  _resultMutableKernel3DLoop(kernelString) {
    return `  const outputX = _this.output[0];
    const outputY = _this.output[1];
    const outputZ = _this.output[2];
    for (let z = 0; z < outputZ; z++) {
      this.thread.z = z;
      const resultY = result[z];
      for (let y = 0; y < outputY; y++) {
        this.thread.y = y;
        const resultX = resultY[y];
        for (let x = 0; x < outputX; x++) {
          this.thread.x = x;
          ${ kernelString }
        }
      }
    }`;
  }

  _kernelOutput() {
    if (!this.subKernels) {
      return '\n    return result;';
    }
    return `\n    return {
      result: result,
      ${ this.subKernels.map(subKernel => `${ subKernel.property }: result_${ subKernel.name }`).join(',\n      ') }
    };`;
  }

  _mapSubKernels(fn) {
    return this.subKernels === null ? [''] :
      this.subKernels.map(fn);
  }

  destroy(removeCanvasReference) {
    if (removeCanvasReference) {
      delete this.canvas;
    }
  }

  static destroyContext(context) {}

  toJSON() {
    const json = super.toJSON();
    json.functionNodes = FunctionBuilder.fromKernel(this, CPUFunctionNode).toJSON();
    return json;
  }

  setOutput(output) {
    super.setOutput(output);
    const [width, height] = this.output;
    if (this.graphical) {
      this._imageData = this.context.createImageData(width, height);
      this._colorData = new Uint8ClampedArray(width * height * 4);
    }
  }

  prependString(value) {
    if (this._kernelString) throw new Error('Kernel already built');
    this._prependedString.push(value);
  }

  hasPrependString(value) {
    return this._prependedString.indexOf(value) > -1;
  }
}

module.exports = {
  CPUKernel
};
},{"../../utils":114,"../function-builder":9,"../kernel":36,"./function-node":6,"./kernel-string":7}],9:[function(require,module,exports){
class FunctionBuilder {
  static fromKernel(kernel, FunctionNode, extraNodeOptions) {
    const {
      kernelArguments,
      kernelConstants,
      argumentNames,
      argumentSizes,
      argumentBitRatios,
      constants,
      constantBitRatios,
      debug,
      loopMaxIterations,
      nativeFunctions,
      output,
      optimizeFloatMemory,
      precision,
      plugins,
      source,
      subKernels,
      functions,
      leadingReturnStatement,
      followingReturnStatement,
      dynamicArguments,
      dynamicOutput,
    } = kernel;

    const argumentTypes = new Array(kernelArguments.length);
    const constantTypes = {};

    for (let i = 0; i < kernelArguments.length; i++) {
      argumentTypes[i] = kernelArguments[i].type;
    }

    for (let i = 0; i < kernelConstants.length; i++) {
      const kernelConstant = kernelConstants[i];
      constantTypes[kernelConstant.name] = kernelConstant.type;
    }

    const needsArgumentType = (functionName, index) => {
      return functionBuilder.needsArgumentType(functionName, index);
    };

    const assignArgumentType = (functionName, index, type) => {
      functionBuilder.assignArgumentType(functionName, index, type);
    };

    const lookupReturnType = (functionName, ast, requestingNode) => {
      return functionBuilder.lookupReturnType(functionName, ast, requestingNode);
    };

    const lookupFunctionArgumentTypes = (functionName) => {
      return functionBuilder.lookupFunctionArgumentTypes(functionName);
    };

    const lookupFunctionArgumentName = (functionName, argumentIndex) => {
      return functionBuilder.lookupFunctionArgumentName(functionName, argumentIndex);
    };

    const lookupFunctionArgumentBitRatio = (functionName, argumentName) => {
      return functionBuilder.lookupFunctionArgumentBitRatio(functionName, argumentName);
    };

    const triggerImplyArgumentType = (functionName, i, argumentType, requestingNode) => {
      functionBuilder.assignArgumentType(functionName, i, argumentType, requestingNode);
    };

    const triggerImplyArgumentBitRatio = (functionName, argumentName, calleeFunctionName, argumentIndex) => {
      functionBuilder.assignArgumentBitRatio(functionName, argumentName, calleeFunctionName, argumentIndex);
    };

    const onFunctionCall = (functionName, calleeFunctionName, args) => {
      functionBuilder.trackFunctionCall(functionName, calleeFunctionName, args);
    };

    const onNestedFunction = (ast, source) => {
      const argumentNames = [];
      for (let i = 0; i < ast.params.length; i++) {
        argumentNames.push(ast.params[i].name);
      }
      const nestedFunction = new FunctionNode(source, Object.assign({}, nodeOptions, {
        returnType: null,
        ast,
        name: ast.id.name,
        argumentNames,
        lookupReturnType,
        lookupFunctionArgumentTypes,
        lookupFunctionArgumentName,
        lookupFunctionArgumentBitRatio,
        needsArgumentType,
        assignArgumentType,
        triggerImplyArgumentType,
        triggerImplyArgumentBitRatio,
        onFunctionCall,
      }));
      nestedFunction.traceFunctionAST(ast);
      functionBuilder.addFunctionNode(nestedFunction);
    };

    const nodeOptions = Object.assign({
      isRootKernel: false,
      onNestedFunction,
      lookupReturnType,
      lookupFunctionArgumentTypes,
      lookupFunctionArgumentName,
      lookupFunctionArgumentBitRatio,
      needsArgumentType,
      assignArgumentType,
      triggerImplyArgumentType,
      triggerImplyArgumentBitRatio,
      onFunctionCall,
      optimizeFloatMemory,
      precision,
      constants,
      constantTypes,
      constantBitRatios,
      debug,
      loopMaxIterations,
      output,
      plugins,
      dynamicArguments,
      dynamicOutput,
    }, extraNodeOptions || {});

    const rootNodeOptions = Object.assign({}, nodeOptions, {
      isRootKernel: true,
      name: 'kernel',
      argumentNames,
      argumentTypes,
      argumentSizes,
      argumentBitRatios,
      leadingReturnStatement,
      followingReturnStatement,
    });

    if (typeof source === 'object' && source.functionNodes) {
      return new FunctionBuilder().fromJSON(source.functionNodes, FunctionNode);
    }

    const rootNode = new FunctionNode(source, rootNodeOptions);

    let functionNodes = null;
    if (functions) {
      functionNodes = functions.map((fn) => new FunctionNode(fn.source, {
        returnType: fn.returnType,
        argumentTypes: fn.argumentTypes,
        output,
        plugins,
        constants,
        constantTypes,
        constantBitRatios,
        optimizeFloatMemory,
        precision,
        lookupReturnType,
        lookupFunctionArgumentTypes,
        lookupFunctionArgumentName,
        lookupFunctionArgumentBitRatio,
        needsArgumentType,
        assignArgumentType,
        triggerImplyArgumentType,
        triggerImplyArgumentBitRatio,
        onFunctionCall,
        onNestedFunction,
      }));
    }

    let subKernelNodes = null;
    if (subKernels) {
      subKernelNodes = subKernels.map((subKernel) => {
        const { name, source } = subKernel;
        return new FunctionNode(source, Object.assign({}, nodeOptions, {
          name,
          isSubKernel: true,
          isRootKernel: false,
        }));
      });
    }

    const functionBuilder = new FunctionBuilder({
      kernel,
      rootNode,
      functionNodes,
      nativeFunctions,
      subKernelNodes
    });

    return functionBuilder;
  }

  constructor(settings) {
    settings = settings || {};
    this.kernel = settings.kernel;
    this.rootNode = settings.rootNode;
    this.functionNodes = settings.functionNodes || [];
    this.subKernelNodes = settings.subKernelNodes || [];
    this.nativeFunctions = settings.nativeFunctions || [];
    this.functionMap = {};
    this.nativeFunctionNames = [];
    this.lookupChain = [];
    this.functionNodeDependencies = {};
    this.functionCalls = {};

    if (this.rootNode) {
      this.functionMap['kernel'] = this.rootNode;
    }

    if (this.functionNodes) {
      for (let i = 0; i < this.functionNodes.length; i++) {
        this.functionMap[this.functionNodes[i].name] = this.functionNodes[i];
      }
    }

    if (this.subKernelNodes) {
      for (let i = 0; i < this.subKernelNodes.length; i++) {
        this.functionMap[this.subKernelNodes[i].name] = this.subKernelNodes[i];
      }
    }

    if (this.nativeFunctions) {
      for (let i = 0; i < this.nativeFunctions.length; i++) {
        const nativeFunction = this.nativeFunctions[i];
        this.nativeFunctionNames.push(nativeFunction.name);
      }
    }
  }

  addFunctionNode(functionNode) {
    if (!functionNode.name) throw new Error('functionNode.name needs set');
    this.functionMap[functionNode.name] = functionNode;
    if (functionNode.isRootKernel) {
      this.rootNode = functionNode;
    }
  }

  traceFunctionCalls(functionName, retList) {
    functionName = functionName || 'kernel';
    retList = retList || [];

    if (this.nativeFunctionNames.indexOf(functionName) > -1) {
      const nativeFunctionIndex = retList.indexOf(functionName);
      if (nativeFunctionIndex === -1) {
        retList.push(functionName);
      } else {
        const dependantNativeFunctionName = retList.splice(nativeFunctionIndex, 1)[0];
        retList.push(dependantNativeFunctionName);
      }
      return retList;
    }

    const functionNode = this.functionMap[functionName];
    if (functionNode) {
      const functionIndex = retList.indexOf(functionName);
      if (functionIndex === -1) {
        retList.push(functionName);
        functionNode.toString(); 
        for (let i = 0; i < functionNode.calledFunctions.length; ++i) {
          this.traceFunctionCalls(functionNode.calledFunctions[i], retList);
        }
      } else {
        const dependantFunctionName = retList.splice(functionIndex, 1)[0];
        retList.push(dependantFunctionName);
      }
    }

    return retList;
  }

  getPrototypeString(functionName) {
    return this.getPrototypes(functionName).join('\n');
  }

  getPrototypes(functionName) {
    if (this.rootNode) {
      this.rootNode.toString();
    }
    if (functionName) {
      return this.getPrototypesFromFunctionNames(this.traceFunctionCalls(functionName, []).reverse());
    }
    return this.getPrototypesFromFunctionNames(Object.keys(this.functionMap));
  }

  getStringFromFunctionNames(functionList) {
    const ret = [];
    for (let i = 0; i < functionList.length; ++i) {
      const node = this.functionMap[functionList[i]];
      if (node) {
        ret.push(this.functionMap[functionList[i]].toString());
      }
    }
    return ret.join('\n');
  }

  getPrototypesFromFunctionNames(functionList) {
    const ret = [];
    for (let i = 0; i < functionList.length; ++i) {
      const functionName = functionList[i];
      const functionIndex = this.nativeFunctionNames.indexOf(functionName);
      if (functionIndex > -1) {
        ret.push(this.nativeFunctions[functionIndex].source);
        continue;
      }
      const node = this.functionMap[functionName];
      if (node) {
        ret.push(node.toString());
      }
    }
    return ret;
  }

  toJSON() {
    return this.traceFunctionCalls(this.rootNode.name).reverse().map(name => {
      const nativeIndex = this.nativeFunctions.indexOf(name);
      if (nativeIndex > -1) {
        return {
          name,
          source: this.nativeFunctions[nativeIndex].source
        };
      } else if (this.functionMap[name]) {
        return this.functionMap[name].toJSON();
      } else {
        throw new Error(`function ${ name } not found`);
      }
    });
  }

  fromJSON(jsonFunctionNodes, FunctionNode) {
    this.functionMap = {};
    for (let i = 0; i < jsonFunctionNodes.length; i++) {
      const jsonFunctionNode = jsonFunctionNodes[i];
      this.functionMap[jsonFunctionNode.settings.name] = new FunctionNode(jsonFunctionNode.ast, jsonFunctionNode.settings);
    }
    return this;
  }

  getString(functionName) {
    if (functionName) {
      return this.getStringFromFunctionNames(this.traceFunctionCalls(functionName).reverse());
    }
    return this.getStringFromFunctionNames(Object.keys(this.functionMap));
  }

  lookupReturnType(functionName, ast, requestingNode) {
    if (ast.type !== 'CallExpression') {
      throw new Error(`expected ast type of "CallExpression", but is ${ ast.type }`);
    }
    if (this._isNativeFunction(functionName)) {
      return this._lookupNativeFunctionReturnType(functionName);
    } else if (this._isFunction(functionName)) {
      const node = this._getFunction(functionName);
      if (node.returnType) {
        return node.returnType;
      } else {
        for (let i = 0; i < this.lookupChain.length; i++) {
          if (this.lookupChain[i].ast === ast) {
            if (node.argumentTypes.length === 0 && ast.arguments.length > 0) {
              const args = ast.arguments;
              for (let j = 0; j < args.length; j++) {
                this.lookupChain.push({
                  name: requestingNode.name,
                  ast: args[i],
                  requestingNode
                });
                node.argumentTypes[j] = requestingNode.getType(args[j]);
                this.lookupChain.pop();
              }
              return node.returnType = node.getType(node.getJsAST());
            }

            throw new Error('circlical logic detected!');
          }
        }
        this.lookupChain.push({
          name: requestingNode.name,
          ast,
          requestingNode
        });
        const type = node.getType(node.getJsAST());
        this.lookupChain.pop();
        return node.returnType = type;
      }
    }

    return null;
  }

  _getFunction(functionName) {
    if (!this._isFunction(functionName)) {
      new Error(`Function ${functionName} not found`);
    }
    return this.functionMap[functionName];
  }

  _isFunction(functionName) {
    return Boolean(this.functionMap[functionName]);
  }

  _getNativeFunction(functionName) {
    for (let i = 0; i < this.nativeFunctions.length; i++) {
      if (this.nativeFunctions[i].name === functionName) return this.nativeFunctions[i];
    }
    return null;
  }

  _isNativeFunction(functionName) {
    return Boolean(this._getNativeFunction(functionName));
  }

  _lookupNativeFunctionReturnType(functionName) {
    let nativeFunction = this._getNativeFunction(functionName);
    if (nativeFunction) {
      return nativeFunction.returnType;
    }
    throw new Error(`Native function ${ functionName } not found`);
  }

  lookupFunctionArgumentTypes(functionName) {
    if (this._isNativeFunction(functionName)) {
      return this._getNativeFunction(functionName).argumentTypes;
    } else if (this._isFunction(functionName)) {
      return this._getFunction(functionName).argumentTypes;
    }
    return null;
  }

  lookupFunctionArgumentName(functionName, argumentIndex) {
    return this._getFunction(functionName).argumentNames[argumentIndex];
  }

  lookupFunctionArgumentBitRatio(functionName, argumentName) {
    if (!this._isFunction(functionName)) {
      throw new Error('function not found');
    }
    if (this.rootNode.name === functionName) {
      const i = this.rootNode.argumentNames.indexOf(argumentName);
      if (i !== -1) {
        return this.rootNode.argumentBitRatios[i];
      }
    }
    const node = this._getFunction(functionName);
    const i = node.argumentNames.indexOf(argumentName);
    if (i === -1) {
      throw new Error('argument not found');
    }
    const bitRatio = node.argumentBitRatios[i];
    if (typeof bitRatio !== 'number') {
      throw new Error('argument bit ratio not found');
    }
    return bitRatio;
  }

  needsArgumentType(functionName, i) {
    if (!this._isFunction(functionName)) return false;
    const fnNode = this._getFunction(functionName);
    return !fnNode.argumentTypes[i];
  }

  assignArgumentType(functionName, i, argumentType, requestingNode) {
    if (!this._isFunction(functionName)) return;
    const fnNode = this._getFunction(functionName);
    if (!fnNode.argumentTypes[i]) {
      fnNode.argumentTypes[i] = argumentType;
    }
  }

  assignArgumentBitRatio(functionName, argumentName, calleeFunctionName, argumentIndex) {
    const node = this._getFunction(functionName);
    if (this._isNativeFunction(calleeFunctionName)) return null;
    const calleeNode = this._getFunction(calleeFunctionName);
    const i = node.argumentNames.indexOf(argumentName);
    if (i === -1) {
      throw new Error(`Argument ${argumentName} not found in arguments from function ${functionName}`);
    }
    const bitRatio = node.argumentBitRatios[i];
    if (typeof bitRatio !== 'number') {
      throw new Error(`Bit ratio for argument ${argumentName} not found in function ${functionName}`);
    }
    if (!calleeNode.argumentBitRatios) {
      calleeNode.argumentBitRatios = new Array(calleeNode.argumentNames.length);
    }
    const calleeBitRatio = calleeNode.argumentBitRatios[i];
    if (typeof calleeBitRatio === 'number') {
      if (calleeBitRatio !== bitRatio) {
        throw new Error(`Incompatible bit ratio found at function ${functionName} at argument ${argumentName}`);
      }
      return calleeBitRatio;
    }
    calleeNode.argumentBitRatios[i] = bitRatio;
    return bitRatio;
  }

  trackFunctionCall(functionName, calleeFunctionName, args) {
    if (!this.functionNodeDependencies[functionName]) {
      this.functionNodeDependencies[functionName] = new Set();
      this.functionCalls[functionName] = [];
    }
    this.functionNodeDependencies[functionName].add(calleeFunctionName);
    this.functionCalls[functionName].push(args);
  }

  getKernelResultType() {
    return this.rootNode.returnType || this.rootNode.getType(this.rootNode.ast);
  }

  getSubKernelResultType(index) {
    const subKernelNode = this.subKernelNodes[index];
    let called = false;
    for (let functionCallIndex = 0; functionCallIndex < this.rootNode.functionCalls.length; functionCallIndex++) {
      const functionCall = this.rootNode.functionCalls[functionCallIndex];
      if (functionCall.ast.callee.name === subKernelNode.name) {
        called = true;
      }
    }
    if (!called) {
      throw new Error(`SubKernel ${ subKernelNode.name } never called by kernel`);
    }
    return subKernelNode.returnType || subKernelNode.getType(subKernelNode.getJsAST());
  }

  getReturnTypes() {
    const result = {
      [this.rootNode.name]: this.rootNode.getType(this.rootNode.ast),
    };
    const list = this.traceFunctionCalls(this.rootNode.name);
    for (let i = 0; i < list.length; i++) {
      const functionName = list[i];
      const functionNode = this.functionMap[functionName];
      result[functionName] = functionNode.getType(functionNode.ast);
    }
    return result;
  }
}

module.exports = {
  FunctionBuilder
};
},{}],10:[function(require,module,exports){
const acorn = require('acorn');
const { utils } = require('../utils');
const { FunctionTracer } = require('./function-tracer');

class FunctionNode {
  constructor(source, settings) {
    if (!source && !settings.ast) {
      throw new Error('source parameter is missing');
    }
    settings = settings || {};
    this.source = source;
    this.ast = null;
    this.name = typeof source === 'string' ? settings.isRootKernel ?
      'kernel' :
      (settings.name || utils.getFunctionNameFromString(source)) : null;
    this.calledFunctions = [];
    this.constants = {};
    this.constantTypes = {};
    this.constantBitRatios = {};
    this.isRootKernel = false;
    this.isSubKernel = false;
    this.debug = null;
    this.functions = null;
    this.identifiers = null;
    this.contexts = null;
    this.functionCalls = null;
    this.states = [];
    this.needsArgumentType = null;
    this.assignArgumentType = null;
    this.lookupReturnType = null;
    this.lookupFunctionArgumentTypes = null;
    this.lookupFunctionArgumentBitRatio = null;
    this.triggerImplyArgumentType = null;
    this.triggerImplyArgumentBitRatio = null;
    this.onNestedFunction = null;
    this.onFunctionCall = null;
    this.optimizeFloatMemory = null;
    this.precision = null;
    this.loopMaxIterations = null;
    this.argumentNames = (typeof this.source === 'string' ? utils.getArgumentNamesFromString(this.source) : null);
    this.argumentTypes = [];
    this.argumentSizes = [];
    this.argumentBitRatios = null;
    this.returnType = null;
    this.output = [];
    this.plugins = null;
    this.leadingReturnStatement = null;
    this.followingReturnStatement = null;
    this.dynamicOutput = null;
    this.dynamicArguments = null;
    this.strictTypingChecking = false;
    this.fixIntegerDivisionAccuracy = null;

    if (settings) {
      for (const p in settings) {
        if (!settings.hasOwnProperty(p)) continue;
        if (!this.hasOwnProperty(p)) continue;
        this[p] = settings[p];
      }
    }

    this.literalTypes = {};

    this.validate();
    this._string = null;
    this._internalVariableNames = {};
  }

  validate() {
    if (typeof this.source !== 'string' && !this.ast) {
      throw new Error('this.source not a string');
    }

    if (!this.ast && !utils.isFunctionString(this.source)) {
      throw new Error('this.source not a function string');
    }

    if (!this.name) {
      throw new Error('this.name could not be set');
    }

    if (this.argumentTypes.length > 0 && this.argumentTypes.length !== this.argumentNames.length) {
      throw new Error(`argumentTypes count of ${ this.argumentTypes.length } exceeds ${ this.argumentNames.length }`);
    }

    if (this.output.length < 1) {
      throw new Error('this.output is not big enough');
    }
  }

  isIdentifierConstant(name) {
    if (!this.constants) return false;
    return this.constants.hasOwnProperty(name);
  }

  isInput(argumentName) {
    return this.argumentTypes[this.argumentNames.indexOf(argumentName)] === 'Input';
  }

  pushState(state) {
    this.states.push(state);
  }

  popState(state) {
    if (this.state !== state) {
      throw new Error(`Cannot popState ${ state } when in ${ this.state }`);
    }
    this.states.pop();
  }

  isState(state) {
    return this.state === state;
  }

  get state() {
    return this.states[this.states.length - 1];
  }

  astMemberExpressionUnroll(ast) {
    if (ast.type === 'Identifier') {
      return ast.name;
    } else if (ast.type === 'ThisExpression') {
      return 'this';
    }

    if (ast.type === 'MemberExpression') {
      if (ast.object && ast.property) {
        if (ast.object.hasOwnProperty('name') && ast.object.name !== 'Math') {
          return this.astMemberExpressionUnroll(ast.property);
        }

        return (
          this.astMemberExpressionUnroll(ast.object) +
          '.' +
          this.astMemberExpressionUnroll(ast.property)
        );
      }
    }

    if (ast.hasOwnProperty('expressions')) {
      const firstExpression = ast.expressions[0];
      if (firstExpression.type === 'Literal' && firstExpression.value === 0 && ast.expressions.length === 2) {
        return this.astMemberExpressionUnroll(ast.expressions[1]);
      }
    }

    throw this.astErrorOutput('Unknown astMemberExpressionUnroll', ast);
  }

  getJsAST(inParser) {
    if (this.ast) {
      return this.ast;
    }
    if (typeof this.source === 'object') {
      this.traceFunctionAST(this.source);
      return this.ast = this.source;
    }

    inParser = inParser || acorn;
    if (inParser === null) {
      throw new Error('Missing JS to AST parser');
    }

    const ast = Object.freeze(inParser.parse(`const parser_${ this.name } = ${ this.source };`, {
      locations: true
    }));
    const functionAST = ast.body[0].declarations[0].init;
    this.traceFunctionAST(functionAST);

    if (!ast) {
      throw new Error('Failed to parse JS code');
    }

    return this.ast = functionAST;
  }

  traceFunctionAST(ast) {
    const { contexts, declarations, functions, identifiers, functionCalls } = new FunctionTracer(ast);
    this.contexts = contexts;
    this.identifiers = identifiers;
    this.functionCalls = functionCalls;
    this.functions = functions;
    for (let i = 0; i < declarations.length; i++) {
      const declaration = declarations[i];
      const { ast, inForLoopInit, inForLoopTest } = declaration;
      const { init } = ast;
      const dependencies = this.getDependencies(init);
      let valueType = null;

      if (inForLoopInit && inForLoopTest) {
        valueType = 'Integer';
      } else {
        if (init) {
          const realType = this.getType(init);
          switch (realType) {
            case 'Integer':
            case 'Float':
            case 'Number':
              if (init.type === 'MemberExpression') {
                valueType = realType;
              } else {
                valueType = 'Number';
              }
              break;
            case 'LiteralInteger':
              valueType = 'Number';
              break;
            default:
              valueType = realType;
          }
        }
      }
      declaration.valueType = valueType;
      declaration.dependencies = dependencies;
      declaration.isSafe = this.isSafeDependencies(dependencies);
    }

    for (let i = 0; i < functions.length; i++) {
      this.onNestedFunction(functions[i], this.source);
    }
  }

  getDeclaration(ast) {
    for (let i = 0; i < this.identifiers.length; i++) {
      const identifier = this.identifiers[i];
      if (ast === identifier.ast) {
        return identifier.declaration;
      }
    }
    return null;
  }

  getVariableType(ast) {
    if (ast.type !== 'Identifier') {
      throw new Error(`ast of ${ast.type} not "Identifier"`);
    }
    let type = null;
    const argumentIndex = this.argumentNames.indexOf(ast.name);
    if (argumentIndex === -1) {
      const declaration = this.getDeclaration(ast);
      if (declaration) {
        return declaration.valueType;
      }
    } else {
      const argumentType = this.argumentTypes[argumentIndex];
      if (argumentType) {
        type = argumentType;
      }
    }
    if (!type && this.strictTypingChecking) {
      throw new Error(`Declaration of ${name} not found`);
    }
    return type;
  }

  getLookupType(type) {
    if (!typeLookupMap.hasOwnProperty(type)) {
      throw new Error(`unknown typeLookupMap ${ type }`);
    }
    return typeLookupMap[type];
  }

  getConstantType(constantName) {
    if (this.constantTypes[constantName]) {
      const type = this.constantTypes[constantName];
      if (type === 'Float') {
        return 'Number';
      } else {
        return type;
      }
    }
    throw new Error(`Type for constant "${ constantName }" not declared`);
  }

  toString() {
    if (this._string) return this._string;
    return this._string = this.astGeneric(this.getJsAST(), []).join('').trim();
  }

  toJSON() {
    const settings = {
      source: this.source,
      name: this.name,
      constants: this.constants,
      constantTypes: this.constantTypes,
      isRootKernel: this.isRootKernel,
      isSubKernel: this.isSubKernel,
      debug: this.debug,
      output: this.output,
      loopMaxIterations: this.loopMaxIterations,
      argumentNames: this.argumentNames,
      argumentTypes: this.argumentTypes,
      argumentSizes: this.argumentSizes,
      returnType: this.returnType,
      leadingReturnStatement: this.leadingReturnStatement,
      followingReturnStatement: this.followingReturnStatement,
    };

    return {
      ast: this.ast,
      settings
    };
  }

  getType(ast) {
    if (Array.isArray(ast)) {
      return this.getType(ast[ast.length - 1]);
    }
    switch (ast.type) {
      case 'BlockStatement':
        return this.getType(ast.body);
      case 'ArrayExpression':
        const childType = this.getType(ast.elements[0]);
        switch (childType) {
          case 'Array(2)':
          case 'Array(3)':
          case 'Array(4)':
            return `Matrix(${ast.elements.length})`;
        }
        return `Array(${ ast.elements.length })`;
      case 'Literal':
        const literalKey = this.astKey(ast);
        if (this.literalTypes[literalKey]) {
          return this.literalTypes[literalKey];
        }
        if (Number.isInteger(ast.value)) {
          return 'LiteralInteger';
        } else if (ast.value === true || ast.value === false) {
          return 'Boolean';
        } else {
          return 'Number';
        }
        case 'AssignmentExpression':
          return this.getType(ast.left);
        case 'CallExpression':
          if (this.isAstMathFunction(ast)) {
            return 'Number';
          }
          if (!ast.callee || !ast.callee.name) {
            if (ast.callee.type === 'SequenceExpression' && ast.callee.expressions[ast.callee.expressions.length - 1].property.name) {
              const functionName = ast.callee.expressions[ast.callee.expressions.length - 1].property.name;
              this.inferArgumentTypesIfNeeded(functionName, ast.arguments);
              return this.lookupReturnType(functionName, ast, this);
            }
            if (this.getVariableSignature(ast.callee, true) === 'this.color') {
              return null;
            }
            if (ast.callee.type === 'MemberExpression' && ast.callee.object && ast.callee.property && ast.callee.property.name && ast.arguments) {
              const functionName = ast.callee.property.name;
              this.inferArgumentTypesIfNeeded(functionName, ast.arguments);
              return this.lookupReturnType(functionName, ast, this);
            }
            throw this.astErrorOutput('Unknown call expression', ast);
          }
          if (ast.callee && ast.callee.name) {
            const functionName = ast.callee.name;
            this.inferArgumentTypesIfNeeded(functionName, ast.arguments);
            return this.lookupReturnType(functionName, ast, this);
          }
          throw this.astErrorOutput(`Unhandled getType Type "${ ast.type }"`, ast);
        case 'LogicalExpression':
          return 'Boolean';
        case 'BinaryExpression':
          switch (ast.operator) {
            case '%':
            case '/':
              if (this.fixIntegerDivisionAccuracy) {
                return 'Number';
              } else {
                break;
              }
              case '>':
              case '<':
                return 'Boolean';
              case '&':
              case '|':
              case '^':
              case '<<':
              case '>>':
              case '>>>':
                return 'Integer';
          }
          const type = this.getType(ast.left);
          if (this.isState('skip-literal-correction')) return type;
          if (type === 'LiteralInteger') {
            const rightType = this.getType(ast.right);
            if (rightType === 'LiteralInteger') {
              if (ast.left.value % 1 === 0) {
                return 'Integer';
              } else {
                return 'Float';
              }
            }
            return rightType;
          }
          return typeLookupMap[type] || type;
        case 'UpdateExpression':
          return this.getType(ast.argument);
        case 'UnaryExpression':
          if (ast.operator === '~') {
            return 'Integer';
          }
          return this.getType(ast.argument);
        case 'VariableDeclaration': {
          const declarations = ast.declarations;
          let lastType;
          for (let i = 0; i < declarations.length; i++) {
            const declaration = declarations[i];
            lastType = this.getType(declaration);
          }
          if (!lastType) {
            throw this.astErrorOutput(`Unable to find type for declaration`, ast);
          }
          return lastType;
        }
        case 'VariableDeclarator':
          const declaration = this.getDeclaration(ast.id);
          if (!declaration) {
            throw this.astErrorOutput(`Unable to find declarator`, ast);
          }

          if (!declaration.valueType) {
            throw this.astErrorOutput(`Unable to find declarator valueType`, ast);
          }

          return declaration.valueType;
        case 'Identifier':
          if (ast.name === 'Infinity') {
            return 'Number';
          }
          if (this.isAstVariable(ast)) {
            const signature = this.getVariableSignature(ast);
            if (signature === 'value') {
              return this.getCheckVariableType(ast);
            }
          }
          const origin = this.findIdentifierOrigin(ast);
          if (origin && origin.init) {
            return this.getType(origin.init);
          }
          return null;
        case 'ReturnStatement':
          return this.getType(ast.argument);
        case 'MemberExpression':
          if (this.isAstMathFunction(ast)) {
            switch (ast.property.name) {
              case 'ceil':
                return 'Integer';
              case 'floor':
                return 'Integer';
              case 'round':
                return 'Integer';
            }
            return 'Number';
          }
          if (this.isAstVariable(ast)) {
            const variableSignature = this.getVariableSignature(ast);
            switch (variableSignature) {
              case 'value[]':
                return this.getLookupType(this.getCheckVariableType(ast.object));
              case 'value[][]':
                return this.getLookupType(this.getCheckVariableType(ast.object.object));
              case 'value[][][]':
                return this.getLookupType(this.getCheckVariableType(ast.object.object.object));
              case 'value[][][][]':
                return this.getLookupType(this.getCheckVariableType(ast.object.object.object.object));
              case 'value.thread.value':
              case 'this.thread.value':
                return 'Integer';
              case 'this.output.value':
                return this.dynamicOutput ? 'Integer' : 'LiteralInteger';
              case 'this.constants.value':
                return this.getConstantType(ast.property.name);
              case 'this.constants.value[]':
                return this.getLookupType(this.getConstantType(ast.object.property.name));
              case 'this.constants.value[][]':
                return this.getLookupType(this.getConstantType(ast.object.object.property.name));
              case 'this.constants.value[][][]':
                return this.getLookupType(this.getConstantType(ast.object.object.object.property.name));
              case 'this.constants.value[][][][]':
                return this.getLookupType(this.getConstantType(ast.object.object.object.object.property.name));
              case 'fn()[]':
              case 'fn()[][]':
              case 'fn()[][][]':
                return this.getLookupType(this.getType(ast.object));
              case 'value.value':
                if (this.isAstMathVariable(ast)) {
                  return 'Number';
                }
                switch (ast.property.name) {
                  case 'r':
                  case 'g':
                  case 'b':
                  case 'a':
                    return this.getLookupType(this.getCheckVariableType(ast.object));
                }
                case '[][]':
                  return 'Number';
            }
            throw this.astErrorOutput('Unhandled getType MemberExpression', ast);
          }
          throw this.astErrorOutput('Unhandled getType MemberExpression', ast);
        case 'ConditionalExpression':
          return this.getType(ast.consequent);
        case 'FunctionDeclaration':
        case 'FunctionExpression':
          const lastReturn = this.findLastReturn(ast.body);
          if (lastReturn) {
            return this.getType(lastReturn);
          }
          return null;
        case 'IfStatement':
          return this.getType(ast.consequent);
        case 'SequenceExpression':
          return this.getType(ast.expressions[ast.expressions.length - 1]);
        default:
          throw this.astErrorOutput(`Unhandled getType Type "${ ast.type }"`, ast);
    }
  }

  getCheckVariableType(ast) {
    const type = this.getVariableType(ast);
    if (!type) {
      throw this.astErrorOutput(`${ast.type} is not defined`, ast);
    }
    return type;
  }

  inferArgumentTypesIfNeeded(functionName, args) {
    for (let i = 0; i < args.length; i++) {
      if (!this.needsArgumentType(functionName, i)) continue;
      const type = this.getType(args[i]);
      if (!type) {
        throw this.astErrorOutput(`Unable to infer argument ${i}`, args[i]);
      }
      this.assignArgumentType(functionName, i, type);
    }
  }

  isAstMathVariable(ast) {
    const mathProperties = [
      'E',
      'PI',
      'SQRT2',
      'SQRT1_2',
      'LN2',
      'LN10',
      'LOG2E',
      'LOG10E',
    ];
    return ast.type === 'MemberExpression' &&
      ast.object && ast.object.type === 'Identifier' &&
      ast.object.name === 'Math' &&
      ast.property &&
      ast.property.type === 'Identifier' &&
      mathProperties.indexOf(ast.property.name) > -1;
  }

  isAstMathFunction(ast) {
    const mathFunctions = [
      'abs',
      'acos',
      'acosh',
      'asin',
      'asinh',
      'atan',
      'atan2',
      'atanh',
      'cbrt',
      'ceil',
      'clz32',
      'cos',
      'cosh',
      'expm1',
      'exp',
      'floor',
      'fround',
      'imul',
      'log',
      'log2',
      'log10',
      'log1p',
      'max',
      'min',
      'pow',
      'random',
      'round',
      'sign',
      'sin',
      'sinh',
      'sqrt',
      'tan',
      'tanh',
      'trunc',
    ];
    return ast.type === 'CallExpression' &&
      ast.callee &&
      ast.callee.type === 'MemberExpression' &&
      ast.callee.object &&
      ast.callee.object.type === 'Identifier' &&
      ast.callee.object.name === 'Math' &&
      ast.callee.property &&
      ast.callee.property.type === 'Identifier' &&
      mathFunctions.indexOf(ast.callee.property.name) > -1;
  }

  isAstVariable(ast) {
    return ast.type === 'Identifier' || ast.type === 'MemberExpression';
  }

  isSafe(ast) {
    return this.isSafeDependencies(this.getDependencies(ast));
  }

  isSafeDependencies(dependencies) {
    return dependencies && dependencies.every ? dependencies.every(dependency => dependency.isSafe) : true;
  }

  getDependencies(ast, dependencies, isNotSafe) {
    if (!dependencies) {
      dependencies = [];
    }
    if (!ast) return null;
    if (Array.isArray(ast)) {
      for (let i = 0; i < ast.length; i++) {
        this.getDependencies(ast[i], dependencies, isNotSafe);
      }
      return dependencies;
    }
    switch (ast.type) {
      case 'AssignmentExpression':
        this.getDependencies(ast.left, dependencies, isNotSafe);
        this.getDependencies(ast.right, dependencies, isNotSafe);
        return dependencies;
      case 'ConditionalExpression':
        this.getDependencies(ast.test, dependencies, isNotSafe);
        this.getDependencies(ast.alternate, dependencies, isNotSafe);
        this.getDependencies(ast.consequent, dependencies, isNotSafe);
        return dependencies;
      case 'Literal':
        dependencies.push({
          origin: 'literal',
          value: ast.value,
          isSafe: isNotSafe === true ? false : ast.value > -Infinity && ast.value < Infinity && !isNaN(ast.value)
        });
        break;
      case 'VariableDeclarator':
        return this.getDependencies(ast.init, dependencies, isNotSafe);
      case 'Identifier':
        const declaration = this.getDeclaration(ast);
        if (declaration) {
          dependencies.push({
            name: ast.name,
            origin: 'declaration',
            isSafe: isNotSafe ? false : this.isSafeDependencies(declaration.dependencies),
          });
        } else if (this.argumentNames.indexOf(ast.name) > -1) {
          dependencies.push({
            name: ast.name,
            origin: 'argument',
            isSafe: false,
          });
        } else if (this.strictTypingChecking) {
          throw new Error(`Cannot find identifier origin "${ast.name}"`);
        }
        break;
      case 'FunctionDeclaration':
        return this.getDependencies(ast.body.body[ast.body.body.length - 1], dependencies, isNotSafe);
      case 'ReturnStatement':
        return this.getDependencies(ast.argument, dependencies);
      case 'BinaryExpression':
      case 'LogicalExpression':
        isNotSafe = (ast.operator === '/' || ast.operator === '*');
        this.getDependencies(ast.left, dependencies, isNotSafe);
        this.getDependencies(ast.right, dependencies, isNotSafe);
        return dependencies;
      case 'UnaryExpression':
      case 'UpdateExpression':
        return this.getDependencies(ast.argument, dependencies, isNotSafe);
      case 'VariableDeclaration':
        return this.getDependencies(ast.declarations, dependencies, isNotSafe);
      case 'ArrayExpression':
        dependencies.push({
          origin: 'declaration',
          isSafe: true,
        });
        return dependencies;
      case 'CallExpression':
        dependencies.push({
          origin: 'function',
          isSafe: true,
        });
        return dependencies;
      case 'MemberExpression':
        const details = this.getMemberExpressionDetails(ast);
        switch (details.signature) {
          case 'value[]':
            this.getDependencies(ast.object, dependencies, isNotSafe);
            break;
          case 'value[][]':
            this.getDependencies(ast.object.object, dependencies, isNotSafe);
            break;
          case 'value[][][]':
            this.getDependencies(ast.object.object.object, dependencies, isNotSafe);
            break;
          case 'this.output.value':
            if (this.dynamicOutput) {
              dependencies.push({
                name: details.name,
                origin: 'output',
                isSafe: false,
              });
            }
            break;
        }
        if (details) {
          if (details.property) {
            this.getDependencies(details.property, dependencies, isNotSafe);
          }
          if (details.xProperty) {
            this.getDependencies(details.xProperty, dependencies, isNotSafe);
          }
          if (details.yProperty) {
            this.getDependencies(details.yProperty, dependencies, isNotSafe);
          }
          if (details.zProperty) {
            this.getDependencies(details.zProperty, dependencies, isNotSafe);
          }
          return dependencies;
        }
        case 'SequenceExpression':
          return this.getDependencies(ast.expressions, dependencies, isNotSafe);
        default:
          throw this.astErrorOutput(`Unhandled type ${ ast.type } in getDependencies`, ast);
    }
    return dependencies;
  }

  getVariableSignature(ast, returnRawValue) {
    if (!this.isAstVariable(ast)) {
      throw new Error(`ast of type "${ ast.type }" is not a variable signature`);
    }
    if (ast.type === 'Identifier') {
      return 'value';
    }
    const signature = [];
    while (true) {
      if (!ast) break;
      if (ast.computed) {
        signature.push('[]');
      } else if (ast.type === 'ThisExpression') {
        signature.unshift('this');
      } else if (ast.property && ast.property.name) {
        if (
          ast.property.name === 'x' ||
          ast.property.name === 'y' ||
          ast.property.name === 'z'
        ) {
          signature.unshift(returnRawValue ? '.' + ast.property.name : '.value');
        } else if (
          ast.property.name === 'constants' ||
          ast.property.name === 'thread' ||
          ast.property.name === 'output'
        ) {
          signature.unshift('.' + ast.property.name);
        } else {
          signature.unshift(returnRawValue ? '.' + ast.property.name : '.value');
        }
      } else if (ast.name) {
        signature.unshift(returnRawValue ? ast.name : 'value');
      } else if (ast.callee && ast.callee.name) {
        signature.unshift(returnRawValue ? ast.callee.name + '()' : 'fn()');
      } else if (ast.elements) {
        signature.unshift('[]');
      } else {
        signature.unshift('unknown');
      }
      ast = ast.object;
    }

    const signatureString = signature.join('');
    if (returnRawValue) {
      return signatureString;
    }

    const allowedExpressions = [
      'value',
      'value[]',
      'value[][]',
      'value[][][]',
      'value[][][][]',
      'value.value',
      'value.thread.value',
      'this.thread.value',
      'this.output.value',
      'this.constants.value',
      'this.constants.value[]',
      'this.constants.value[][]',
      'this.constants.value[][][]',
      'this.constants.value[][][][]',
      'fn()[]',
      'fn()[][]',
      'fn()[][][]',
      '[][]',
    ];
    if (allowedExpressions.indexOf(signatureString) > -1) {
      return signatureString;
    }
    return null;
  }

  build() {
    return this.toString().length > 0;
  }

  astGeneric(ast, retArr) {
    if (ast === null) {
      throw this.astErrorOutput('NULL ast', ast);
    } else {
      if (Array.isArray(ast)) {
        for (let i = 0; i < ast.length; i++) {
          this.astGeneric(ast[i], retArr);
        }
        return retArr;
      }

      switch (ast.type) {
        case 'FunctionDeclaration':
          return this.astFunctionDeclaration(ast, retArr);
        case 'FunctionExpression':
          return this.astFunctionExpression(ast, retArr);
        case 'ReturnStatement':
          return this.astReturnStatement(ast, retArr);
        case 'Literal':
          return this.astLiteral(ast, retArr);
        case 'BinaryExpression':
          return this.astBinaryExpression(ast, retArr);
        case 'Identifier':
          return this.astIdentifierExpression(ast, retArr);
        case 'AssignmentExpression':
          return this.astAssignmentExpression(ast, retArr);
        case 'ExpressionStatement':
          return this.astExpressionStatement(ast, retArr);
        case 'EmptyStatement':
          return this.astEmptyStatement(ast, retArr);
        case 'BlockStatement':
          return this.astBlockStatement(ast, retArr);
        case 'IfStatement':
          return this.astIfStatement(ast, retArr);
        case 'SwitchStatement':
          return this.astSwitchStatement(ast, retArr);
        case 'BreakStatement':
          return this.astBreakStatement(ast, retArr);
        case 'ContinueStatement':
          return this.astContinueStatement(ast, retArr);
        case 'ForStatement':
          return this.astForStatement(ast, retArr);
        case 'WhileStatement':
          return this.astWhileStatement(ast, retArr);
        case 'DoWhileStatement':
          return this.astDoWhileStatement(ast, retArr);
        case 'VariableDeclaration':
          return this.astVariableDeclaration(ast, retArr);
        case 'VariableDeclarator':
          return this.astVariableDeclarator(ast, retArr);
        case 'ThisExpression':
          return this.astThisExpression(ast, retArr);
        case 'SequenceExpression':
          return this.astSequenceExpression(ast, retArr);
        case 'UnaryExpression':
          return this.astUnaryExpression(ast, retArr);
        case 'UpdateExpression':
          return this.astUpdateExpression(ast, retArr);
        case 'LogicalExpression':
          return this.astLogicalExpression(ast, retArr);
        case 'MemberExpression':
          return this.astMemberExpression(ast, retArr);
        case 'CallExpression':
          return this.astCallExpression(ast, retArr);
        case 'ArrayExpression':
          return this.astArrayExpression(ast, retArr);
        case 'DebuggerStatement':
          return this.astDebuggerStatement(ast, retArr);
        case 'ConditionalExpression':
          return this.astConditionalExpression(ast, retArr);
      }

      throw this.astErrorOutput('Unknown ast type : ' + ast.type, ast);
    }
  }
  astErrorOutput(error, ast) {
    if (typeof this.source !== 'string') {
      return new Error(error);
    }

    const debugString = utils.getAstString(this.source, ast);
    const leadingSource = this.source.substr(ast.start);
    const splitLines = leadingSource.split(/\n/);
    const lineBefore = splitLines.length > 0 ? splitLines[splitLines.length - 1] : 0;
    return new Error(`${error} on line ${ splitLines.length }, position ${ lineBefore.length }:\n ${ debugString }`);
  }

  astDebuggerStatement(arrNode, retArr) {
    return retArr;
  }

  astConditionalExpression(ast, retArr) {
    if (ast.type !== 'ConditionalExpression') {
      throw this.astErrorOutput('Not a conditional expression', ast);
    }
    retArr.push('(');
    this.astGeneric(ast.test, retArr);
    retArr.push('?');
    this.astGeneric(ast.consequent, retArr);
    retArr.push(':');
    this.astGeneric(ast.alternate, retArr);
    retArr.push(')');
    return retArr;
  }

  astFunction(ast, retArr) {
    throw new Error(`"astFunction" not defined on ${ this.constructor.name }`);
  }

  astFunctionDeclaration(ast, retArr) {
    if (this.isChildFunction(ast)) {
      return retArr;
    }
    return this.astFunction(ast, retArr);
  }
  astFunctionExpression(ast, retArr) {
    if (this.isChildFunction(ast)) {
      return retArr;
    }
    return this.astFunction(ast, retArr);
  }
  isChildFunction(ast) {
    for (let i = 0; i < this.functions.length; i++) {
      if (this.functions[i] === ast) {
        return true;
      }
    }
    return false;
  }
  astReturnStatement(ast, retArr) {
    return retArr;
  }
  astLiteral(ast, retArr) {
    this.literalTypes[this.astKey(ast)] = 'Number';
    return retArr;
  }
  astBinaryExpression(ast, retArr) {
    return retArr;
  }
  astIdentifierExpression(ast, retArr) {
    return retArr;
  }
  astAssignmentExpression(ast, retArr) {
    return retArr;
  }
  astExpressionStatement(esNode, retArr) {
    this.astGeneric(esNode.expression, retArr);
    retArr.push(';');
    return retArr;
  }
  astEmptyStatement(eNode, retArr) {
    return retArr;
  }
  astBlockStatement(ast, retArr) {
    return retArr;
  }
  astIfStatement(ast, retArr) {
    return retArr;
  }
  astSwitchStatement(ast, retArr) {
    return retArr;
  }
  astBreakStatement(brNode, retArr) {
    retArr.push('break;');
    return retArr;
  }
  astContinueStatement(crNode, retArr) {
    retArr.push('continue;\n');
    return retArr;
  }
  astForStatement(ast, retArr) {
    return retArr;
  }
  astWhileStatement(ast, retArr) {
    return retArr;
  }
  astDoWhileStatement(ast, retArr) {
    return retArr;
  }
  astVariableDeclarator(iVarDecNode, retArr) {
    this.astGeneric(iVarDecNode.id, retArr);
    if (iVarDecNode.init !== null) {
      retArr.push('=');
      this.astGeneric(iVarDecNode.init, retArr);
    }
    return retArr;
  }
  astThisExpression(ast, retArr) {
    return retArr;
  }
  astSequenceExpression(sNode, retArr) {
    const { expressions } = sNode;
    const sequenceResult = [];
    for (let i = 0; i < expressions.length; i++) {
      const expression = expressions[i];
      const expressionResult = [];
      this.astGeneric(expression, expressionResult);
      sequenceResult.push(expressionResult.join(''));
    }
    if (sequenceResult.length > 1) {
      retArr.push('(', sequenceResult.join(','), ')');
    } else {
      retArr.push(sequenceResult[0]);
    }
    return retArr;
  }
  astUnaryExpression(uNode, retArr) {
    const unaryResult = this.checkAndUpconvertBitwiseUnary(uNode, retArr);
    if (unaryResult) {
      return retArr;
    }

    if (uNode.prefix) {
      retArr.push(uNode.operator);
      this.astGeneric(uNode.argument, retArr);
    } else {
      this.astGeneric(uNode.argument, retArr);
      retArr.push(uNode.operator);
    }

    return retArr;
  }

  checkAndUpconvertBitwiseUnary(uNode, retArr) {}

  astUpdateExpression(uNode, retArr) {
    if (uNode.prefix) {
      retArr.push(uNode.operator);
      this.astGeneric(uNode.argument, retArr);
    } else {
      this.astGeneric(uNode.argument, retArr);
      retArr.push(uNode.operator);
    }

    return retArr;
  }
  astLogicalExpression(logNode, retArr) {
    retArr.push('(');
    this.astGeneric(logNode.left, retArr);
    retArr.push(logNode.operator);
    this.astGeneric(logNode.right, retArr);
    retArr.push(')');
    return retArr;
  }
  astMemberExpression(ast, retArr) {
    return retArr;
  }
  astCallExpression(ast, retArr) {
    return retArr;
  }
  astArrayExpression(ast, retArr) {
    return retArr;
  }

  getMemberExpressionDetails(ast) {
    if (ast.type !== 'MemberExpression') {
      throw this.astErrorOutput(`Expression ${ ast.type } not a MemberExpression`, ast);
    }
    let name = null;
    let type = null;
    const variableSignature = this.getVariableSignature(ast);
    switch (variableSignature) {
      case 'value':
        return null;
      case 'value.thread.value':
      case 'this.thread.value':
      case 'this.output.value':
        return {
          signature: variableSignature,
            type: 'Integer',
            name: ast.property.name
        };
      case 'value[]':
        if (typeof ast.object.name !== 'string') {
          throw this.astErrorOutput('Unexpected expression', ast);
        }
        name = ast.object.name;
        return {
          name,
          origin: 'user',
            signature: variableSignature,
            type: this.getVariableType(ast.object),
            xProperty: ast.property
        };
      case 'value[][]':
        if (typeof ast.object.object.name !== 'string') {
          throw this.astErrorOutput('Unexpected expression', ast);
        }
        name = ast.object.object.name;
        return {
          name,
          origin: 'user',
            signature: variableSignature,
            type: this.getVariableType(ast.object.object),
            yProperty: ast.object.property,
            xProperty: ast.property,
        };
      case 'value[][][]':
        if (typeof ast.object.object.object.name !== 'string') {
          throw this.astErrorOutput('Unexpected expression', ast);
        }
        name = ast.object.object.object.name;
        return {
          name,
          origin: 'user',
            signature: variableSignature,
            type: this.getVariableType(ast.object.object.object),
            zProperty: ast.object.object.property,
            yProperty: ast.object.property,
            xProperty: ast.property,
        };
      case 'value[][][][]':
        if (typeof ast.object.object.object.object.name !== 'string') {
          throw this.astErrorOutput('Unexpected expression', ast);
        }
        name = ast.object.object.object.object.name;
        return {
          name,
          origin: 'user',
            signature: variableSignature,
            type: this.getVariableType(ast.object.object.object.object),
            zProperty: ast.object.object.property,
            yProperty: ast.object.property,
            xProperty: ast.property,
        };
      case 'value.value':
        if (typeof ast.property.name !== 'string') {
          throw this.astErrorOutput('Unexpected expression', ast);
        }
        if (this.isAstMathVariable(ast)) {
          name = ast.property.name;
          return {
            name,
            origin: 'Math',
            type: 'Number',
            signature: variableSignature,
          };
        }
        switch (ast.property.name) {
          case 'r':
          case 'g':
          case 'b':
          case 'a':
            name = ast.object.name;
            return {
              name,
              property: ast.property.name,
                origin: 'user',
                signature: variableSignature,
                type: 'Number'
            };
          default:
            throw this.astErrorOutput('Unexpected expression', ast);
        }
        case 'this.constants.value':
          if (typeof ast.property.name !== 'string') {
            throw this.astErrorOutput('Unexpected expression', ast);
          }
          name = ast.property.name;
          type = this.getConstantType(name);
          if (!type) {
            throw this.astErrorOutput('Constant has no type', ast);
          }
          return {
            name,
            type,
            origin: 'constants',
              signature: variableSignature,
          };
        case 'this.constants.value[]':
          if (typeof ast.object.property.name !== 'string') {
            throw this.astErrorOutput('Unexpected expression', ast);
          }
          name = ast.object.property.name;
          type = this.getConstantType(name);
          if (!type) {
            throw this.astErrorOutput('Constant has no type', ast);
          }
          return {
            name,
            type,
            origin: 'constants',
              signature: variableSignature,
              xProperty: ast.property,
          };
        case 'this.constants.value[][]': {
          if (typeof ast.object.object.property.name !== 'string') {
            throw this.astErrorOutput('Unexpected expression', ast);
          }
          name = ast.object.object.property.name;
          type = this.getConstantType(name);
          if (!type) {
            throw this.astErrorOutput('Constant has no type', ast);
          }
          return {
            name,
            type,
            origin: 'constants',
            signature: variableSignature,
            yProperty: ast.object.property,
            xProperty: ast.property,
          };
        }
        case 'this.constants.value[][][]': {
          if (typeof ast.object.object.object.property.name !== 'string') {
            throw this.astErrorOutput('Unexpected expression', ast);
          }
          name = ast.object.object.object.property.name;
          type = this.getConstantType(name);
          if (!type) {
            throw this.astErrorOutput('Constant has no type', ast);
          }
          return {
            name,
            type,
            origin: 'constants',
            signature: variableSignature,
            zProperty: ast.object.object.property,
            yProperty: ast.object.property,
            xProperty: ast.property,
          };
        }
        case 'fn()[]':
        case 'fn()[][]':
        case '[][]':
          return {
            signature: variableSignature,
              property: ast.property,
          };
        default:
          throw this.astErrorOutput('Unexpected expression', ast);
    }
  }

  findIdentifierOrigin(astToFind) {
    const stack = [this.ast];

    while (stack.length > 0) {
      const atNode = stack[0];
      if (atNode.type === 'VariableDeclarator' && atNode.id && atNode.id.name && atNode.id.name === astToFind.name) {
        return atNode;
      }
      stack.shift();
      if (atNode.argument) {
        stack.push(atNode.argument);
      } else if (atNode.body) {
        stack.push(atNode.body);
      } else if (atNode.declarations) {
        stack.push(atNode.declarations);
      } else if (Array.isArray(atNode)) {
        for (let i = 0; i < atNode.length; i++) {
          stack.push(atNode[i]);
        }
      }
    }
    return null;
  }

  findLastReturn(ast) {
    const stack = [ast || this.ast];

    while (stack.length > 0) {
      const atNode = stack.pop();
      if (atNode.type === 'ReturnStatement') {
        return atNode;
      }
      if (atNode.type === 'FunctionDeclaration') {
        continue;
      }
      if (atNode.argument) {
        stack.push(atNode.argument);
      } else if (atNode.body) {
        stack.push(atNode.body);
      } else if (atNode.declarations) {
        stack.push(atNode.declarations);
      } else if (Array.isArray(atNode)) {
        for (let i = 0; i < atNode.length; i++) {
          stack.push(atNode[i]);
        }
      } else if (atNode.consequent) {
        stack.push(atNode.consequent);
      } else if (atNode.cases) {
        stack.push(atNode.cases);
      }
    }
    return null;
  }

  getInternalVariableName(name) {
    if (!this._internalVariableNames.hasOwnProperty(name)) {
      this._internalVariableNames[name] = 0;
    }
    this._internalVariableNames[name]++;
    if (this._internalVariableNames[name] === 1) {
      return name;
    }
    return name + this._internalVariableNames[name];
  }

  astKey(ast, separator = ',') {
    if (!ast.start || !ast.end) throw new Error('AST start and end needed');
    return `${ast.start}${separator}${ast.end}`;
  }
}

const typeLookupMap = {
  'Number': 'Number',
  'Float': 'Float',
  'Integer': 'Integer',
  'Array': 'Number',
  'Array(2)': 'Number',
  'Array(3)': 'Number',
  'Array(4)': 'Number',
  'Matrix(2)': 'Number',
  'Matrix(3)': 'Number',
  'Matrix(4)': 'Number',
  'Array2D': 'Number',
  'Array3D': 'Number',
  'Input': 'Number',
  'HTMLCanvas': 'Array(4)',
  'HTMLImage': 'Array(4)',
  'HTMLVideo': 'Array(4)',
  'HTMLImageArray': 'Array(4)',
  'NumberTexture': 'Number',
  'MemoryOptimizedNumberTexture': 'Number',
  'Array1D(2)': 'Array(2)',
  'Array1D(3)': 'Array(3)',
  'Array1D(4)': 'Array(4)',
  'Array2D(2)': 'Array(2)',
  'Array2D(3)': 'Array(3)',
  'Array2D(4)': 'Array(4)',
  'Array3D(2)': 'Array(2)',
  'Array3D(3)': 'Array(3)',
  'Array3D(4)': 'Array(4)',
  'ArrayTexture(1)': 'Number',
  'ArrayTexture(2)': 'Array(2)',
  'ArrayTexture(3)': 'Array(3)',
  'ArrayTexture(4)': 'Array(4)',
};

module.exports = {
  FunctionNode
};
},{"../utils":114,"./function-tracer":11,"acorn":1}],11:[function(require,module,exports){
const { utils } = require('../utils');

function last(array) {
  return array.length > 0 ? array[array.length - 1] : null;
}

const states = {
  trackIdentifiers: 'trackIdentifiers',
  memberExpression: 'memberExpression',
  inForLoopInit: 'inForLoopInit'
};

class FunctionTracer {
  constructor(ast) {
    this.runningContexts = [];
    this.functionContexts = [];
    this.contexts = [];
    this.functionCalls = [];
    this.declarations = [];
    this.identifiers = [];
    this.functions = [];
    this.returnStatements = [];
    this.trackedIdentifiers = null;
    this.states = [];
    this.newFunctionContext();
    this.scan(ast);
  }

  isState(state) {
    return this.states[this.states.length - 1] === state;
  }

  hasState(state) {
    return this.states.indexOf(state) > -1;
  }

  pushState(state) {
    this.states.push(state);
  }

  popState(state) {
    if (this.isState(state)) {
      this.states.pop();
    } else {
      throw new Error(`Cannot pop the non-active state "${state}"`);
    }
  }

  get currentFunctionContext() {
    return last(this.functionContexts);
  }

  get currentContext() {
    return last(this.runningContexts);
  }

  newFunctionContext() {
    const newContext = { '@contextType': 'function' };
    this.contexts.push(newContext);
    this.functionContexts.push(newContext);
  }

  newContext(run) {
    const newContext = Object.assign({ '@contextType': 'const/let' }, this.currentContext);
    this.contexts.push(newContext);
    this.runningContexts.push(newContext);
    run();
    const { currentFunctionContext } = this;
    for (const p in currentFunctionContext) {
      if (!currentFunctionContext.hasOwnProperty(p) || newContext.hasOwnProperty(p)) continue;
      newContext[p] = currentFunctionContext[p];
    }
    this.runningContexts.pop();
    return newContext;
  }

  useFunctionContext(run) {
    const functionContext = last(this.functionContexts);
    this.runningContexts.push(functionContext);
    run();
    this.runningContexts.pop();
  }

  getIdentifiers(run) {
    const trackedIdentifiers = this.trackedIdentifiers = [];
    this.pushState(states.trackIdentifiers);
    run();
    this.trackedIdentifiers = null;
    this.popState(states.trackIdentifiers);
    return trackedIdentifiers;
  }

  getDeclaration(name) {
    const { currentContext, currentFunctionContext, runningContexts } = this;
    const declaration = currentContext[name] || currentFunctionContext[name] || null;

    if (
      !declaration &&
      currentContext === currentFunctionContext &&
      runningContexts.length > 0
    ) {
      const previousRunningContext = runningContexts[runningContexts.length - 2];
      if (previousRunningContext[name]) {
        return previousRunningContext[name];
      }
    }

    return declaration;
  }

  scan(ast) {
    if (!ast) return;
    if (Array.isArray(ast)) {
      for (let i = 0; i < ast.length; i++) {
        this.scan(ast[i]);
      }
      return;
    }
    switch (ast.type) {
      case 'Program':
        this.useFunctionContext(() => {
          this.scan(ast.body);
        });
        break;
      case 'BlockStatement':
        this.newContext(() => {
          this.scan(ast.body);
        });
        break;
      case 'AssignmentExpression':
      case 'LogicalExpression':
        this.scan(ast.left);
        this.scan(ast.right);
        break;
      case 'BinaryExpression':
        this.scan(ast.left);
        this.scan(ast.right);
        break;
      case 'UpdateExpression':
        if (ast.operator === '++') {
          const declaration = this.getDeclaration(ast.argument.name);
          if (declaration) {
            declaration.suggestedType = 'Integer';
          }
        }
        this.scan(ast.argument);
        break;
      case 'UnaryExpression':
        this.scan(ast.argument);
        break;
      case 'VariableDeclaration':
        if (ast.kind === 'var') {
          this.useFunctionContext(() => {
            ast.declarations = utils.normalizeDeclarations(ast);
            this.scan(ast.declarations);
          });
        } else {
          ast.declarations = utils.normalizeDeclarations(ast);
          this.scan(ast.declarations);
        }
        break;
      case 'VariableDeclarator': {
        const { currentContext } = this;
        const inForLoopInit = this.hasState(states.inForLoopInit);
        const declaration = {
          ast: ast,
          context: currentContext,
          name: ast.id.name,
          origin: 'declaration',
          inForLoopInit,
          inForLoopTest: null,
          assignable: currentContext === this.currentFunctionContext || (!inForLoopInit && !currentContext.hasOwnProperty(ast.id.name)),
          suggestedType: null,
          valueType: null,
          dependencies: null,
          isSafe: null,
        };
        if (!currentContext[ast.id.name]) {
          currentContext[ast.id.name] = declaration;
        }
        this.declarations.push(declaration);
        this.scan(ast.id);
        this.scan(ast.init);
        break;
      }
      case 'FunctionExpression':
      case 'FunctionDeclaration':
        if (this.runningContexts.length === 0) {
          this.scan(ast.body);
        } else {
          this.functions.push(ast);
        }
        break;
      case 'IfStatement':
        this.scan(ast.test);
        this.scan(ast.consequent);
        if (ast.alternate) this.scan(ast.alternate);
        break;
      case 'ForStatement': {
        let testIdentifiers;
        const context = this.newContext(() => {
          this.pushState(states.inForLoopInit);
          this.scan(ast.init);
          this.popState(states.inForLoopInit);

          testIdentifiers = this.getIdentifiers(() => {
            this.scan(ast.test);
          });

          this.scan(ast.update);
          this.newContext(() => {
            this.scan(ast.body);
          });
        });

        if (testIdentifiers) {
          for (const p in context) {
            if (p === '@contextType') continue;
            if (testIdentifiers.indexOf(p) > -1) {
              context[p].inForLoopTest = true;
            }
          }
        }
        break;
      }
      case 'DoWhileStatement':
      case 'WhileStatement':
        this.newContext(() => {
          this.scan(ast.body);
          this.scan(ast.test);
        });
        break;
      case 'Identifier': {
        if (this.isState(states.trackIdentifiers)) {
          this.trackedIdentifiers.push(ast.name);
        }
        this.identifiers.push({
          context: this.currentContext,
          declaration: this.getDeclaration(ast.name),
          ast,
        });
        break;
      }
      case 'ReturnStatement':
        this.returnStatements.push(ast);
        this.scan(ast.argument);
        break;
      case 'MemberExpression':
        this.pushState(states.memberExpression);
        this.scan(ast.object);
        this.scan(ast.property);
        this.popState(states.memberExpression);
        break;
      case 'ExpressionStatement':
        this.scan(ast.expression);
        break;
      case 'SequenceExpression':
        this.scan(ast.expressions);
        break;
      case 'CallExpression':
        this.functionCalls.push({
          context: this.currentContext,
          ast,
        });
        this.scan(ast.arguments);
        break;
      case 'ArrayExpression':
        this.scan(ast.elements);
        break;
      case 'ConditionalExpression':
        this.scan(ast.test);
        this.scan(ast.alternate);
        this.scan(ast.consequent);
        break;
      case 'SwitchStatement':
        this.scan(ast.discriminant);
        this.scan(ast.cases);
        break;
      case 'SwitchCase':
        this.scan(ast.test);
        this.scan(ast.consequent);
        break;

      case 'ThisExpression':
      case 'Literal':
      case 'DebuggerStatement':
      case 'EmptyStatement':
      case 'BreakStatement':
      case 'ContinueStatement':
        break;
      default:
        throw new Error(`unhandled type "${ast.type}"`);
    }
  }
}

module.exports = {
  FunctionTracer,
};
},{"../utils":114}],12:[function(require,module,exports){
const { glWiretap } = require('gl-wiretap');
const { utils } = require('../../utils');

function toStringWithoutUtils(fn) {
  return fn.toString()
    .replace('=>', '')
    .replace(/^function /, '')
    .replace(/utils[.]/g, '/*utils.*/');
}

function glKernelString(Kernel, args, originKernel, setupContextString, destroyContextString) {
  if (!originKernel.built) {
    originKernel.build.apply(originKernel, args);
  }
  args = args ? Array.from(args).map(arg => {
    switch (typeof arg) {
      case 'boolean':
        return new Boolean(arg);
      case 'number':
        return new Number(arg);
      default:
        return arg;
    }
  }) : null;
  const uploadedValues = [];
  const postResult = [];
  const context = glWiretap(originKernel.context, {
    useTrackablePrimitives: true,
    onReadPixels: (targetName) => {
      if (kernel.subKernels) {
        if (!subKernelsResultVariableSetup) {
          postResult.push(`    const result = { result: ${getRenderString(targetName, kernel)} };`);
          subKernelsResultVariableSetup = true;
        } else {
          const property = kernel.subKernels[subKernelsResultIndex++].property;
          postResult.push(`    result${isNaN(property) ? '.' + property : `[${property}]`} = ${getRenderString(targetName, kernel)};`);
        }
        if (subKernelsResultIndex === kernel.subKernels.length) {
          postResult.push('    return result;');
        }
        return;
      }
      if (targetName) {
        postResult.push(`    return ${getRenderString(targetName, kernel)};`);
      } else {
        postResult.push(`    return null;`);
      }
    },
    onUnrecognizedArgumentLookup: (argument) => {
      const argumentName = findKernelValue(argument, kernel.kernelArguments, [], context, uploadedValues);
      if (argumentName) {
        return argumentName;
      }
      const constantName = findKernelValue(argument, kernel.kernelConstants, constants ? Object.keys(constants).map(key => constants[key]) : [], context, uploadedValues);
      if (constantName) {
        return constantName;
      }
      return null;
    }
  });
  let subKernelsResultVariableSetup = false;
  let subKernelsResultIndex = 0;
  const {
    source,
    canvas,
    output,
    pipeline,
    graphical,
    loopMaxIterations,
    constants,
    optimizeFloatMemory,
    precision,
    fixIntegerDivisionAccuracy,
    functions,
    nativeFunctions,
    subKernels,
    immutable,
    argumentTypes,
    constantTypes,
    kernelArguments,
    kernelConstants,
    tactic,
  } = originKernel;
  const kernel = new Kernel(source, {
    canvas,
    context,
    checkContext: false,
    output,
    pipeline,
    graphical,
    loopMaxIterations,
    constants,
    optimizeFloatMemory,
    precision,
    fixIntegerDivisionAccuracy,
    functions,
    nativeFunctions,
    subKernels,
    immutable,
    argumentTypes,
    constantTypes,
    tactic,
  });
  let result = [];
  context.setIndent(2);
  kernel.build.apply(kernel, args);
  result.push(context.toString());
  context.reset();

  kernel.kernelArguments.forEach((kernelArgument, i) => {
    switch (kernelArgument.type) {
      case 'Integer':
      case 'Boolean':
      case 'Number':
      case 'Float':
      case 'Array':
      case 'Array(2)':
      case 'Array(3)':
      case 'Array(4)':
      case 'HTMLCanvas':
      case 'HTMLImage':
      case 'HTMLVideo':
        context.insertVariable(`uploadValue_${kernelArgument.name}`, kernelArgument.uploadValue);
        break;
      case 'HTMLImageArray':
        for (let imageIndex = 0; imageIndex < args[i].length; imageIndex++) {
          const arg = args[i];
          context.insertVariable(`uploadValue_${kernelArgument.name}[${imageIndex}]`, arg[imageIndex]);
        }
        break;
      case 'Input':
        context.insertVariable(`uploadValue_${kernelArgument.name}`, kernelArgument.uploadValue);
        break;
      case 'MemoryOptimizedNumberTexture':
      case 'NumberTexture':
      case 'Array1D(2)':
      case 'Array1D(3)':
      case 'Array1D(4)':
      case 'Array2D(2)':
      case 'Array2D(3)':
      case 'Array2D(4)':
      case 'Array3D(2)':
      case 'Array3D(3)':
      case 'Array3D(4)':
      case 'ArrayTexture(1)':
      case 'ArrayTexture(2)':
      case 'ArrayTexture(3)':
      case 'ArrayTexture(4)':
        context.insertVariable(`uploadValue_${kernelArgument.name}`, args[i].texture);
        break;
      default:
        throw new Error(`unhandled kernelArgumentType insertion for glWiretap of type ${kernelArgument.type}`);
    }
  });
  result.push('/** start of injected functions **/');
  result.push(`function ${toStringWithoutUtils(utils.flattenTo)}`);
  result.push(`function ${toStringWithoutUtils(utils.flatten2dArrayTo)}`);
  result.push(`function ${toStringWithoutUtils(utils.flatten3dArrayTo)}`);
  result.push(`function ${toStringWithoutUtils(utils.flatten4dArrayTo)}`);
  result.push(`function ${toStringWithoutUtils(utils.isArray)}`);
  if (kernel.renderOutput !== kernel.renderTexture && kernel.formatValues) {
    result.push(
      `  const renderOutput = function ${toStringWithoutUtils(kernel.formatValues)};`
    );
  }
  result.push('/** end of injected functions **/');
  result.push(`  const innerKernel = function (${kernel.kernelArguments.map(kernelArgument => kernelArgument.varName).join(', ')}) {`);
  context.setIndent(4);
  kernel.run.apply(kernel, args);
  if (kernel.renderKernels) {
    kernel.renderKernels();
  } else if (kernel.renderOutput) {
    kernel.renderOutput();
  }
  result.push('    /** start setup uploads for kernel values **/');
  kernel.kernelArguments.forEach(kernelArgument => {
    result.push('    ' + kernelArgument.getStringValueHandler().split('\n').join('\n    '));
  });
  result.push('    /** end setup uploads for kernel values **/');
  result.push(context.toString());
  if (kernel.renderOutput === kernel.renderTexture) {
    context.reset();
    const framebufferName = context.getContextVariableName(kernel.framebuffer);
    if (kernel.renderKernels) {
      const results = kernel.renderKernels();
      const textureName = context.getContextVariableName(kernel.texture.texture);
      result.push(`    return {
      result: {
        texture: ${ textureName },
        type: '${ results.result.type }',
        toArray: ${ getToArrayString(results.result, textureName, framebufferName) }
      },`);
      const { subKernels, mappedTextures } = kernel;
      for (let i = 0; i < subKernels.length; i++) {
        const texture = mappedTextures[i];
        const subKernel = subKernels[i];
        const subKernelResult = results[subKernel.property];
        const subKernelTextureName = context.getContextVariableName(texture.texture);
        result.push(`
      ${subKernel.property}: {
        texture: ${ subKernelTextureName },
        type: '${ subKernelResult.type }',
        toArray: ${ getToArrayString(subKernelResult, subKernelTextureName, framebufferName) }
      },`);
      }
      result.push(`    };`);
    } else {
      const rendered = kernel.renderOutput();
      const textureName = context.getContextVariableName(kernel.texture.texture);
      result.push(`    return {
        texture: ${ textureName },
        type: '${ rendered.type }',
        toArray: ${ getToArrayString(rendered, textureName, framebufferName) }
      };`);
    }
  }
  result.push(`    ${destroyContextString ? '\n' + destroyContextString + '    ': ''}`);
  result.push(postResult.join('\n'));
  result.push('  };');
  if (kernel.graphical) {
    result.push(getGetPixelsString(kernel));
    result.push(`  innerKernel.getPixels = getPixels;`);
  }
  result.push('  return innerKernel;');

  let constantsUpload = [];
  kernelConstants.forEach((kernelConstant) => {
    constantsUpload.push(`${kernelConstant.getStringValueHandler()}`);
  });
  return `function kernel(settings) {
  const { context, constants } = settings;
  ${constantsUpload.join('')}
  ${setupContextString ? setupContextString : ''}
${result.join('\n')}
}`;
}

function getRenderString(targetName, kernel) {
  const readBackValue = kernel.precision === 'single' ? targetName : `new Float32Array(${targetName}.buffer)`;
  if (kernel.output[2]) {
    return `renderOutput(${readBackValue}, ${kernel.output[0]}, ${kernel.output[1]}, ${kernel.output[2]})`;
  }
  if (kernel.output[1]) {
    return `renderOutput(${readBackValue}, ${kernel.output[0]}, ${kernel.output[1]})`;
  }

  return `renderOutput(${readBackValue}, ${kernel.output[0]})`;
}

function getGetPixelsString(kernel) {
  const getPixels = kernel.getPixels.toString();
  const useFunctionKeyword = !/^function/.test(getPixels);
  return utils.flattenFunctionToString(`${useFunctionKeyword ? 'function ' : ''}${ getPixels }`, {
    findDependency: (object, name) => {
      if (object === 'utils') {
        return `const ${name} = ${utils[name].toString()};`;
      }
      return null;
    },
    thisLookup: (property) => {
      if (property === 'context') {
        return null;
      }
      if (kernel.hasOwnProperty(property)) {
        return JSON.stringify(kernel[property]);
      }
      throw new Error(`unhandled thisLookup ${ property }`);
    }
  });
}

function getToArrayString(kernelResult, textureName, framebufferName) {
  const toArray = kernelResult.toArray.toString();
  const useFunctionKeyword = !/^function/.test(toArray);
  const flattenedFunctions = utils.flattenFunctionToString(`${useFunctionKeyword ? 'function ' : ''}${ toArray }`, {
    findDependency: (object, name) => {
      if (object === 'utils') {
        return `const ${name} = ${utils[name].toString()};`;
      } else if (object === 'this') {
        if (name === 'framebuffer') {
          return '';
        }
        return `${useFunctionKeyword ? 'function ' : ''}${kernelResult[name].toString()}`;
      } else {
        throw new Error('unhandled fromObject');
      }
    },
    thisLookup: (property, isDeclaration) => {
      if (property === 'texture') {
        return textureName;
      }
      if (property === 'context') {
        if (isDeclaration) return null;
        return 'gl';
      }
      if (kernelResult.hasOwnProperty(property)) {
        return JSON.stringify(kernelResult[property]);
      }
      throw new Error(`unhandled thisLookup ${ property }`);
    }
  });
  return `() => {
  function framebuffer() { return ${framebufferName}; };
  ${flattenedFunctions}
  return toArray();
  }`;
}

function findKernelValue(argument, kernelValues, values, context, uploadedValues) {
  if (argument === null) return null;
  if (kernelValues === null) return null;
  switch (typeof argument) {
    case 'boolean':
    case 'number':
      return null;
  }
  if (
    typeof HTMLImageElement !== 'undefined' &&
    argument instanceof HTMLImageElement
  ) {
    for (let i = 0; i < kernelValues.length; i++) {
      const kernelValue = kernelValues[i];
      if (kernelValue.type !== 'HTMLImageArray' && kernelValue) continue;
      if (kernelValue.uploadValue !== argument) continue;
      const variableIndex = values[i].indexOf(argument);
      if (variableIndex === -1) continue;
      const variableName = `uploadValue_${kernelValue.name}[${variableIndex}]`;
      context.insertVariable(variableName, argument);
      return variableName;
    }
  }

  for (let i = 0; i < kernelValues.length; i++) {
    const kernelValue = kernelValues[i];
    if (argument !== kernelValue.uploadValue) continue;
    const variable = `uploadValue_${kernelValue.name}`;
    context.insertVariable(variable, kernelValue);
    return variable;
  }
  return null;
}

module.exports = {
  glKernelString
};
},{"../../utils":114,"gl-wiretap":3}],13:[function(require,module,exports){
const { Kernel } = require('../kernel');
const { utils } = require('../../utils');
const { GLTextureArray2Float } = require('./texture/array-2-float');
const { GLTextureArray2Float2D } = require('./texture/array-2-float-2d');
const { GLTextureArray2Float3D } = require('./texture/array-2-float-3d');
const { GLTextureArray3Float } = require('./texture/array-3-float');
const { GLTextureArray3Float2D } = require('./texture/array-3-float-2d');
const { GLTextureArray3Float3D } = require('./texture/array-3-float-3d');
const { GLTextureArray4Float } = require('./texture/array-4-float');
const { GLTextureArray4Float2D } = require('./texture/array-4-float-2d');
const { GLTextureArray4Float3D } = require('./texture/array-4-float-3d');
const { GLTextureFloat } = require('./texture/float');
const { GLTextureFloat2D } = require('./texture/float-2d');
const { GLTextureFloat3D } = require('./texture/float-3d');
const { GLTextureMemoryOptimized } = require('./texture/memory-optimized');
const { GLTextureMemoryOptimized2D } = require('./texture/memory-optimized-2d');
const { GLTextureMemoryOptimized3D } = require('./texture/memory-optimized-3d');
const { GLTextureUnsigned } = require('./texture/unsigned');
const { GLTextureUnsigned2D } = require('./texture/unsigned-2d');
const { GLTextureUnsigned3D } = require('./texture/unsigned-3d');
const { GLTextureGraphical } = require('./texture/graphical');

class GLKernel extends Kernel {
  static get mode() {
    return 'gpu';
  }

  static getIsFloatRead() {
    const kernelString = `function kernelFunction() {
      return 1;
    }`;
    const kernel = new this(kernelString, {
      context: this.testContext,
      canvas: this.testCanvas,
      validate: false,
      output: [1],
      precision: 'single',
      returnType: 'Number',
      tactic: 'speed',
    });
    kernel.build();
    kernel.run();
    const result = kernel.renderOutput();
    kernel.destroy(true);
    return result[0] === 1;
  }

  static getIsIntegerDivisionAccurate() {
    function kernelFunction(v1, v2) {
      return v1[this.thread.x] / v2[this.thread.x];
    }
    const kernel = new this(kernelFunction.toString(), {
      context: this.testContext,
      canvas: this.testCanvas,
      validate: false,
      output: [2],
      returnType: 'Number',
      precision: 'unsigned',
      tactic: 'speed',
    });
    const args = [
      [6, 6030401],
      [3, 3991]
    ];
    kernel.build.apply(kernel, args);
    kernel.run.apply(kernel, args);
    const result = kernel.renderOutput();
    kernel.destroy(true);
    return result[0] === 2 && result[1] === 1511;
  }

  static getIsSpeedTacticSupported() {
    function kernelFunction(value) {
      return value[this.thread.x];
    }
    const kernel = new this(kernelFunction.toString(), {
      context: this.testContext,
      canvas: this.testCanvas,
      validate: false,
      output: [4],
      returnType: 'Number',
      precision: 'unsigned',
      tactic: 'speed',
    });
    const args = [
      [0, 1, 2, 3]
    ];
    kernel.build.apply(kernel, args);
    kernel.run.apply(kernel, args);
    const result = kernel.renderOutput();
    kernel.destroy(true);
    return Math.round(result[0]) === 0 && Math.round(result[1]) === 1 && Math.round(result[2]) === 2 && Math.round(result[3]) === 3;
  }

  static get testCanvas() {
    throw new Error(`"testCanvas" not defined on ${ this.name }`);
  }

  static get testContext() {
    throw new Error(`"testContext" not defined on ${ this.name }`);
  }

  static getFeatures() {
    const gl = this.testContext;
    const isDrawBuffers = this.getIsDrawBuffers();
    return Object.freeze({
      isFloatRead: this.getIsFloatRead(),
      isIntegerDivisionAccurate: this.getIsIntegerDivisionAccurate(),
      isSpeedTacticSupported: this.getIsSpeedTacticSupported(),
      isTextureFloat: this.getIsTextureFloat(),
      isDrawBuffers,
      kernelMap: isDrawBuffers,
      channelCount: this.getChannelCount(),
      maxTextureSize: this.getMaxTextureSize(),
      lowIntPrecision: gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.LOW_INT),
      lowFloatPrecision: gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.LOW_FLOAT),
      mediumIntPrecision: gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_INT),
      mediumFloatPrecision: gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT),
      highIntPrecision: gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_INT),
      highFloatPrecision: gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT),
    });
  }

  static setupFeatureChecks() {
    throw new Error(`"setupFeatureChecks" not defined on ${ this.name }`);
  }

  static getSignature(kernel, argumentTypes) {
    return kernel.getVariablePrecisionString() + (argumentTypes.length > 0 ? ':' + argumentTypes.join(',') : '');
  }

  setFixIntegerDivisionAccuracy(fix) {
    this.fixIntegerDivisionAccuracy = fix;
    return this;
  }

  setPrecision(flag) {
    this.precision = flag;
    return this;
  }

  setFloatTextures(flag) {
    utils.warnDeprecated('method', 'setFloatTextures', 'setOptimizeFloatMemory');
    this.floatTextures = flag;
    return this;
  }

  static nativeFunctionArguments(source) {
    const argumentTypes = [];
    const argumentNames = [];
    const states = [];
    const isStartingVariableName = /^[a-zA-Z_]/;
    const isVariableChar = /[a-zA-Z_0-9]/;
    let i = 0;
    let argumentName = null;
    let argumentType = null;
    while (i < source.length) {
      const char = source[i];
      const nextChar = source[i + 1];
      const state = states.length > 0 ? states[states.length - 1] : null;

      if (state === 'FUNCTION_ARGUMENTS' && char === '/' && nextChar === '*') {
        states.push('MULTI_LINE_COMMENT');
        i += 2;
        continue;
      } else if (state === 'MULTI_LINE_COMMENT' && char === '*' && nextChar === '/') {
        states.pop();
        i += 2;
        continue;
      }

      else if (state === 'FUNCTION_ARGUMENTS' && char === '/' && nextChar === '/') {
        states.push('COMMENT');
        i += 2;
        continue;
      } else if (state === 'COMMENT' && char === '\n') {
        states.pop();
        i++;
        continue;
      }

      else if (state === null && char === '(') {
        states.push('FUNCTION_ARGUMENTS');
        i++;
        continue;
      } else if (state === 'FUNCTION_ARGUMENTS') {
        if (char === ')') {
          states.pop();
          break;
        }
        if (char === 'f' && nextChar === 'l' && source[i + 2] === 'o' && source[i + 3] === 'a' && source[i + 4] === 't' && source[i + 5] === ' ') {
          states.push('DECLARE_VARIABLE');
          argumentType = 'float';
          argumentName = '';
          i += 6;
          continue;
        } else if (char === 'i' && nextChar === 'n' && source[i + 2] === 't' && source[i + 3] === ' ') {
          states.push('DECLARE_VARIABLE');
          argumentType = 'int';
          argumentName = '';
          i += 4;
          continue;
        } else if (char === 'v' && nextChar === 'e' && source[i + 2] === 'c' && source[i + 3] === '2' && source[i + 4] === ' ') {
          states.push('DECLARE_VARIABLE');
          argumentType = 'vec2';
          argumentName = '';
          i += 5;
          continue;
        } else if (char === 'v' && nextChar === 'e' && source[i + 2] === 'c' && source[i + 3] === '3' && source[i + 4] === ' ') {
          states.push('DECLARE_VARIABLE');
          argumentType = 'vec3';
          argumentName = '';
          i += 5;
          continue;
        } else if (char === 'v' && nextChar === 'e' && source[i + 2] === 'c' && source[i + 3] === '4' && source[i + 4] === ' ') {
          states.push('DECLARE_VARIABLE');
          argumentType = 'vec4';
          argumentName = '';
          i += 5;
          continue;
        }
      }

      else if (state === 'DECLARE_VARIABLE') {
        if (argumentName === '') {
          if (char === ' ') {
            i++;
            continue;
          }
          if (!isStartingVariableName.test(char)) {
            throw new Error('variable name is not expected string');
          }
        }
        argumentName += char;
        if (!isVariableChar.test(nextChar)) {
          states.pop();
          argumentNames.push(argumentName);
          argumentTypes.push(typeMap[argumentType]);
        }
      }

      i++;
    }
    if (states.length > 0) {
      throw new Error('GLSL function was not parsable');
    }
    return {
      argumentNames,
      argumentTypes,
    };
  }

  static nativeFunctionReturnType(source) {
    return typeMap[source.match(/int|float|vec[2-4]/)[0]];
  }

  static combineKernels(combinedKernel, lastKernel) {
    combinedKernel.apply(null, arguments);
    const {
      texSize,
      context,
      threadDim
    } = lastKernel.texSize;
    let result;
    if (lastKernel.precision === 'single') {
      const w = texSize[0];
      const h = Math.ceil(texSize[1] / 4);
      result = new Float32Array(w * h * 4 * 4);
      context.readPixels(0, 0, w, h * 4, context.RGBA, context.FLOAT, result);
    } else {
      const bytes = new Uint8Array(texSize[0] * texSize[1] * 4);
      context.readPixels(0, 0, texSize[0], texSize[1], context.RGBA, context.UNSIGNED_BYTE, bytes);
      result = new Float32Array(bytes.buffer);
    }

    result = result.subarray(0, threadDim[0] * threadDim[1] * threadDim[2]);

    if (lastKernel.output.length === 1) {
      return result;
    } else if (lastKernel.output.length === 2) {
      return utils.splitArray(result, lastKernel.output[0]);
    } else if (lastKernel.output.length === 3) {
      const cube = utils.splitArray(result, lastKernel.output[0] * lastKernel.output[1]);
      return cube.map(function(x) {
        return utils.splitArray(x, lastKernel.output[0]);
      });
    }
  }

  constructor(source, settings) {
    super(source, settings);
    this.transferValues = null;
    this.formatValues = null;
    this.TextureConstructor = null;
    this.renderOutput = null;
    this.renderRawOutput = null;
    this.texSize = null;
    this.translatedSource = null;
    this.compiledFragmentShader = null;
    this.compiledVertexShader = null;
    this.switchingKernels = null;
    this._textureSwitched = null;
    this._mappedTextureSwitched = null;
  }

  checkTextureSize() {
    const { features } = this.constructor;
    if (this.texSize[0] > features.maxTextureSize || this.texSize[1] > features.maxTextureSize) {
      throw new Error(`Texture size [${this.texSize[0]},${this.texSize[1]}] generated by kernel is larger than supported size [${features.maxTextureSize},${features.maxTextureSize}]`);
    }
  }

  translateSource() {
    throw new Error(`"translateSource" not defined on ${this.constructor.name}`);
  }

  pickRenderStrategy(args) {
    if (this.graphical) {
      this.renderRawOutput = this.readPackedPixelsToUint8Array;
      this.transferValues = (pixels) => pixels;
      this.TextureConstructor = GLTextureGraphical;
      return null;
    }
    if (this.precision === 'unsigned') {
      this.renderRawOutput = this.readPackedPixelsToUint8Array;
      this.transferValues = this.readPackedPixelsToFloat32Array;
      if (this.pipeline) {
        this.renderOutput = this.renderTexture;
        if (this.subKernels !== null) {
          this.renderKernels = this.renderKernelsToTextures;
        }
        switch (this.returnType) {
          case 'LiteralInteger':
          case 'Float':
          case 'Number':
          case 'Integer':
            if (this.output[2] > 0) {
              this.TextureConstructor = GLTextureUnsigned3D;
              return null;
            } else if (this.output[1] > 0) {
              this.TextureConstructor = GLTextureUnsigned2D;
              return null;
            } else {
              this.TextureConstructor = GLTextureUnsigned;
              return null;
            }
            case 'Array(2)':
            case 'Array(3)':
            case 'Array(4)':
              return this.requestFallback(args);
        }
      } else {
        if (this.subKernels !== null) {
          this.renderKernels = this.renderKernelsToArrays;
        }
        switch (this.returnType) {
          case 'LiteralInteger':
          case 'Float':
          case 'Number':
          case 'Integer':
            this.renderOutput = this.renderValues;
            if (this.output[2] > 0) {
              this.TextureConstructor = GLTextureUnsigned3D;
              this.formatValues = utils.erect3DPackedFloat;
              return null;
            } else if (this.output[1] > 0) {
              this.TextureConstructor = GLTextureUnsigned2D;
              this.formatValues = utils.erect2DPackedFloat;
              return null;
            } else {
              this.TextureConstructor = GLTextureUnsigned;
              this.formatValues = utils.erectPackedFloat;
              return null;
            }
            case 'Array(2)':
            case 'Array(3)':
            case 'Array(4)':
              return this.requestFallback(args);
        }
      }
    } else if (this.precision === 'single') {
      this.renderRawOutput = this.readFloatPixelsToFloat32Array;
      this.transferValues = this.readFloatPixelsToFloat32Array;
      if (this.pipeline) {
        this.renderOutput = this.renderTexture;
        if (this.subKernels !== null) {
          this.renderKernels = this.renderKernelsToTextures;
        }
        switch (this.returnType) {
          case 'LiteralInteger':
          case 'Float':
          case 'Number':
          case 'Integer': {
            if (this.optimizeFloatMemory) {
              if (this.output[2] > 0) {
                this.TextureConstructor = GLTextureMemoryOptimized3D;
                return null;
              } else if (this.output[1] > 0) {
                this.TextureConstructor = GLTextureMemoryOptimized2D;
                return null;
              } else {
                this.TextureConstructor = GLTextureMemoryOptimized;
                return null;
              }
            } else {
              if (this.output[2] > 0) {
                this.TextureConstructor = GLTextureFloat3D;
                return null;
              } else if (this.output[1] > 0) {
                this.TextureConstructor = GLTextureFloat2D;
                return null;
              } else {
                this.TextureConstructor = GLTextureFloat;
                return null;
              }
            }
          }
          case 'Array(2)': {
            if (this.output[2] > 0) {
              this.TextureConstructor = GLTextureArray2Float3D;
              return null;
            } else if (this.output[1] > 0) {
              this.TextureConstructor = GLTextureArray2Float2D;
              return null;
            } else {
              this.TextureConstructor = GLTextureArray2Float;
              return null;
            }
          }
          case 'Array(3)': {
            if (this.output[2] > 0) {
              this.TextureConstructor = GLTextureArray3Float3D;
              return null;
            } else if (this.output[1] > 0) {
              this.TextureConstructor = GLTextureArray3Float2D;
              return null;
            } else {
              this.TextureConstructor = GLTextureArray3Float;
              return null;
            }
          }
          case 'Array(4)': {
            if (this.output[2] > 0) {
              this.TextureConstructor = GLTextureArray4Float3D;
              return null;
            } else if (this.output[1] > 0) {
              this.TextureConstructor = GLTextureArray4Float2D;
              return null;
            } else {
              this.TextureConstructor = GLTextureArray4Float;
              return null;
            }
          }
        }
      }
      this.renderOutput = this.renderValues;
      if (this.subKernels !== null) {
        this.renderKernels = this.renderKernelsToArrays;
      }
      if (this.optimizeFloatMemory) {
        switch (this.returnType) {
          case 'LiteralInteger':
          case 'Float':
          case 'Number':
          case 'Integer': {
            if (this.output[2] > 0) {
              this.TextureConstructor = GLTextureMemoryOptimized3D;
              this.formatValues = utils.erectMemoryOptimized3DFloat;
              return null;
            } else if (this.output[1] > 0) {
              this.TextureConstructor = GLTextureMemoryOptimized2D;
              this.formatValues = utils.erectMemoryOptimized2DFloat;
              return null;
            } else {
              this.TextureConstructor = GLTextureMemoryOptimized;
              this.formatValues = utils.erectMemoryOptimizedFloat;
              return null;
            }
          }
          case 'Array(2)': {
            if (this.output[2] > 0) {
              this.TextureConstructor = GLTextureArray2Float3D;
              this.formatValues = utils.erect3DArray2;
              return null;
            } else if (this.output[1] > 0) {
              this.TextureConstructor = GLTextureArray2Float2D;
              this.formatValues = utils.erect2DArray2;
              return null;
            } else {
              this.TextureConstructor = GLTextureArray2Float;
              this.formatValues = utils.erectArray2;
              return null;
            }
          }
          case 'Array(3)': {
            if (this.output[2] > 0) {
              this.TextureConstructor = GLTextureArray3Float3D;
              this.formatValues = utils.erect3DArray3;
              return null;
            } else if (this.output[1] > 0) {
              this.TextureConstructor = GLTextureArray3Float2D;
              this.formatValues = utils.erect2DArray3;
              return null;
            } else {
              this.TextureConstructor = GLTextureArray3Float;
              this.formatValues = utils.erectArray3;
              return null;
            }
          }
          case 'Array(4)': {
            if (this.output[2] > 0) {
              this.TextureConstructor = GLTextureArray4Float3D;
              this.formatValues = utils.erect3DArray4;
              return null;
            } else if (this.output[1] > 0) {
              this.TextureConstructor = GLTextureArray4Float2D;
              this.formatValues = utils.erect2DArray4;
              return null;
            } else {
              this.TextureConstructor = GLTextureArray4Float;
              this.formatValues = utils.erectArray4;
              return null;
            }
          }
        }
      } else {
        switch (this.returnType) {
          case 'LiteralInteger':
          case 'Float':
          case 'Number':
          case 'Integer': {
            if (this.output[2] > 0) {
              this.TextureConstructor = GLTextureFloat3D;
              this.formatValues = utils.erect3DFloat;
              return null;
            } else if (this.output[1] > 0) {
              this.TextureConstructor = GLTextureFloat2D;
              this.formatValues = utils.erect2DFloat;
              return null;
            } else {
              this.TextureConstructor = GLTextureFloat;
              this.formatValues = utils.erectFloat;
              return null;
            }
          }
          case 'Array(2)': {
            if (this.output[2] > 0) {
              this.TextureConstructor = GLTextureArray2Float3D;
              this.formatValues = utils.erect3DArray2;
              return null;
            } else if (this.output[1] > 0) {
              this.TextureConstructor = GLTextureArray2Float2D;
              this.formatValues = utils.erect2DArray2;
              return null;
            } else {
              this.TextureConstructor = GLTextureArray2Float;
              this.formatValues = utils.erectArray2;
              return null;
            }
          }
          case 'Array(3)': {
            if (this.output[2] > 0) {
              this.TextureConstructor = GLTextureArray3Float3D;
              this.formatValues = utils.erect3DArray3;
              return null;
            } else if (this.output[1] > 0) {
              this.TextureConstructor = GLTextureArray3Float2D;
              this.formatValues = utils.erect2DArray3;
              return null;
            } else {
              this.TextureConstructor = GLTextureArray3Float;
              this.formatValues = utils.erectArray3;
              return null;
            }
          }
          case 'Array(4)': {
            if (this.output[2] > 0) {
              this.TextureConstructor = GLTextureArray4Float3D;
              this.formatValues = utils.erect3DArray4;
              return null;
            } else if (this.output[1] > 0) {
              this.TextureConstructor = GLTextureArray4Float2D;
              this.formatValues = utils.erect2DArray4;
              return null;
            } else {
              this.TextureConstructor = GLTextureArray4Float;
              this.formatValues = utils.erectArray4;
              return null;
            }
          }
        }
      }
    } else {
      throw new Error(`unhandled precision of "${this.precision}"`);
    }

    throw new Error(`unhandled return type "${this.returnType}"`);
  }

  getKernelString() {
    throw new Error(`abstract method call`);
  }

  getMainResultTexture() {
    switch (this.returnType) {
      case 'LiteralInteger':
      case 'Float':
      case 'Integer':
      case 'Number':
        return this.getMainResultNumberTexture();
      case 'Array(2)':
        return this.getMainResultArray2Texture();
      case 'Array(3)':
        return this.getMainResultArray3Texture();
      case 'Array(4)':
        return this.getMainResultArray4Texture();
      default:
        throw new Error(`unhandled returnType type ${ this.returnType }`);
    }
  }

  getMainResultKernelNumberTexture() {
    throw new Error(`abstract method call`);
  }
  getMainResultSubKernelNumberTexture() {
    throw new Error(`abstract method call`);
  }
  getMainResultKernelArray2Texture() {
    throw new Error(`abstract method call`);
  }
  getMainResultSubKernelArray2Texture() {
    throw new Error(`abstract method call`);
  }
  getMainResultKernelArray3Texture() {
    throw new Error(`abstract method call`);
  }
  getMainResultSubKernelArray3Texture() {
    throw new Error(`abstract method call`);
  }
  getMainResultKernelArray4Texture() {
    throw new Error(`abstract method call`);
  }
  getMainResultSubKernelArray4Texture() {
    throw new Error(`abstract method call`);
  }
  getMainResultGraphical() {
    throw new Error(`abstract method call`);
  }
  getMainResultMemoryOptimizedFloats() {
    throw new Error(`abstract method call`);
  }
  getMainResultPackedPixels() {
    throw new Error(`abstract method call`);
  }

  getMainResultString() {
    if (this.graphical) {
      return this.getMainResultGraphical();
    } else if (this.precision === 'single') {
      if (this.optimizeFloatMemory) {
        return this.getMainResultMemoryOptimizedFloats();
      }
      return this.getMainResultTexture();
    } else {
      return this.getMainResultPackedPixels();
    }
  }

  getMainResultNumberTexture() {
    return utils.linesToString(this.getMainResultKernelNumberTexture()) +
      utils.linesToString(this.getMainResultSubKernelNumberTexture());
  }

  getMainResultArray2Texture() {
    return utils.linesToString(this.getMainResultKernelArray2Texture()) +
      utils.linesToString(this.getMainResultSubKernelArray2Texture());
  }

  getMainResultArray3Texture() {
    return utils.linesToString(this.getMainResultKernelArray3Texture()) +
      utils.linesToString(this.getMainResultSubKernelArray3Texture());
  }

  getMainResultArray4Texture() {
    return utils.linesToString(this.getMainResultKernelArray4Texture()) +
      utils.linesToString(this.getMainResultSubKernelArray4Texture());
  }

  getFloatTacticDeclaration() {
    const variablePrecision = this.getVariablePrecisionString(this.texSize, this.tactic);
    return `precision ${variablePrecision} float;\n`;
  }

  getIntTacticDeclaration() {
    return `precision ${this.getVariablePrecisionString(this.texSize, this.tactic, true)} int;\n`;
  }

  getSampler2DTacticDeclaration() {
    return `precision ${this.getVariablePrecisionString(this.texSize, this.tactic)} sampler2D;\n`;
  }

  getSampler2DArrayTacticDeclaration() {
    return `precision ${this.getVariablePrecisionString(this.texSize, this.tactic)} sampler2DArray;\n`;
  }

  renderTexture() {
    return this.immutable ? this.texture.clone() : this.texture;
  }
  readPackedPixelsToUint8Array() {
    if (this.precision !== 'unsigned') throw new Error('Requires this.precision to be "unsigned"');
    const {
      texSize,
      context: gl
    } = this;
    const result = new Uint8Array(texSize[0] * texSize[1] * 4);
    gl.readPixels(0, 0, texSize[0], texSize[1], gl.RGBA, gl.UNSIGNED_BYTE, result);
    return result;
  }

  readPackedPixelsToFloat32Array() {
    return new Float32Array(this.readPackedPixelsToUint8Array().buffer);
  }

  readFloatPixelsToFloat32Array() {
    if (this.precision !== 'single') throw new Error('Requires this.precision to be "single"');
    const {
      texSize,
      context: gl
    } = this;
    const w = texSize[0];
    const h = texSize[1];
    const result = new Float32Array(w * h * 4);
    gl.readPixels(0, 0, w, h, gl.RGBA, gl.FLOAT, result);
    return result;
  }

  getPixels(flip) {
    const {
      context: gl,
      output
    } = this;
    const [width, height] = output;
    const pixels = new Uint8Array(width * height * 4);
    gl.readPixels(0, 0, width, height, gl.RGBA, gl.UNSIGNED_BYTE, pixels);
    return new Uint8ClampedArray((flip ? pixels : utils.flipPixels(pixels, width, height)).buffer);
  }

  renderKernelsToArrays() {
    const result = {
      result: this.renderOutput(),
    };
    for (let i = 0; i < this.subKernels.length; i++) {
      result[this.subKernels[i].property] = this.mappedTextures[i].toArray();
    }
    return result;
  }

  renderKernelsToTextures() {
    const result = {
      result: this.renderOutput(),
    };
    if (this.immutable) {
      for (let i = 0; i < this.subKernels.length; i++) {
        result[this.subKernels[i].property] = this.mappedTextures[i].clone();
      }
    } else {
      for (let i = 0; i < this.subKernels.length; i++) {
        result[this.subKernels[i].property] = this.mappedTextures[i];
      }
    }
    return result;
  }

  resetSwitchingKernels() {
    const existingValue = this.switchingKernels;
    this.switchingKernels = null;
    return existingValue;
  }

  setOutput(output) {
    const newOutput = this.toKernelOutput(output);
    if (this.program) {
      if (!this.dynamicOutput) {
        throw new Error('Resizing a kernel with dynamicOutput: false is not possible');
      }
      const newThreadDim = [newOutput[0], newOutput[1] || 1, newOutput[2] || 1];
      const newTexSize = utils.getKernelTextureSize({
        optimizeFloatMemory: this.optimizeFloatMemory,
        precision: this.precision,
      }, newThreadDim);
      const oldTexSize = this.texSize;
      if (oldTexSize) {
        const oldPrecision = this.getVariablePrecisionString(oldTexSize, this.tactic);
        const newPrecision = this.getVariablePrecisionString(newTexSize, this.tactic);
        if (oldPrecision !== newPrecision) {
          if (this.debug) {
            console.warn('Precision requirement changed, asking GPU instance to recompile');
          }
          this.switchKernels({
            type: 'outputPrecisionMismatch',
            precision: newPrecision,
            needed: output
          });
          return;
        }
      }
      this.output = newOutput;
      this.threadDim = newThreadDim;
      this.texSize = newTexSize;
      const { context: gl } = this;
      gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer);
      this.updateMaxTexSize();
      this.framebuffer.width = this.texSize[0];
      this.framebuffer.height = this.texSize[1];
      gl.viewport(0, 0, this.maxTexSize[0], this.maxTexSize[1]);
      this.canvas.width = this.maxTexSize[0];
      this.canvas.height = this.maxTexSize[1];
      if (this.texture) {
        this.texture.delete();
      }
      this.texture = null;
      this._setupOutputTexture();
      if (this.mappedTextures && this.mappedTextures.length > 0) {
        for (let i = 0; i < this.mappedTextures.length; i++) {
          this.mappedTextures[i].delete();
        }
        this.mappedTextures = null;
        this._setupSubOutputTextures();
      }
    } else {
      this.output = newOutput;
    }
    return this;
  }
  renderValues() {
    return this.formatValues(
      this.transferValues(),
      this.output[0],
      this.output[1],
      this.output[2]
    );
  }
  switchKernels(reason) {
    if (this.switchingKernels) {
      this.switchingKernels.push(reason);
    } else {
      this.switchingKernels = [reason];
    }
  }
  getVariablePrecisionString(textureSize = this.texSize, tactic = this.tactic, isInt = false) {
    if (!tactic) {
      if (!this.constructor.features.isSpeedTacticSupported) return 'highp';
      const low = this.constructor.features[isInt ? 'lowIntPrecision' : 'lowFloatPrecision'];
      const medium = this.constructor.features[isInt ? 'mediumIntPrecision' : 'mediumFloatPrecision'];
      const high = this.constructor.features[isInt ? 'highIntPrecision' : 'highFloatPrecision'];
      const requiredSize = Math.log2(textureSize[0] * textureSize[1]);
      if (requiredSize <= low.rangeMax) {
        return 'lowp';
      } else if (requiredSize <= medium.rangeMax) {
        return 'mediump';
      } else if (requiredSize <= high.rangeMax) {
        return 'highp';
      } else {
        throw new Error(`The required size exceeds that of the ability of your system`);
      }
    }
    switch (tactic) {
      case 'speed':
        return 'lowp';
      case 'balanced':
        return 'mediump';
      case 'precision':
        return 'highp';
      default:
        throw new Error(`Unknown tactic "${tactic}" use "speed", "balanced", "precision", or empty for auto`);
    }
  }

  updateTextureArgumentRefs(kernelValue, arg) {
    if (!this.immutable) return;
    if (this.texture.texture === arg.texture) {
      const { prevArg } = kernelValue;
      if (prevArg) {
        if (prevArg.texture._refs === 1) {
          this.texture.delete();
          this.texture = prevArg.clone();
          this._textureSwitched = true;
        }
        prevArg.delete();
      }
      kernelValue.prevArg = arg.clone();
    } else if (this.mappedTextures && this.mappedTextures.length > 0) {
      const { mappedTextures } = this;
      for (let i = 0; i < mappedTextures.length; i++) {
        const mappedTexture = mappedTextures[i];
        if (mappedTexture.texture === arg.texture) {
          const { prevArg } = kernelValue;
          if (prevArg) {
            if (prevArg.texture._refs === 1) {
              mappedTexture.delete();
              mappedTextures[i] = prevArg.clone();
              this._mappedTextureSwitched[i] = true;
            }
            prevArg.delete();
          }
          kernelValue.prevArg = arg.clone();
          return;
        }
      }
    }
  }

  onActivate(previousKernel) {
    this._textureSwitched = true;
    this.texture = previousKernel.texture;
    if (this.mappedTextures) {
      for (let i = 0; i < this.mappedTextures.length; i++) {
        this._mappedTextureSwitched[i] = true;
      }
      this.mappedTextures = previousKernel.mappedTextures;
    }
  }

  initCanvas() {}
}

const typeMap = {
  int: 'Integer',
  float: 'Number',
  vec2: 'Array(2)',
  vec3: 'Array(3)',
  vec4: 'Array(4)',
};

module.exports = {
  GLKernel
};
},{"../../utils":114,"../kernel":36,"./texture/array-2-float":16,"./texture/array-2-float-2d":14,"./texture/array-2-float-3d":15,"./texture/array-3-float":19,"./texture/array-3-float-2d":17,"./texture/array-3-float-3d":18,"./texture/array-4-float":22,"./texture/array-4-float-2d":20,"./texture/array-4-float-3d":21,"./texture/float":25,"./texture/float-2d":23,"./texture/float-3d":24,"./texture/graphical":26,"./texture/memory-optimized":30,"./texture/memory-optimized-2d":28,"./texture/memory-optimized-3d":29,"./texture/unsigned":33,"./texture/unsigned-2d":31,"./texture/unsigned-3d":32}],14:[function(require,module,exports){
const { utils } = require('../../../utils');
const { GLTextureFloat } = require('./float');

class GLTextureArray2Float2D extends GLTextureFloat {
  constructor(settings) {
    super(settings);
    this.type = 'ArrayTexture(2)';
  }
  toArray() {
    return utils.erect2DArray2(this.renderValues(), this.output[0], this.output[1]);
  }
}

module.exports = {
  GLTextureArray2Float2D
};
},{"../../../utils":114,"./float":25}],15:[function(require,module,exports){
const { utils } = require('../../../utils');
const { GLTextureFloat } = require('./float');

class GLTextureArray2Float3D extends GLTextureFloat {
  constructor(settings) {
    super(settings);
    this.type = 'ArrayTexture(2)';
  }
  toArray() {
    return utils.erect3DArray2(this.renderValues(), this.output[0], this.output[1], this.output[2]);
  }
}

module.exports = {
  GLTextureArray2Float3D
};
},{"../../../utils":114,"./float":25}],16:[function(require,module,exports){
const { utils } = require('../../../utils');
const { GLTextureFloat } = require('./float');

class GLTextureArray2Float extends GLTextureFloat {
  constructor(settings) {
    super(settings);
    this.type = 'ArrayTexture(2)';
  }
  toArray() {
    return utils.erectArray2(this.renderValues(), this.output[0], this.output[1]);
  }
}

module.exports = {
  GLTextureArray2Float
};
},{"../../../utils":114,"./float":25}],17:[function(require,module,exports){
const { utils } = require('../../../utils');
const { GLTextureFloat } = require('./float');

class GLTextureArray3Float2D extends GLTextureFloat {
  constructor(settings) {
    super(settings);
    this.type = 'ArrayTexture(3)';
  }
  toArray() {
    return utils.erect2DArray3(this.renderValues(), this.output[0], this.output[1]);
  }
}

module.exports = {
  GLTextureArray3Float2D
};
},{"../../../utils":114,"./float":25}],18:[function(require,module,exports){
const { utils } = require('../../../utils');
const { GLTextureFloat } = require('./float');

class GLTextureArray3Float3D extends GLTextureFloat {
  constructor(settings) {
    super(settings);
    this.type = 'ArrayTexture(3)';
  }
  toArray() {
    return utils.erect3DArray3(this.renderValues(), this.output[0], this.output[1], this.output[2]);
  }
}

module.exports = {
  GLTextureArray3Float3D
};
},{"../../../utils":114,"./float":25}],19:[function(require,module,exports){
const { utils } = require('../../../utils');
const { GLTextureFloat } = require('./float');

class GLTextureArray3Float extends GLTextureFloat {
  constructor(settings) {
    super(settings);
    this.type = 'ArrayTexture(3)';
  }
  toArray() {
    return utils.erectArray3(this.renderValues(), this.output[0]);
  }
}

module.exports = {
  GLTextureArray3Float
};
},{"../../../utils":114,"./float":25}],20:[function(require,module,exports){
const { utils } = require('../../../utils');
const { GLTextureFloat } = require('./float');

class GLTextureArray4Float2D extends GLTextureFloat {
  constructor(settings) {
    super(settings);
    this.type = 'ArrayTexture(4)';
  }
  toArray() {
    return utils.erect2DArray4(this.renderValues(), this.output[0], this.output[1]);
  }
}

module.exports = {
  GLTextureArray4Float2D
};
},{"../../../utils":114,"./float":25}],21:[function(require,module,exports){
const { utils } = require('../../../utils');
const { GLTextureFloat } = require('./float');

class GLTextureArray4Float3D extends GLTextureFloat {
  constructor(settings) {
    super(settings);
    this.type = 'ArrayTexture(4)';
  }
  toArray() {
    return utils.erect3DArray4(this.renderValues(), this.output[0], this.output[1], this.output[2]);
  }
}

module.exports = {
  GLTextureArray4Float3D
};
},{"../../../utils":114,"./float":25}],22:[function(require,module,exports){
const { utils } = require('../../../utils');
const { GLTextureFloat } = require('./float');

class GLTextureArray4Float extends GLTextureFloat {
  constructor(settings) {
    super(settings);
    this.type = 'ArrayTexture(4)';
  }
  toArray() {
    return utils.erectArray4(this.renderValues(), this.output[0]);
  }
}

module.exports = {
  GLTextureArray4Float
};
},{"../../../utils":114,"./float":25}],23:[function(require,module,exports){
const { utils } = require('../../../utils');
const { GLTextureFloat } = require('./float');

class GLTextureFloat2D extends GLTextureFloat {
  constructor(settings) {
    super(settings);
    this.type = 'ArrayTexture(1)';
  }
  toArray() {
    return utils.erect2DFloat(this.renderValues(), this.output[0], this.output[1]);
  }
}

module.exports = {
  GLTextureFloat2D
};
},{"../../../utils":114,"./float":25}],24:[function(require,module,exports){
const { utils } = require('../../../utils');
const { GLTextureFloat } = require('./float');

class GLTextureFloat3D extends GLTextureFloat {
  constructor(settings) {
    super(settings);
    this.type = 'ArrayTexture(1)';
  }
  toArray() {
    return utils.erect3DFloat(this.renderValues(), this.output[0], this.output[1], this.output[2]);
  }
}

module.exports = {
  GLTextureFloat3D
};
},{"../../../utils":114,"./float":25}],25:[function(require,module,exports){
const { utils } = require('../../../utils');
const { GLTexture } = require('./index');

class GLTextureFloat extends GLTexture {
  get textureType() {
    return this.context.FLOAT;
  }
  constructor(settings) {
    super(settings);
    this.type = 'ArrayTexture(1)';
  }
  renderRawOutput() {
    const gl = this.context;
    const size = this.size;
    gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer());
    gl.framebufferTexture2D(
      gl.FRAMEBUFFER,
      gl.COLOR_ATTACHMENT0,
      gl.TEXTURE_2D,
      this.texture,
      0
    );
    const result = new Float32Array(size[0] * size[1] * 4);
    gl.readPixels(0, 0, size[0], size[1], gl.RGBA, gl.FLOAT, result);
    return result;
  }
  renderValues() {
    if (this._deleted) return null;
    return this.renderRawOutput();
  }
  toArray() {
    return utils.erectFloat(this.renderValues(), this.output[0]);
  }
}

module.exports = {
  GLTextureFloat
};
},{"../../../utils":114,"./index":27}],26:[function(require,module,exports){
const { GLTextureUnsigned } = require('./unsigned');

class GLTextureGraphical extends GLTextureUnsigned {
  constructor(settings) {
    super(settings);
    this.type = 'ArrayTexture(4)';
  }
  toArray() {
    return this.renderValues();
  }
}

module.exports = {
  GLTextureGraphical
};
},{"./unsigned":33}],27:[function(require,module,exports){
const { Texture } = require('../../../texture');

class GLTexture extends Texture {
  get textureType() {
    throw new Error(`"textureType" not implemented on ${ this.name }`);
  }

  clone() {
    return new this.constructor(this);
  }

  beforeMutate() {
    if (this.texture._refs > 1) {
      this.newTexture();
      return true;
    }
    return false;
  }

  cloneTexture() {
    this.texture._refs--;
    const { context: gl, size, texture, kernel } = this;
    if (kernel.debug) {
      console.warn('cloning internal texture');
    }
    gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer());
    selectTexture(gl, texture);
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
    const target = gl.createTexture();
    selectTexture(gl, target);
    gl.texImage2D(gl.TEXTURE_2D, 0, this.internalFormat, size[0], size[1], 0, this.textureFormat, this.textureType, null);
    gl.copyTexSubImage2D(gl.TEXTURE_2D, 0, 0, 0, 0, 0, size[0], size[1]);
    target._refs = 1;
    this.texture = target;
  }

  newTexture() {
    this.texture._refs--;
    const gl = this.context;
    const size = this.size;
    const kernel = this.kernel;
    if (kernel.debug) {
      console.warn('new internal texture');
    }
    const target = gl.createTexture();
    selectTexture(gl, target);
    gl.texImage2D(gl.TEXTURE_2D, 0, this.internalFormat, size[0], size[1], 0, this.textureFormat, this.textureType, null);
    target._refs = 1;
    this.texture = target;
  }

  clear() {
    if (this.texture._refs) {
      this.texture._refs--;
      const gl = this.context;
      const target = this.texture = gl.createTexture();
      selectTexture(gl, target);
      const size = this.size;
      target._refs = 1;
      gl.texImage2D(gl.TEXTURE_2D, 0, this.internalFormat, size[0], size[1], 0, this.textureFormat, this.textureType, null);
    }
    const { context: gl, texture } = this;
    gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer());
    gl.bindTexture(gl.TEXTURE_2D, texture);
    selectTexture(gl, texture);
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
    gl.clearColor(0, 0, 0, 0);
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
  }

  delete() {
    if (this._deleted) return;
    this._deleted = true;
    if (this.texture._refs) {
      this.texture._refs--;
      if (this.texture._refs) return;
    }
    this.context.deleteTexture(this.texture);
  }

  framebuffer() {
    if (!this._framebuffer) {
      this._framebuffer = this.kernel.getRawValueFramebuffer(this.size[0], this.size[1]);
    }
    return this._framebuffer;
  }
}

function selectTexture(gl, texture) {
  gl.activeTexture(gl.TEXTURE15);
  gl.bindTexture(gl.TEXTURE_2D, texture);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
}

module.exports = { GLTexture };
},{"../../../texture":113}],28:[function(require,module,exports){
const { utils } = require('../../../utils');
const { GLTextureFloat } = require('./float');

class GLTextureMemoryOptimized2D extends GLTextureFloat {
  constructor(settings) {
    super(settings);
    this.type = 'MemoryOptimizedNumberTexture';
  }
  toArray() {
    return utils.erectMemoryOptimized2DFloat(this.renderValues(), this.output[0], this.output[1]);
  }
}

module.exports = {
  GLTextureMemoryOptimized2D
};
},{"../../../utils":114,"./float":25}],29:[function(require,module,exports){
const { utils } = require('../../../utils');
const { GLTextureFloat } = require('./float');

class GLTextureMemoryOptimized3D extends GLTextureFloat {
  constructor(settings) {
    super(settings);
    this.type = 'MemoryOptimizedNumberTexture';
  }
  toArray() {
    return utils.erectMemoryOptimized3DFloat(this.renderValues(), this.output[0], this.output[1], this.output[2]);
  }
}

module.exports = {
  GLTextureMemoryOptimized3D
};
},{"../../../utils":114,"./float":25}],30:[function(require,module,exports){
const { utils } = require('../../../utils');
const { GLTextureFloat } = require('./float');

class GLTextureMemoryOptimized extends GLTextureFloat {
  constructor(settings) {
    super(settings);
    this.type = 'MemoryOptimizedNumberTexture';
  }
  toArray() {
    return utils.erectMemoryOptimizedFloat(this.renderValues(), this.output[0]);
  }
}

module.exports = {
  GLTextureMemoryOptimized
};
},{"../../../utils":114,"./float":25}],31:[function(require,module,exports){
const { utils } = require('../../../utils');
const { GLTextureUnsigned } = require('./unsigned');

class GLTextureUnsigned2D extends GLTextureUnsigned {
  constructor(settings) {
    super(settings);
    this.type = 'NumberTexture';
  }
  toArray() {
    return utils.erect2DPackedFloat(this.renderValues(), this.output[0], this.output[1]);
  }
}

module.exports = {
  GLTextureUnsigned2D
};
},{"../../../utils":114,"./unsigned":33}],32:[function(require,module,exports){
const { utils } = require('../../../utils');
const { GLTextureUnsigned } = require('./unsigned');

class GLTextureUnsigned3D extends GLTextureUnsigned {
  constructor(settings) {
    super(settings);
    this.type = 'NumberTexture';
  }
  toArray() {
    return utils.erect3DPackedFloat(this.renderValues(), this.output[0], this.output[1], this.output[2]);
  }
}

module.exports = {
  GLTextureUnsigned3D
};
},{"../../../utils":114,"./unsigned":33}],33:[function(require,module,exports){
const { utils } = require('../../../utils');
const { GLTexture } = require('./index');

class GLTextureUnsigned extends GLTexture {
  get textureType() {
    return this.context.UNSIGNED_BYTE;
  }
  constructor(settings) {
    super(settings);
    this.type = 'NumberTexture';
  }
  renderRawOutput() {
    const { context: gl } = this;
    gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer());
    gl.framebufferTexture2D(
      gl.FRAMEBUFFER,
      gl.COLOR_ATTACHMENT0,
      gl.TEXTURE_2D,
      this.texture,
      0
    );
    const result = new Uint8Array(this.size[0] * this.size[1] * 4);
    gl.readPixels(0, 0, this.size[0], this.size[1], gl.RGBA, gl.UNSIGNED_BYTE, result);
    return result;
  }
  renderValues() {
    if (this._deleted) return null;
    return new Float32Array(this.renderRawOutput().buffer);
  }
  toArray() {
    return utils.erectPackedFloat(this.renderValues(), this.output[0]);
  }
}

module.exports = {
  GLTextureUnsigned
};
},{"../../../utils":114,"./index":27}],34:[function(require,module,exports){
const getContext = require('gl');
const { WebGLKernel } = require('../web-gl/kernel');
const { glKernelString } = require('../gl/kernel-string');

let isSupported = null;
let testCanvas = null;
let testContext = null;
let testExtensions = null;
let features = null;

class HeadlessGLKernel extends WebGLKernel {
  static get isSupported() {
    if (isSupported !== null) return isSupported;
    this.setupFeatureChecks();
    isSupported = testContext !== null;
    return isSupported;
  }

  static setupFeatureChecks() {
    testCanvas = null;
    testExtensions = null;
    if (typeof getContext !== 'function') return;
    try { 
      testContext = getContext(2, 2, {
        preserveDrawingBuffer: true
      });
      if (!testContext || !testContext.getExtension) return;
      testExtensions = {
        STACKGL_resize_drawingbuffer: testContext.getExtension('STACKGL_resize_drawingbuffer'),
        STACKGL_destroy_context: testContext.getExtension('STACKGL_destroy_context'),
        OES_texture_float: testContext.getExtension('OES_texture_float'),
        OES_texture_float_linear: testContext.getExtension('OES_texture_float_linear'),
        OES_element_index_uint: testContext.getExtension('OES_element_index_uint'),
        WEBGL_draw_buffers: testContext.getExtension('WEBGL_draw_buffers'),
        WEBGL_color_buffer_float: testContext.getExtension('WEBGL_color_buffer_float'),
      };
      features = this.getFeatures();
    } catch (e) {
      console.warn(e);
    }
  }

  static isContextMatch(context) {
    try {
      return context.getParameter(context.RENDERER) === 'ANGLE';
    } catch (e) {
      return false;
    }
  }

  static getIsTextureFloat() {
    return Boolean(testExtensions.OES_texture_float);
  }

  static getIsDrawBuffers() {
    return Boolean(testExtensions.WEBGL_draw_buffers);
  }

  static getChannelCount() {
    return testExtensions.WEBGL_draw_buffers ?
      testContext.getParameter(testExtensions.WEBGL_draw_buffers.MAX_DRAW_BUFFERS_WEBGL) :
      1;
  }

  static getMaxTextureSize() {
    return testContext.getParameter(testContext.MAX_TEXTURE_SIZE);
  }

  static get testCanvas() {
    return testCanvas;
  }

  static get testContext() {
    return testContext;
  }

  static get features() {
    return features;
  }

  initCanvas() {
    return {};
  }

  initContext() {
    return getContext(2, 2, {
      preserveDrawingBuffer: true
    });
  }

  initExtensions() {
    this.extensions = {
      STACKGL_resize_drawingbuffer: this.context.getExtension('STACKGL_resize_drawingbuffer'),
      STACKGL_destroy_context: this.context.getExtension('STACKGL_destroy_context'),
      OES_texture_float: this.context.getExtension('OES_texture_float'),
      OES_texture_float_linear: this.context.getExtension('OES_texture_float_linear'),
      OES_element_index_uint: this.context.getExtension('OES_element_index_uint'),
      WEBGL_draw_buffers: this.context.getExtension('WEBGL_draw_buffers'),
    };
  }

  build() {
    super.build.apply(this, arguments);
    if (!this.fallbackRequested) {
      this.extensions.STACKGL_resize_drawingbuffer.resize(this.maxTexSize[0], this.maxTexSize[1]);
    }
  }

  destroyExtensions() {
    this.extensions.STACKGL_resize_drawingbuffer = null;
    this.extensions.STACKGL_destroy_context = null;
    this.extensions.OES_texture_float = null;
    this.extensions.OES_texture_float_linear = null;
    this.extensions.OES_element_index_uint = null;
    this.extensions.WEBGL_draw_buffers = null;
  }

  static destroyContext(context) {
    const extension = context.getExtension('STACKGL_destroy_context');
    if (extension && extension.destroy) {
      extension.destroy();
    }
  }

  toString() {
    const setupContextString = `const gl = context || require('gl')(1, 1);\n`;
    const destroyContextString = `    if (!context) { gl.getExtension('STACKGL_destroy_context').destroy(); }\n`;
    return glKernelString(this.constructor, arguments, this, setupContextString, destroyContextString);
  }

  setOutput(output) {
    super.setOutput(output);
    if (this.graphical && this.extensions.STACKGL_resize_drawingbuffer) {
      this.extensions.STACKGL_resize_drawingbuffer.resize(this.maxTexSize[0], this.maxTexSize[1]);
    }
    return this;
  }
}

module.exports = {
  HeadlessGLKernel
};
},{"../gl/kernel-string":12,"../web-gl/kernel":70,"gl":2}],35:[function(require,module,exports){
class KernelValue {
  constructor(value, settings) {
    const {
      name,
      kernel,
      context,
      checkContext,
      onRequestContextHandle,
      onUpdateValueMismatch,
      origin,
      strictIntegers,
      type,
      tactic,
    } = settings;
    if (!name) {
      throw new Error('name not set');
    }
    if (!type) {
      throw new Error('type not set');
    }
    if (!origin) {
      throw new Error('origin not set');
    }
    if (origin !== 'user' && origin !== 'constants') {
      throw new Error(`origin must be "user" or "constants" value is "${ origin }"`);
    }
    if (!onRequestContextHandle) {
      throw new Error('onRequestContextHandle is not set');
    }
    this.name = name;
    this.origin = origin;
    this.tactic = tactic;
    this.varName = origin === 'constants' ? `constants.${name}` : name;
    this.kernel = kernel;
    this.strictIntegers = strictIntegers;
    this.type = value.type || type;
    this.size = value.size || null;
    this.index = null;
    this.context = context;
    this.checkContext = checkContext !== null && checkContext !== undefined ? checkContext : true;
    this.contextHandle = null;
    this.onRequestContextHandle = onRequestContextHandle;
    this.onUpdateValueMismatch = onUpdateValueMismatch;
    this.forceUploadEachRun = null;
  }

  get id() {
    return `${this.origin}_${name}`;
  }

  getSource() {
    throw new Error(`"getSource" not defined on ${ this.constructor.name }`);
  }

  updateValue(value) {
    throw new Error(`"updateValue" not defined on ${ this.constructor.name }`);
  }
}

module.exports = {
  KernelValue
};
},{}],36:[function(require,module,exports){
const { utils } = require('../utils');
const { Input } = require('../input');

class Kernel {
  static get isSupported() {
    throw new Error(`"isSupported" not implemented on ${ this.name }`);
  }

  static isContextMatch(context) {
    throw new Error(`"isContextMatch" not implemented on ${ this.name }`);
  }

  static getFeatures() {
    throw new Error(`"getFeatures" not implemented on ${ this.name }`);
  }

  static destroyContext(context) {
    throw new Error(`"destroyContext" called on ${ this.name }`);
  }

  static nativeFunctionArguments() {
    throw new Error(`"nativeFunctionArguments" called on ${ this.name }`);
  }

  static nativeFunctionReturnType() {
    throw new Error(`"nativeFunctionReturnType" called on ${ this.name }`);
  }

  static combineKernels() {
    throw new Error(`"combineKernels" called on ${ this.name }`);
  }

  constructor(source, settings) {
    if (typeof source !== 'object') {
      if (typeof source !== 'string') {
        throw new Error('source not a string');
      }
      if (!utils.isFunctionString(source)) {
        throw new Error('source not a function string');
      }
    }
    this.useLegacyEncoder = false;
    this.fallbackRequested = false;
    this.onRequestFallback = null;

    this.argumentNames = typeof source === 'string' ? utils.getArgumentNamesFromString(source) : null;
    this.argumentTypes = null;
    this.argumentSizes = null;
    this.argumentBitRatios = null;
    this.kernelArguments = null;
    this.kernelConstants = null;
    this.forceUploadKernelConstants = null;


    this.source = source;

    this.output = null;

    this.debug = false;

    this.graphical = false;

    this.loopMaxIterations = 0;

    this.constants = null;

    this.constantTypes = null;

    this.constantBitRatios = null;

    this.dynamicArguments = false;

    this.dynamicOutput = false;

    this.canvas = null;

    this.context = null;

    this.checkContext = null;

    this.gpu = null;

    this.functions = null;

    this.nativeFunctions = null;

    this.injectedNative = null;

    this.subKernels = null;

    this.validate = true;

    this.immutable = false;

    this.pipeline = false;

    this.precision = null;

    this.tactic = null;

    this.plugins = null;

    this.returnType = null;
    this.leadingReturnStatement = null;
    this.followingReturnStatement = null;
    this.optimizeFloatMemory = null;
    this.strictIntegers = false;
    this.fixIntegerDivisionAccuracy = null;
    this.built = false;
    this.signature = null;
  }

  mergeSettings(settings) {
    for (let p in settings) {
      if (!settings.hasOwnProperty(p) || !this.hasOwnProperty(p)) continue;
      switch (p) {
        case 'output':
          if (!Array.isArray(settings.output)) {
            this.setOutput(settings.output); 
            continue;
          }
          break;
        case 'functions':
          this.functions = [];
          for (let i = 0; i < settings.functions.length; i++) {
            this.addFunction(settings.functions[i]);
          }
          continue;
        case 'graphical':
          if (settings[p] && !settings.hasOwnProperty('precision')) {
            this.precision = 'unsigned';
          }
          this[p] = settings[p];
          continue;
        case 'nativeFunctions':
          if (!settings.nativeFunctions) continue;
          this.nativeFunctions = [];
          for (let i = 0; i < settings.nativeFunctions.length; i++) {
            const s = settings.nativeFunctions[i];
            const { name, source } = s;
            this.addNativeFunction(name, source, s);
          }
          continue;
      }
      this[p] = settings[p];
    }

    if (!this.canvas) this.canvas = this.initCanvas();
    if (!this.context) this.context = this.initContext();
    if (!this.plugins) this.plugins = this.initPlugins(settings);
  }
  build() {
    throw new Error(`"build" not defined on ${ this.constructor.name }`);
  }

  run() {
    throw new Error(`"run" not defined on ${ this.constructor.name }`)
  }

  initCanvas() {
    throw new Error(`"initCanvas" not defined on ${ this.constructor.name }`);
  }

  initContext() {
    throw new Error(`"initContext" not defined on ${ this.constructor.name }`);
  }

  initPlugins(settings) {
    throw new Error(`"initPlugins" not defined on ${ this.constructor.name }`);
  }

  addFunction(source, settings = {}) {
    if (source.name && source.source && source.argumentTypes && 'returnType' in source) {
      this.functions.push(source);
    } else if ('settings' in source && 'source' in source) {
      this.functions.push(this.functionToIGPUFunction(source.source, source.settings));
    } else if (typeof source === 'string' || typeof source === 'function') {
      this.functions.push(this.functionToIGPUFunction(source, settings));
    } else {
      throw new Error(`function not properly defined`);
    }
    return this;
  }

  addNativeFunction(name, source, settings = {}) {
    const { argumentTypes, argumentNames } = settings.argumentTypes ?
      splitArgumentTypes(settings.argumentTypes) :
      this.constructor.nativeFunctionArguments(source) || {};
    this.nativeFunctions.push({
      name,
      source,
      settings,
      argumentTypes,
      argumentNames,
      returnType: settings.returnType || this.constructor.nativeFunctionReturnType(source)
    });
    return this;
  }

  setupArguments(args) {
    this.kernelArguments = [];
    if (!this.argumentTypes) {
      if (!this.argumentTypes) {
        this.argumentTypes = [];
        for (let i = 0; i < args.length; i++) {
          const argType = utils.getVariableType(args[i], this.strictIntegers);
          const type = argType === 'Integer' ? 'Number' : argType;
          this.argumentTypes.push(type);
          this.kernelArguments.push({
            type
          });
        }
      }
    } else {
      for (let i = 0; i < this.argumentTypes.length; i++) {
        this.kernelArguments.push({
          type: this.argumentTypes[i]
        });
      }
    }

    this.argumentSizes = new Array(args.length);
    this.argumentBitRatios = new Int32Array(args.length);

    for (let i = 0; i < args.length; i++) {
      const arg = args[i];
      this.argumentSizes[i] = arg.constructor === Input ? arg.size : null;
      this.argumentBitRatios[i] = this.getBitRatio(arg);
    }

    if (this.argumentNames.length !== args.length) {
      throw new Error(`arguments are miss-aligned`);
    }
  }

  setupConstants() {
    this.kernelConstants = [];
    let needsConstantTypes = this.constantTypes === null;
    if (needsConstantTypes) {
      this.constantTypes = {};
    }
    this.constantBitRatios = {};
    if (this.constants) {
      for (let name in this.constants) {
        if (needsConstantTypes) {
          const type = utils.getVariableType(this.constants[name], this.strictIntegers);
          this.constantTypes[name] = type;
          this.kernelConstants.push({
            name,
            type
          });
        } else {
          this.kernelConstants.push({
            name,
            type: this.constantTypes[name]
          });
        }
        this.constantBitRatios[name] = this.getBitRatio(this.constants[name]);
      }
    }
  }

  setOptimizeFloatMemory(flag) {
    this.optimizeFloatMemory = flag;
    return this;
  }

  toKernelOutput(output) {
    if (output.hasOwnProperty('x')) {
      if (output.hasOwnProperty('y')) {
        if (output.hasOwnProperty('z')) {
          return [output.x, output.y, output.z];
        } else {
          return [output.x, output.y];
        }
      } else {
        return [output.x];
      }
    } else {
      return output;
    }
  }

  setOutput(output) {
    this.output = this.toKernelOutput(output);
    return this;
  }

  setDebug(flag) {
    this.debug = flag;
    return this;
  }

  setGraphical(flag) {
    this.graphical = flag;
    this.precision = 'unsigned';
    return this;
  }

  setLoopMaxIterations(max) {
    this.loopMaxIterations = max;
    return this;
  }

  setConstants(constants) {
    this.constants = constants;
    return this;
  }

  setConstantTypes(constantTypes) {
    this.constantTypes = constantTypes;
    return this;
  }

  setFunctions(functions) {
    for (let i = 0; i < functions.length; i++) {
      this.addFunction(functions[i]);
    }
    return this;
  }

  setNativeFunctions(nativeFunctions) {
    for (let i = 0; i < nativeFunctions.length; i++) {
      const settings = nativeFunctions[i];
      const { name, source } = settings;
      this.addNativeFunction(name, source, settings);
    }
    return this;
  }

  setInjectedNative(injectedNative) {
    this.injectedNative = injectedNative;
    return this;
  }

  setPipeline(flag) {
    this.pipeline = flag;
    return this;
  }

  setPrecision(flag) {
    this.precision = flag;
    return this;
  }

  setDimensions(flag) {
    utils.warnDeprecated('method', 'setDimensions', 'setOutput');
    this.output = flag;
    return this;
  }

  setOutputToTexture(flag) {
    utils.warnDeprecated('method', 'setOutputToTexture', 'setPipeline');
    this.pipeline = flag;
    return this;
  }

  setImmutable(flag) {
    this.immutable = flag;
    return this;
  }

  setCanvas(canvas) {
    this.canvas = canvas;
    return this;
  }

  setStrictIntegers(flag) {
    this.strictIntegers = flag;
    return this;
  }

  setDynamicOutput(flag) {
    this.dynamicOutput = flag;
    return this;
  }

  setHardcodeConstants(flag) {
    utils.warnDeprecated('method', 'setHardcodeConstants');
    this.setDynamicOutput(flag);
    this.setDynamicArguments(flag);
    return this;
  }

  setDynamicArguments(flag) {
    this.dynamicArguments = flag;
    return this;
  }

  setUseLegacyEncoder(flag) {
    this.useLegacyEncoder = flag;
    return this;
  }

  setWarnVarUsage(flag) {
    utils.warnDeprecated('method', 'setWarnVarUsage');
    return this;
  }

  getCanvas() {
    utils.warnDeprecated('method', 'getCanvas');
    return this.canvas;
  }

  getWebGl() {
    utils.warnDeprecated('method', 'getWebGl');
    return this.context;
  }

  setContext(context) {
    this.context = context;
    return this;
  }

  setArgumentTypes(argumentTypes) {
    if (Array.isArray(argumentTypes)) {
      this.argumentTypes = argumentTypes;
    } else {
      this.argumentTypes = [];
      for (const p in argumentTypes) {
        if (!argumentTypes.hasOwnProperty(p)) continue;
        const argumentIndex = this.argumentNames.indexOf(p);
        if (argumentIndex === -1) throw new Error(`unable to find argument ${ p }`);
        this.argumentTypes[argumentIndex] = argumentTypes[p];
      }
    }
    return this;
  }

  setTactic(tactic) {
    this.tactic = tactic;
    return this;
  }

  requestFallback(args) {
    if (!this.onRequestFallback) {
      throw new Error(`"onRequestFallback" not defined on ${ this.constructor.name }`);
    }
    this.fallbackRequested = true;
    return this.onRequestFallback(args);
  }

  validateSettings() {
    throw new Error(`"validateSettings" not defined on ${ this.constructor.name }`);
  }

  addSubKernel(subKernel) {
    if (this.subKernels === null) {
      this.subKernels = [];
    }
    if (!subKernel.source) throw new Error('subKernel missing "source" property');
    if (!subKernel.property && isNaN(subKernel.property)) throw new Error('subKernel missing "property" property');
    if (!subKernel.name) throw new Error('subKernel missing "name" property');
    this.subKernels.push(subKernel);
    return this;
  }

  destroy(removeCanvasReferences) {
    throw new Error(`"destroy" called on ${ this.constructor.name }`);
  }

  getBitRatio(value) {
    if (this.precision === 'single') {
      return 4;
    } else if (Array.isArray(value[0])) {
      return this.getBitRatio(value[0]);
    } else if (value.constructor === Input) {
      return this.getBitRatio(value.value);
    }
    switch (value.constructor) {
      case Uint8ClampedArray:
      case Uint8Array:
      case Int8Array:
        return 1;
      case Uint16Array:
      case Int16Array:
        return 2;
      case Float32Array:
      case Int32Array:
      default:
        return 4;
    }
  }

  getPixels(flip) {
    throw new Error(`"getPixels" called on ${ this.constructor.name }`);
  }

  checkOutput() {
    if (!this.output || !utils.isArray(this.output)) throw new Error('kernel.output not an array');
    if (this.output.length < 1) throw new Error('kernel.output is empty, needs at least 1 value');
    for (let i = 0; i < this.output.length; i++) {
      if (isNaN(this.output[i]) || this.output[i] < 1) {
        throw new Error(`${ this.constructor.name }.output[${ i }] incorrectly defined as \`${ this.output[i] }\`, needs to be numeric, and greater than 0`);
      }
    }
  }

  prependString(value) {
    throw new Error(`"prependString" called on ${ this.constructor.name }`);
  }

  hasPrependString(value) {
    throw new Error(`"hasPrependString" called on ${ this.constructor.name }`);
  }

  toJSON() {
    return {
      settings: {
        output: this.output,
        pipeline: this.pipeline,
        argumentNames: this.argumentNames,
        argumentsTypes: this.argumentTypes,
        constants: this.constants,
        pluginNames: this.plugins ? this.plugins.map(plugin => plugin.name) : null,
        returnType: this.returnType,
      }
    };
  }

  buildSignature(args) {
    const Constructor = this.constructor;
    this.signature = Constructor.getSignature(this, Constructor.getArgumentTypes(this, args));
  }

  static getArgumentTypes(kernel, args) {
    const argumentTypes = new Array(args.length);
    for (let i = 0; i < args.length; i++) {
      const arg = args[i];
      const type = kernel.argumentTypes[i];
      if (arg.type) {
        argumentTypes[i] = arg.type;
      } else {
        switch (type) {
          case 'Number':
          case 'Integer':
          case 'Float':
          case 'ArrayTexture(1)':
            argumentTypes[i] = utils.getVariableType(arg);
            break;
          default:
            argumentTypes[i] = type;
        }
      }
    }
    return argumentTypes;
  }

  static getSignature(kernel, argumentTypes) {
    throw new Error(`"getSignature" not implemented on ${ this.name }`);
  }

  functionToIGPUFunction(source, settings = {}) {
    if (typeof source !== 'string' && typeof source !== 'function') throw new Error('source not a string or function');
    const sourceString = typeof source === 'string' ? source : source.toString();
    let argumentTypes = [];

    if (Array.isArray(settings.argumentTypes)) {
      argumentTypes = settings.argumentTypes;
    } else if (typeof settings.argumentTypes === 'object') {
      argumentTypes = utils.getArgumentNamesFromString(sourceString)
        .map(name => settings.argumentTypes[name]) || [];
    } else {
      argumentTypes = settings.argumentTypes || [];
    }

    return {
      name: utils.getFunctionNameFromString(sourceString) || null,
      source: sourceString,
      argumentTypes,
      returnType: settings.returnType || null,
    };
  }

  onActivate(previousKernel) {}
}

function splitArgumentTypes(argumentTypesObject) {
  const argumentNames = Object.keys(argumentTypesObject);
  const argumentTypes = [];
  for (let i = 0; i < argumentNames.length; i++) {
    const argumentName = argumentNames[i];
    argumentTypes.push(argumentTypesObject[argumentName]);
  }
  return { argumentTypes, argumentNames };
}

module.exports = {
  Kernel
};
},{"../input":110,"../utils":114}],37:[function(require,module,exports){
const fragmentShader = `__HEADER__;
__FLOAT_TACTIC_DECLARATION__;
__INT_TACTIC_DECLARATION__;
__SAMPLER_2D_TACTIC_DECLARATION__;

const int LOOP_MAX = __LOOP_MAX__;

__PLUGINS__;
__CONSTANTS__;

varying vec2 vTexCoord;

float acosh(float x) {
  return log(x + sqrt(x * x - 1.0));
}

float sinh(float x) {
  return (pow(${Math.E}, x) - pow(${Math.E}, -x)) / 2.0;
}

float asinh(float x) {
  return log(x + sqrt(x * x + 1.0));
}

float atan2(float v1, float v2) {
  if (v1 == 0.0 || v2 == 0.0) return 0.0;
  return atan(v1 / v2);
}

float atanh(float x) {
  x = (x + 1.0) / (x - 1.0);
  if (x < 0.0) {
    return 0.5 * log(-x);
  }
  return 0.5 * log(x);
}

float cbrt(float x) {
  if (x >= 0.0) {
    return pow(x, 1.0 / 3.0);
  } else {
    return -pow(x, 1.0 / 3.0);
  }
}

float cosh(float x) {
  return (pow(${Math.E}, x) + pow(${Math.E}, -x)) / 2.0; 
}

float expm1(float x) {
  return pow(${Math.E}, x) - 1.0; 
}

float fround(highp float x) {
  return x;
}

float imul(float v1, float v2) {
  return float(int(v1) * int(v2));
}

float log10(float x) {
  return log2(x) * (1.0 / log2(10.0));
}

float log1p(float x) {
  return log(1.0 + x);
}

float _pow(float v1, float v2) {
  if (v2 == 0.0) return 1.0;
  return pow(v1, v2);
}

float tanh(float x) {
  float e = exp(2.0 * x);
  return (e - 1.0) / (e + 1.0);
}

float trunc(float x) {
  if (x >= 0.0) {
    return floor(x); 
  } else {
    return ceil(x);
  }
}

vec4 _round(vec4 x) {
  return floor(x + 0.5);
}

float _round(float x) {
  return floor(x + 0.5);
}

const int BIT_COUNT = 32;
int modi(int x, int y) {
  return x - y * (x / y);
}

int bitwiseOr(int a, int b) {
  int result = 0;
  int n = 1;
  
  for (int i = 0; i < BIT_COUNT; i++) {
    if ((modi(a, 2) == 1) || (modi(b, 2) == 1)) {
      result += n;
    }
    a = a / 2;
    b = b / 2;
    n = n * 2;
    if(!(a > 0 || b > 0)) {
      break;
    }
  }
  return result;
}
int bitwiseXOR(int a, int b) {
  int result = 0;
  int n = 1;
  
  for (int i = 0; i < BIT_COUNT; i++) {
    if ((modi(a, 2) == 1) != (modi(b, 2) == 1)) {
      result += n;
    }
    a = a / 2;
    b = b / 2;
    n = n * 2;
    if(!(a > 0 || b > 0)) {
      break;
    }
  }
  return result;
}
int bitwiseAnd(int a, int b) {
  int result = 0;
  int n = 1;
  for (int i = 0; i < BIT_COUNT; i++) {
    if ((modi(a, 2) == 1) && (modi(b, 2) == 1)) {
      result += n;
    }
    a = a / 2;
    b = b / 2;
    n = n * 2;
    if(!(a > 0 && b > 0)) {
      break;
    }
  }
  return result;
}
int bitwiseNot(int a) {
  int result = 0;
  int n = 1;
  
  for (int i = 0; i < BIT_COUNT; i++) {
    if (modi(a, 2) == 0) {
      result += n;    
    }
    a = a / 2;
    n = n * 2;
  }
  return result;
}
int bitwiseZeroFillLeftShift(int n, int shift) {
  int maxBytes = BIT_COUNT;
  for (int i = 0; i < BIT_COUNT; i++) {
    if (maxBytes >= n) {
      break;
    }
    maxBytes *= 2;
  }
  for (int i = 0; i < BIT_COUNT; i++) {
    if (i >= shift) {
      break;
    }
    n *= 2;
  }

  int result = 0;
  int byteVal = 1;
  for (int i = 0; i < BIT_COUNT; i++) {
    if (i >= maxBytes) break;
    if (modi(n, 2) > 0) { result += byteVal; }
    n = int(n / 2);
    byteVal *= 2;
  }
  return result;
}

int bitwiseSignedRightShift(int num, int shifts) {
  return int(floor(float(num) / pow(2.0, float(shifts))));
}

int bitwiseZeroFillRightShift(int n, int shift) {
  int maxBytes = BIT_COUNT;
  for (int i = 0; i < BIT_COUNT; i++) {
    if (maxBytes >= n) {
      break;
    }
    maxBytes *= 2;
  }
  for (int i = 0; i < BIT_COUNT; i++) {
    if (i >= shift) {
      break;
    }
    n /= 2;
  }
  int result = 0;
  int byteVal = 1;
  for (int i = 0; i < BIT_COUNT; i++) {
    if (i >= maxBytes) break;
    if (modi(n, 2) > 0) { result += byteVal; }
    n = int(n / 2);
    byteVal *= 2;
  }
  return result;
}

vec2 integerMod(vec2 x, float y) {
  vec2 res = floor(mod(x, y));
  return res * step(1.0 - floor(y), -res);
}

vec3 integerMod(vec3 x, float y) {
  vec3 res = floor(mod(x, y));
  return res * step(1.0 - floor(y), -res);
}

vec4 integerMod(vec4 x, vec4 y) {
  vec4 res = floor(mod(x, y));
  return res * step(1.0 - floor(y), -res);
}

float integerMod(float x, float y) {
  float res = floor(mod(x, y));
  return res * (res > floor(y) - 1.0 ? 0.0 : 1.0);
}

int integerMod(int x, int y) {
  return x - (y * int(x / y));
}

__DIVIDE_WITH_INTEGER_CHECK__;

// Here be dragons!
// DO NOT OPTIMIZE THIS CODE
// YOU WILL BREAK SOMETHING ON SOMEBODY\'S MACHINE
// LEAVE IT AS IT IS, LEST YOU WASTE YOUR OWN TIME
const vec2 MAGIC_VEC = vec2(1.0, -256.0);
const vec4 SCALE_FACTOR = vec4(1.0, 256.0, 65536.0, 0.0);
const vec4 SCALE_FACTOR_INV = vec4(1.0, 0.00390625, 0.0000152587890625, 0.0); // 1, 1/256, 1/65536
float decode32(vec4 texel) {
  __DECODE32_ENDIANNESS__;
  texel *= 255.0;
  vec2 gte128;
  gte128.x = texel.b >= 128.0 ? 1.0 : 0.0;
  gte128.y = texel.a >= 128.0 ? 1.0 : 0.0;
  float exponent = 2.0 * texel.a - 127.0 + dot(gte128, MAGIC_VEC);
  float res = exp2(_round(exponent));
  texel.b = texel.b - 128.0 * gte128.x;
  res = dot(texel, SCALE_FACTOR) * exp2(_round(exponent-23.0)) + res;
  res *= gte128.y * -2.0 + 1.0;
  return res;
}

float decode16(vec4 texel, int index) {
  int channel = integerMod(index, 2);
  if (channel == 0) return texel.r * 255.0 + texel.g * 65280.0;
  if (channel == 1) return texel.b * 255.0 + texel.a * 65280.0;
  return 0.0;
}

float decode8(vec4 texel, int index) {
  int channel = integerMod(index, 4);
  if (channel == 0) return texel.r * 255.0;
  if (channel == 1) return texel.g * 255.0;
  if (channel == 2) return texel.b * 255.0;
  if (channel == 3) return texel.a * 255.0;
  return 0.0;
}

vec4 legacyEncode32(float f) {
  float F = abs(f);
  float sign = f < 0.0 ? 1.0 : 0.0;
  float exponent = floor(log2(F));
  float mantissa = (exp2(-exponent) * F);
  // exponent += floor(log2(mantissa));
  vec4 texel = vec4(F * exp2(23.0-exponent)) * SCALE_FACTOR_INV;
  texel.rg = integerMod(texel.rg, 256.0);
  texel.b = integerMod(texel.b, 128.0);
  texel.a = exponent*0.5 + 63.5;
  texel.ba += vec2(integerMod(exponent+127.0, 2.0), sign) * 128.0;
  texel = floor(texel);
  texel *= 0.003921569; // 1/255
  __ENCODE32_ENDIANNESS__;
  return texel;
}

// https://github.com/gpujs/gpu.js/wiki/Encoder-details
vec4 encode32(float value) {
  if (value == 0.0) return vec4(0, 0, 0, 0);

  float exponent;
  float mantissa;
  vec4  result;
  float sgn;

  sgn = step(0.0, -value);
  value = abs(value);

  exponent = floor(log2(value));

  mantissa = value*pow(2.0, -exponent)-1.0;
  exponent = exponent+127.0;
  result   = vec4(0,0,0,0);

  result.a = floor(exponent/2.0);
  exponent = exponent - result.a*2.0;
  result.a = result.a + 128.0*sgn;

  result.b = floor(mantissa * 128.0);
  mantissa = mantissa - result.b / 128.0;
  result.b = result.b + exponent*128.0;

  result.g = floor(mantissa*32768.0);
  mantissa = mantissa - result.g/32768.0;

  result.r = floor(mantissa*8388608.0);
  return result/255.0;
}
// Dragons end here

int index;
ivec3 threadId;

ivec3 indexTo3D(int idx, ivec3 texDim) {
  int z = int(idx / (texDim.x * texDim.y));
  idx -= z * int(texDim.x * texDim.y);
  int y = int(idx / texDim.x);
  int x = int(integerMod(idx, texDim.x));
  return ivec3(x, y, z);
}

float get32(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  int index = x + texDim.x * (y + texDim.y * z);
  int w = texSize.x;
  vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;
  vec4 texel = texture2D(tex, st / vec2(texSize));
  return decode32(texel);
}

float get16(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  int index = x + texDim.x * (y + texDim.y * z);
  int w = texSize.x * 2;
  vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;
  vec4 texel = texture2D(tex, st / vec2(texSize.x * 2, texSize.y));
  return decode16(texel, index);
}

float get8(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  int index = x + texDim.x * (y + texDim.y * z);
  int w = texSize.x * 4;
  vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;
  vec4 texel = texture2D(tex, st / vec2(texSize.x * 4, texSize.y));
  return decode8(texel, index);
}

float getMemoryOptimized32(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  int index = x + texDim.x * (y + texDim.y * z);
  int channel = integerMod(index, 4);
  index = index / 4;
  int w = texSize.x;
  vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;
  vec4 texel = texture2D(tex, st / vec2(texSize));
  if (channel == 0) return texel.r;
  if (channel == 1) return texel.g;
  if (channel == 2) return texel.b;
  if (channel == 3) return texel.a;
  return 0.0;
}

vec4 getImage2D(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  int index = x + texDim.x * (y + texDim.y * z);
  int w = texSize.x;
  vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;
  return texture2D(tex, st / vec2(texSize));
}

float getFloatFromSampler2D(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  vec4 result = getImage2D(tex, texSize, texDim, z, y, x);
  return result[0];
}

vec2 getVec2FromSampler2D(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  vec4 result = getImage2D(tex, texSize, texDim, z, y, x);
  return vec2(result[0], result[1]);
}

vec2 getMemoryOptimizedVec2(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  int index = x + (texDim.x * (y + (texDim.y * z)));
  int channel = integerMod(index, 2);
  index = index / 2;
  int w = texSize.x;
  vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;
  vec4 texel = texture2D(tex, st / vec2(texSize));
  if (channel == 0) return vec2(texel.r, texel.g);
  if (channel == 1) return vec2(texel.b, texel.a);
  return vec2(0.0, 0.0);
}

vec3 getVec3FromSampler2D(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  vec4 result = getImage2D(tex, texSize, texDim, z, y, x);
  return vec3(result[0], result[1], result[2]);
}

vec3 getMemoryOptimizedVec3(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  int fieldIndex = 3 * (x + texDim.x * (y + texDim.y * z));
  int vectorIndex = fieldIndex / 4;
  int vectorOffset = fieldIndex - vectorIndex * 4;
  int readY = vectorIndex / texSize.x;
  int readX = vectorIndex - readY * texSize.x;
  vec4 tex1 = texture2D(tex, (vec2(readX, readY) + 0.5) / vec2(texSize));
  
  if (vectorOffset == 0) {
    return tex1.xyz;
  } else if (vectorOffset == 1) {
    return tex1.yzw;
  } else {
    readX++;
    if (readX >= texSize.x) {
      readX = 0;
      readY++;
    }
    vec4 tex2 = texture2D(tex, vec2(readX, readY) / vec2(texSize));
    if (vectorOffset == 2) {
      return vec3(tex1.z, tex1.w, tex2.x);
    } else {
      return vec3(tex1.w, tex2.x, tex2.y);
    }
  }
}

vec4 getVec4FromSampler2D(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  return getImage2D(tex, texSize, texDim, z, y, x);
}

vec4 getMemoryOptimizedVec4(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  int index = x + texDim.x * (y + texDim.y * z);
  int channel = integerMod(index, 2);
  int w = texSize.x;
  vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;
  vec4 texel = texture2D(tex, st / vec2(texSize));
  return vec4(texel.r, texel.g, texel.b, texel.a);
}

vec4 actualColor;
void color(float r, float g, float b, float a) {
  actualColor = vec4(r,g,b,a);
}

void color(float r, float g, float b) {
  color(r,g,b,1.0);
}

void color(sampler2D image) {
  actualColor = texture2D(image, vTexCoord);
}

float modulo(float number, float divisor) {
  if (number < 0.0) {
    number = abs(number);
    if (divisor < 0.0) {
      divisor = abs(divisor);
    }
    return -mod(number, divisor);
  }
  if (divisor < 0.0) {
    divisor = abs(divisor);
  }
  return mod(number, divisor);
}

__INJECTED_NATIVE__;
__MAIN_CONSTANTS__;
__MAIN_ARGUMENTS__;
__KERNEL__;

void main(void) {
  index = int(vTexCoord.s * float(uTexSize.x)) + int(vTexCoord.t * float(uTexSize.y)) * uTexSize.x;
  __MAIN_RESULT__;
}`;

module.exports = {
  fragmentShader
};
},{}],38:[function(require,module,exports){
const { utils } = require('../../utils');
const { FunctionNode } = require('../function-node');

class WebGLFunctionNode extends FunctionNode {
  constructor(source, settings) {
    super(source, settings);
    if (settings && settings.hasOwnProperty('fixIntegerDivisionAccuracy')) {
      this.fixIntegerDivisionAccuracy = settings.fixIntegerDivisionAccuracy;
    }
  }

  astConditionalExpression(ast, retArr) {
    if (ast.type !== 'ConditionalExpression') {
      throw this.astErrorOutput('Not a conditional expression', ast);
    }
    const consequentType = this.getType(ast.consequent);
    const alternateType = this.getType(ast.alternate);
    if (consequentType === null && alternateType === null) {
      retArr.push('if (');
      this.astGeneric(ast.test, retArr);
      retArr.push(') {');
      this.astGeneric(ast.consequent, retArr);
      retArr.push(';');
      retArr.push('} else {');
      this.astGeneric(ast.alternate, retArr);
      retArr.push(';');
      retArr.push('}');
      return retArr;
    }
    retArr.push('(');
    this.astGeneric(ast.test, retArr);
    retArr.push('?');
    this.astGeneric(ast.consequent, retArr);
    retArr.push(':');
    this.astGeneric(ast.alternate, retArr);
    retArr.push(')');
    return retArr;
  }

  astFunction(ast, retArr) {
    if (this.isRootKernel) {
      retArr.push('void');
    } else {
      if (!this.returnType) {
        const lastReturn = this.findLastReturn();
        if (lastReturn) {
          this.returnType = this.getType(ast.body);
          if (this.returnType === 'LiteralInteger') {
            this.returnType = 'Number';
          }
        }
      }

      const { returnType } = this;
      if (!returnType) {
        retArr.push('void');
      } else {
        const type = typeMap[returnType];
        if (!type) {
          throw new Error(`unknown type ${returnType}`);
        }
        retArr.push(type);
      }
    }
    retArr.push(' ');
    retArr.push(this.name);
    retArr.push('(');

    if (!this.isRootKernel) {
      for (let i = 0; i < this.argumentNames.length; ++i) {
        const argumentName = this.argumentNames[i];

        if (i > 0) {
          retArr.push(', ');
        }
        let argumentType = this.argumentTypes[this.argumentNames.indexOf(argumentName)];
        if (!argumentType) {
          throw this.astErrorOutput(`Unknown argument ${argumentName} type`, ast);
        }
        if (argumentType === 'LiteralInteger') {
          this.argumentTypes[i] = argumentType = 'Number';
        }
        const type = typeMap[argumentType];
        if (!type) {
          throw this.astErrorOutput('Unexpected expression', ast);
        }
        const name = utils.sanitizeName(argumentName);
        if (type === 'sampler2D' || type === 'sampler2DArray') {
          retArr.push(`${type} user_${name},ivec2 user_${name}Size,ivec3 user_${name}Dim`);
        } else {
          retArr.push(`${type} user_${name}`);
        }
      }
    }

    retArr.push(') {\n');

    for (let i = 0; i < ast.body.body.length; ++i) {
      this.astGeneric(ast.body.body[i], retArr);
      retArr.push('\n');
    }

    retArr.push('}\n');
    return retArr;
  }

  astReturnStatement(ast, retArr) {
    if (!ast.argument) throw this.astErrorOutput('Unexpected return statement', ast);
    this.pushState('skip-literal-correction');
    const type = this.getType(ast.argument);
    this.popState('skip-literal-correction');

    const result = [];

    if (!this.returnType) {
      if (type === 'LiteralInteger' || type === 'Integer') {
        this.returnType = 'Number';
      } else {
        this.returnType = type;
      }
    }

    switch (this.returnType) {
      case 'LiteralInteger':
      case 'Number':
      case 'Float':
        switch (type) {
          case 'Integer':
            result.push('float(');
            this.astGeneric(ast.argument, result);
            result.push(')');
            break;
          case 'LiteralInteger':
            this.castLiteralToFloat(ast.argument, result);

            if (this.getType(ast) === 'Integer') {
              result.unshift('float(');
              result.push(')');
            }
            break;
          default:
            this.astGeneric(ast.argument, result);
        }
        break;
      case 'Integer':
        switch (type) {
          case 'Float':
          case 'Number':
            this.castValueToInteger(ast.argument, result);
            break;
          case 'LiteralInteger':
            this.castLiteralToInteger(ast.argument, result);
            break;
          default:
            this.astGeneric(ast.argument, result);
        }
        break;
      case 'Array(4)':
      case 'Array(3)':
      case 'Array(2)':
      case 'Matrix(2)':
      case 'Matrix(3)':
      case 'Matrix(4)':
      case 'Input':
        this.astGeneric(ast.argument, result);
        break;
      default:
        throw this.astErrorOutput(`unhandled return type ${this.returnType}`, ast);
    }

    if (this.isRootKernel) {
      retArr.push(`kernelResult = ${ result.join('') };`);
      retArr.push('return;');
    } else if (this.isSubKernel) {
      retArr.push(`subKernelResult_${ this.name } = ${ result.join('') };`);
      retArr.push(`return subKernelResult_${ this.name };`);
    } else {
      retArr.push(`return ${ result.join('') };`);
    }
    return retArr;
  }

  astLiteral(ast, retArr) {
    if (isNaN(ast.value)) {
      throw this.astErrorOutput(
        'Non-numeric literal not supported : ' + ast.value,
        ast
      );
    }

    const key = this.astKey(ast);
    if (Number.isInteger(ast.value)) {
      if (this.isState('casting-to-integer') || this.isState('building-integer')) {
        this.literalTypes[key] = 'Integer';
        retArr.push(`${ast.value}`);
      } else if (this.isState('casting-to-float') || this.isState('building-float')) {
        this.literalTypes[key] = 'Number';
        retArr.push(`${ast.value}.0`);
      } else {
        this.literalTypes[key] = 'Number';
        retArr.push(`${ast.value}.0`);
      }
    } else if (this.isState('casting-to-integer') || this.isState('building-integer')) {
      this.literalTypes[key] = 'Integer';
      retArr.push(Math.round(ast.value));
    } else {
      this.literalTypes[key] = 'Number';
      retArr.push(`${ast.value}`);
    }
    return retArr;
  }

  astBinaryExpression(ast, retArr) {
    if (this.checkAndUpconvertOperator(ast, retArr)) {
      return retArr;
    }

    if (this.fixIntegerDivisionAccuracy && ast.operator === '/') {
      retArr.push('divWithIntCheck(');
      this.pushState('building-float');
      switch (this.getType(ast.left)) {
        case 'Integer':
          this.castValueToFloat(ast.left, retArr);
          break;
        case 'LiteralInteger':
          this.castLiteralToFloat(ast.left, retArr);
          break;
        default:
          this.astGeneric(ast.left, retArr);
      }
      retArr.push(', ');
      switch (this.getType(ast.right)) {
        case 'Integer':
          this.castValueToFloat(ast.right, retArr);
          break;
        case 'LiteralInteger':
          this.castLiteralToFloat(ast.right, retArr);
          break;
        default:
          this.astGeneric(ast.right, retArr);
      }
      this.popState('building-float');
      retArr.push(')');
      return retArr;
    }

    retArr.push('(');
    const leftType = this.getType(ast.left) || 'Number';
    const rightType = this.getType(ast.right) || 'Number';
    if (!leftType || !rightType) {
      throw this.astErrorOutput(`Unhandled binary expression`, ast);
    }
    const key = leftType + ' & ' + rightType;
    switch (key) {
      case 'Integer & Integer':
        this.pushState('building-integer');
        this.astGeneric(ast.left, retArr);
        retArr.push(operatorMap[ast.operator] || ast.operator);
        this.astGeneric(ast.right, retArr);
        this.popState('building-integer');
        break;
      case 'Number & Float':
      case 'Float & Number':
      case 'Float & Float':
      case 'Number & Number':
        this.pushState('building-float');
        this.astGeneric(ast.left, retArr);
        retArr.push(operatorMap[ast.operator] || ast.operator);
        this.astGeneric(ast.right, retArr);
        this.popState('building-float');
        break;
      case 'LiteralInteger & LiteralInteger':
        if (this.isState('casting-to-integer') || this.isState('building-integer')) {
          this.pushState('building-integer');
          this.astGeneric(ast.left, retArr);
          retArr.push(operatorMap[ast.operator] || ast.operator);
          this.astGeneric(ast.right, retArr);
          this.popState('building-integer');
        } else {
          this.pushState('building-float');
          this.castLiteralToFloat(ast.left, retArr);
          retArr.push(operatorMap[ast.operator] || ast.operator);
          this.castLiteralToFloat(ast.right, retArr);
          this.popState('building-float');
        }
        break;

      case 'Integer & Float':
      case 'Integer & Number':
        if (ast.operator === '>' || ast.operator === '<' && ast.right.type === 'Literal') {
          if (!Number.isInteger(ast.right.value)) {
            this.pushState('building-float');
            this.castValueToFloat(ast.left, retArr);
            retArr.push(operatorMap[ast.operator] || ast.operator);
            this.astGeneric(ast.right, retArr);
            this.popState('building-float');
            break;
          }
        }
        this.pushState('building-integer');
        this.astGeneric(ast.left, retArr);
        retArr.push(operatorMap[ast.operator] || ast.operator);
        this.pushState('casting-to-integer');
        if (ast.right.type === 'Literal') {
          const literalResult = [];
          this.astGeneric(ast.right, literalResult);
          const literalType = this.getType(ast.right);
          if (literalType === 'Integer') {
            retArr.push(literalResult.join(''));
          } else {
            throw this.astErrorOutput(`Unhandled binary expression with literal`, ast);
          }
        } else {
          retArr.push('int(');
          this.astGeneric(ast.right, retArr);
          retArr.push(')');
        }
        this.popState('casting-to-integer');
        this.popState('building-integer');
        break;
      case 'Integer & LiteralInteger':
        this.pushState('building-integer');
        this.astGeneric(ast.left, retArr);
        retArr.push(operatorMap[ast.operator] || ast.operator);
        this.castLiteralToInteger(ast.right, retArr);
        this.popState('building-integer');
        break;

      case 'Number & Integer':
        this.pushState('building-float');
        this.astGeneric(ast.left, retArr);
        retArr.push(operatorMap[ast.operator] || ast.operator);
        this.castValueToFloat(ast.right, retArr);
        this.popState('building-float');
        break;
      case 'Float & LiteralInteger':
      case 'Number & LiteralInteger':
        this.pushState('building-float');
        this.astGeneric(ast.left, retArr);
        retArr.push(operatorMap[ast.operator] || ast.operator);
        this.castLiteralToFloat(ast.right, retArr);
        this.popState('building-float');
        break;
      case 'LiteralInteger & Float':
      case 'LiteralInteger & Number':
        if (this.isState('casting-to-integer')) {
          this.pushState('building-integer');
          this.castLiteralToInteger(ast.left, retArr);
          retArr.push(operatorMap[ast.operator] || ast.operator);
          this.castValueToInteger(ast.right, retArr);
          this.popState('building-integer');
        } else {
          this.pushState('building-float');
          this.astGeneric(ast.left, retArr);
          retArr.push(operatorMap[ast.operator] || ast.operator);
          this.pushState('casting-to-float');
          this.astGeneric(ast.right, retArr);
          this.popState('casting-to-float');
          this.popState('building-float');
        }
        break;
      case 'LiteralInteger & Integer':
        this.pushState('building-integer');
        this.castLiteralToInteger(ast.left, retArr);
        retArr.push(operatorMap[ast.operator] || ast.operator);
        this.astGeneric(ast.right, retArr);
        this.popState('building-integer');
        break;

      case 'Boolean & Boolean':
        this.pushState('building-boolean');
        this.astGeneric(ast.left, retArr);
        retArr.push(operatorMap[ast.operator] || ast.operator);
        this.astGeneric(ast.right, retArr);
        this.popState('building-boolean');
        break;

      case 'Float & Integer':
        this.pushState('building-float');
        this.astGeneric(ast.left, retArr);
        retArr.push(operatorMap[ast.operator] || ast.operator);
        this.castValueToFloat(ast.right, retArr);
        this.popState('building-float');
        break;

      default:
        throw this.astErrorOutput(`Unhandled binary expression between ${key}`, ast);
    }
    retArr.push(')');

    return retArr;
  }

  checkAndUpconvertOperator(ast, retArr) {
    const bitwiseResult = this.checkAndUpconvertBitwiseOperators(ast, retArr);
    if (bitwiseResult) {
      return bitwiseResult;
    }
    const upconvertableOperators = {
      '%': this.fixIntegerDivisionAccuracy ? 'integerCorrectionModulo' : 'modulo',
      '**': 'pow',
    };
    const foundOperator = upconvertableOperators[ast.operator];
    if (!foundOperator) return null;
    retArr.push(foundOperator);
    retArr.push('(');
    switch (this.getType(ast.left)) {
      case 'Integer':
        this.castValueToFloat(ast.left, retArr);
        break;
      case 'LiteralInteger':
        this.castLiteralToFloat(ast.left, retArr);
        break;
      default:
        this.astGeneric(ast.left, retArr);
    }
    retArr.push(',');
    switch (this.getType(ast.right)) {
      case 'Integer':
        this.castValueToFloat(ast.right, retArr);
        break;
      case 'LiteralInteger':
        this.castLiteralToFloat(ast.right, retArr);
        break;
      default:
        this.astGeneric(ast.right, retArr);
    }
    retArr.push(')');
    return retArr;
  }

  checkAndUpconvertBitwiseOperators(ast, retArr) {
    const upconvertableOperators = {
      '&': 'bitwiseAnd',
      '|': 'bitwiseOr',
      '^': 'bitwiseXOR',
      '<<': 'bitwiseZeroFillLeftShift',
      '>>': 'bitwiseSignedRightShift',
      '>>>': 'bitwiseZeroFillRightShift',
    };
    const foundOperator = upconvertableOperators[ast.operator];
    if (!foundOperator) return null;
    retArr.push(foundOperator);
    retArr.push('(');
    const leftType = this.getType(ast.left);
    switch (leftType) {
      case 'Number':
      case 'Float':
        this.castValueToInteger(ast.left, retArr);
        break;
      case 'LiteralInteger':
        this.castLiteralToInteger(ast.left, retArr);
        break;
      default:
        this.astGeneric(ast.left, retArr);
    }
    retArr.push(',');
    const rightType = this.getType(ast.right);
    switch (rightType) {
      case 'Number':
      case 'Float':
        this.castValueToInteger(ast.right, retArr);
        break;
      case 'LiteralInteger':
        this.castLiteralToInteger(ast.right, retArr);
        break;
      default:
        this.astGeneric(ast.right, retArr);
    }
    retArr.push(')');
    return retArr;
  }

  checkAndUpconvertBitwiseUnary(ast, retArr) {
    const upconvertableOperators = {
      '~': 'bitwiseNot',
    };
    const foundOperator = upconvertableOperators[ast.operator];
    if (!foundOperator) return null;
    retArr.push(foundOperator);
    retArr.push('(');
    switch (this.getType(ast.argument)) {
      case 'Number':
      case 'Float':
        this.castValueToInteger(ast.argument, retArr);
        break;
      case 'LiteralInteger':
        this.castLiteralToInteger(ast.argument, retArr);
        break;
      default:
        this.astGeneric(ast.argument, retArr);
    }
    retArr.push(')');
    return retArr;
  }

  castLiteralToInteger(ast, retArr) {
    this.pushState('casting-to-integer');
    this.astGeneric(ast, retArr);
    this.popState('casting-to-integer');
    return retArr;
  }

  castLiteralToFloat(ast, retArr) {
    this.pushState('casting-to-float');
    this.astGeneric(ast, retArr);
    this.popState('casting-to-float');
    return retArr;
  }

  castValueToInteger(ast, retArr) {
    this.pushState('casting-to-integer');
    retArr.push('int(');
    this.astGeneric(ast, retArr);
    retArr.push(')');
    this.popState('casting-to-integer');
    return retArr;
  }

  castValueToFloat(ast, retArr) {
    this.pushState('casting-to-float');
    retArr.push('float(');
    this.astGeneric(ast, retArr);
    retArr.push(')');
    this.popState('casting-to-float');
    return retArr;
  }

  astIdentifierExpression(idtNode, retArr) {
    if (idtNode.type !== 'Identifier') {
      throw this.astErrorOutput('IdentifierExpression - not an Identifier', idtNode);
    }

    const type = this.getType(idtNode);

    const name = utils.sanitizeName(idtNode.name);
    if (idtNode.name === 'Infinity') {
      retArr.push('3.402823466e+38');
    } else if (type === 'Boolean') {
      if (this.argumentNames.indexOf(name) > -1) {
        retArr.push(`bool(user_${name})`);
      } else {
        retArr.push(`user_${name}`);
      }
    } else {
      retArr.push(`user_${name}`);
    }

    return retArr;
  }

  astForStatement(forNode, retArr) {
    if (forNode.type !== 'ForStatement') {
      throw this.astErrorOutput('Invalid for statement', forNode);
    }

    const initArr = [];
    const testArr = [];
    const updateArr = [];
    const bodyArr = [];
    let isSafe = null;

    if (forNode.init) {
      const { declarations } = forNode.init;
      if (declarations.length > 1) {
        isSafe = false;
      }
      this.astGeneric(forNode.init, initArr);
      for (let i = 0; i < declarations.length; i++) {
        if (declarations[i].init && declarations[i].init.type !== 'Literal') {
          isSafe = false;
        }
      }
    } else {
      isSafe = false;
    }

    if (forNode.test) {
      this.astGeneric(forNode.test, testArr);
    } else {
      isSafe = false;
    }

    if (forNode.update) {
      this.astGeneric(forNode.update, updateArr);
    } else {
      isSafe = false;
    }

    if (forNode.body) {
      this.pushState('loop-body');
      this.astGeneric(forNode.body, bodyArr);
      this.popState('loop-body');
    }

    if (isSafe === null) {
      isSafe = this.isSafe(forNode.init) && this.isSafe(forNode.test);
    }

    if (isSafe) {
      const initString = initArr.join('');
      const initNeedsSemiColon = initString[initString.length - 1] !== ';';
      retArr.push(`for (${initString}${initNeedsSemiColon ? ';' : ''}${testArr.join('')};${updateArr.join('')}){\n`);
      retArr.push(bodyArr.join(''));
      retArr.push('}\n');
    } else {
      const iVariableName = this.getInternalVariableName('safeI');
      if (initArr.length > 0) {
        retArr.push(initArr.join(''), '\n');
      }
      retArr.push(`for (int ${iVariableName}=0;${iVariableName}<LOOP_MAX;${iVariableName}++){\n`);
      if (testArr.length > 0) {
        retArr.push(`if (!${testArr.join('')}) break;\n`);
      }
      retArr.push(bodyArr.join(''));
      retArr.push(`\n${updateArr.join('')};`);
      retArr.push('}\n');
    }
    return retArr;
  }

  astWhileStatement(whileNode, retArr) {
    if (whileNode.type !== 'WhileStatement') {
      throw this.astErrorOutput('Invalid while statement', whileNode);
    }

    const iVariableName = this.getInternalVariableName('safeI');
    retArr.push(`for (int ${iVariableName}=0;${iVariableName}<LOOP_MAX;${iVariableName}++){\n`);
    retArr.push('if (!');
    this.astGeneric(whileNode.test, retArr);
    retArr.push(') break;\n');
    this.astGeneric(whileNode.body, retArr);
    retArr.push('}\n');

    return retArr;
  }

  astDoWhileStatement(doWhileNode, retArr) {
    if (doWhileNode.type !== 'DoWhileStatement') {
      throw this.astErrorOutput('Invalid while statement', doWhileNode);
    }

    const iVariableName = this.getInternalVariableName('safeI');
    retArr.push(`for (int ${iVariableName}=0;${iVariableName}<LOOP_MAX;${iVariableName}++){\n`);
    this.astGeneric(doWhileNode.body, retArr);
    retArr.push('if (!');
    this.astGeneric(doWhileNode.test, retArr);
    retArr.push(') break;\n');
    retArr.push('}\n');

    return retArr;
  }


  astAssignmentExpression(assNode, retArr) {
    if (assNode.operator === '%=') {
      this.astGeneric(assNode.left, retArr);
      retArr.push('=');
      retArr.push('mod(');
      this.astGeneric(assNode.left, retArr);
      retArr.push(',');
      this.astGeneric(assNode.right, retArr);
      retArr.push(')');
    } else if (assNode.operator === '**=') {
      this.astGeneric(assNode.left, retArr);
      retArr.push('=');
      retArr.push('pow(');
      this.astGeneric(assNode.left, retArr);
      retArr.push(',');
      this.astGeneric(assNode.right, retArr);
      retArr.push(')');
    } else {
      const leftType = this.getType(assNode.left);
      const rightType = this.getType(assNode.right);
      this.astGeneric(assNode.left, retArr);
      retArr.push(assNode.operator);
      if (leftType !== 'Integer' && rightType === 'Integer') {
        retArr.push('float(');
        this.astGeneric(assNode.right, retArr);
        retArr.push(')');
      } else {
        this.astGeneric(assNode.right, retArr);
      }
      return retArr;
    }
  }

  astBlockStatement(bNode, retArr) {
    if (this.isState('loop-body')) {
      this.pushState('block-body'); 
      for (let i = 0; i < bNode.body.length; i++) {
        this.astGeneric(bNode.body[i], retArr);
      }
      this.popState('block-body');
    } else {
      retArr.push('{\n');
      for (let i = 0; i < bNode.body.length; i++) {
        this.astGeneric(bNode.body[i], retArr);
      }
      retArr.push('}\n');
    }
    return retArr;
  }

  astVariableDeclaration(varDecNode, retArr) {
    const declarations = varDecNode.declarations;
    if (!declarations || !declarations[0] || !declarations[0].init) {
      throw this.astErrorOutput('Unexpected expression', varDecNode);
    }
    const result = [];
    let lastType = null;
    const declarationSets = [];
    let declarationSet = [];
    for (let i = 0; i < declarations.length; i++) {
      const declaration = declarations[i];
      const init = declaration.init;
      const info = this.getDeclaration(declaration.id);
      const actualType = this.getType(declaration.init);
      let type = actualType;
      if (type === 'LiteralInteger') {
        if (info.suggestedType === 'Integer') {
          type = 'Integer';
        } else {
          type = 'Number';
        }
      }
      const markupType = typeMap[type];
      if (!markupType) {
        throw this.astErrorOutput(`Markup type ${ type } not handled`, varDecNode);
      }
      const declarationResult = [];
      if (actualType === 'Integer' && type === 'Integer') {
        info.valueType = 'Number';
        if (i === 0 || lastType === null) {
          declarationResult.push('float ');
        } else if (type !== lastType) {
          throw new Error('Unhandled declaration');
        }
        lastType = type;
        declarationResult.push(`user_${utils.sanitizeName(declaration.id.name)}=`);
        declarationResult.push('float(');
        this.astGeneric(init, declarationResult);
        declarationResult.push(')');
      } else {
        info.valueType = type;
        if (i === 0 || lastType === null) {
          declarationResult.push(`${markupType} `);
        } else if (type !== lastType) {
          declarationSets.push(declarationSet.join(','));
          declarationSet = [];
          declarationResult.push(`${markupType} `);
        }
        lastType = type;
        declarationResult.push(`user_${utils.sanitizeName(declaration.id.name)}=`);
        if (actualType === 'Number' && type === 'Integer') {
          if (init.left && init.left.type === 'Literal') {
            this.astGeneric(init, declarationResult);
          } else {
            declarationResult.push('int(');
            this.astGeneric(init, declarationResult);
            declarationResult.push(')');
          }
        } else if (actualType === 'LiteralInteger' && type === 'Integer') {
          this.castLiteralToInteger(init, declarationResult);
        } else {
          this.astGeneric(init, declarationResult);
        }
      }
      declarationSet.push(declarationResult.join(''));
    }

    if (declarationSet.length > 0) {
      declarationSets.push(declarationSet.join(','));
    }

    result.push(declarationSets.join(';'));

    retArr.push(result.join(''));
    retArr.push(';');
    return retArr;
  }

  astIfStatement(ifNode, retArr) {
    retArr.push('if (');
    this.astGeneric(ifNode.test, retArr);
    retArr.push(')');
    if (ifNode.consequent.type === 'BlockStatement') {
      this.astGeneric(ifNode.consequent, retArr);
    } else {
      retArr.push(' {\n');
      this.astGeneric(ifNode.consequent, retArr);
      retArr.push('\n}\n');
    }

    if (ifNode.alternate) {
      retArr.push('else ');
      if (ifNode.alternate.type === 'BlockStatement' || ifNode.alternate.type === 'IfStatement') {
        this.astGeneric(ifNode.alternate, retArr);
      } else {
        retArr.push(' {\n');
        this.astGeneric(ifNode.alternate, retArr);
        retArr.push('\n}\n');
      }
    }
    return retArr;
  }

  astSwitchStatement(ast, retArr) {
    if (ast.type !== 'SwitchStatement') {
      throw this.astErrorOutput('Invalid switch statement', ast);
    }
    const { discriminant, cases } = ast;
    const type = this.getType(discriminant);
    const varName = `switchDiscriminant${this.astKey(ast, '_')}`;
    switch (type) {
      case 'Float':
      case 'Number':
        retArr.push(`float ${varName} = `);
        this.astGeneric(discriminant, retArr);
        retArr.push(';\n');
        break;
      case 'Integer':
        retArr.push(`int ${varName} = `);
        this.astGeneric(discriminant, retArr);
        retArr.push(';\n');
        break;
    }
    if (cases.length === 1 && !cases[0].test) {
      this.astGeneric(cases[0].consequent, retArr);
      return retArr;
    }

    let fallingThrough = false;
    let defaultResult = [];
    let movingDefaultToEnd = false;
    let pastFirstIf = false;
    for (let i = 0; i < cases.length; i++) {
      if (!cases[i].test) {
        if (cases.length > i + 1) {
          movingDefaultToEnd = true;
          this.astGeneric(cases[i].consequent, defaultResult);
          continue;
        } else {
          retArr.push(' else {\n');
        }
      } else {
        if (i === 0 || !pastFirstIf) {
          pastFirstIf = true;
          retArr.push(`if (${varName} == `);
        } else {
          if (fallingThrough) {
            retArr.push(`${varName} == `);
            fallingThrough = false;
          } else {
            retArr.push(` else if (${varName} == `);
          }
        }
        if (type === 'Integer') {
          const testType = this.getType(cases[i].test);
          switch (testType) {
            case 'Number':
            case 'Float':
              this.castValueToInteger(cases[i].test, retArr);
              break;
            case 'LiteralInteger':
              this.castLiteralToInteger(cases[i].test, retArr);
              break;
          }
        } else if (type === 'Float') {
          const testType = this.getType(cases[i].test);
          switch (testType) {
            case 'LiteralInteger':
              this.castLiteralToFloat(cases[i].test, retArr);
              break;
            case 'Integer':
              this.castValueToFloat(cases[i].test, retArr);
              break;
          }
        } else {
          throw new Error('unhanlded');
        }
        if (!cases[i].consequent || cases[i].consequent.length === 0) {
          fallingThrough = true;
          retArr.push(' || ');
          continue;
        }
        retArr.push(`) {\n`);
      }
      this.astGeneric(cases[i].consequent, retArr);
      retArr.push('\n}');
    }
    if (movingDefaultToEnd) {
      retArr.push(' else {');
      retArr.push(defaultResult.join(''));
      retArr.push('}');
    }
    return retArr;
  }

  astThisExpression(tNode, retArr) {
    retArr.push('this');
    return retArr;
  }

  astMemberExpression(mNode, retArr) {
    const {
      property,
      name,
      signature,
      origin,
      type,
      xProperty,
      yProperty,
      zProperty
    } = this.getMemberExpressionDetails(mNode);
    switch (signature) {
      case 'value.thread.value':
      case 'this.thread.value':
        if (name !== 'x' && name !== 'y' && name !== 'z') {
          throw this.astErrorOutput('Unexpected expression, expected `this.thread.x`, `this.thread.y`, or `this.thread.z`', mNode);
        }
        retArr.push(`threadId.${name}`);
        return retArr;
      case 'this.output.value':
        if (this.dynamicOutput) {
          switch (name) {
            case 'x':
              if (this.isState('casting-to-float')) {
                retArr.push('float(uOutputDim.x)');
              } else {
                retArr.push('uOutputDim.x');
              }
              break;
            case 'y':
              if (this.isState('casting-to-float')) {
                retArr.push('float(uOutputDim.y)');
              } else {
                retArr.push('uOutputDim.y');
              }
              break;
            case 'z':
              if (this.isState('casting-to-float')) {
                retArr.push('float(uOutputDim.z)');
              } else {
                retArr.push('uOutputDim.z');
              }
              break;
            default:
              throw this.astErrorOutput('Unexpected expression', mNode);
          }
        } else {
          switch (name) {
            case 'x':
              if (this.isState('casting-to-integer')) {
                retArr.push(this.output[0]);
              } else {
                retArr.push(this.output[0], '.0');
              }
              break;
            case 'y':
              if (this.isState('casting-to-integer')) {
                retArr.push(this.output[1]);
              } else {
                retArr.push(this.output[1], '.0');
              }
              break;
            case 'z':
              if (this.isState('casting-to-integer')) {
                retArr.push(this.output[2]);
              } else {
                retArr.push(this.output[2], '.0');
              }
              break;
            default:
              throw this.astErrorOutput('Unexpected expression', mNode);
          }
        }
        return retArr;
      case 'value':
        throw this.astErrorOutput('Unexpected expression', mNode);
      case 'value[]':
      case 'value[][]':
      case 'value[][][]':
      case 'value[][][][]':
      case 'value.value':
        if (origin === 'Math') {
          retArr.push(Math[name]);
          return retArr;
        }
        const cleanName = utils.sanitizeName(name);
        switch (property) {
          case 'r':
            retArr.push(`user_${ cleanName }.r`);
            return retArr;
          case 'g':
            retArr.push(`user_${ cleanName }.g`);
            return retArr;
          case 'b':
            retArr.push(`user_${ cleanName }.b`);
            return retArr;
          case 'a':
            retArr.push(`user_${ cleanName }.a`);
            return retArr;
        }
        break;
      case 'this.constants.value':
        if (typeof xProperty === 'undefined') {
          switch (type) {
            case 'Array(2)':
            case 'Array(3)':
            case 'Array(4)':
              retArr.push(`constants_${ utils.sanitizeName(name) }`);
              return retArr;
          }
        }
        case 'this.constants.value[]':
        case 'this.constants.value[][]':
        case 'this.constants.value[][][]':
        case 'this.constants.value[][][][]':
          break;
        case 'fn()[]':
          this.astCallExpression(mNode.object, retArr);
          retArr.push('[');
          retArr.push(this.memberExpressionPropertyMarkup(property));
          retArr.push(']');
          return retArr;
        case 'fn()[][]':
          this.astCallExpression(mNode.object.object, retArr);
          retArr.push('[');
          retArr.push(this.memberExpressionPropertyMarkup(mNode.object.property));
          retArr.push(']');
          retArr.push('[');
          retArr.push(this.memberExpressionPropertyMarkup(mNode.property));
          retArr.push(']');
          return retArr;
        case '[][]':
          this.astArrayExpression(mNode.object, retArr);
          retArr.push('[');
          retArr.push(this.memberExpressionPropertyMarkup(property));
          retArr.push(']');
          return retArr;
        default:
          throw this.astErrorOutput('Unexpected expression', mNode);
    }

    if (mNode.computed === false) {
      switch (type) {
        case 'Number':
        case 'Integer':
        case 'Float':
        case 'Boolean':
          retArr.push(`${origin}_${utils.sanitizeName(name)}`);
          return retArr;
      }
    }

    const markupName = `${origin}_${utils.sanitizeName(name)}`;

    switch (type) {
      case 'Array(2)':
      case 'Array(3)':
      case 'Array(4)':
        this.astGeneric(mNode.object, retArr);
        retArr.push('[');
        retArr.push(this.memberExpressionPropertyMarkup(xProperty));
        retArr.push(']');
        break;
      case 'HTMLImageArray':
        retArr.push(`getImage3D(${ markupName }, ${ markupName }Size, ${ markupName }Dim, `);
        this.memberExpressionXYZ(xProperty, yProperty, zProperty, retArr);
        retArr.push(')');
        break;
      case 'ArrayTexture(1)':
        retArr.push(`getFloatFromSampler2D(${ markupName }, ${ markupName }Size, ${ markupName }Dim, `);
        this.memberExpressionXYZ(xProperty, yProperty, zProperty, retArr);
        retArr.push(')');
        break;
      case 'Array1D(2)':
      case 'Array2D(2)':
      case 'Array3D(2)':
        retArr.push(`getMemoryOptimizedVec2(${ markupName }, ${ markupName }Size, ${ markupName }Dim, `);
        this.memberExpressionXYZ(xProperty, yProperty, zProperty, retArr);
        retArr.push(')');
        break;
      case 'ArrayTexture(2)':
        retArr.push(`getVec2FromSampler2D(${ markupName }, ${ markupName }Size, ${ markupName }Dim, `);
        this.memberExpressionXYZ(xProperty, yProperty, zProperty, retArr);
        retArr.push(')');
        break;
      case 'Array1D(3)':
      case 'Array2D(3)':
      case 'Array3D(3)':
        retArr.push(`getMemoryOptimizedVec3(${ markupName }, ${ markupName }Size, ${ markupName }Dim, `);
        this.memberExpressionXYZ(xProperty, yProperty, zProperty, retArr);
        retArr.push(')');
        break;
      case 'ArrayTexture(3)':
        retArr.push(`getVec3FromSampler2D(${ markupName }, ${ markupName }Size, ${ markupName }Dim, `);
        this.memberExpressionXYZ(xProperty, yProperty, zProperty, retArr);
        retArr.push(')');
        break;
      case 'Array1D(4)':
      case 'Array2D(4)':
      case 'Array3D(4)':
        retArr.push(`getMemoryOptimizedVec4(${ markupName }, ${ markupName }Size, ${ markupName }Dim, `);
        this.memberExpressionXYZ(xProperty, yProperty, zProperty, retArr);
        retArr.push(')');
        break;
      case 'ArrayTexture(4)':
      case 'HTMLCanvas':
      case 'HTMLImage':
      case 'HTMLVideo':
        retArr.push(`getVec4FromSampler2D(${ markupName }, ${ markupName }Size, ${ markupName }Dim, `);
        this.memberExpressionXYZ(xProperty, yProperty, zProperty, retArr);
        retArr.push(')');
        break;
      case 'NumberTexture':
      case 'Array':
      case 'Array2D':
      case 'Array3D':
      case 'Array4D':
      case 'Input':
      case 'Number':
      case 'Float':
      case 'Integer':
        if (this.precision === 'single') {
          retArr.push(`getMemoryOptimized32(${markupName}, ${markupName}Size, ${markupName}Dim, `);
          this.memberExpressionXYZ(xProperty, yProperty, zProperty, retArr);
          retArr.push(')');
        } else {
          const bitRatio = (origin === 'user' ?
            this.lookupFunctionArgumentBitRatio(this.name, name) :
            this.constantBitRatios[name]
          );
          switch (bitRatio) {
            case 1:
              retArr.push(`get8(${markupName}, ${markupName}Size, ${markupName}Dim, `);
              break;
            case 2:
              retArr.push(`get16(${markupName}, ${markupName}Size, ${markupName}Dim, `);
              break;
            case 4:
            case 0:
              retArr.push(`get32(${markupName}, ${markupName}Size, ${markupName}Dim, `);
              break;
            default:
              throw new Error(`unhandled bit ratio of ${bitRatio}`);
          }
          this.memberExpressionXYZ(xProperty, yProperty, zProperty, retArr);
          retArr.push(')');
        }
        break;
      case 'MemoryOptimizedNumberTexture':
        retArr.push(`getMemoryOptimized32(${ markupName }, ${ markupName }Size, ${ markupName }Dim, `);
        this.memberExpressionXYZ(xProperty, yProperty, zProperty, retArr);
        retArr.push(')');
        break;
      case 'Matrix(2)':
      case 'Matrix(3)':
      case 'Matrix(4)':
        retArr.push(`${markupName}[${this.memberExpressionPropertyMarkup(yProperty)}]`);
        if (yProperty) {
          retArr.push(`[${this.memberExpressionPropertyMarkup(xProperty)}]`);
        }
        break;
      default:
        throw new Error(`unhandled member expression "${ type }"`);
    }
    return retArr;
  }

  astCallExpression(ast, retArr) {
    if (!ast.callee) {
      throw this.astErrorOutput('Unknown CallExpression', ast);
    }

    let functionName = null;
    const isMathFunction = this.isAstMathFunction(ast);

    if (isMathFunction || (ast.callee.object && ast.callee.object.type === 'ThisExpression')) {
      functionName = ast.callee.property.name;
    }
    else if (ast.callee.type === 'SequenceExpression' && ast.callee.expressions[0].type === 'Literal' && !isNaN(ast.callee.expressions[0].raw)) {
      functionName = ast.callee.expressions[1].property.name;
    } else {
      functionName = ast.callee.name;
    }

    if (!functionName) {
      throw this.astErrorOutput(`Unhandled function, couldn't find name`, ast);
    }

    switch (functionName) {
      case 'pow':
        functionName = '_pow';
        break;
      case 'round':
        functionName = '_round';
        break;
    }

    if (this.calledFunctions.indexOf(functionName) < 0) {
      this.calledFunctions.push(functionName);
    }

    if (functionName === 'random' && this.plugins && this.plugins.length > 0) {
      for (let i = 0; i < this.plugins.length; i++) {
        const plugin = this.plugins[i];
        if (plugin.functionMatch === 'Math.random()' && plugin.functionReplace) {
          retArr.push(plugin.functionReplace);
          return retArr;
        }
      }
    }

    if (this.onFunctionCall) {
      this.onFunctionCall(this.name, functionName, ast.arguments);
    }

    retArr.push(functionName);

    retArr.push('(');

    if (isMathFunction) {
      for (let i = 0; i < ast.arguments.length; ++i) {
        const argument = ast.arguments[i];
        const argumentType = this.getType(argument);
        if (i > 0) {
          retArr.push(', ');
        }

        switch (argumentType) {
          case 'Integer':
            this.castValueToFloat(argument, retArr);
            break;
          default:
            this.astGeneric(argument, retArr);
            break;
        }
      }
    } else {
      const targetTypes = this.lookupFunctionArgumentTypes(functionName) || [];
      for (let i = 0; i < ast.arguments.length; ++i) {
        const argument = ast.arguments[i];
        let targetType = targetTypes[i];
        if (i > 0) {
          retArr.push(', ');
        }
        const argumentType = this.getType(argument);
        if (!targetType) {
          this.triggerImplyArgumentType(functionName, i, argumentType, this);
          targetType = argumentType;
        }
        switch (argumentType) {
          case 'Boolean':
            this.astGeneric(argument, retArr);
            continue;
          case 'Number':
          case 'Float':
            if (targetType === 'Integer') {
              retArr.push('int(');
              this.astGeneric(argument, retArr);
              retArr.push(')');
              continue;
            } else if (targetType === 'Number' || targetType === 'Float') {
              this.astGeneric(argument, retArr);
              continue;
            } else if (targetType === 'LiteralInteger') {
              this.castLiteralToFloat(argument, retArr);
              continue;
            }
            break;
          case 'Integer':
            if (targetType === 'Number' || targetType === 'Float') {
              retArr.push('float(');
              this.astGeneric(argument, retArr);
              retArr.push(')');
              continue;
            } else if (targetType === 'Integer') {
              this.astGeneric(argument, retArr);
              continue;
            }
            break;
          case 'LiteralInteger':
            if (targetType === 'Integer') {
              this.castLiteralToInteger(argument, retArr);
              continue;
            } else if (targetType === 'Number' || targetType === 'Float') {
              this.castLiteralToFloat(argument, retArr);
              continue;
            } else if (targetType === 'LiteralInteger') {
              this.astGeneric(argument, retArr);
              continue;
            }
            break;
          case 'Array(2)':
          case 'Array(3)':
          case 'Array(4)':
            if (targetType === argumentType) {
              if (argument.type === 'Identifier') {
                retArr.push(`user_${utils.sanitizeName(argument.name)}`);
              } else if (argument.type === 'ArrayExpression' || argument.type === 'MemberExpression' || argument.type === 'CallExpression') {
                this.astGeneric(argument, retArr);
              } else {
                throw this.astErrorOutput(`Unhandled argument type ${ argument.type }`, ast);
              }
              continue;
            }
            break;
          case 'HTMLCanvas':
          case 'HTMLImage':
          case 'HTMLImageArray':
          case 'HTMLVideo':
          case 'ArrayTexture(1)':
          case 'ArrayTexture(2)':
          case 'ArrayTexture(3)':
          case 'ArrayTexture(4)':
          case 'Array':
          case 'Input':
            if (targetType === argumentType) {
              if (argument.type !== 'Identifier') throw this.astErrorOutput(`Unhandled argument type ${ argument.type }`, ast);
              this.triggerImplyArgumentBitRatio(this.name, argument.name, functionName, i);
              const name = utils.sanitizeName(argument.name);
              retArr.push(`user_${name},user_${name}Size,user_${name}Dim`);
              continue;
            }
            break;
        }
        throw this.astErrorOutput(`Unhandled argument combination of ${ argumentType } and ${ targetType } for argument named "${ argument.name }"`, ast);
      }
    }
    retArr.push(')');

    return retArr;
  }

  astArrayExpression(arrNode, retArr) {
    const returnType = this.getType(arrNode);

    const arrLen = arrNode.elements.length;

    switch (returnType) {
      case 'Matrix(2)':
      case 'Matrix(3)':
      case 'Matrix(4)':
        retArr.push(`mat${arrLen}(`);
        break;
      default:
        retArr.push(`vec${arrLen}(`);
    }
    for (let i = 0; i < arrLen; ++i) {
      if (i > 0) {
        retArr.push(', ');
      }
      const subNode = arrNode.elements[i];
      this.astGeneric(subNode, retArr)
    }
    retArr.push(')');

    return retArr;
  }

  memberExpressionXYZ(x, y, z, retArr) {
    if (z) {
      retArr.push(this.memberExpressionPropertyMarkup(z), ', ');
    } else {
      retArr.push('0, ');
    }
    if (y) {
      retArr.push(this.memberExpressionPropertyMarkup(y), ', ');
    } else {
      retArr.push('0, ');
    }
    retArr.push(this.memberExpressionPropertyMarkup(x));
    return retArr;
  }

  memberExpressionPropertyMarkup(property) {
    if (!property) {
      throw new Error('Property not set');
    }
    const type = this.getType(property);
    const result = [];
    switch (type) {
      case 'Number':
      case 'Float':
        this.castValueToInteger(property, result);
        break;
      case 'LiteralInteger':
        this.castLiteralToInteger(property, result);
        break;
      default:
        this.astGeneric(property, result);
    }
    return result.join('');
  }
}

const typeMap = {
  'Array': 'sampler2D',
  'Array(2)': 'vec2',
  'Array(3)': 'vec3',
  'Array(4)': 'vec4',
  'Matrix(2)': 'mat2',
  'Matrix(3)': 'mat3',
  'Matrix(4)': 'mat4',
  'Array2D': 'sampler2D',
  'Array3D': 'sampler2D',
  'Boolean': 'bool',
  'Float': 'float',
  'Input': 'sampler2D',
  'Integer': 'int',
  'Number': 'float',
  'LiteralInteger': 'float',
  'NumberTexture': 'sampler2D',
  'MemoryOptimizedNumberTexture': 'sampler2D',
  'ArrayTexture(1)': 'sampler2D',
  'ArrayTexture(2)': 'sampler2D',
  'ArrayTexture(3)': 'sampler2D',
  'ArrayTexture(4)': 'sampler2D',
  'HTMLVideo': 'sampler2D',
  'HTMLCanvas': 'sampler2D',
  'HTMLImage': 'sampler2D',
  'HTMLImageArray': 'sampler2DArray',
};

const operatorMap = {
  '===': '==',
  '!==': '!='
};

module.exports = {
  WebGLFunctionNode
};
},{"../../utils":114,"../function-node":10}],39:[function(require,module,exports){
const { WebGLKernelValueBoolean } = require('./kernel-value/boolean');
const { WebGLKernelValueFloat } = require('./kernel-value/float');
const { WebGLKernelValueInteger } = require('./kernel-value/integer');

const { WebGLKernelValueHTMLImage } = require('./kernel-value/html-image');
const { WebGLKernelValueDynamicHTMLImage } = require('./kernel-value/dynamic-html-image');

const { WebGLKernelValueHTMLVideo } = require('./kernel-value/html-video');
const { WebGLKernelValueDynamicHTMLVideo } = require('./kernel-value/dynamic-html-video');

const { WebGLKernelValueSingleInput } = require('./kernel-value/single-input');
const { WebGLKernelValueDynamicSingleInput } = require('./kernel-value/dynamic-single-input');

const { WebGLKernelValueUnsignedInput } = require('./kernel-value/unsigned-input');
const { WebGLKernelValueDynamicUnsignedInput } = require('./kernel-value/dynamic-unsigned-input');

const { WebGLKernelValueMemoryOptimizedNumberTexture } = require('./kernel-value/memory-optimized-number-texture');
const { WebGLKernelValueDynamicMemoryOptimizedNumberTexture } = require('./kernel-value/dynamic-memory-optimized-number-texture');

const { WebGLKernelValueNumberTexture } = require('./kernel-value/number-texture');
const { WebGLKernelValueDynamicNumberTexture } = require('./kernel-value/dynamic-number-texture');

const { WebGLKernelValueSingleArray } = require('./kernel-value/single-array');
const { WebGLKernelValueDynamicSingleArray } = require('./kernel-value/dynamic-single-array');

const { WebGLKernelValueSingleArray1DI } = require('./kernel-value/single-array1d-i');
const { WebGLKernelValueDynamicSingleArray1DI } = require('./kernel-value/dynamic-single-array1d-i');

const { WebGLKernelValueSingleArray2DI } = require('./kernel-value/single-array2d-i');
const { WebGLKernelValueDynamicSingleArray2DI } = require('./kernel-value/dynamic-single-array2d-i');

const { WebGLKernelValueSingleArray3DI } = require('./kernel-value/single-array3d-i');
const { WebGLKernelValueDynamicSingleArray3DI } = require('./kernel-value/dynamic-single-array3d-i');

const { WebGLKernelValueSingleArray2 } = require('./kernel-value/single-array2');
const { WebGLKernelValueSingleArray3 } = require('./kernel-value/single-array3');
const { WebGLKernelValueSingleArray4 } = require('./kernel-value/single-array4');

const { WebGLKernelValueUnsignedArray } = require('./kernel-value/unsigned-array');
const { WebGLKernelValueDynamicUnsignedArray } = require('./kernel-value/dynamic-unsigned-array');

const kernelValueMaps = {
  unsigned: {
    dynamic: {
      'Boolean': WebGLKernelValueBoolean,
      'Integer': WebGLKernelValueInteger,
      'Float': WebGLKernelValueFloat,
      'Array': WebGLKernelValueDynamicUnsignedArray,
      'Array(2)': false,
      'Array(3)': false,
      'Array(4)': false,
      'Array1D(2)': false,
      'Array1D(3)': false,
      'Array1D(4)': false,
      'Array2D(2)': false,
      'Array2D(3)': false,
      'Array2D(4)': false,
      'Array3D(2)': false,
      'Array3D(3)': false,
      'Array3D(4)': false,
      'Input': WebGLKernelValueDynamicUnsignedInput,
      'NumberTexture': WebGLKernelValueDynamicNumberTexture,
      'ArrayTexture(1)': WebGLKernelValueDynamicNumberTexture,
      'ArrayTexture(2)': WebGLKernelValueDynamicNumberTexture,
      'ArrayTexture(3)': WebGLKernelValueDynamicNumberTexture,
      'ArrayTexture(4)': WebGLKernelValueDynamicNumberTexture,
      'MemoryOptimizedNumberTexture': WebGLKernelValueDynamicMemoryOptimizedNumberTexture,
      'HTMLCanvas': WebGLKernelValueDynamicHTMLImage,
      'HTMLImage': WebGLKernelValueDynamicHTMLImage,
      'HTMLImageArray': false,
      'HTMLVideo': WebGLKernelValueDynamicHTMLVideo,
    },
    static: {
      'Boolean': WebGLKernelValueBoolean,
      'Float': WebGLKernelValueFloat,
      'Integer': WebGLKernelValueInteger,
      'Array': WebGLKernelValueUnsignedArray,
      'Array(2)': false,
      'Array(3)': false,
      'Array(4)': false,
      'Array1D(2)': false,
      'Array1D(3)': false,
      'Array1D(4)': false,
      'Array2D(2)': false,
      'Array2D(3)': false,
      'Array2D(4)': false,
      'Array3D(2)': false,
      'Array3D(3)': false,
      'Array3D(4)': false,
      'Input': WebGLKernelValueUnsignedInput,
      'NumberTexture': WebGLKernelValueNumberTexture,
      'ArrayTexture(1)': WebGLKernelValueNumberTexture,
      'ArrayTexture(2)': WebGLKernelValueNumberTexture,
      'ArrayTexture(3)': WebGLKernelValueNumberTexture,
      'ArrayTexture(4)': WebGLKernelValueNumberTexture,
      'MemoryOptimizedNumberTexture': WebGLKernelValueMemoryOptimizedNumberTexture,
      'HTMLCanvas': WebGLKernelValueHTMLImage,
      'HTMLImage': WebGLKernelValueHTMLImage,
      'HTMLImageArray': false,
      'HTMLVideo': WebGLKernelValueHTMLVideo,
    }
  },
  single: {
    dynamic: {
      'Boolean': WebGLKernelValueBoolean,
      'Integer': WebGLKernelValueInteger,
      'Float': WebGLKernelValueFloat,
      'Array': WebGLKernelValueDynamicSingleArray,
      'Array(2)': WebGLKernelValueSingleArray2,
      'Array(3)': WebGLKernelValueSingleArray3,
      'Array(4)': WebGLKernelValueSingleArray4,
      'Array1D(2)': WebGLKernelValueDynamicSingleArray1DI,
      'Array1D(3)': WebGLKernelValueDynamicSingleArray1DI,
      'Array1D(4)': WebGLKernelValueDynamicSingleArray1DI,
      'Array2D(2)': WebGLKernelValueDynamicSingleArray2DI,
      'Array2D(3)': WebGLKernelValueDynamicSingleArray2DI,
      'Array2D(4)': WebGLKernelValueDynamicSingleArray2DI,
      'Array3D(2)': WebGLKernelValueDynamicSingleArray3DI,
      'Array3D(3)': WebGLKernelValueDynamicSingleArray3DI,
      'Array3D(4)': WebGLKernelValueDynamicSingleArray3DI,
      'Input': WebGLKernelValueDynamicSingleInput,
      'NumberTexture': WebGLKernelValueDynamicNumberTexture,
      'ArrayTexture(1)': WebGLKernelValueDynamicNumberTexture,
      'ArrayTexture(2)': WebGLKernelValueDynamicNumberTexture,
      'ArrayTexture(3)': WebGLKernelValueDynamicNumberTexture,
      'ArrayTexture(4)': WebGLKernelValueDynamicNumberTexture,
      'MemoryOptimizedNumberTexture': WebGLKernelValueDynamicMemoryOptimizedNumberTexture,
      'HTMLCanvas': WebGLKernelValueDynamicHTMLImage,
      'HTMLImage': WebGLKernelValueDynamicHTMLImage,
      'HTMLImageArray': false,
      'HTMLVideo': WebGLKernelValueDynamicHTMLVideo,
    },
    static: {
      'Boolean': WebGLKernelValueBoolean,
      'Float': WebGLKernelValueFloat,
      'Integer': WebGLKernelValueInteger,
      'Array': WebGLKernelValueSingleArray,
      'Array(2)': WebGLKernelValueSingleArray2,
      'Array(3)': WebGLKernelValueSingleArray3,
      'Array(4)': WebGLKernelValueSingleArray4,
      'Array1D(2)': WebGLKernelValueSingleArray1DI,
      'Array1D(3)': WebGLKernelValueSingleArray1DI,
      'Array1D(4)': WebGLKernelValueSingleArray1DI,
      'Array2D(2)': WebGLKernelValueSingleArray2DI,
      'Array2D(3)': WebGLKernelValueSingleArray2DI,
      'Array2D(4)': WebGLKernelValueSingleArray2DI,
      'Array3D(2)': WebGLKernelValueSingleArray3DI,
      'Array3D(3)': WebGLKernelValueSingleArray3DI,
      'Array3D(4)': WebGLKernelValueSingleArray3DI,
      'Input': WebGLKernelValueSingleInput,
      'NumberTexture': WebGLKernelValueNumberTexture,
      'ArrayTexture(1)': WebGLKernelValueNumberTexture,
      'ArrayTexture(2)': WebGLKernelValueNumberTexture,
      'ArrayTexture(3)': WebGLKernelValueNumberTexture,
      'ArrayTexture(4)': WebGLKernelValueNumberTexture,
      'MemoryOptimizedNumberTexture': WebGLKernelValueMemoryOptimizedNumberTexture,
      'HTMLCanvas': WebGLKernelValueHTMLImage,
      'HTMLImage': WebGLKernelValueHTMLImage,
      'HTMLImageArray': false,
      'HTMLVideo': WebGLKernelValueHTMLVideo,
    }
  },
};

function lookupKernelValueType(type, dynamic, precision, value) {
  if (!type) {
    throw new Error('type missing');
  }
  if (!dynamic) {
    throw new Error('dynamic missing');
  }
  if (!precision) {
    throw new Error('precision missing');
  }
  if (value.type) {
    type = value.type;
  }
  const types = kernelValueMaps[precision][dynamic];
  if (types[type] === false) {
    return null;
  } else if (types[type] === undefined) {
    throw new Error(`Could not find a KernelValue for ${ type }`);
  }
  return types[type];
}

module.exports = {
  lookupKernelValueType,
  kernelValueMaps,
};
},{"./kernel-value/boolean":41,"./kernel-value/dynamic-html-image":42,"./kernel-value/dynamic-html-video":43,"./kernel-value/dynamic-memory-optimized-number-texture":44,"./kernel-value/dynamic-number-texture":45,"./kernel-value/dynamic-single-array":46,"./kernel-value/dynamic-single-array1d-i":47,"./kernel-value/dynamic-single-array2d-i":48,"./kernel-value/dynamic-single-array3d-i":49,"./kernel-value/dynamic-single-input":50,"./kernel-value/dynamic-unsigned-array":51,"./kernel-value/dynamic-unsigned-input":52,"./kernel-value/float":53,"./kernel-value/html-image":54,"./kernel-value/html-video":55,"./kernel-value/integer":57,"./kernel-value/memory-optimized-number-texture":58,"./kernel-value/number-texture":59,"./kernel-value/single-array":60,"./kernel-value/single-array1d-i":61,"./kernel-value/single-array2":62,"./kernel-value/single-array2d-i":63,"./kernel-value/single-array3":64,"./kernel-value/single-array3d-i":65,"./kernel-value/single-array4":66,"./kernel-value/single-input":67,"./kernel-value/unsigned-array":68,"./kernel-value/unsigned-input":69}],40:[function(require,module,exports){
const { WebGLKernelValue } = require('./index');
const { Input } = require('../../../input');

class WebGLKernelArray extends WebGLKernelValue {
  checkSize(width, height) {
    if (!this.kernel.validate) return;
    const { maxTextureSize } = this.kernel.constructor.features;
    if (width > maxTextureSize || height > maxTextureSize) {
      if (width > height) {
        throw new Error(`Argument texture width of ${width} larger than maximum size of ${maxTextureSize} for your GPU`);
      } else if (width < height) {
        throw new Error(`Argument texture height of ${height} larger than maximum size of ${maxTextureSize} for your GPU`);
      } else {
        throw new Error(`Argument texture height and width of ${height} larger than maximum size of ${maxTextureSize} for your GPU`);
      }
    }
  }

  setup() {
    this.requestTexture();
    this.setupTexture();
    this.defineTexture();
  }

  requestTexture() {
    this.texture = this.onRequestTexture();
  }

  defineTexture() {
    const { context: gl } = this;
    gl.activeTexture(this.contextHandle);
    gl.bindTexture(gl.TEXTURE_2D, this.texture);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
  }

  setupTexture() {
    this.contextHandle = this.onRequestContextHandle();
    this.index = this.onRequestIndex();
    this.dimensionsId = this.id + 'Dim';
    this.sizeId = this.id + 'Size';
  }

  getBitRatio(value) {
    if (Array.isArray(value[0])) {
      return this.getBitRatio(value[0]);
    } else if (value.constructor === Input) {
      return this.getBitRatio(value.value);
    }
    switch (value.constructor) {
      case Uint8ClampedArray:
      case Uint8Array:
      case Int8Array:
        return 1;
      case Uint16Array:
      case Int16Array:
        return 2;
      case Float32Array:
      case Int32Array:
      default:
        return 4;
    }
  }

  destroy() {
    if (this.prevArg) {
      this.prevArg.delete();
    }
    this.context.deleteTexture(this.texture);
  }
}

module.exports = {
  WebGLKernelArray
};
},{"../../../input":110,"./index":56}],41:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGLKernelValue } = require('./index');

class WebGLKernelValueBoolean extends WebGLKernelValue {
  constructor(value, settings) {
    super(value, settings);
    this.uploadValue = value;
  }
  getSource(value) {
    if (this.origin === 'constants') {
      return `const bool ${this.id} = ${value};\n`;
    }
    return `uniform bool ${this.id};\n`;
  }

  getStringValueHandler() {
    return `const uploadValue_${this.name} = ${this.varName};\n`;
  }

  updateValue(value) {
    if (this.origin === 'constants') return;
    this.kernel.setUniform1i(this.id, this.uploadValue = value);
  }
}

module.exports = {
  WebGLKernelValueBoolean
};
},{"../../../utils":114,"./index":56}],42:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGLKernelValueHTMLImage } = require('./html-image');

class WebGLKernelValueDynamicHTMLImage extends WebGLKernelValueHTMLImage {
  getSource() {
    return utils.linesToString([
      `uniform sampler2D ${this.id}`,
      `uniform ivec2 ${this.sizeId}`,
      `uniform ivec3 ${this.dimensionsId}`,
    ]);
  }

  updateValue(value) {
    const { width, height } = value;
    this.checkSize(width, height);
    this.dimensions = [width, height, 1];
    this.textureSize = [width, height];
    this.kernel.setUniform3iv(this.dimensionsId, this.dimensions);
    this.kernel.setUniform2iv(this.sizeId, this.textureSize);
    super.updateValue(value);
  }
}

module.exports = {
  WebGLKernelValueDynamicHTMLImage
};
},{"../../../utils":114,"./html-image":54}],43:[function(require,module,exports){
const { WebGLKernelValueDynamicHTMLImage } = require('./dynamic-html-image');

class WebGLKernelValueDynamicHTMLVideo extends WebGLKernelValueDynamicHTMLImage {}

module.exports = {
  WebGLKernelValueDynamicHTMLVideo
};
},{"./dynamic-html-image":42}],44:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGLKernelValueMemoryOptimizedNumberTexture } = require('./memory-optimized-number-texture');

class WebGLKernelValueDynamicMemoryOptimizedNumberTexture extends WebGLKernelValueMemoryOptimizedNumberTexture {
  getSource() {
    return utils.linesToString([
      `uniform sampler2D ${this.id}`,
      `uniform ivec2 ${this.sizeId}`,
      `uniform ivec3 ${this.dimensionsId}`,
    ]);
  }

  updateValue(inputTexture) {
    this.dimensions = inputTexture.dimensions;
    this.checkSize(inputTexture.size[0], inputTexture.size[1]);
    this.textureSize = inputTexture.size;
    this.kernel.setUniform3iv(this.dimensionsId, this.dimensions);
    this.kernel.setUniform2iv(this.sizeId, this.textureSize);
    super.updateValue(inputTexture);
  }
}

module.exports = {
  WebGLKernelValueDynamicMemoryOptimizedNumberTexture
};
},{"../../../utils":114,"./memory-optimized-number-texture":58}],45:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGLKernelValueNumberTexture } = require('./number-texture');

class WebGLKernelValueDynamicNumberTexture extends WebGLKernelValueNumberTexture {
  getSource() {
    return utils.linesToString([
      `uniform sampler2D ${this.id}`,
      `uniform ivec2 ${this.sizeId}`,
      `uniform ivec3 ${this.dimensionsId}`,
    ]);
  }

  updateValue(value) {
    this.dimensions = value.dimensions;
    this.checkSize(value.size[0], value.size[1]);
    this.textureSize = value.size;
    this.kernel.setUniform3iv(this.dimensionsId, this.dimensions);
    this.kernel.setUniform2iv(this.sizeId, this.textureSize);
    super.updateValue(value);
  }
}

module.exports = {
  WebGLKernelValueDynamicNumberTexture
};
},{"../../../utils":114,"./number-texture":59}],46:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGLKernelValueSingleArray } = require('./single-array');

class WebGLKernelValueDynamicSingleArray extends WebGLKernelValueSingleArray {
  getSource() {
    return utils.linesToString([
      `uniform sampler2D ${this.id}`,
      `uniform ivec2 ${this.sizeId}`,
      `uniform ivec3 ${this.dimensionsId}`,
    ]);
  }

  updateValue(value) {
    this.dimensions = utils.getDimensions(value, true);
    this.textureSize = utils.getMemoryOptimizedFloatTextureSize(this.dimensions, this.bitRatio);
    this.uploadArrayLength = this.textureSize[0] * this.textureSize[1] * this.bitRatio;
    this.checkSize(this.textureSize[0], this.textureSize[1]);
    this.uploadValue = new Float32Array(this.uploadArrayLength);
    this.kernel.setUniform3iv(this.dimensionsId, this.dimensions);
    this.kernel.setUniform2iv(this.sizeId, this.textureSize);
    super.updateValue(value);
  }
}

module.exports = {
  WebGLKernelValueDynamicSingleArray
};
},{"../../../utils":114,"./single-array":60}],47:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGLKernelValueSingleArray1DI } = require('./single-array1d-i');

class WebGLKernelValueDynamicSingleArray1DI extends WebGLKernelValueSingleArray1DI {
  getSource() {
    return utils.linesToString([
      `uniform sampler2D ${this.id}`,
      `uniform ivec2 ${this.sizeId}`,
      `uniform ivec3 ${this.dimensionsId}`,
    ]);
  }

  updateValue(value) {
    this.setShape(value);
    this.kernel.setUniform3iv(this.dimensionsId, this.dimensions);
    this.kernel.setUniform2iv(this.sizeId, this.textureSize);
    super.updateValue(value);
  }
}

module.exports = {
  WebGLKernelValueDynamicSingleArray1DI
};
},{"../../../utils":114,"./single-array1d-i":61}],48:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGLKernelValueSingleArray2DI } = require('./single-array2d-i');

class WebGLKernelValueDynamicSingleArray2DI extends WebGLKernelValueSingleArray2DI {
  getSource() {
    return utils.linesToString([
      `uniform sampler2D ${this.id}`,
      `uniform ivec2 ${this.sizeId}`,
      `uniform ivec3 ${this.dimensionsId}`,
    ]);
  }

  updateValue(value) {
    this.setShape(value);
    this.kernel.setUniform3iv(this.dimensionsId, this.dimensions);
    this.kernel.setUniform2iv(this.sizeId, this.textureSize);
    super.updateValue(value);
  }
}

module.exports = {
  WebGLKernelValueDynamicSingleArray2DI
};
},{"../../../utils":114,"./single-array2d-i":63}],49:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGLKernelValueSingleArray3DI } = require('./single-array3d-i');

class WebGLKernelValueDynamicSingleArray3DI extends WebGLKernelValueSingleArray3DI {
  getSource() {
    return utils.linesToString([
      `uniform sampler2D ${this.id}`,
      `uniform ivec2 ${this.sizeId}`,
      `uniform ivec3 ${this.dimensionsId}`,
    ]);
  }

  updateValue(value) {
    this.setShape(value);
    this.kernel.setUniform3iv(this.dimensionsId, this.dimensions);
    this.kernel.setUniform2iv(this.sizeId, this.textureSize);
    super.updateValue(value);
  }
}

module.exports = {
  WebGLKernelValueDynamicSingleArray3DI
};
},{"../../../utils":114,"./single-array3d-i":65}],50:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGLKernelValueSingleInput } = require('./single-input');

class WebGLKernelValueDynamicSingleInput extends WebGLKernelValueSingleInput {
  getSource() {
    return utils.linesToString([
      `uniform sampler2D ${this.id}`,
      `uniform ivec2 ${this.sizeId}`,
      `uniform ivec3 ${this.dimensionsId}`,
    ]);
  }

  updateValue(value) {
    let [w, h, d] = value.size;
    this.dimensions = new Int32Array([w || 1, h || 1, d || 1]);
    this.textureSize = utils.getMemoryOptimizedFloatTextureSize(this.dimensions, this.bitRatio);
    this.uploadArrayLength = this.textureSize[0] * this.textureSize[1] * this.bitRatio;
    this.checkSize(this.textureSize[0], this.textureSize[1]);
    this.uploadValue = new Float32Array(this.uploadArrayLength);
    this.kernel.setUniform3iv(this.dimensionsId, this.dimensions);
    this.kernel.setUniform2iv(this.sizeId, this.textureSize);
    super.updateValue(value);
  }
}

module.exports = {
  WebGLKernelValueDynamicSingleInput
};
},{"../../../utils":114,"./single-input":67}],51:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGLKernelValueUnsignedArray } = require('./unsigned-array');

class WebGLKernelValueDynamicUnsignedArray extends WebGLKernelValueUnsignedArray {
  getSource() {
    return utils.linesToString([
      `uniform sampler2D ${this.id}`,
      `uniform ivec2 ${this.sizeId}`,
      `uniform ivec3 ${this.dimensionsId}`,
    ]);
  }

  updateValue(value) {
    this.dimensions = utils.getDimensions(value, true);
    this.textureSize = utils.getMemoryOptimizedPackedTextureSize(this.dimensions, this.bitRatio);
    this.uploadArrayLength = this.textureSize[0] * this.textureSize[1] * (4 / this.bitRatio);
    this.checkSize(this.textureSize[0], this.textureSize[1]);
    const Type = this.getTransferArrayType(value);
    this.preUploadValue = new Type(this.uploadArrayLength);
    this.uploadValue = new Uint8Array(this.preUploadValue.buffer);
    this.kernel.setUniform3iv(this.dimensionsId, this.dimensions);
    this.kernel.setUniform2iv(this.sizeId, this.textureSize);
    super.updateValue(value);
  }
}

module.exports = {
  WebGLKernelValueDynamicUnsignedArray
};
},{"../../../utils":114,"./unsigned-array":68}],52:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGLKernelValueUnsignedInput } = require('./unsigned-input');

class WebGLKernelValueDynamicUnsignedInput extends WebGLKernelValueUnsignedInput {
  getSource() {
    return utils.linesToString([
      `uniform sampler2D ${this.id}`,
      `uniform ivec2 ${this.sizeId}`,
      `uniform ivec3 ${this.dimensionsId}`,
    ]);
  }

  updateValue(value) {
    let [w, h, d] = value.size;
    this.dimensions = new Int32Array([w || 1, h || 1, d || 1]);
    this.textureSize = utils.getMemoryOptimizedPackedTextureSize(this.dimensions, this.bitRatio);
    this.uploadArrayLength = this.textureSize[0] * this.textureSize[1] * (4 / this.bitRatio);
    this.checkSize(this.textureSize[0], this.textureSize[1]);
    const Type = this.getTransferArrayType(value.value);
    this.preUploadValue = new Type(this.uploadArrayLength);
    this.uploadValue = new Uint8Array(this.preUploadValue.buffer);
    this.kernel.setUniform3iv(this.dimensionsId, this.dimensions);
    this.kernel.setUniform2iv(this.sizeId, this.textureSize);
    super.updateValue(value);
  }
}

module.exports = {
  WebGLKernelValueDynamicUnsignedInput
};
},{"../../../utils":114,"./unsigned-input":69}],53:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGLKernelValue } = require('./index');

class WebGLKernelValueFloat extends WebGLKernelValue {
  constructor(value, settings) {
    super(value, settings);
    this.uploadValue = value;
  }
  getStringValueHandler() {
    return `const uploadValue_${this.name} = ${this.varName};\n`;
  }
  getSource(value) {
    if (this.origin === 'constants') {
      if (Number.isInteger(value)) {
        return `const float ${this.id} = ${value}.0;\n`;
      }
      return `const float ${this.id} = ${value};\n`;
    }
    return `uniform float ${this.id};\n`;
  }

  updateValue(value) {
    if (this.origin === 'constants') return;
    this.kernel.setUniform1f(this.id, this.uploadValue = value);
  }
}

module.exports = {
  WebGLKernelValueFloat
};
},{"../../../utils":114,"./index":56}],54:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGLKernelArray } = require('./array');

class WebGLKernelValueHTMLImage extends WebGLKernelArray {
  constructor(value, settings) {
    super(value, settings);
    const { width, height } = value;
    this.checkSize(width, height);
    this.dimensions = [width, height, 1];
    this.textureSize = [width, height];
    this.uploadValue = value;
  }

  getStringValueHandler() {
    return `const uploadValue_${this.name} = ${this.varName};\n`;
  }

  getSource() {
    return utils.linesToString([
      `uniform sampler2D ${this.id}`,
      `ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`,
      `ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`,
    ]);
  }

  updateValue(inputImage) {
    if (inputImage.constructor !== this.initialValueConstructor) {
      this.onUpdateValueMismatch(inputImage.constructor);
      return;
    }
    const { context: gl } = this;
    gl.activeTexture(this.contextHandle);
    gl.bindTexture(gl.TEXTURE_2D, this.texture);
    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, this.uploadValue = inputImage);
    this.kernel.setUniform1i(this.id, this.index);
  }
}

module.exports = {
  WebGLKernelValueHTMLImage
};
},{"../../../utils":114,"./array":40}],55:[function(require,module,exports){
const { WebGLKernelValueHTMLImage } = require('./html-image');

class WebGLKernelValueHTMLVideo extends WebGLKernelValueHTMLImage {}

module.exports = {
  WebGLKernelValueHTMLVideo
};
},{"./html-image":54}],56:[function(require,module,exports){
const { utils } = require('../../../utils');
const { KernelValue } = require('../../kernel-value');

class WebGLKernelValue extends KernelValue {
  constructor(value, settings) {
    super(value, settings);
    this.dimensionsId = null;
    this.sizeId = null;
    this.initialValueConstructor = value.constructor;
    this.onRequestTexture = settings.onRequestTexture;
    this.onRequestIndex = settings.onRequestIndex;
    this.uploadValue = null;
    this.textureSize = null;
    this.bitRatio = null;
    this.prevArg = null;
  }

  get id() {
    return `${this.origin}_${utils.sanitizeName(this.name)}`;
  }

  setup() {}

  getTransferArrayType(value) {
    if (Array.isArray(value[0])) {
      return this.getTransferArrayType(value[0]);
    }
    switch (value.constructor) {
      case Array:
      case Int32Array:
      case Int16Array:
      case Int8Array:
        return Float32Array;
      case Uint8ClampedArray:
      case Uint8Array:
      case Uint16Array:
      case Uint32Array:
      case Float32Array:
      case Float64Array:
        return value.constructor;
    }
    console.warn('Unfamiliar constructor type.  Will go ahead and use, but likley this may result in a transfer of zeros');
    return value.constructor;
  }

  getStringValueHandler() {
    throw new Error(`"getStringValueHandler" not implemented on ${this.constructor.name}`);
  }

  getVariablePrecisionString() {
    return this.kernel.getVariablePrecisionString(this.textureSize || undefined, this.tactic || undefined);
  }

  destroy() {}
}

module.exports = {
  WebGLKernelValue
};
},{"../../../utils":114,"../../kernel-value":35}],57:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGLKernelValue } = require('./index');

class WebGLKernelValueInteger extends WebGLKernelValue {
  constructor(value, settings) {
    super(value, settings);
    this.uploadValue = value;
  }
  getStringValueHandler() {
    return `const uploadValue_${this.name} = ${this.varName};\n`;
  }
  getSource(value) {
    if (this.origin === 'constants') {
      return `const int ${this.id} = ${ parseInt(value) };\n`;
    }
    return `uniform int ${this.id};\n`;
  }

  updateValue(value) {
    if (this.origin === 'constants') return;
    this.kernel.setUniform1i(this.id, this.uploadValue = value);
  }
}

module.exports = {
  WebGLKernelValueInteger
};
},{"../../../utils":114,"./index":56}],58:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGLKernelArray } = require('./array');

const sameError = `Source and destination textures are the same.  Use immutable = true and manually cleanup kernel output texture memory with texture.delete()`;

class WebGLKernelValueMemoryOptimizedNumberTexture extends WebGLKernelArray {
  constructor(value, settings) {
    super(value, settings);
    const [width, height] = value.size;
    this.checkSize(width, height);
    this.dimensions = value.dimensions;
    this.textureSize = value.size;
    this.uploadValue = value.texture;
    this.forceUploadEachRun = true;
  }

  setup() {
    this.setupTexture();
  }

  getStringValueHandler() {
    return `const uploadValue_${this.name} = ${this.varName}.texture;\n`;
  }

  getSource() {
    return utils.linesToString([
      `uniform sampler2D ${this.id}`,
      `ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`,
      `ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`,
    ]);
  }

  updateValue(inputTexture) {
    if (inputTexture.constructor !== this.initialValueConstructor) {
      this.onUpdateValueMismatch(inputTexture.constructor);
      return;
    }
    if (this.checkContext && inputTexture.context !== this.context) {
      throw new Error(`Value ${this.name} (${this.type}) must be from same context`);
    }

    const { kernel, context: gl } = this;
    if (kernel.pipeline) {
      if (kernel.immutable) {
        kernel.updateTextureArgumentRefs(this, inputTexture);
      } else {
        if (kernel.texture && kernel.texture.texture === inputTexture.texture) {
          throw new Error(sameError);
        } else if (kernel.mappedTextures) {
          const { mappedTextures } = kernel;
          for (let i = 0; i < mappedTextures.length; i++) {
            if (mappedTextures[i].texture === inputTexture.texture) {
              throw new Error(sameError);
            }
          }
        }
      }
    }

    gl.activeTexture(this.contextHandle);
    gl.bindTexture(gl.TEXTURE_2D, this.uploadValue = inputTexture.texture);
    this.kernel.setUniform1i(this.id, this.index);
  }
}

module.exports = {
  WebGLKernelValueMemoryOptimizedNumberTexture,
  sameError
};

},{"../../../utils":114,"./array":40}],59:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGLKernelArray } = require('./array');
const { sameError } = require('./memory-optimized-number-texture');

class WebGLKernelValueNumberTexture extends WebGLKernelArray {
  constructor(value, settings) {
    super(value, settings);
    const [width, height] = value.size;
    this.checkSize(width, height);
    const { size: textureSize, dimensions } = value;
    this.bitRatio = this.getBitRatio(value);
    this.dimensions = dimensions;
    this.textureSize = textureSize;
    this.uploadValue = value.texture;
    this.forceUploadEachRun = true;
  }

  setup() {
    this.setupTexture();
  }

  getStringValueHandler() {
    return `const uploadValue_${this.name} = ${this.varName}.texture;\n`;
  }

  getSource() {
    return utils.linesToString([
      `uniform sampler2D ${this.id}`,
      `ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`,
      `ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`,
    ]);
  }

  updateValue(inputTexture) {
    if (inputTexture.constructor !== this.initialValueConstructor) {
      this.onUpdateValueMismatch(inputTexture.constructor);
      return;
    }
    if (this.checkContext && inputTexture.context !== this.context) {
      throw new Error(`Value ${this.name} (${this.type}) must be from same context`);
    }

    const { kernel, context: gl } = this;
    if (kernel.pipeline) {
      if (kernel.immutable) {
        kernel.updateTextureArgumentRefs(this, inputTexture);
      } else {
        if (kernel.texture && kernel.texture.texture === inputTexture.texture) {
          throw new Error(sameError);
        } else if (kernel.mappedTextures) {
          const { mappedTextures } = kernel;
          for (let i = 0; i < mappedTextures.length; i++) {
            if (mappedTextures[i].texture === inputTexture.texture) {
              throw new Error(sameError);
            }
          }
        }
      }
    }

    gl.activeTexture(this.contextHandle);
    gl.bindTexture(gl.TEXTURE_2D, this.uploadValue = inputTexture.texture);
    this.kernel.setUniform1i(this.id, this.index);
  }
}

module.exports = {
  WebGLKernelValueNumberTexture
};

},{"../../../utils":114,"./array":40,"./memory-optimized-number-texture":58}],60:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGLKernelArray } = require('./array');

class WebGLKernelValueSingleArray extends WebGLKernelArray {
  constructor(value, settings) {
    super(value, settings);
    this.bitRatio = 4;
    this.dimensions = utils.getDimensions(value, true);
    this.textureSize = utils.getMemoryOptimizedFloatTextureSize(this.dimensions, this.bitRatio);
    this.uploadArrayLength = this.textureSize[0] * this.textureSize[1] * this.bitRatio;
    this.checkSize(this.textureSize[0], this.textureSize[1]);
    this.uploadValue = new Float32Array(this.uploadArrayLength);
  }

  getStringValueHandler() {
    return utils.linesToString([
      `const uploadValue_${this.name} = new Float32Array(${this.uploadArrayLength})`,
      `flattenTo(${this.varName}, uploadValue_${this.name})`,
    ]);
  }

  getSource() {
    return utils.linesToString([
      `uniform sampler2D ${this.id}`,
      `ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`,
      `ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`,
    ]);
  }

  updateValue(value) {
    if (value.constructor !== this.initialValueConstructor) {
      this.onUpdateValueMismatch(value.constructor);
      return;
    }
    const { context: gl } = this;
    utils.flattenTo(value, this.uploadValue);
    gl.activeTexture(this.contextHandle);
    gl.bindTexture(gl.TEXTURE_2D, this.texture);
    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, this.textureSize[0], this.textureSize[1], 0, gl.RGBA, gl.FLOAT, this.uploadValue);
    this.kernel.setUniform1i(this.id, this.index);
  }
}

module.exports = {
  WebGLKernelValueSingleArray
};
},{"../../../utils":114,"./array":40}],61:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGLKernelArray } = require('./array');

class WebGLKernelValueSingleArray1DI extends WebGLKernelArray {
  constructor(value, settings) {
    super(value, settings);
    this.bitRatio = 4;
    this.setShape(value);
  }

  setShape(value) {
    const valueDimensions = utils.getDimensions(value, true);
    this.textureSize = utils.getMemoryOptimizedFloatTextureSize(valueDimensions, this.bitRatio);
    this.dimensions = new Int32Array([valueDimensions[1], 1, 1]);
    this.uploadArrayLength = this.textureSize[0] * this.textureSize[1] * this.bitRatio;
    this.checkSize(this.textureSize[0], this.textureSize[1]);
    this.uploadValue = new Float32Array(this.uploadArrayLength);
  }

  getStringValueHandler() {
    return utils.linesToString([
      `const uploadValue_${this.name} = new Float32Array(${this.uploadArrayLength})`,
      `flattenTo(${this.varName}, uploadValue_${this.name})`,
    ]);
  }

  getSource() {
    return utils.linesToString([
      `uniform sampler2D ${this.id}`,
      `ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`,
      `ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`,
    ]);
  }

  updateValue(value) {
    if (value.constructor !== this.initialValueConstructor) {
      this.onUpdateValueMismatch(value.constructor);
      return;
    }
    const { context: gl } = this;
    utils.flatten2dArrayTo(value, this.uploadValue);
    gl.activeTexture(this.contextHandle);
    gl.bindTexture(gl.TEXTURE_2D, this.texture);
    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, this.textureSize[0], this.textureSize[1], 0, gl.RGBA, gl.FLOAT, this.uploadValue);
    this.kernel.setUniform1i(this.id, this.index);
  }
}

module.exports = {
  WebGLKernelValueSingleArray1DI
};
},{"../../../utils":114,"./array":40}],62:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGLKernelValue } = require('./index');

class WebGLKernelValueSingleArray2 extends WebGLKernelValue {
  constructor(value, settings) {
    super(value, settings);
    this.uploadValue = value;
  }
  getSource(value) {
    if (this.origin === 'constants') {
      return `const vec2 ${this.id} = vec2(${value[0]},${value[1]});\n`;
    }
    return `uniform vec2 ${this.id};\n`;
  }

  getStringValueHandler() {
    if (this.origin === 'constants') return '';
    return `const uploadValue_${this.name} = ${this.varName};\n`;
  }

  updateValue(value) {
    if (this.origin === 'constants') return;
    this.kernel.setUniform2fv(this.id, this.uploadValue = value);
  }
}

module.exports = {
  WebGLKernelValueSingleArray2
};
},{"../../../utils":114,"./index":56}],63:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGLKernelArray } = require('./array');

class WebGLKernelValueSingleArray2DI extends WebGLKernelArray {
  constructor(value, settings) {
    super(value, settings);
    this.bitRatio = 4;
    this.setShape(value);
  }

  setShape(value) {
    const valueDimensions = utils.getDimensions(value, true);
    this.textureSize = utils.getMemoryOptimizedFloatTextureSize(valueDimensions, this.bitRatio);
    this.dimensions = new Int32Array([valueDimensions[1], valueDimensions[2], 1]);
    this.uploadArrayLength = this.textureSize[0] * this.textureSize[1] * this.bitRatio;
    this.checkSize(this.textureSize[0], this.textureSize[1]);
    this.uploadValue = new Float32Array(this.uploadArrayLength);
  }

  getStringValueHandler() {
    return utils.linesToString([
      `const uploadValue_${this.name} = new Float32Array(${this.uploadArrayLength})`,
      `flattenTo(${this.varName}, uploadValue_${this.name})`,
    ]);
  }

  getSource() {
    return utils.linesToString([
      `uniform sampler2D ${this.id}`,
      `ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`,
      `ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`,
    ]);
  }

  updateValue(value) {
    if (value.constructor !== this.initialValueConstructor) {
      this.onUpdateValueMismatch(value.constructor);
      return;
    }
    const { context: gl } = this;
    utils.flatten3dArrayTo(value, this.uploadValue);
    gl.activeTexture(this.contextHandle);
    gl.bindTexture(gl.TEXTURE_2D, this.texture);
    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, this.textureSize[0], this.textureSize[1], 0, gl.RGBA, gl.FLOAT, this.uploadValue);
    this.kernel.setUniform1i(this.id, this.index);
  }
}

module.exports = {
  WebGLKernelValueSingleArray2DI
};
},{"../../../utils":114,"./array":40}],64:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGLKernelValue } = require('./index');

class WebGLKernelValueSingleArray3 extends WebGLKernelValue {
  constructor(value, settings) {
    super(value, settings);
    this.uploadValue = value;
  }
  getSource(value) {
    if (this.origin === 'constants') {
      return `const vec3 ${this.id} = vec3(${value[0]},${value[1]},${value[2]});\n`;
    }
    return `uniform vec3 ${this.id};\n`;
  }

  getStringValueHandler() {
    if (this.origin === 'constants') return '';
    return `const uploadValue_${this.name} = ${this.varName};\n`;
  }

  updateValue(value) {
    if (this.origin === 'constants') return;
    this.kernel.setUniform3fv(this.id, this.uploadValue = value);
  }
}

module.exports = {
  WebGLKernelValueSingleArray3
};
},{"../../../utils":114,"./index":56}],65:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGLKernelArray } = require('./array');

class WebGLKernelValueSingleArray3DI extends WebGLKernelArray {
  constructor(value, settings) {
    super(value, settings);
    this.bitRatio = 4;
    this.setShape(value);
  }

  setShape(value) {
    const valueDimensions = utils.getDimensions(value, true);
    this.textureSize = utils.getMemoryOptimizedFloatTextureSize(valueDimensions, this.bitRatio);
    this.dimensions = new Int32Array([valueDimensions[1], valueDimensions[2], valueDimensions[3]]);
    this.uploadArrayLength = this.textureSize[0] * this.textureSize[1] * this.bitRatio;
    this.checkSize(this.textureSize[0], this.textureSize[1]);
    this.uploadValue = new Float32Array(this.uploadArrayLength);
  }

  getStringValueHandler() {
    return utils.linesToString([
      `const uploadValue_${this.name} = new Float32Array(${this.uploadArrayLength})`,
      `flattenTo(${this.varName}, uploadValue_${this.name})`,
    ]);
  }

  getSource() {
    return utils.linesToString([
      `uniform sampler2D ${this.id}`,
      `ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`,
      `ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`,
    ]);
  }

  updateValue(value) {
    if (value.constructor !== this.initialValueConstructor) {
      this.onUpdateValueMismatch(value.constructor);
      return;
    }
    const { context: gl } = this;
    utils.flatten4dArrayTo(value, this.uploadValue);
    gl.activeTexture(this.contextHandle);
    gl.bindTexture(gl.TEXTURE_2D, this.texture);
    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, this.textureSize[0], this.textureSize[1], 0, gl.RGBA, gl.FLOAT, this.uploadValue);
    this.kernel.setUniform1i(this.id, this.index);
  }
}

module.exports = {
  WebGLKernelValueSingleArray3DI
};
},{"../../../utils":114,"./array":40}],66:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGLKernelValue } = require('./index');

class WebGLKernelValueSingleArray4 extends WebGLKernelValue {
  constructor(value, settings) {
    super(value, settings);
    this.uploadValue = value;
  }
  getSource(value) {
    if (this.origin === 'constants') {
      return `const vec4 ${this.id} = vec4(${value[0]},${value[1]},${value[2]},${value[3]});\n`;
    }
    return `uniform vec4 ${this.id};\n`;
  }

  getStringValueHandler() {
    if (this.origin === 'constants') return '';
    return `const uploadValue_${this.name} = ${this.varName};\n`;
  }

  updateValue(value) {
    if (this.origin === 'constants') return;
    this.kernel.setUniform4fv(this.id, this.uploadValue = value);
  }
}

module.exports = {
  WebGLKernelValueSingleArray4
};
},{"../../../utils":114,"./index":56}],67:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGLKernelArray } = require('./array');

class WebGLKernelValueSingleInput extends WebGLKernelArray {
  constructor(value, settings) {
    super(value, settings);
    this.bitRatio = 4;
    let [w, h, d] = value.size;
    this.dimensions = new Int32Array([w || 1, h || 1, d || 1]);
    this.textureSize = utils.getMemoryOptimizedFloatTextureSize(this.dimensions, this.bitRatio);
    this.uploadArrayLength = this.textureSize[0] * this.textureSize[1] * this.bitRatio;
    this.checkSize(this.textureSize[0], this.textureSize[1]);
    this.uploadValue = new Float32Array(this.uploadArrayLength);
  }

  getStringValueHandler() {
    return utils.linesToString([
      `const uploadValue_${this.name} = new Float32Array(${this.uploadArrayLength})`,
      `flattenTo(${this.varName}.value, uploadValue_${this.name})`,
    ]);
  }

  getSource() {
    return utils.linesToString([
      `uniform sampler2D ${this.id}`,
      `ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`,
      `ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`,
    ]);
  }

  updateValue(input) {
    if (input.constructor !== this.initialValueConstructor) {
      this.onUpdateValueMismatch(input.constructor);
      return;
    }
    const { context: gl } = this;
    utils.flattenTo(input.value, this.uploadValue);
    gl.activeTexture(this.contextHandle);
    gl.bindTexture(gl.TEXTURE_2D, this.texture);
    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, this.textureSize[0], this.textureSize[1], 0, gl.RGBA, gl.FLOAT, this.uploadValue);
    this.kernel.setUniform1i(this.id, this.index);
  }
}

module.exports = {
  WebGLKernelValueSingleInput
};
},{"../../../utils":114,"./array":40}],68:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGLKernelArray } = require('./array');

class WebGLKernelValueUnsignedArray extends WebGLKernelArray {
  constructor(value, settings) {
    super(value, settings);
    this.bitRatio = this.getBitRatio(value);
    this.dimensions = utils.getDimensions(value, true);
    this.textureSize = utils.getMemoryOptimizedPackedTextureSize(this.dimensions, this.bitRatio);
    this.uploadArrayLength = this.textureSize[0] * this.textureSize[1] * (4 / this.bitRatio);
    this.checkSize(this.textureSize[0], this.textureSize[1]);
    this.TranserArrayType = this.getTransferArrayType(value);
    this.preUploadValue = new this.TranserArrayType(this.uploadArrayLength);
    this.uploadValue = new Uint8Array(this.preUploadValue.buffer);
  }

  getStringValueHandler() {
    return utils.linesToString([
      `const preUploadValue_${this.name} = new ${this.TranserArrayType.name}(${this.uploadArrayLength})`,
      `const uploadValue_${this.name} = new Uint8Array(preUploadValue_${this.name}.buffer)`,
      `flattenTo(${this.varName}, preUploadValue_${this.name})`,
    ]);
  }

  getSource() {
    return utils.linesToString([
      `uniform sampler2D ${this.id}`,
      `ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`,
      `ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`,
    ]);
  }

  updateValue(value) {
    if (value.constructor !== this.initialValueConstructor) {
      this.onUpdateValueMismatch(value.constructor);
      return;
    }
    const { context: gl } = this;
    utils.flattenTo(value, this.preUploadValue);
    gl.activeTexture(this.contextHandle);
    gl.bindTexture(gl.TEXTURE_2D, this.texture);
    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, this.textureSize[0], this.textureSize[1], 0, gl.RGBA, gl.UNSIGNED_BYTE, this.uploadValue);
    this.kernel.setUniform1i(this.id, this.index);
  }
}

module.exports = {
  WebGLKernelValueUnsignedArray
};
},{"../../../utils":114,"./array":40}],69:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGLKernelArray } = require('./array');

class WebGLKernelValueUnsignedInput extends WebGLKernelArray {
  constructor(value, settings) {
    super(value, settings);
    this.bitRatio = this.getBitRatio(value);
    const [w, h, d] = value.size;
    this.dimensions = new Int32Array([w || 1, h || 1, d || 1]);
    this.textureSize = utils.getMemoryOptimizedPackedTextureSize(this.dimensions, this.bitRatio);
    this.uploadArrayLength = this.textureSize[0] * this.textureSize[1] * (4 / this.bitRatio);
    this.checkSize(this.textureSize[0], this.textureSize[1]);
    this.TranserArrayType = this.getTransferArrayType(value.value);
    this.preUploadValue = new this.TranserArrayType(this.uploadArrayLength);
    this.uploadValue = new Uint8Array(this.preUploadValue.buffer);
  }

  getStringValueHandler() {
    return utils.linesToString([
      `const preUploadValue_${this.name} = new ${this.TranserArrayType.name}(${this.uploadArrayLength})`,
      `const uploadValue_${this.name} = new Uint8Array(preUploadValue_${this.name}.buffer)`,
      `flattenTo(${this.varName}.value, preUploadValue_${this.name})`,
    ]);
  }

  getSource() {
    return utils.linesToString([
      `uniform sampler2D ${this.id}`,
      `ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`,
      `ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`,
    ]);
  }

  updateValue(input) {
    if (input.constructor !== this.initialValueConstructor) {
      this.onUpdateValueMismatch(value.constructor);
      return;
    }
    const { context: gl } = this;
    utils.flattenTo(input.value, this.preUploadValue);
    gl.activeTexture(this.contextHandle);
    gl.bindTexture(gl.TEXTURE_2D, this.texture);
    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, this.textureSize[0], this.textureSize[1], 0, gl.RGBA, gl.UNSIGNED_BYTE, this.uploadValue);
    this.kernel.setUniform1i(this.id, this.index);
  }
}

module.exports = {
  WebGLKernelValueUnsignedInput
};
},{"../../../utils":114,"./array":40}],70:[function(require,module,exports){
const { GLKernel } = require('../gl/kernel');
const { FunctionBuilder } = require('../function-builder');
const { WebGLFunctionNode } = require('./function-node');
const { utils } = require('../../utils');
const mrud = require('../../plugins/math-random-uniformly-distributed');
const { fragmentShader } = require('./fragment-shader');
const { vertexShader } = require('./vertex-shader');
const { glKernelString } = require('../gl/kernel-string');
const { lookupKernelValueType } = require('./kernel-value-maps');

let isSupported = null;
let testCanvas = null;
let testContext = null;
let testExtensions = null;
let features = null;

const plugins = [mrud];
const canvases = [];
const maxTexSizes = {};


class WebGLKernel extends GLKernel {
  static get isSupported() {
    if (isSupported !== null) {
      return isSupported;
    }
    this.setupFeatureChecks();
    isSupported = this.isContextMatch(testContext);
    return isSupported;
  }

  static setupFeatureChecks() {
    if (typeof document !== 'undefined') {
      testCanvas = document.createElement('canvas');
    } else if (typeof OffscreenCanvas !== 'undefined') {
      testCanvas = new OffscreenCanvas(0, 0);
    }
    if (!testCanvas) return;
    testContext = testCanvas.getContext('webgl') || testCanvas.getContext('experimental-webgl');
    if (!testContext || !testContext.getExtension) return;
    testExtensions = {
      OES_texture_float: testContext.getExtension('OES_texture_float'),
      OES_texture_float_linear: testContext.getExtension('OES_texture_float_linear'),
      OES_element_index_uint: testContext.getExtension('OES_element_index_uint'),
      WEBGL_draw_buffers: testContext.getExtension('WEBGL_draw_buffers'),
    };
    features = this.getFeatures();
  }

  static isContextMatch(context) {
    if (typeof WebGLRenderingContext !== 'undefined') {
      return context instanceof WebGLRenderingContext;
    }
    return false;
  }

  static getIsTextureFloat() {
    return Boolean(testExtensions.OES_texture_float);
  }

  static getIsDrawBuffers() {
    return Boolean(testExtensions.WEBGL_draw_buffers);
  }

  static getChannelCount() {
    return testExtensions.WEBGL_draw_buffers ?
      testContext.getParameter(testExtensions.WEBGL_draw_buffers.MAX_DRAW_BUFFERS_WEBGL) :
      1;
  }

  static getMaxTextureSize() {
    return testContext.getParameter(testContext.MAX_TEXTURE_SIZE);
  }

  static lookupKernelValueType(type, dynamic, precision, value) {
    return lookupKernelValueType(type, dynamic, precision, value);
  }

  static get testCanvas() {
    return testCanvas;
  }

  static get testContext() {
    return testContext;
  }

  static get features() {
    return features;
  }

  static get fragmentShader() {
    return fragmentShader;
  }

  static get vertexShader() {
    return vertexShader;
  }

  constructor(source, settings) {
    super(source, settings);
    this.program = null;
    this.pipeline = settings.pipeline;
    this.endianness = utils.systemEndianness();
    this.extensions = {};
    this.argumentTextureCount = 0;
    this.constantTextureCount = 0;
    this.fragShader = null;
    this.vertShader = null;
    this.drawBuffersMap = null;

    this.maxTexSize = null;
    this.onRequestSwitchKernel = null;

    this.texture = null;
    this.mappedTextures = null;
    this.mergeSettings(source.settings || settings);

    this.threadDim = null;
    this.framebuffer = null;
    this.buffer = null;

    this.textureCache = [];
    this.programUniformLocationCache = {};
    this.uniform1fCache = {};
    this.uniform1iCache = {};
    this.uniform2fCache = {};
    this.uniform2fvCache = {};
    this.uniform2ivCache = {};
    this.uniform3fvCache = {};
    this.uniform3ivCache = {};
    this.uniform4fvCache = {};
    this.uniform4ivCache = {};
  }

  initCanvas() {
    if (typeof document !== 'undefined') {
      const canvas = document.createElement('canvas');
      canvas.width = 2;
      canvas.height = 2;
      return canvas;
    } else if (typeof OffscreenCanvas !== 'undefined') {
      return new OffscreenCanvas(0, 0);
    }
  }

  initContext() {
    const settings = {
      alpha: false,
      depth: false,
      antialias: false
    };
    return this.canvas.getContext('webgl', settings) || this.canvas.getContext('experimental-webgl', settings);
  }

  initPlugins(settings) {
    const pluginsToUse = [];
    const { source } = this;
    if (typeof source === 'string') {
      for (let i = 0; i < plugins.length; i++) {
        const plugin = plugins[i];
        if (source.match(plugin.functionMatch)) {
          pluginsToUse.push(plugin);
        }
      }
    } else if (typeof source === 'object') {
      if (settings.pluginNames) { 
        for (let i = 0; i < plugins.length; i++) {
          const plugin = plugins[i];
          const usePlugin = settings.pluginNames.some(pluginName => pluginName === plugin.name);
          if (usePlugin) {
            pluginsToUse.push(plugin);
          }
        }
      }
    }
    return pluginsToUse;
  }

  initExtensions() {
    this.extensions = {
      OES_texture_float: this.context.getExtension('OES_texture_float'),
      OES_texture_float_linear: this.context.getExtension('OES_texture_float_linear'),
      OES_element_index_uint: this.context.getExtension('OES_element_index_uint'),
      WEBGL_draw_buffers: this.context.getExtension('WEBGL_draw_buffers'),
      WEBGL_color_buffer_float: this.context.getExtension('WEBGL_color_buffer_float'),
    };
  }

  validateSettings(args) {
    if (!this.validate) {
      this.texSize = utils.getKernelTextureSize({
        optimizeFloatMemory: this.optimizeFloatMemory,
        precision: this.precision,
      }, this.output);
      return;
    }

    const { features } = this.constructor;

    if (this.optimizeFloatMemory === true && !features.isTextureFloat) {
      throw new Error('Float textures are not supported');
    } else if (this.precision === 'single' && !features.isFloatRead) {
      throw new Error('Single precision not supported');
    } else if (!this.graphical && this.precision === null && features.isTextureFloat) {
      this.precision = features.isFloatRead ? 'single' : 'unsigned';
    }

    if (this.subKernels && this.subKernels.length > 0 && !this.extensions.WEBGL_draw_buffers) {
      throw new Error('could not instantiate draw buffers extension');
    }

    if (this.fixIntegerDivisionAccuracy === null) {
      this.fixIntegerDivisionAccuracy = !features.isIntegerDivisionAccurate;
    } else if (this.fixIntegerDivisionAccuracy && features.isIntegerDivisionAccurate) {
      this.fixIntegerDivisionAccuracy = false;
    }

    this.checkOutput();

    if (!this.output || this.output.length === 0) {
      if (args.length !== 1) {
        throw new Error('Auto output only supported for kernels with only one input');
      }

      const argType = utils.getVariableType(args[0], this.strictIntegers);
      switch (argType) {
        case 'Array':
          this.output = utils.getDimensions(argType);
          break;
        case 'NumberTexture':
        case 'MemoryOptimizedNumberTexture':
        case 'ArrayTexture(1)':
        case 'ArrayTexture(2)':
        case 'ArrayTexture(3)':
        case 'ArrayTexture(4)':
          this.output = args[0].output;
          break;
        default:
          throw new Error('Auto output not supported for input type: ' + argType);
      }
    }

    if (this.graphical) {
      if (this.output.length !== 2) {
        throw new Error('Output must have 2 dimensions on graphical mode');
      }

      if (this.precision === 'precision') {
        this.precision = 'unsigned';
        console.warn('Cannot use graphical mode and single precision at the same time');
      }

      this.texSize = utils.clone(this.output);
      return;
    } else if (this.precision === null && features.isTextureFloat) {
      this.precision = 'single';
    }

    this.texSize = utils.getKernelTextureSize({
      optimizeFloatMemory: this.optimizeFloatMemory,
      precision: this.precision,
    }, this.output);

    this.checkTextureSize();
  }

  updateMaxTexSize() {
    const { texSize, canvas } = this;
    if (this.maxTexSize === null) {
      let canvasIndex = canvases.indexOf(canvas);
      if (canvasIndex === -1) {
        canvasIndex = canvases.length;
        canvases.push(canvas);
        maxTexSizes[canvasIndex] = [texSize[0], texSize[1]];
      }
      this.maxTexSize = maxTexSizes[canvasIndex];
    }
    if (this.maxTexSize[0] < texSize[0]) {
      this.maxTexSize[0] = texSize[0];
    }
    if (this.maxTexSize[1] < texSize[1]) {
      this.maxTexSize[1] = texSize[1];
    }
  }

  setupArguments(args) {
    this.kernelArguments = [];
    this.argumentTextureCount = 0;
    const needsArgumentTypes = this.argumentTypes === null;
    if (needsArgumentTypes) {
      this.argumentTypes = [];
    }
    this.argumentSizes = [];
    this.argumentBitRatios = [];

    if (args.length < this.argumentNames.length) {
      throw new Error('not enough arguments for kernel');
    } else if (args.length > this.argumentNames.length) {
      throw new Error('too many arguments for kernel');
    }

    const { context: gl } = this;
    let textureIndexes = 0;

    const onRequestTexture = () => {
      return this.createTexture();
    };
    const onRequestIndex = () => {
      return this.constantTextureCount + textureIndexes++;
    };
    const onUpdateValueMismatch = (constructor) => {
      this.switchKernels({
        type: 'argumentMismatch',
        needed: constructor
      });
    };
    const onRequestContextHandle = () => {
      return gl.TEXTURE0 + this.constantTextureCount + this.argumentTextureCount++;
    };

    for (let index = 0; index < args.length; index++) {
      const value = args[index];
      const name = this.argumentNames[index];
      let type;
      if (needsArgumentTypes) {
        type = utils.getVariableType(value, this.strictIntegers);
        this.argumentTypes.push(type);
      } else {
        type = this.argumentTypes[index];
      }
      const KernelValue = this.constructor.lookupKernelValueType(type, this.dynamicArguments ? 'dynamic' : 'static', this.precision, args[index]);
      if (KernelValue === null) {
        return this.requestFallback(args);
      }
      const kernelArgument = new KernelValue(value, {
        name,
        type,
        tactic: this.tactic,
        origin: 'user',
        context: gl,
        checkContext: this.checkContext,
        kernel: this,
        strictIntegers: this.strictIntegers,
        onRequestTexture,
        onRequestIndex,
        onUpdateValueMismatch,
        onRequestContextHandle,
      });
      this.kernelArguments.push(kernelArgument);
      kernelArgument.setup();
      this.argumentSizes.push(kernelArgument.textureSize);
      this.argumentBitRatios[index] = kernelArgument.bitRatio;
    }
  }

  createTexture() {
    const texture = this.context.createTexture();
    this.textureCache.push(texture);
    return texture;
  }

  setupConstants(args) {
    const { context: gl } = this;
    this.kernelConstants = [];
    this.forceUploadKernelConstants = [];
    let needsConstantTypes = this.constantTypes === null;
    if (needsConstantTypes) {
      this.constantTypes = {};
    }
    this.constantBitRatios = {};
    let textureIndexes = 0;
    for (const name in this.constants) {
      const value = this.constants[name];
      let type;
      if (needsConstantTypes) {
        type = utils.getVariableType(value, this.strictIntegers);
        this.constantTypes[name] = type;
      } else {
        type = this.constantTypes[name];
      }
      const KernelValue = this.constructor.lookupKernelValueType(type, 'static', this.precision, value);
      if (KernelValue === null) {
        return this.requestFallback(args);
      }
      const kernelValue = new KernelValue(value, {
        name,
        type,
        tactic: this.tactic,
        origin: 'constants',
        context: this.context,
        checkContext: this.checkContext,
        kernel: this,
        strictIntegers: this.strictIntegers,
        onRequestTexture: () => {
          return this.createTexture();
        },
        onRequestIndex: () => {
          return textureIndexes++;
        },
        onRequestContextHandle: () => {
          return gl.TEXTURE0 + this.constantTextureCount++;
        }
      });
      this.constantBitRatios[name] = kernelValue.bitRatio;
      this.kernelConstants.push(kernelValue);
      kernelValue.setup();
      if (kernelValue.forceUploadEachRun) {
        this.forceUploadKernelConstants.push(kernelValue);
      }
    }
  }

  build() {
    if (this.built) return;
    this.initExtensions();
    this.validateSettings(arguments);
    this.setupConstants(arguments);
    if (this.fallbackRequested) return;
    this.setupArguments(arguments);
    if (this.fallbackRequested) return;
    this.updateMaxTexSize();
    this.translateSource();
    const failureResult = this.pickRenderStrategy(arguments);
    if (failureResult) {
      return failureResult;
    }
    const { texSize, context: gl, canvas } = this;
    gl.enable(gl.SCISSOR_TEST);
    if (this.pipeline && this.precision === 'single') {
      gl.viewport(0, 0, this.maxTexSize[0], this.maxTexSize[1]);
      canvas.width = this.maxTexSize[0];
      canvas.height = this.maxTexSize[1];
    } else {
      gl.viewport(0, 0, this.maxTexSize[0], this.maxTexSize[1]);
      canvas.width = this.maxTexSize[0];
      canvas.height = this.maxTexSize[1];
    }
    const threadDim = this.threadDim = Array.from(this.output);
    while (threadDim.length < 3) {
      threadDim.push(1);
    }

    const compiledVertexShader = this.getVertexShader(arguments);
    const vertShader = gl.createShader(gl.VERTEX_SHADER);
    gl.shaderSource(vertShader, compiledVertexShader);
    gl.compileShader(vertShader);
    this.vertShader = vertShader;

    const compiledFragmentShader = this.getFragmentShader(arguments);
    const fragShader = gl.createShader(gl.FRAGMENT_SHADER);
    gl.shaderSource(fragShader, compiledFragmentShader);
    gl.compileShader(fragShader);
    this.fragShader = fragShader;

    if (this.debug) {
      console.log('GLSL Shader Output:');
      console.log(compiledFragmentShader);
    }

    if (!gl.getShaderParameter(vertShader, gl.COMPILE_STATUS)) {
      throw new Error('Error compiling vertex shader: ' + gl.getShaderInfoLog(vertShader));
    }
    if (!gl.getShaderParameter(fragShader, gl.COMPILE_STATUS)) {
      throw new Error('Error compiling fragment shader: ' + gl.getShaderInfoLog(fragShader));
    }

    const program = this.program = gl.createProgram();
    gl.attachShader(program, vertShader);
    gl.attachShader(program, fragShader);
    gl.linkProgram(program);
    this.framebuffer = gl.createFramebuffer();
    this.framebuffer.width = texSize[0];
    this.framebuffer.height = texSize[1];
    this.rawValueFramebuffers = {};

    const vertices = new Float32Array([-1, -1,
      1, -1, -1, 1,
      1, 1
    ]);
    const texCoords = new Float32Array([
      0, 0,
      1, 0,
      0, 1,
      1, 1
    ]);

    const texCoordOffset = vertices.byteLength;

    let buffer = this.buffer;
    if (!buffer) {
      buffer = this.buffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
      gl.bufferData(gl.ARRAY_BUFFER, vertices.byteLength + texCoords.byteLength, gl.STATIC_DRAW);
    } else {
      gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
    }

    gl.bufferSubData(gl.ARRAY_BUFFER, 0, vertices);
    gl.bufferSubData(gl.ARRAY_BUFFER, texCoordOffset, texCoords);

    const aPosLoc = gl.getAttribLocation(this.program, 'aPos');
    gl.enableVertexAttribArray(aPosLoc);
    gl.vertexAttribPointer(aPosLoc, 2, gl.FLOAT, false, 0, 0);
    const aTexCoordLoc = gl.getAttribLocation(this.program, 'aTexCoord');
    gl.enableVertexAttribArray(aTexCoordLoc);
    gl.vertexAttribPointer(aTexCoordLoc, 2, gl.FLOAT, false, 0, texCoordOffset);
    gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer);

    let i = 0;
    gl.useProgram(this.program);
    for (let p in this.constants) {
      this.kernelConstants[i++].updateValue(this.constants[p]);
    }

    this._setupOutputTexture();
    if (
      this.subKernels !== null &&
      this.subKernels.length > 0
    ) {
      this._mappedTextureSwitched = {};
      this._setupSubOutputTextures();
    }
    this.buildSignature(arguments);
    this.built = true;
  }

  translateSource() {
    const functionBuilder = FunctionBuilder.fromKernel(this, WebGLFunctionNode, {
      fixIntegerDivisionAccuracy: this.fixIntegerDivisionAccuracy
    });
    this.translatedSource = functionBuilder.getPrototypeString('kernel');
    this.setupReturnTypes(functionBuilder);
  }

  setupReturnTypes(functionBuilder) {
    if (!this.graphical && !this.returnType) {
      this.returnType = functionBuilder.getKernelResultType();
    }

    if (this.subKernels && this.subKernels.length > 0) {
      for (let i = 0; i < this.subKernels.length; i++) {
        const subKernel = this.subKernels[i];
        if (!subKernel.returnType) {
          subKernel.returnType = functionBuilder.getSubKernelResultType(i);
        }
      }
    }
  }

  run() {
    const { kernelArguments, texSize, forceUploadKernelConstants, context: gl } = this;

    gl.useProgram(this.program);
    gl.scissor(0, 0, texSize[0], texSize[1]);
    if (this.dynamicOutput) {
      this.setUniform3iv('uOutputDim', new Int32Array(this.threadDim));
      this.setUniform2iv('uTexSize', texSize);
    }

    this.setUniform2f('ratio', texSize[0] / this.maxTexSize[0], texSize[1] / this.maxTexSize[1]);

    for (let i = 0; i < forceUploadKernelConstants.length; i++) {
      const constant = forceUploadKernelConstants[i];
      constant.updateValue(this.constants[constant.name]);
      if (this.switchingKernels) return;
    }
    for (let i = 0; i < kernelArguments.length; i++) {
      kernelArguments[i].updateValue(arguments[i]);
      if (this.switchingKernels) return;
    }

    if (this.plugins) {
      for (let i = 0; i < this.plugins.length; i++) {
        const plugin = this.plugins[i];
        if (plugin.onBeforeRun) {
          plugin.onBeforeRun(this);
        }
      }
    }

    if (this.graphical) {
      if (this.pipeline) {
        gl.bindRenderbuffer(gl.RENDERBUFFER, null);
        gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer);
        if (this.immutable) {
          this._replaceOutputTexture();
        }
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
        return this.immutable ? this.texture.clone() : this.texture;
      }
      gl.bindRenderbuffer(gl.RENDERBUFFER, null);
      gl.bindFramebuffer(gl.FRAMEBUFFER, null);
      gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
      return;
    }

    gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer);
    if (this.immutable) {
      this._replaceOutputTexture();
    }

    if (this.subKernels !== null) {
      if (this.immutable) {
        this._replaceSubOutputTextures();
      }
      this.drawBuffers();
    }

    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
  }

  drawBuffers() {
    this.extensions.WEBGL_draw_buffers.drawBuffersWEBGL(this.drawBuffersMap);
  }

  getInternalFormat() {
    return this.context.RGBA;
  }
  getTextureFormat() {
    const { context: gl } = this;
    switch (this.getInternalFormat()) {
      case gl.RGBA:
        return gl.RGBA;
      default:
        throw new Error('Unknown internal format');
    }
  }

  _replaceOutputTexture() {
    if (this.texture.beforeMutate() || this._textureSwitched) {
      const gl = this.context;
      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.texture.texture, 0);
      this._textureSwitched = false;
    }
  }

  _setupOutputTexture() {
    const gl = this.context;
    const texSize = this.texSize;
    if (this.texture) {
      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.texture.texture, 0);
      return;
    }
    const texture = this.createTexture();
    gl.activeTexture(gl.TEXTURE0 + this.constantTextureCount + this.argumentTextureCount);
    gl.bindTexture(gl.TEXTURE_2D, texture);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
    const format = this.getInternalFormat();
    if (this.precision === 'single') {
      gl.texImage2D(gl.TEXTURE_2D, 0, format, texSize[0], texSize[1], 0, gl.RGBA, gl.FLOAT, null);
    } else {
      gl.texImage2D(gl.TEXTURE_2D, 0, format, texSize[0], texSize[1], 0, format, gl.UNSIGNED_BYTE, null);
    }
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
    this.texture = new this.TextureConstructor({
      texture,
      size: texSize,
      dimensions: this.threadDim,
      output: this.output,
      context: this.context,
      internalFormat: this.getInternalFormat(),
      textureFormat: this.getTextureFormat(),
      kernel: this,
    });
  }

  _replaceSubOutputTextures() {
    const gl = this.context;
    for (let i = 0; i < this.mappedTextures.length; i++) {
      const mappedTexture = this.mappedTextures[i];
      if (mappedTexture.beforeMutate() || this._mappedTextureSwitched[i]) {
        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + i + 1, gl.TEXTURE_2D, mappedTexture.texture, 0);
        this._mappedTextureSwitched[i] = false;
      }
    }
  }

  _setupSubOutputTextures() {
    const gl = this.context;
    if (this.mappedTextures) {
      for (let i = 0; i < this.subKernels.length; i++) {
        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + i + 1, gl.TEXTURE_2D, this.mappedTextures[i].texture, 0);
      }
      return;
    }
    const texSize = this.texSize;
    this.drawBuffersMap = [gl.COLOR_ATTACHMENT0];
    this.mappedTextures = [];
    for (let i = 0; i < this.subKernels.length; i++) {
      const texture = this.createTexture();
      this.drawBuffersMap.push(gl.COLOR_ATTACHMENT0 + i + 1);
      gl.activeTexture(gl.TEXTURE0 + this.constantTextureCount + this.argumentTextureCount + i);
      gl.bindTexture(gl.TEXTURE_2D, texture);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
      if (this.precision === 'single') {
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, texSize[0], texSize[1], 0, gl.RGBA, gl.FLOAT, null);
      } else {
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, texSize[0], texSize[1], 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
      }
      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + i + 1, gl.TEXTURE_2D, texture, 0);

      this.mappedTextures.push(new this.TextureConstructor({
        texture,
        size: texSize,
        dimensions: this.threadDim,
        output: this.output,
        context: this.context,
        internalFormat: this.getInternalFormat(),
        textureFormat: this.getTextureFormat(),
        kernel: this,
      }));
    }
  }

  setUniform1f(name, value) {
    if (this.uniform1fCache.hasOwnProperty(name)) {
      const cache = this.uniform1fCache[name];
      if (value === cache) {
        return;
      }
    }
    this.uniform1fCache[name] = value;
    const loc = this.getUniformLocation(name);
    this.context.uniform1f(loc, value);
  }

  setUniform1i(name, value) {
    if (this.uniform1iCache.hasOwnProperty(name)) {
      const cache = this.uniform1iCache[name];
      if (value === cache) {
        return;
      }
    }
    this.uniform1iCache[name] = value;
    const loc = this.getUniformLocation(name);
    this.context.uniform1i(loc, value);
  }

  setUniform2f(name, value1, value2) {
    if (this.uniform2fCache.hasOwnProperty(name)) {
      const cache = this.uniform2fCache[name];
      if (
        value1 === cache[0] &&
        value2 === cache[1]
      ) {
        return;
      }
    }
    this.uniform2fCache[name] = [value1, value2];
    const loc = this.getUniformLocation(name);
    this.context.uniform2f(loc, value1, value2);
  }

  setUniform2fv(name, value) {
    if (this.uniform2fvCache.hasOwnProperty(name)) {
      const cache = this.uniform2fvCache[name];
      if (
        value[0] === cache[0] &&
        value[1] === cache[1]
      ) {
        return;
      }
    }
    this.uniform2fvCache[name] = value;
    const loc = this.getUniformLocation(name);
    this.context.uniform2fv(loc, value);
  }

  setUniform2iv(name, value) {
    if (this.uniform2ivCache.hasOwnProperty(name)) {
      const cache = this.uniform2ivCache[name];
      if (
        value[0] === cache[0] &&
        value[1] === cache[1]
      ) {
        return;
      }
    }
    this.uniform2ivCache[name] = value;
    const loc = this.getUniformLocation(name);
    this.context.uniform2iv(loc, value);
  }

  setUniform3fv(name, value) {
    if (this.uniform3fvCache.hasOwnProperty(name)) {
      const cache = this.uniform3fvCache[name];
      if (
        value[0] === cache[0] &&
        value[1] === cache[1] &&
        value[2] === cache[2]
      ) {
        return;
      }
    }
    this.uniform3fvCache[name] = value;
    const loc = this.getUniformLocation(name);
    this.context.uniform3fv(loc, value);
  }

  setUniform3iv(name, value) {
    if (this.uniform3ivCache.hasOwnProperty(name)) {
      const cache = this.uniform3ivCache[name];
      if (
        value[0] === cache[0] &&
        value[1] === cache[1] &&
        value[2] === cache[2]
      ) {
        return;
      }
    }
    this.uniform3ivCache[name] = value;
    const loc = this.getUniformLocation(name);
    this.context.uniform3iv(loc, value);
  }

  setUniform4fv(name, value) {
    if (this.uniform4fvCache.hasOwnProperty(name)) {
      const cache = this.uniform4fvCache[name];
      if (
        value[0] === cache[0] &&
        value[1] === cache[1] &&
        value[2] === cache[2] &&
        value[3] === cache[3]
      ) {
        return;
      }
    }
    this.uniform4fvCache[name] = value;
    const loc = this.getUniformLocation(name);
    this.context.uniform4fv(loc, value);
  }

  setUniform4iv(name, value) {
    if (this.uniform4ivCache.hasOwnProperty(name)) {
      const cache = this.uniform4ivCache[name];
      if (
        value[0] === cache[0] &&
        value[1] === cache[1] &&
        value[2] === cache[2] &&
        value[3] === cache[3]
      ) {
        return;
      }
    }
    this.uniform4ivCache[name] = value;
    const loc = this.getUniformLocation(name);
    this.context.uniform4iv(loc, value);
  }

  getUniformLocation(name) {
    if (this.programUniformLocationCache.hasOwnProperty(name)) {
      return this.programUniformLocationCache[name];
    }
    return this.programUniformLocationCache[name] = this.context.getUniformLocation(this.program, name);
  }

  _getFragShaderArtifactMap(args) {
    return {
      HEADER: this._getHeaderString(),
      LOOP_MAX: this._getLoopMaxString(),
      PLUGINS: this._getPluginsString(),
      CONSTANTS: this._getConstantsString(),
      DECODE32_ENDIANNESS: this._getDecode32EndiannessString(),
      ENCODE32_ENDIANNESS: this._getEncode32EndiannessString(),
      DIVIDE_WITH_INTEGER_CHECK: this._getDivideWithIntegerCheckString(),
      INJECTED_NATIVE: this._getInjectedNative(),
      MAIN_CONSTANTS: this._getMainConstantsString(),
      MAIN_ARGUMENTS: this._getMainArgumentsString(args),
      KERNEL: this.getKernelString(),
      MAIN_RESULT: this.getMainResultString(),
      FLOAT_TACTIC_DECLARATION: this.getFloatTacticDeclaration(),
      INT_TACTIC_DECLARATION: this.getIntTacticDeclaration(),
      SAMPLER_2D_TACTIC_DECLARATION: this.getSampler2DTacticDeclaration(),
      SAMPLER_2D_ARRAY_TACTIC_DECLARATION: this.getSampler2DArrayTacticDeclaration(),
    };
  }

  _getVertShaderArtifactMap(args) {
    return {
      FLOAT_TACTIC_DECLARATION: this.getFloatTacticDeclaration(),
      INT_TACTIC_DECLARATION: this.getIntTacticDeclaration(),
      SAMPLER_2D_TACTIC_DECLARATION: this.getSampler2DTacticDeclaration(),
      SAMPLER_2D_ARRAY_TACTIC_DECLARATION: this.getSampler2DArrayTacticDeclaration(),
    };
  }

  _getHeaderString() {
    return (
      this.subKernels !== null ?
      '#extension GL_EXT_draw_buffers : require\n' :
      ''
    );
  }

  _getLoopMaxString() {
    return (
      this.loopMaxIterations ?
      ` ${parseInt(this.loopMaxIterations)};\n` :
      ' 1000;\n'
    );
  }

  _getPluginsString() {
    if (!this.plugins) return '\n';
    return this.plugins.map(plugin => plugin.source && this.source.match(plugin.functionMatch) ? plugin.source : '').join('\n');
  }

  _getConstantsString() {
    const result = [];
    const { threadDim, texSize } = this;
    if (this.dynamicOutput) {
      result.push(
        'uniform ivec3 uOutputDim',
        'uniform ivec2 uTexSize'
      );
    } else {
      result.push(
        `ivec3 uOutputDim = ivec3(${threadDim[0]}, ${threadDim[1]}, ${threadDim[2]})`,
        `ivec2 uTexSize = ivec2(${texSize[0]}, ${texSize[1]})`
      );
    }
    return utils.linesToString(result);
  }

  _getTextureCoordinate() {
    const subKernels = this.subKernels;
    if (subKernels === null || subKernels.length < 1) {
      return 'varying vec2 vTexCoord;\n';
    } else {
      return 'out vec2 vTexCoord;\n';
    }
  }

  _getDecode32EndiannessString() {
    return (
      this.endianness === 'LE' ?
      '' :
      '  texel.rgba = texel.abgr;\n'
    );
  }

  _getEncode32EndiannessString() {
    return (
      this.endianness === 'LE' ?
      '' :
      '  texel.rgba = texel.abgr;\n'
    );
  }

  _getDivideWithIntegerCheckString() {
    return this.fixIntegerDivisionAccuracy ?
      `float divWithIntCheck(float x, float y) {
  if (floor(x) == x && floor(y) == y && integerMod(x, y) == 0.0) {
    return float(int(x) / int(y));
  }
  return x / y;
}

float integerCorrectionModulo(float number, float divisor) {
  if (number < 0.0) {
    number = abs(number);
    if (divisor < 0.0) {
      divisor = abs(divisor);
    }
    return -(number - (divisor * floor(divWithIntCheck(number, divisor))));
  }
  if (divisor < 0.0) {
    divisor = abs(divisor);
  }
  return number - (divisor * floor(divWithIntCheck(number, divisor)));
}` :
      '';
  }

  _getMainArgumentsString(args) {
    const results = [];
    const { argumentNames } = this;
    for (let i = 0; i < argumentNames.length; i++) {
      results.push(this.kernelArguments[i].getSource(args[i]));
    }
    return results.join('');
  }

  _getInjectedNative() {
    return this.injectedNative || '';
  }

  _getMainConstantsString() {
    const result = [];
    const { constants } = this;
    if (constants) {
      let i = 0;
      for (const name in constants) {
        if (!this.constants.hasOwnProperty(name)) continue;
        result.push(this.kernelConstants[i++].getSource(this.constants[name]));
      }
    }
    return result.join('');
  }

  getRawValueFramebuffer(width, height) {
    if (!this.rawValueFramebuffers[width]) {
      this.rawValueFramebuffers[width] = {};
    }
    if (!this.rawValueFramebuffers[width][height]) {
      const framebuffer = this.context.createFramebuffer();
      framebuffer.width = width;
      framebuffer.height = height;
      this.rawValueFramebuffers[width][height] = framebuffer;
    }
    return this.rawValueFramebuffers[width][height];
  }

  getKernelResultDeclaration() {
    switch (this.returnType) {
      case 'Array(2)':
        return 'vec2 kernelResult';
      case 'Array(3)':
        return 'vec3 kernelResult';
      case 'Array(4)':
        return 'vec4 kernelResult';
      case 'LiteralInteger':
      case 'Float':
      case 'Number':
      case 'Integer':
        return 'float kernelResult';
      default:
        if (this.graphical) {
          return 'float kernelResult';
        } else {
          throw new Error(`unrecognized output type "${ this.returnType }"`);
        }
    }
  }
  getKernelString() {
    const result = [this.getKernelResultDeclaration()];
    const { subKernels } = this;
    if (subKernels !== null) {
      switch (this.returnType) {
        case 'Number':
        case 'Float':
        case 'Integer':
          for (let i = 0; i < subKernels.length; i++) {
            const subKernel = subKernels[i];
            result.push(
              subKernel.returnType === 'Integer' ?
              `int subKernelResult_${ subKernel.name } = 0` :
              `float subKernelResult_${ subKernel.name } = 0.0`
            );
          }
          break;
        case 'Array(2)':
          for (let i = 0; i < subKernels.length; i++) {
            result.push(
              `vec2 subKernelResult_${ subKernels[i].name }`
            );
          }
          break;
        case 'Array(3)':
          for (let i = 0; i < subKernels.length; i++) {
            result.push(
              `vec3 subKernelResult_${ subKernels[i].name }`
            );
          }
          break;
        case 'Array(4)':
          for (let i = 0; i < subKernels.length; i++) {
            result.push(
              `vec4 subKernelResult_${ subKernels[i].name }`
            );
          }
          break;
      }
    }

    return utils.linesToString(result) + this.translatedSource;
  }

  getMainResultGraphical() {
    return utils.linesToString([
      '  threadId = indexTo3D(index, uOutputDim)',
      '  kernel()',
      '  gl_FragColor = actualColor',
    ]);
  }

  getMainResultPackedPixels() {
    switch (this.returnType) {
      case 'LiteralInteger':
      case 'Number':
      case 'Integer':
      case 'Float':
        return this.getMainResultKernelPackedPixels() +
          this.getMainResultSubKernelPackedPixels();
      default:
        throw new Error(`packed output only usable with Numbers, "${this.returnType}" specified`);
    }
  }

  getMainResultKernelPackedPixels() {
    return utils.linesToString([
      '  threadId = indexTo3D(index, uOutputDim)',
      '  kernel()',
      `  gl_FragData[0] = ${this.useLegacyEncoder ? 'legacyEncode32' : 'encode32'}(kernelResult)`
    ]);
  }

  getMainResultSubKernelPackedPixels() {
    const result = [];
    if (!this.subKernels) return '';
    for (let i = 0; i < this.subKernels.length; i++) {
      const subKernel = this.subKernels[i];
      if (subKernel.returnType === 'Integer') {
        result.push(
          `  gl_FragData[${i + 1}] = ${this.useLegacyEncoder ? 'legacyEncode32' : 'encode32'}(float(subKernelResult_${this.subKernels[i].name}))`
        );
      } else {
        result.push(
          `  gl_FragData[${i + 1}] = ${this.useLegacyEncoder ? 'legacyEncode32' : 'encode32'}(subKernelResult_${this.subKernels[i].name})`
        );
      }
    }
    return utils.linesToString(result);
  }

  getMainResultMemoryOptimizedFloats() {
    const result = [
      '  index *= 4',
    ];

    switch (this.returnType) {
      case 'Number':
      case 'Integer':
      case 'Float':
        const channels = ['r', 'g', 'b', 'a'];
        for (let i = 0; i < channels.length; i++) {
          const channel = channels[i];
          this.getMainResultKernelMemoryOptimizedFloats(result, channel);
          this.getMainResultSubKernelMemoryOptimizedFloats(result, channel);
          if (i + 1 < channels.length) {
            result.push('  index += 1');
          }
        }
        break;
      default:
        throw new Error(`optimized output only usable with Numbers, ${this.returnType} specified`);
    }

    return utils.linesToString(result);
  }

  getMainResultKernelMemoryOptimizedFloats(result, channel) {
    result.push(
      '  threadId = indexTo3D(index, uOutputDim)',
      '  kernel()',
      `  gl_FragData[0].${channel} = kernelResult`
    );
  }

  getMainResultSubKernelMemoryOptimizedFloats(result, channel) {
    if (!this.subKernels) return result;
    for (let i = 0; i < this.subKernels.length; i++) {
      const subKernel = this.subKernels[i];
      if (subKernel.returnType === 'Integer') {
        result.push(
          `  gl_FragData[${i + 1}].${channel} = float(subKernelResult_${this.subKernels[i].name})`
        );
      } else {
        result.push(
          `  gl_FragData[${i + 1}].${channel} = subKernelResult_${this.subKernels[i].name}`
        );
      }
    }
  }

  getMainResultKernelNumberTexture() {
    return [
      '  threadId = indexTo3D(index, uOutputDim)',
      '  kernel()',
      '  gl_FragData[0][0] = kernelResult',
    ];
  }

  getMainResultSubKernelNumberTexture() {
    const result = [];
    if (!this.subKernels) return result;
    for (let i = 0; i < this.subKernels.length; ++i) {
      const subKernel = this.subKernels[i];
      if (subKernel.returnType === 'Integer') {
        result.push(
          `  gl_FragData[${i + 1}][0] = float(subKernelResult_${subKernel.name})`
        );
      } else {
        result.push(
          `  gl_FragData[${i + 1}][0] = subKernelResult_${subKernel.name}`
        );
      }
    }
    return result;
  }

  getMainResultKernelArray2Texture() {
    return [
      '  threadId = indexTo3D(index, uOutputDim)',
      '  kernel()',
      '  gl_FragData[0][0] = kernelResult[0]',
      '  gl_FragData[0][1] = kernelResult[1]',
    ];
  }

  getMainResultSubKernelArray2Texture() {
    const result = [];
    if (!this.subKernels) return result;
    for (let i = 0; i < this.subKernels.length; ++i) {
      result.push(
        `  gl_FragData[${i + 1}][0] = subKernelResult_${this.subKernels[i].name}[0]`,
        `  gl_FragData[${i + 1}][1] = subKernelResult_${this.subKernels[i].name}[1]`
      );
    }
    return result;
  }

  getMainResultKernelArray3Texture() {
    return [
      '  threadId = indexTo3D(index, uOutputDim)',
      '  kernel()',
      '  gl_FragData[0][0] = kernelResult[0]',
      '  gl_FragData[0][1] = kernelResult[1]',
      '  gl_FragData[0][2] = kernelResult[2]',
    ];
  }

  getMainResultSubKernelArray3Texture() {
    const result = [];
    if (!this.subKernels) return result;
    for (let i = 0; i < this.subKernels.length; ++i) {
      result.push(
        `  gl_FragData[${i + 1}][0] = subKernelResult_${this.subKernels[i].name}[0]`,
        `  gl_FragData[${i + 1}][1] = subKernelResult_${this.subKernels[i].name}[1]`,
        `  gl_FragData[${i + 1}][2] = subKernelResult_${this.subKernels[i].name}[2]`
      );
    }
    return result;
  }

  getMainResultKernelArray4Texture() {
    return [
      '  threadId = indexTo3D(index, uOutputDim)',
      '  kernel()',
      '  gl_FragData[0] = kernelResult',
    ];
  }

  getMainResultSubKernelArray4Texture() {
    const result = [];
    if (!this.subKernels) return result;
    switch (this.returnType) {
      case 'Number':
      case 'Float':
      case 'Integer':
        for (let i = 0; i < this.subKernels.length; ++i) {
          const subKernel = this.subKernels[i];
          if (subKernel.returnType === 'Integer') {
            result.push(
              `  gl_FragData[${i + 1}] = float(subKernelResult_${this.subKernels[i].name})`
            );
          } else {
            result.push(
              `  gl_FragData[${i + 1}] = subKernelResult_${this.subKernels[i].name}`
            );
          }
        }
        break;
      case 'Array(2)':
        for (let i = 0; i < this.subKernels.length; ++i) {
          result.push(
            `  gl_FragData[${i + 1}][0] = subKernelResult_${this.subKernels[i].name}[0]`,
            `  gl_FragData[${i + 1}][1] = subKernelResult_${this.subKernels[i].name}[1]`
          );
        }
        break;
      case 'Array(3)':
        for (let i = 0; i < this.subKernels.length; ++i) {
          result.push(
            `  gl_FragData[${i + 1}][0] = subKernelResult_${this.subKernels[i].name}[0]`,
            `  gl_FragData[${i + 1}][1] = subKernelResult_${this.subKernels[i].name}[1]`,
            `  gl_FragData[${i + 1}][2] = subKernelResult_${this.subKernels[i].name}[2]`
          );
        }
        break;
      case 'Array(4)':
        for (let i = 0; i < this.subKernels.length; ++i) {
          result.push(
            `  gl_FragData[${i + 1}][0] = subKernelResult_${this.subKernels[i].name}[0]`,
            `  gl_FragData[${i + 1}][1] = subKernelResult_${this.subKernels[i].name}[1]`,
            `  gl_FragData[${i + 1}][2] = subKernelResult_${this.subKernels[i].name}[2]`,
            `  gl_FragData[${i + 1}][3] = subKernelResult_${this.subKernels[i].name}[3]`
          );
        }
        break;
    }

    return result;
  }

  replaceArtifacts(src, map) {
    return src.replace(/[ ]*__([A-Z]+[0-9]*([_]?[A-Z]*[0-9]?)*)__;\n/g, (match, artifact) => {
      if (map.hasOwnProperty(artifact)) {
        return map[artifact];
      }
      throw `unhandled artifact ${artifact}`;
    });
  }

  getFragmentShader(args) {
    if (this.compiledFragmentShader !== null) {
      return this.compiledFragmentShader;
    }
    return this.compiledFragmentShader = this.replaceArtifacts(this.constructor.fragmentShader, this._getFragShaderArtifactMap(args));
  }

  getVertexShader(args) {
    if (this.compiledVertexShader !== null) {
      return this.compiledVertexShader;
    }
    return this.compiledVertexShader = this.replaceArtifacts(this.constructor.vertexShader, this._getVertShaderArtifactMap(args));
  }

  toString() {
    const setupContextString = utils.linesToString([
      `const gl = context`,
    ]);
    return glKernelString(this.constructor, arguments, this, setupContextString);
  }

  destroy(removeCanvasReferences) {
    if (!this.context) return;
    if (this.buffer) {
      this.context.deleteBuffer(this.buffer);
    }
    if (this.framebuffer) {
      this.context.deleteFramebuffer(this.framebuffer);
    }
    for (const width in this.rawValueFramebuffers) {
      for (const height in this.rawValueFramebuffers[width]) {
        this.context.deleteFramebuffer(this.rawValueFramebuffers[width][height]);
        delete this.rawValueFramebuffers[width][height];
      }
      delete this.rawValueFramebuffers[width];
    }
    if (this.vertShader) {
      this.context.deleteShader(this.vertShader);
    }
    if (this.fragShader) {
      this.context.deleteShader(this.fragShader);
    }
    if (this.program) {
      this.context.deleteProgram(this.program);
    }
    if (this.texture) {
      this.texture.delete();
      const textureCacheIndex = this.textureCache.indexOf(this.texture.texture);
      if (textureCacheIndex > -1) {
        this.textureCache.splice(textureCacheIndex, 1);
      }
      this.texture = null;
    }
    if (this.mappedTextures && this.mappedTextures.length) {
      for (let i = 0; i < this.mappedTextures.length; i++) {
        const mappedTexture = this.mappedTextures[i];
        mappedTexture.delete();
        const textureCacheIndex = this.textureCache.indexOf(mappedTexture.texture);
        if (textureCacheIndex > -1) {
          this.textureCache.splice(textureCacheIndex, 1);
        }
      }
      this.mappedTextures = null;
    }
    if (this.kernelArguments) {
      for (let i = 0; i < this.kernelArguments.length; i++) {
        this.kernelArguments[i].destroy();
      }
    }
    if (this.kernelConstants) {
      for (let i = 0; i < this.kernelConstants.length; i++) {
        this.kernelConstants[i].destroy();
      }
    }
    while (this.textureCache.length > 0) {
      const texture = this.textureCache.pop();
      this.context.deleteTexture(texture);
    }
    if (removeCanvasReferences) {
      const idx = canvases.indexOf(this.canvas);
      if (idx >= 0) {
        canvases[idx] = null;
        maxTexSizes[idx] = null;
      }
    }
    this.destroyExtensions();
    delete this.context;
    delete this.canvas;
    if (!this.gpu) return;
    const i = this.gpu.kernels.indexOf(this);
    if (i === -1) return;
    this.gpu.kernels.splice(i, 1);
  }

  destroyExtensions() {
    this.extensions.OES_texture_float = null;
    this.extensions.OES_texture_float_linear = null;
    this.extensions.OES_element_index_uint = null;
    this.extensions.WEBGL_draw_buffers = null;
  }

  static destroyContext(context) {
    const extension = context.getExtension('WEBGL_lose_context');
    if (extension) {
      extension.loseContext();
    }
  }

  toJSON() {
    const json = super.toJSON();
    json.functionNodes = FunctionBuilder.fromKernel(this, WebGLFunctionNode).toJSON();
    json.settings.threadDim = this.threadDim;
    return json;
  }
}

module.exports = {
  WebGLKernel
};
},{"../../plugins/math-random-uniformly-distributed":112,"../../utils":114,"../function-builder":9,"../gl/kernel":13,"../gl/kernel-string":12,"./fragment-shader":37,"./function-node":38,"./kernel-value-maps":39,"./vertex-shader":71}],71:[function(require,module,exports){
const vertexShader = `__FLOAT_TACTIC_DECLARATION__;
__INT_TACTIC_DECLARATION__;
__SAMPLER_2D_TACTIC_DECLARATION__;

attribute vec2 aPos;
attribute vec2 aTexCoord;

varying vec2 vTexCoord;
uniform vec2 ratio;

void main(void) {
  gl_Position = vec4((aPos + vec2(1)) * ratio + vec2(-1), 0, 1);
  vTexCoord = aTexCoord;
}`;

module.exports = {
  vertexShader
};
},{}],72:[function(require,module,exports){
const fragmentShader = `#version 300 es
__HEADER__;
__FLOAT_TACTIC_DECLARATION__;
__INT_TACTIC_DECLARATION__;
__SAMPLER_2D_TACTIC_DECLARATION__;
__SAMPLER_2D_ARRAY_TACTIC_DECLARATION__;

const int LOOP_MAX = __LOOP_MAX__;

__PLUGINS__;
__CONSTANTS__;

in vec2 vTexCoord;

float atan2(float v1, float v2) {
  if (v1 == 0.0 || v2 == 0.0) return 0.0;
  return atan(v1 / v2);
}

float cbrt(float x) {
  if (x >= 0.0) {
    return pow(x, 1.0 / 3.0);
  } else {
    return -pow(x, 1.0 / 3.0);
  }
}

float expm1(float x) {
  return pow(${Math.E}, x) - 1.0; 
}

float fround(highp float x) {
  return x;
}

float imul(float v1, float v2) {
  return float(int(v1) * int(v2));
}

float log10(float x) {
  return log2(x) * (1.0 / log2(10.0));
}

float log1p(float x) {
  return log(1.0 + x);
}

float _pow(float v1, float v2) {
  if (v2 == 0.0) return 1.0;
  return pow(v1, v2);
}

float _round(float x) {
  return floor(x + 0.5);
}


const int BIT_COUNT = 32;
int modi(int x, int y) {
  return x - y * (x / y);
}

int bitwiseOr(int a, int b) {
  int result = 0;
  int n = 1;
  
  for (int i = 0; i < BIT_COUNT; i++) {
    if ((modi(a, 2) == 1) || (modi(b, 2) == 1)) {
      result += n;
    }
    a = a / 2;
    b = b / 2;
    n = n * 2;
    if(!(a > 0 || b > 0)) {
      break;
    }
  }
  return result;
}
int bitwiseXOR(int a, int b) {
  int result = 0;
  int n = 1;
  
  for (int i = 0; i < BIT_COUNT; i++) {
    if ((modi(a, 2) == 1) != (modi(b, 2) == 1)) {
      result += n;
    }
    a = a / 2;
    b = b / 2;
    n = n * 2;
    if(!(a > 0 || b > 0)) {
      break;
    }
  }
  return result;
}
int bitwiseAnd(int a, int b) {
  int result = 0;
  int n = 1;
  for (int i = 0; i < BIT_COUNT; i++) {
    if ((modi(a, 2) == 1) && (modi(b, 2) == 1)) {
      result += n;
    }
    a = a / 2;
    b = b / 2;
    n = n * 2;
    if(!(a > 0 && b > 0)) {
      break;
    }
  }
  return result;
}
int bitwiseNot(int a) {
  int result = 0;
  int n = 1;
  
  for (int i = 0; i < BIT_COUNT; i++) {
    if (modi(a, 2) == 0) {
      result += n;    
    }
    a = a / 2;
    n = n * 2;
  }
  return result;
}
int bitwiseZeroFillLeftShift(int n, int shift) {
  int maxBytes = BIT_COUNT;
  for (int i = 0; i < BIT_COUNT; i++) {
    if (maxBytes >= n) {
      break;
    }
    maxBytes *= 2;
  }
  for (int i = 0; i < BIT_COUNT; i++) {
    if (i >= shift) {
      break;
    }
    n *= 2;
  }

  int result = 0;
  int byteVal = 1;
  for (int i = 0; i < BIT_COUNT; i++) {
    if (i >= maxBytes) break;
    if (modi(n, 2) > 0) { result += byteVal; }
    n = int(n / 2);
    byteVal *= 2;
  }
  return result;
}

int bitwiseSignedRightShift(int num, int shifts) {
  return int(floor(float(num) / pow(2.0, float(shifts))));
}

int bitwiseZeroFillRightShift(int n, int shift) {
  int maxBytes = BIT_COUNT;
  for (int i = 0; i < BIT_COUNT; i++) {
    if (maxBytes >= n) {
      break;
    }
    maxBytes *= 2;
  }
  for (int i = 0; i < BIT_COUNT; i++) {
    if (i >= shift) {
      break;
    }
    n /= 2;
  }
  int result = 0;
  int byteVal = 1;
  for (int i = 0; i < BIT_COUNT; i++) {
    if (i >= maxBytes) break;
    if (modi(n, 2) > 0) { result += byteVal; }
    n = int(n / 2);
    byteVal *= 2;
  }
  return result;
}

vec2 integerMod(vec2 x, float y) {
  vec2 res = floor(mod(x, y));
  return res * step(1.0 - floor(y), -res);
}

vec3 integerMod(vec3 x, float y) {
  vec3 res = floor(mod(x, y));
  return res * step(1.0 - floor(y), -res);
}

vec4 integerMod(vec4 x, vec4 y) {
  vec4 res = floor(mod(x, y));
  return res * step(1.0 - floor(y), -res);
}

float integerMod(float x, float y) {
  float res = floor(mod(x, y));
  return res * (res > floor(y) - 1.0 ? 0.0 : 1.0);
}

int integerMod(int x, int y) {
  return x - (y * int(x/y));
}

__DIVIDE_WITH_INTEGER_CHECK__;

// Here be dragons!
// DO NOT OPTIMIZE THIS CODE
// YOU WILL BREAK SOMETHING ON SOMEBODY\'S MACHINE
// LEAVE IT AS IT IS, LEST YOU WASTE YOUR OWN TIME
const vec2 MAGIC_VEC = vec2(1.0, -256.0);
const vec4 SCALE_FACTOR = vec4(1.0, 256.0, 65536.0, 0.0);
const vec4 SCALE_FACTOR_INV = vec4(1.0, 0.00390625, 0.0000152587890625, 0.0); // 1, 1/256, 1/65536
float decode32(vec4 texel) {
  __DECODE32_ENDIANNESS__;
  texel *= 255.0;
  vec2 gte128;
  gte128.x = texel.b >= 128.0 ? 1.0 : 0.0;
  gte128.y = texel.a >= 128.0 ? 1.0 : 0.0;
  float exponent = 2.0 * texel.a - 127.0 + dot(gte128, MAGIC_VEC);
  float res = exp2(round(exponent));
  texel.b = texel.b - 128.0 * gte128.x;
  res = dot(texel, SCALE_FACTOR) * exp2(round(exponent-23.0)) + res;
  res *= gte128.y * -2.0 + 1.0;
  return res;
}

float decode16(vec4 texel, int index) {
  int channel = integerMod(index, 2);
  return texel[channel*2] * 255.0 + texel[channel*2 + 1] * 65280.0;
}

float decode8(vec4 texel, int index) {
  int channel = integerMod(index, 4);
  return texel[channel] * 255.0;
}

vec4 legacyEncode32(float f) {
  float F = abs(f);
  float sign = f < 0.0 ? 1.0 : 0.0;
  float exponent = floor(log2(F));
  float mantissa = (exp2(-exponent) * F);
  // exponent += floor(log2(mantissa));
  vec4 texel = vec4(F * exp2(23.0-exponent)) * SCALE_FACTOR_INV;
  texel.rg = integerMod(texel.rg, 256.0);
  texel.b = integerMod(texel.b, 128.0);
  texel.a = exponent*0.5 + 63.5;
  texel.ba += vec2(integerMod(exponent+127.0, 2.0), sign) * 128.0;
  texel = floor(texel);
  texel *= 0.003921569; // 1/255
  __ENCODE32_ENDIANNESS__;
  return texel;
}

// https://github.com/gpujs/gpu.js/wiki/Encoder-details
vec4 encode32(float value) {
  if (value == 0.0) return vec4(0, 0, 0, 0);

  float exponent;
  float mantissa;
  vec4  result;
  float sgn;

  sgn = step(0.0, -value);
  value = abs(value);

  exponent = floor(log2(value));

  mantissa = value*pow(2.0, -exponent)-1.0;
  exponent = exponent+127.0;
  result   = vec4(0,0,0,0);

  result.a = floor(exponent/2.0);
  exponent = exponent - result.a*2.0;
  result.a = result.a + 128.0*sgn;

  result.b = floor(mantissa * 128.0);
  mantissa = mantissa - result.b / 128.0;
  result.b = result.b + exponent*128.0;

  result.g = floor(mantissa*32768.0);
  mantissa = mantissa - result.g/32768.0;

  result.r = floor(mantissa*8388608.0);
  return result/255.0;
}
// Dragons end here

int index;
ivec3 threadId;

ivec3 indexTo3D(int idx, ivec3 texDim) {
  int z = int(idx / (texDim.x * texDim.y));
  idx -= z * int(texDim.x * texDim.y);
  int y = int(idx / texDim.x);
  int x = int(integerMod(idx, texDim.x));
  return ivec3(x, y, z);
}

float get32(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  int index = x + texDim.x * (y + texDim.y * z);
  int w = texSize.x;
  vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;
  vec4 texel = texture(tex, st / vec2(texSize));
  return decode32(texel);
}

float get16(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  int index = x + (texDim.x * (y + (texDim.y * z)));
  int w = texSize.x * 2;
  vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;
  vec4 texel = texture(tex, st / vec2(texSize.x * 2, texSize.y));
  return decode16(texel, index);
}

float get8(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  int index = x + (texDim.x * (y + (texDim.y * z)));
  int w = texSize.x * 4;
  vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;
  vec4 texel = texture(tex, st / vec2(texSize.x * 4, texSize.y));
  return decode8(texel, index);
}

float getMemoryOptimized32(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  int index = x + (texDim.x * (y + (texDim.y * z)));
  int channel = integerMod(index, 4);
  index = index / 4;
  int w = texSize.x;
  vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;
  index = index / 4;
  vec4 texel = texture(tex, st / vec2(texSize));
  return texel[channel];
}

vec4 getImage2D(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  int index = x + texDim.x * (y + texDim.y * z);
  int w = texSize.x;
  vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;
  return texture(tex, st / vec2(texSize));
}

vec4 getImage3D(sampler2DArray tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  int index = x + texDim.x * (y + texDim.y * z);
  int w = texSize.x;
  vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;
  return texture(tex, vec3(st / vec2(texSize), z));
}

float getFloatFromSampler2D(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  vec4 result = getImage2D(tex, texSize, texDim, z, y, x);
  return result[0];
}

vec2 getVec2FromSampler2D(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  vec4 result = getImage2D(tex, texSize, texDim, z, y, x);
  return vec2(result[0], result[1]);
}

vec2 getMemoryOptimizedVec2(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  int index = x + texDim.x * (y + texDim.y * z);
  int channel = integerMod(index, 2);
  index = index / 2;
  int w = texSize.x;
  vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;
  vec4 texel = texture(tex, st / vec2(texSize));
  if (channel == 0) return vec2(texel.r, texel.g);
  if (channel == 1) return vec2(texel.b, texel.a);
  return vec2(0.0, 0.0);
}

vec3 getVec3FromSampler2D(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  vec4 result = getImage2D(tex, texSize, texDim, z, y, x);
  return vec3(result[0], result[1], result[2]);
}

vec3 getMemoryOptimizedVec3(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  int fieldIndex = 3 * (x + texDim.x * (y + texDim.y * z));
  int vectorIndex = fieldIndex / 4;
  int vectorOffset = fieldIndex - vectorIndex * 4;
  int readY = vectorIndex / texSize.x;
  int readX = vectorIndex - readY * texSize.x;
  vec4 tex1 = texture(tex, (vec2(readX, readY) + 0.5) / vec2(texSize));

  if (vectorOffset == 0) {
    return tex1.xyz;
  } else if (vectorOffset == 1) {
    return tex1.yzw;
  } else {
    readX++;
    if (readX >= texSize.x) {
      readX = 0;
      readY++;
    }
    vec4 tex2 = texture(tex, vec2(readX, readY) / vec2(texSize));
    if (vectorOffset == 2) {
      return vec3(tex1.z, tex1.w, tex2.x);
    } else {
      return vec3(tex1.w, tex2.x, tex2.y);
    }
  }
}

vec4 getVec4FromSampler2D(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  return getImage2D(tex, texSize, texDim, z, y, x);
}

vec4 getMemoryOptimizedVec4(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  int index = x + texDim.x * (y + texDim.y * z);
  int channel = integerMod(index, 2);
  int w = texSize.x;
  vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;
  vec4 texel = texture(tex, st / vec2(texSize));
  return vec4(texel.r, texel.g, texel.b, texel.a);
}

vec4 actualColor;
void color(float r, float g, float b, float a) {
  actualColor = vec4(r,g,b,a);
}

void color(float r, float g, float b) {
  color(r,g,b,1.0);
}

float modulo(float number, float divisor) {
  if (number < 0.0) {
    number = abs(number);
    if (divisor < 0.0) {
      divisor = abs(divisor);
    }
    return -mod(number, divisor);
  }
  if (divisor < 0.0) {
    divisor = abs(divisor);
  }
  return mod(number, divisor);
}

__INJECTED_NATIVE__;
__MAIN_CONSTANTS__;
__MAIN_ARGUMENTS__;
__KERNEL__;

void main(void) {
  index = int(vTexCoord.s * float(uTexSize.x)) + int(vTexCoord.t * float(uTexSize.y)) * uTexSize.x;
  __MAIN_RESULT__;
}`;

module.exports = {
  fragmentShader
};
},{}],73:[function(require,module,exports){
const { utils } = require('../../utils');
const { WebGLFunctionNode } = require('../web-gl/function-node');

class WebGL2FunctionNode extends WebGLFunctionNode {

  astIdentifierExpression(idtNode, retArr) {
    if (idtNode.type !== 'Identifier') {
      throw this.astErrorOutput(
        'IdentifierExpression - not an Identifier',
        idtNode
      );
    }

    const type = this.getType(idtNode);

    const name = utils.sanitizeName(idtNode.name);
    if (idtNode.name === 'Infinity') {
      retArr.push('intBitsToFloat(2139095039)');
    } else if (type === 'Boolean') {
      if (this.argumentNames.indexOf(name) > -1) {
        retArr.push(`bool(user_${name})`);
      } else {
        retArr.push(`user_${name}`);
      }
    } else {
      retArr.push(`user_${name}`);
    }

    return retArr;
  }
}

module.exports = {
  WebGL2FunctionNode
};
},{"../../utils":114,"../web-gl/function-node":38}],74:[function(require,module,exports){
const { WebGL2KernelValueBoolean } = require('./kernel-value/boolean');
const { WebGL2KernelValueFloat } = require('./kernel-value/float');
const { WebGL2KernelValueInteger } = require('./kernel-value/integer');

const { WebGL2KernelValueHTMLImage } = require('./kernel-value/html-image');
const { WebGL2KernelValueDynamicHTMLImage } = require('./kernel-value/dynamic-html-image');

const { WebGL2KernelValueHTMLImageArray } = require('./kernel-value/html-image-array');
const { WebGL2KernelValueDynamicHTMLImageArray } = require('./kernel-value/dynamic-html-image-array');

const { WebGL2KernelValueHTMLVideo } = require('./kernel-value/html-video');
const { WebGL2KernelValueDynamicHTMLVideo } = require('./kernel-value/dynamic-html-video');

const { WebGL2KernelValueSingleInput } = require('./kernel-value/single-input');
const { WebGL2KernelValueDynamicSingleInput } = require('./kernel-value/dynamic-single-input');

const { WebGL2KernelValueUnsignedInput } = require('./kernel-value/unsigned-input');
const { WebGL2KernelValueDynamicUnsignedInput } = require('./kernel-value/dynamic-unsigned-input');

const { WebGL2KernelValueMemoryOptimizedNumberTexture } = require('./kernel-value/memory-optimized-number-texture');
const { WebGL2KernelValueDynamicMemoryOptimizedNumberTexture } = require('./kernel-value/dynamic-memory-optimized-number-texture');

const { WebGL2KernelValueNumberTexture } = require('./kernel-value/number-texture');
const { WebGL2KernelValueDynamicNumberTexture } = require('./kernel-value/dynamic-number-texture');

const { WebGL2KernelValueSingleArray } = require('./kernel-value/single-array');
const { WebGL2KernelValueDynamicSingleArray } = require('./kernel-value/dynamic-single-array');

const { WebGL2KernelValueSingleArray1DI } = require('./kernel-value/single-array1d-i');
const { WebGL2KernelValueDynamicSingleArray1DI } = require('./kernel-value/dynamic-single-array1d-i');

const { WebGL2KernelValueSingleArray2DI } = require('./kernel-value/single-array2d-i');
const { WebGL2KernelValueDynamicSingleArray2DI } = require('./kernel-value/dynamic-single-array2d-i');

const { WebGL2KernelValueSingleArray3DI } = require('./kernel-value/single-array3d-i');
const { WebGL2KernelValueDynamicSingleArray3DI } = require('./kernel-value/dynamic-single-array3d-i');

const { WebGL2KernelValueSingleArray2 } = require('./kernel-value/single-array2');
const { WebGL2KernelValueSingleArray3 } = require('./kernel-value/single-array3');
const { WebGL2KernelValueSingleArray4 } = require('./kernel-value/single-array4');

const { WebGL2KernelValueUnsignedArray } = require('./kernel-value/unsigned-array');
const { WebGL2KernelValueDynamicUnsignedArray } = require('./kernel-value/dynamic-unsigned-array');

const kernelValueMaps = {
  unsigned: {
    dynamic: {
      'Boolean': WebGL2KernelValueBoolean,
      'Integer': WebGL2KernelValueInteger,
      'Float': WebGL2KernelValueFloat,
      'Array': WebGL2KernelValueDynamicUnsignedArray,
      'Array(2)': false,
      'Array(3)': false,
      'Array(4)': false,
      'Array1D(2)': false,
      'Array1D(3)': false,
      'Array1D(4)': false,
      'Array2D(2)': false,
      'Array2D(3)': false,
      'Array2D(4)': false,
      'Array3D(2)': false,
      'Array3D(3)': false,
      'Array3D(4)': false,
      'Input': WebGL2KernelValueDynamicUnsignedInput,
      'NumberTexture': WebGL2KernelValueDynamicNumberTexture,
      'ArrayTexture(1)': WebGL2KernelValueDynamicNumberTexture,
      'ArrayTexture(2)': WebGL2KernelValueDynamicNumberTexture,
      'ArrayTexture(3)': WebGL2KernelValueDynamicNumberTexture,
      'ArrayTexture(4)': WebGL2KernelValueDynamicNumberTexture,
      'MemoryOptimizedNumberTexture': WebGL2KernelValueDynamicMemoryOptimizedNumberTexture,
      'HTMLCanvas': WebGL2KernelValueDynamicHTMLImage,
      'HTMLImage': WebGL2KernelValueDynamicHTMLImage,
      'HTMLImageArray': WebGL2KernelValueDynamicHTMLImageArray,
      'HTMLVideo': WebGL2KernelValueDynamicHTMLVideo,
    },
    static: {
      'Boolean': WebGL2KernelValueBoolean,
      'Float': WebGL2KernelValueFloat,
      'Integer': WebGL2KernelValueInteger,
      'Array': WebGL2KernelValueUnsignedArray,
      'Array(2)': false,
      'Array(3)': false,
      'Array(4)': false,
      'Array1D(2)': false,
      'Array1D(3)': false,
      'Array1D(4)': false,
      'Array2D(2)': false,
      'Array2D(3)': false,
      'Array2D(4)': false,
      'Array3D(2)': false,
      'Array3D(3)': false,
      'Array3D(4)': false,
      'Input': WebGL2KernelValueUnsignedInput,
      'NumberTexture': WebGL2KernelValueNumberTexture,
      'ArrayTexture(1)': WebGL2KernelValueNumberTexture,
      'ArrayTexture(2)': WebGL2KernelValueNumberTexture,
      'ArrayTexture(3)': WebGL2KernelValueNumberTexture,
      'ArrayTexture(4)': WebGL2KernelValueNumberTexture,
      'MemoryOptimizedNumberTexture': WebGL2KernelValueDynamicMemoryOptimizedNumberTexture,
      'HTMLCanvas': WebGL2KernelValueHTMLImage,
      'HTMLImage': WebGL2KernelValueHTMLImage,
      'HTMLImageArray': WebGL2KernelValueHTMLImageArray,
      'HTMLVideo': WebGL2KernelValueHTMLVideo,
    }
  },
  single: {
    dynamic: {
      'Boolean': WebGL2KernelValueBoolean,
      'Integer': WebGL2KernelValueInteger,
      'Float': WebGL2KernelValueFloat,
      'Array': WebGL2KernelValueDynamicSingleArray,
      'Array(2)': WebGL2KernelValueSingleArray2,
      'Array(3)': WebGL2KernelValueSingleArray3,
      'Array(4)': WebGL2KernelValueSingleArray4,
      'Array1D(2)': WebGL2KernelValueDynamicSingleArray1DI,
      'Array1D(3)': WebGL2KernelValueDynamicSingleArray1DI,
      'Array1D(4)': WebGL2KernelValueDynamicSingleArray1DI,
      'Array2D(2)': WebGL2KernelValueDynamicSingleArray2DI,
      'Array2D(3)': WebGL2KernelValueDynamicSingleArray2DI,
      'Array2D(4)': WebGL2KernelValueDynamicSingleArray2DI,
      'Array3D(2)': WebGL2KernelValueDynamicSingleArray3DI,
      'Array3D(3)': WebGL2KernelValueDynamicSingleArray3DI,
      'Array3D(4)': WebGL2KernelValueDynamicSingleArray3DI,
      'Input': WebGL2KernelValueDynamicSingleInput,
      'NumberTexture': WebGL2KernelValueDynamicNumberTexture,
      'ArrayTexture(1)': WebGL2KernelValueDynamicNumberTexture,
      'ArrayTexture(2)': WebGL2KernelValueDynamicNumberTexture,
      'ArrayTexture(3)': WebGL2KernelValueDynamicNumberTexture,
      'ArrayTexture(4)': WebGL2KernelValueDynamicNumberTexture,
      'MemoryOptimizedNumberTexture': WebGL2KernelValueDynamicMemoryOptimizedNumberTexture,
      'HTMLCanvas': WebGL2KernelValueDynamicHTMLImage,
      'HTMLImage': WebGL2KernelValueDynamicHTMLImage,
      'HTMLImageArray': WebGL2KernelValueDynamicHTMLImageArray,
      'HTMLVideo': WebGL2KernelValueDynamicHTMLVideo,
    },
    static: {
      'Boolean': WebGL2KernelValueBoolean,
      'Float': WebGL2KernelValueFloat,
      'Integer': WebGL2KernelValueInteger,
      'Array': WebGL2KernelValueSingleArray,
      'Array(2)': WebGL2KernelValueSingleArray2,
      'Array(3)': WebGL2KernelValueSingleArray3,
      'Array(4)': WebGL2KernelValueSingleArray4,
      'Array1D(2)': WebGL2KernelValueSingleArray1DI,
      'Array1D(3)': WebGL2KernelValueSingleArray1DI,
      'Array1D(4)': WebGL2KernelValueSingleArray1DI,
      'Array2D(2)': WebGL2KernelValueSingleArray2DI,
      'Array2D(3)': WebGL2KernelValueSingleArray2DI,
      'Array2D(4)': WebGL2KernelValueSingleArray2DI,
      'Array3D(2)': WebGL2KernelValueSingleArray3DI,
      'Array3D(3)': WebGL2KernelValueSingleArray3DI,
      'Array3D(4)': WebGL2KernelValueSingleArray3DI,
      'Input': WebGL2KernelValueSingleInput,
      'NumberTexture': WebGL2KernelValueNumberTexture,
      'ArrayTexture(1)': WebGL2KernelValueNumberTexture,
      'ArrayTexture(2)': WebGL2KernelValueNumberTexture,
      'ArrayTexture(3)': WebGL2KernelValueNumberTexture,
      'ArrayTexture(4)': WebGL2KernelValueNumberTexture,
      'MemoryOptimizedNumberTexture': WebGL2KernelValueMemoryOptimizedNumberTexture,
      'HTMLCanvas': WebGL2KernelValueHTMLImage,
      'HTMLImage': WebGL2KernelValueHTMLImage,
      'HTMLImageArray': WebGL2KernelValueHTMLImageArray,
      'HTMLVideo': WebGL2KernelValueHTMLVideo,
    }
  },
};

function lookupKernelValueType(type, dynamic, precision, value) {
  if (!type) {
    throw new Error('type missing');
  }
  if (!dynamic) {
    throw new Error('dynamic missing');
  }
  if (!precision) {
    throw new Error('precision missing');
  }
  if (value.type) {
    type = value.type;
  }
  const types = kernelValueMaps[precision][dynamic];
  if (types[type] === false) {
    return null;
  } else if (types[type] === undefined) {
    throw new Error(`Could not find a KernelValue for ${ type }`);
  }
  return types[type];
}

module.exports = {
  kernelValueMaps,
  lookupKernelValueType
};
},{"./kernel-value/boolean":75,"./kernel-value/dynamic-html-image":77,"./kernel-value/dynamic-html-image-array":76,"./kernel-value/dynamic-html-video":78,"./kernel-value/dynamic-memory-optimized-number-texture":79,"./kernel-value/dynamic-number-texture":80,"./kernel-value/dynamic-single-array":81,"./kernel-value/dynamic-single-array1d-i":82,"./kernel-value/dynamic-single-array2d-i":83,"./kernel-value/dynamic-single-array3d-i":84,"./kernel-value/dynamic-single-input":85,"./kernel-value/dynamic-unsigned-array":86,"./kernel-value/dynamic-unsigned-input":87,"./kernel-value/float":88,"./kernel-value/html-image":90,"./kernel-value/html-image-array":89,"./kernel-value/html-video":91,"./kernel-value/integer":92,"./kernel-value/memory-optimized-number-texture":93,"./kernel-value/number-texture":94,"./kernel-value/single-array":95,"./kernel-value/single-array1d-i":96,"./kernel-value/single-array2":97,"./kernel-value/single-array2d-i":98,"./kernel-value/single-array3":99,"./kernel-value/single-array3d-i":100,"./kernel-value/single-array4":101,"./kernel-value/single-input":102,"./kernel-value/unsigned-array":103,"./kernel-value/unsigned-input":104}],75:[function(require,module,exports){
const { WebGLKernelValueBoolean } = require('../../web-gl/kernel-value/boolean');

class WebGL2KernelValueBoolean extends WebGLKernelValueBoolean {}

module.exports = {
  WebGL2KernelValueBoolean
};
},{"../../web-gl/kernel-value/boolean":41}],76:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGL2KernelValueHTMLImageArray } = require('./html-image-array');

class WebGL2KernelValueDynamicHTMLImageArray extends WebGL2KernelValueHTMLImageArray {
  getSource() {
    const variablePrecision = this.getVariablePrecisionString();
    return utils.linesToString([
      `uniform ${ variablePrecision } sampler2DArray ${this.id}`,
      `uniform ${ variablePrecision } ivec2 ${this.sizeId}`,
      `uniform ${ variablePrecision } ivec3 ${this.dimensionsId}`,
    ]);
  }

  updateValue(images) {
    const { width, height } = images[0];
    this.checkSize(width, height);
    this.dimensions = [width, height, images.length];
    this.textureSize = [width, height];
    this.kernel.setUniform3iv(this.dimensionsId, this.dimensions);
    this.kernel.setUniform2iv(this.sizeId, this.textureSize);
    super.updateValue(images);
  }
}

module.exports = {
  WebGL2KernelValueDynamicHTMLImageArray
};
},{"../../../utils":114,"./html-image-array":89}],77:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGLKernelValueDynamicHTMLImage } = require('../../web-gl/kernel-value/dynamic-html-image');

class WebGL2KernelValueDynamicHTMLImage extends WebGLKernelValueDynamicHTMLImage {
  getSource() {
    const variablePrecision = this.getVariablePrecisionString();
    return utils.linesToString([
      `uniform ${ variablePrecision } sampler2D ${this.id}`,
      `uniform ${ variablePrecision } ivec2 ${this.sizeId}`,
      `uniform ${ variablePrecision } ivec3 ${this.dimensionsId}`,
    ]);
  }
}

module.exports = {
  WebGL2KernelValueDynamicHTMLImage
};
},{"../../../utils":114,"../../web-gl/kernel-value/dynamic-html-image":42}],78:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGL2KernelValueDynamicHTMLImage } = require('./dynamic-html-image');

class WebGL2KernelValueDynamicHTMLVideo extends WebGL2KernelValueDynamicHTMLImage {}

module.exports = {
  WebGL2KernelValueDynamicHTMLVideo
};
},{"../../../utils":114,"./dynamic-html-image":77}],79:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGLKernelValueDynamicMemoryOptimizedNumberTexture } = require('../../web-gl/kernel-value/dynamic-memory-optimized-number-texture');

class WebGL2KernelValueDynamicMemoryOptimizedNumberTexture extends WebGLKernelValueDynamicMemoryOptimizedNumberTexture {
  getSource() {
    return utils.linesToString([
      `uniform sampler2D ${this.id}`,
      `uniform ivec2 ${this.sizeId}`,
      `uniform ivec3 ${this.dimensionsId}`,
    ]);
  }
}

module.exports = {
  WebGL2KernelValueDynamicMemoryOptimizedNumberTexture
};
},{"../../../utils":114,"../../web-gl/kernel-value/dynamic-memory-optimized-number-texture":44}],80:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGLKernelValueDynamicNumberTexture } = require('../../web-gl/kernel-value/dynamic-number-texture');

class WebGL2KernelValueDynamicNumberTexture extends WebGLKernelValueDynamicNumberTexture {
  getSource() {
    const variablePrecision = this.getVariablePrecisionString();
    return utils.linesToString([
      `uniform ${ variablePrecision } sampler2D ${this.id}`,
      `uniform ${ variablePrecision } ivec2 ${this.sizeId}`,
      `uniform ${ variablePrecision } ivec3 ${this.dimensionsId}`,
    ]);
  }
}

module.exports = {
  WebGL2KernelValueDynamicNumberTexture
};
},{"../../../utils":114,"../../web-gl/kernel-value/dynamic-number-texture":45}],81:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGL2KernelValueSingleArray } = require('../../web-gl2/kernel-value/single-array');

class WebGL2KernelValueDynamicSingleArray extends WebGL2KernelValueSingleArray {
  getSource() {
    const variablePrecision = this.getVariablePrecisionString();
    return utils.linesToString([
      `uniform ${ variablePrecision } sampler2D ${this.id}`,
      `uniform ${ variablePrecision } ivec2 ${this.sizeId}`,
      `uniform ${ variablePrecision } ivec3 ${this.dimensionsId}`,
    ]);
  }

  updateValue(value) {
    this.dimensions = utils.getDimensions(value, true);
    this.textureSize = utils.getMemoryOptimizedFloatTextureSize(this.dimensions, this.bitRatio);
    this.uploadArrayLength = this.textureSize[0] * this.textureSize[1] * this.bitRatio;
    this.checkSize(this.textureSize[0], this.textureSize[1]);
    this.uploadValue = new Float32Array(this.uploadArrayLength);
    this.kernel.setUniform3iv(this.dimensionsId, this.dimensions);
    this.kernel.setUniform2iv(this.sizeId, this.textureSize);
    super.updateValue(value);
  }
}

module.exports = {
  WebGL2KernelValueDynamicSingleArray
};
},{"../../../utils":114,"../../web-gl2/kernel-value/single-array":95}],82:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGL2KernelValueSingleArray1DI } = require('../../web-gl2/kernel-value/single-array1d-i');

class WebGL2KernelValueDynamicSingleArray1DI extends WebGL2KernelValueSingleArray1DI {
  getSource() {
    const variablePrecision = this.getVariablePrecisionString();
    return utils.linesToString([
      `uniform ${ variablePrecision } sampler2D ${this.id}`,
      `uniform ${ variablePrecision } ivec2 ${this.sizeId}`,
      `uniform ${ variablePrecision } ivec3 ${this.dimensionsId}`,
    ]);
  }

  updateValue(value) {
    this.setShape(value);
    this.kernel.setUniform3iv(this.dimensionsId, this.dimensions);
    this.kernel.setUniform2iv(this.sizeId, this.textureSize);
    super.updateValue(value);
  }
}

module.exports = {
  WebGL2KernelValueDynamicSingleArray1DI
};
},{"../../../utils":114,"../../web-gl2/kernel-value/single-array1d-i":96}],83:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGL2KernelValueSingleArray2DI } = require('../../web-gl2/kernel-value/single-array2d-i');

class WebGL2KernelValueDynamicSingleArray2DI extends WebGL2KernelValueSingleArray2DI {
  getSource() {
    const variablePrecision = this.getVariablePrecisionString();
    return utils.linesToString([
      `uniform ${ variablePrecision } sampler2D ${this.id}`,
      `uniform ${ variablePrecision } ivec2 ${this.sizeId}`,
      `uniform ${ variablePrecision } ivec3 ${this.dimensionsId}`,
    ]);
  }

  updateValue(value) {
    this.setShape(value);
    this.kernel.setUniform3iv(this.dimensionsId, this.dimensions);
    this.kernel.setUniform2iv(this.sizeId, this.textureSize);
    super.updateValue(value);
  }
}

module.exports = {
  WebGL2KernelValueDynamicSingleArray2DI
};
},{"../../../utils":114,"../../web-gl2/kernel-value/single-array2d-i":98}],84:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGL2KernelValueSingleArray3DI } = require('../../web-gl2/kernel-value/single-array3d-i');

class WebGL2KernelValueDynamicSingleArray3DI extends WebGL2KernelValueSingleArray3DI {
  getSource() {
    const variablePrecision = this.getVariablePrecisionString();
    return utils.linesToString([
      `uniform ${ variablePrecision } sampler2D ${this.id}`,
      `uniform ${ variablePrecision } ivec2 ${this.sizeId}`,
      `uniform ${ variablePrecision } ivec3 ${this.dimensionsId}`,
    ]);
  }

  updateValue(value) {
    this.setShape(value);
    this.kernel.setUniform3iv(this.dimensionsId, this.dimensions);
    this.kernel.setUniform2iv(this.sizeId, this.textureSize);
    super.updateValue(value);
  }
}

module.exports = {
  WebGL2KernelValueDynamicSingleArray3DI
};
},{"../../../utils":114,"../../web-gl2/kernel-value/single-array3d-i":100}],85:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGL2KernelValueSingleInput } = require('../../web-gl2/kernel-value/single-input');

class WebGL2KernelValueDynamicSingleInput extends WebGL2KernelValueSingleInput {
  getSource() {
    const variablePrecision = this.getVariablePrecisionString();
    return utils.linesToString([
      `uniform ${ variablePrecision } sampler2D ${this.id}`,
      `uniform ${ variablePrecision } ivec2 ${this.sizeId}`,
      `uniform ${ variablePrecision } ivec3 ${this.dimensionsId}`,
    ]);
  }

  updateValue(value) {
    let [w, h, d] = value.size;
    this.dimensions = new Int32Array([w || 1, h || 1, d || 1]);
    this.textureSize = utils.getMemoryOptimizedFloatTextureSize(this.dimensions, this.bitRatio);
    this.uploadArrayLength = this.textureSize[0] * this.textureSize[1] * this.bitRatio;
    this.checkSize(this.textureSize[0], this.textureSize[1]);
    this.uploadValue = new Float32Array(this.uploadArrayLength);
    this.kernel.setUniform3iv(this.dimensionsId, this.dimensions);
    this.kernel.setUniform2iv(this.sizeId, this.textureSize);
    super.updateValue(value);
  }
}

module.exports = {
  WebGL2KernelValueDynamicSingleInput
};
},{"../../../utils":114,"../../web-gl2/kernel-value/single-input":102}],86:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGLKernelValueDynamicUnsignedArray } = require('../../web-gl/kernel-value/dynamic-unsigned-array');

class WebGL2KernelValueDynamicUnsignedArray extends WebGLKernelValueDynamicUnsignedArray {
  getSource() {
    const variablePrecision = this.getVariablePrecisionString();
    return utils.linesToString([
      `uniform ${ variablePrecision } sampler2D ${this.id}`,
      `uniform ${ variablePrecision } ivec2 ${this.sizeId}`,
      `uniform ${ variablePrecision } ivec3 ${this.dimensionsId}`,
    ]);
  }
}

module.exports = {
  WebGL2KernelValueDynamicUnsignedArray
};
},{"../../../utils":114,"../../web-gl/kernel-value/dynamic-unsigned-array":51}],87:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGLKernelValueDynamicUnsignedInput } = require('../../web-gl/kernel-value/dynamic-unsigned-input');

class WebGL2KernelValueDynamicUnsignedInput extends WebGLKernelValueDynamicUnsignedInput {
  getSource() {
    const variablePrecision = this.getVariablePrecisionString();
    return utils.linesToString([
      `uniform ${ variablePrecision } sampler2D ${this.id}`,
      `uniform ${ variablePrecision } ivec2 ${this.sizeId}`,
      `uniform ${ variablePrecision } ivec3 ${this.dimensionsId}`,
    ]);
  }
}

module.exports = {
  WebGL2KernelValueDynamicUnsignedInput
};
},{"../../../utils":114,"../../web-gl/kernel-value/dynamic-unsigned-input":52}],88:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGLKernelValueFloat } = require('../../web-gl/kernel-value/float');

class WebGL2KernelValueFloat extends WebGLKernelValueFloat {}

module.exports = {
  WebGL2KernelValueFloat
};
},{"../../../utils":114,"../../web-gl/kernel-value/float":53}],89:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGLKernelArray } = require('../../web-gl/kernel-value/array');

class WebGL2KernelValueHTMLImageArray extends WebGLKernelArray {
  constructor(value, settings) {
    super(value, settings);
    this.checkSize(value[0].width, value[0].height);
    this.dimensions = [value[0].width, value[0].height, value.length];
    this.textureSize = [value[0].width, value[0].height];
  }
  defineTexture() {
    const { context: gl } = this;
    gl.activeTexture(this.contextHandle);
    gl.bindTexture(gl.TEXTURE_2D_ARRAY, this.texture);
    gl.texParameteri(gl.TEXTURE_2D_ARRAY, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D_ARRAY, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
  }

  getStringValueHandler() {
    return `const uploadValue_${this.name} = ${this.varName};\n`;
  }
  getSource() {
    const variablePrecision = this.getVariablePrecisionString();
    return utils.linesToString([
      `uniform ${ variablePrecision } sampler2DArray ${this.id}`,
      `${ variablePrecision } ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`,
      `${ variablePrecision } ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`,
    ]);
  }

  updateValue(images) {
    const { context: gl } = this;
    gl.activeTexture(this.contextHandle);
    gl.bindTexture(gl.TEXTURE_2D_ARRAY, this.texture);
    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
    gl.texImage3D(
      gl.TEXTURE_2D_ARRAY,
      0,
      gl.RGBA,
      images[0].width,
      images[0].height,
      images.length,
      0,
      gl.RGBA,
      gl.UNSIGNED_BYTE,
      null
    );
    for (let i = 0; i < images.length; i++) {
      const xOffset = 0;
      const yOffset = 0;
      const imageDepth = 1;
      gl.texSubImage3D(
        gl.TEXTURE_2D_ARRAY,
        0,
        xOffset,
        yOffset,
        i,
        images[i].width,
        images[i].height,
        imageDepth,
        gl.RGBA,
        gl.UNSIGNED_BYTE,
        this.uploadValue = images[i]
      );
    }
    this.kernel.setUniform1i(this.id, this.index);
  }
}

module.exports = {
  WebGL2KernelValueHTMLImageArray
};
},{"../../../utils":114,"../../web-gl/kernel-value/array":40}],90:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGLKernelValueHTMLImage } = require('../../web-gl/kernel-value/html-image');

class WebGL2KernelValueHTMLImage extends WebGLKernelValueHTMLImage {
  getSource() {
    const variablePrecision = this.getVariablePrecisionString();
    return utils.linesToString([
      `uniform ${ variablePrecision } sampler2D ${this.id}`,
      `${ variablePrecision } ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`,
      `${ variablePrecision } ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`,
    ]);
  }
}

module.exports = {
  WebGL2KernelValueHTMLImage
};
},{"../../../utils":114,"../../web-gl/kernel-value/html-image":54}],91:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGL2KernelValueHTMLImage } = require('./html-image');

class WebGL2KernelValueHTMLVideo extends WebGL2KernelValueHTMLImage {}

module.exports = {
  WebGL2KernelValueHTMLVideo
};
},{"../../../utils":114,"./html-image":90}],92:[function(require,module,exports){
const { WebGLKernelValueInteger } = require('../../web-gl/kernel-value/integer');

class WebGL2KernelValueInteger extends WebGLKernelValueInteger {
  getSource(value) {
    const variablePrecision = this.getVariablePrecisionString();
    if (this.origin === 'constants') {
      return `const ${ variablePrecision } int ${this.id} = ${ parseInt(value) };\n`;
    }
    return `uniform ${ variablePrecision } int ${this.id};\n`;
  }

  updateValue(value) {
    if (this.origin === 'constants') return;
    this.kernel.setUniform1i(this.id, this.uploadValue = value);
  }
}

module.exports = {
  WebGL2KernelValueInteger
};
},{"../../web-gl/kernel-value/integer":57}],93:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGLKernelValueMemoryOptimizedNumberTexture } = require('../../web-gl/kernel-value/memory-optimized-number-texture');

class WebGL2KernelValueMemoryOptimizedNumberTexture extends WebGLKernelValueMemoryOptimizedNumberTexture {
  getSource() {
    const { id, sizeId, textureSize, dimensionsId, dimensions } = this;
    const variablePrecision = this.getVariablePrecisionString();
    return utils.linesToString([
      `uniform sampler2D ${id}`,
      `${ variablePrecision } ivec2 ${sizeId} = ivec2(${textureSize[0]}, ${textureSize[1]})`,
      `${ variablePrecision } ivec3 ${dimensionsId} = ivec3(${dimensions[0]}, ${dimensions[1]}, ${dimensions[2]})`,
    ]);
  }
}

module.exports = {
  WebGL2KernelValueMemoryOptimizedNumberTexture
};
},{"../../../utils":114,"../../web-gl/kernel-value/memory-optimized-number-texture":58}],94:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGLKernelValueNumberTexture } = require('../../web-gl/kernel-value/number-texture');

class WebGL2KernelValueNumberTexture extends WebGLKernelValueNumberTexture {
  getSource() {
    const { id, sizeId, textureSize, dimensionsId, dimensions } = this;
    const variablePrecision = this.getVariablePrecisionString();
    return utils.linesToString([
      `uniform ${ variablePrecision } sampler2D ${id}`,
      `${ variablePrecision } ivec2 ${sizeId} = ivec2(${textureSize[0]}, ${textureSize[1]})`,
      `${ variablePrecision } ivec3 ${dimensionsId} = ivec3(${dimensions[0]}, ${dimensions[1]}, ${dimensions[2]})`,
    ]);
  }
}

module.exports = {
  WebGL2KernelValueNumberTexture
};
},{"../../../utils":114,"../../web-gl/kernel-value/number-texture":59}],95:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGLKernelValueSingleArray } = require('../../web-gl/kernel-value/single-array');

class WebGL2KernelValueSingleArray extends WebGLKernelValueSingleArray {
  getSource() {
    const variablePrecision = this.getVariablePrecisionString();
    return utils.linesToString([
      `uniform ${ variablePrecision } sampler2D ${this.id}`,
      `${ variablePrecision } ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`,
      `${ variablePrecision } ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`,
    ]);
  }

  updateValue(value) {
    if (value.constructor !== this.initialValueConstructor) {
      this.onUpdateValueMismatch(value.constructor);
      return;
    }
    const { context: gl } = this;
    utils.flattenTo(value, this.uploadValue);
    gl.activeTexture(this.contextHandle);
    gl.bindTexture(gl.TEXTURE_2D, this.texture);
    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA32F, this.textureSize[0], this.textureSize[1], 0, gl.RGBA, gl.FLOAT, this.uploadValue);
    this.kernel.setUniform1i(this.id, this.index);
  }
}

module.exports = {
  WebGL2KernelValueSingleArray
};
},{"../../../utils":114,"../../web-gl/kernel-value/single-array":60}],96:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGLKernelValueSingleArray1DI } = require('../../web-gl/kernel-value/single-array1d-i');

class WebGL2KernelValueSingleArray1DI extends WebGLKernelValueSingleArray1DI {
  updateValue(value) {
    if (value.constructor !== this.initialValueConstructor) {
      this.onUpdateValueMismatch(value.constructor);
      return;
    }
    const { context: gl } = this;
    utils.flattenTo(value, this.uploadValue);
    gl.activeTexture(this.contextHandle);
    gl.bindTexture(gl.TEXTURE_2D, this.texture);
    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA32F, this.textureSize[0], this.textureSize[1], 0, gl.RGBA, gl.FLOAT, this.uploadValue);
    this.kernel.setUniform1i(this.id, this.index);
  }
}

module.exports = {
  WebGL2KernelValueSingleArray1DI
};
},{"../../../utils":114,"../../web-gl/kernel-value/single-array1d-i":61}],97:[function(require,module,exports){
const { WebGLKernelValueSingleArray2 } = require('../../web-gl/kernel-value/single-array2');

class WebGL2KernelValueSingleArray2 extends WebGLKernelValueSingleArray2 {}

module.exports = {
  WebGL2KernelValueSingleArray2
};
},{"../../web-gl/kernel-value/single-array2":62}],98:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGLKernelValueSingleArray2DI } = require('../../web-gl/kernel-value/single-array2d-i');

class WebGL2KernelValueSingleArray2DI extends WebGLKernelValueSingleArray2DI {
  updateValue(value) {
    if (value.constructor !== this.initialValueConstructor) {
      this.onUpdateValueMismatch(value.constructor);
      return;
    }
    const { context: gl } = this;
    utils.flattenTo(value, this.uploadValue);
    gl.activeTexture(this.contextHandle);
    gl.bindTexture(gl.TEXTURE_2D, this.texture);
    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA32F, this.textureSize[0], this.textureSize[1], 0, gl.RGBA, gl.FLOAT, this.uploadValue);
    this.kernel.setUniform1i(this.id, this.index);
  }
}

module.exports = {
  WebGL2KernelValueSingleArray2DI
};
},{"../../../utils":114,"../../web-gl/kernel-value/single-array2d-i":63}],99:[function(require,module,exports){
const { WebGLKernelValueSingleArray3 } = require('../../web-gl/kernel-value/single-array3');

class WebGL2KernelValueSingleArray3 extends WebGLKernelValueSingleArray3 {}

module.exports = {
  WebGL2KernelValueSingleArray3
};
},{"../../web-gl/kernel-value/single-array3":64}],100:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGLKernelValueSingleArray3DI } = require('../../web-gl/kernel-value/single-array3d-i');

class WebGL2KernelValueSingleArray3DI extends WebGLKernelValueSingleArray3DI {
  updateValue(value) {
    if (value.constructor !== this.initialValueConstructor) {
      this.onUpdateValueMismatch(value.constructor);
      return;
    }
    const { context: gl } = this;
    utils.flattenTo(value, this.uploadValue);
    gl.activeTexture(this.contextHandle);
    gl.bindTexture(gl.TEXTURE_2D, this.texture);
    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA32F, this.textureSize[0], this.textureSize[1], 0, gl.RGBA, gl.FLOAT, this.uploadValue);
    this.kernel.setUniform1i(this.id, this.index);
  }
}

module.exports = {
  WebGL2KernelValueSingleArray3DI
};
},{"../../../utils":114,"../../web-gl/kernel-value/single-array3d-i":65}],101:[function(require,module,exports){
const { WebGLKernelValueSingleArray4 } = require('../../web-gl/kernel-value/single-array4');

class WebGL2KernelValueSingleArray4 extends WebGLKernelValueSingleArray4 {}

module.exports = {
  WebGL2KernelValueSingleArray4
};
},{"../../web-gl/kernel-value/single-array4":66}],102:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGLKernelValueSingleInput } = require('../../web-gl/kernel-value/single-input');

class WebGL2KernelValueSingleInput extends WebGLKernelValueSingleInput {
  getSource() {
    const variablePrecision = this.getVariablePrecisionString();
    return utils.linesToString([
      `uniform ${ variablePrecision } sampler2D ${this.id}`,
      `${ variablePrecision } ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`,
      `${ variablePrecision } ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`,
    ]);
  }

  updateValue(input) {
    const { context: gl } = this;
    utils.flattenTo(input.value, this.uploadValue);
    gl.activeTexture(this.contextHandle);
    gl.bindTexture(gl.TEXTURE_2D, this.texture);
    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA32F, this.textureSize[0], this.textureSize[1], 0, gl.RGBA, gl.FLOAT, this.uploadValue);
    this.kernel.setUniform1i(this.id, this.index);
  }
}

module.exports = {
  WebGL2KernelValueSingleInput
};
},{"../../../utils":114,"../../web-gl/kernel-value/single-input":67}],103:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGLKernelValueUnsignedArray } = require('../../web-gl/kernel-value/unsigned-array');

class WebGL2KernelValueUnsignedArray extends WebGLKernelValueUnsignedArray {
  getSource() {
    const variablePrecision = this.getVariablePrecisionString();
    return utils.linesToString([
      `uniform ${ variablePrecision } sampler2D ${this.id}`,
      `${ variablePrecision } ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`,
      `${ variablePrecision } ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`,
    ]);
  }
}

module.exports = {
  WebGL2KernelValueUnsignedArray
};
},{"../../../utils":114,"../../web-gl/kernel-value/unsigned-array":68}],104:[function(require,module,exports){
const { utils } = require('../../../utils');
const { WebGLKernelValueUnsignedInput } = require('../../web-gl/kernel-value/unsigned-input');

class WebGL2KernelValueUnsignedInput extends WebGLKernelValueUnsignedInput {
  getSource() {
    const variablePrecision = this.getVariablePrecisionString();
    return utils.linesToString([
      `uniform ${ variablePrecision } sampler2D ${this.id}`,
      `${ variablePrecision } ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`,
      `${ variablePrecision } ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`,
    ]);
  }
}

module.exports = {
  WebGL2KernelValueUnsignedInput
};
},{"../../../utils":114,"../../web-gl/kernel-value/unsigned-input":69}],105:[function(require,module,exports){
const { WebGLKernel } = require('../web-gl/kernel');
const { WebGL2FunctionNode } = require('./function-node');
const { FunctionBuilder } = require('../function-builder');
const { utils } = require('../../utils');
const { fragmentShader } = require('./fragment-shader');
const { vertexShader } = require('./vertex-shader');
const { lookupKernelValueType } = require('./kernel-value-maps');

let isSupported = null;
let testCanvas = null;
let testContext = null;
let testExtensions = null;

let features = null;

class WebGL2Kernel extends WebGLKernel {
  static get isSupported() {
    if (isSupported !== null) {
      return isSupported;
    }
    this.setupFeatureChecks();
    isSupported = this.isContextMatch(testContext);
    return isSupported;
  }

  static setupFeatureChecks() {
    if (typeof document !== 'undefined') {
      testCanvas = document.createElement('canvas');
    } else if (typeof OffscreenCanvas !== 'undefined') {
      testCanvas = new OffscreenCanvas(0, 0);
    }
    if (!testCanvas) return;
    testContext = testCanvas.getContext('webgl2');
    if (!testContext || !testContext.getExtension) return;
    testExtensions = {
      EXT_color_buffer_float: testContext.getExtension('EXT_color_buffer_float'),
      OES_texture_float_linear: testContext.getExtension('OES_texture_float_linear'),
    };
    features = this.getFeatures();
  }

  static isContextMatch(context) {
    if (typeof WebGL2RenderingContext !== 'undefined') {
      return context instanceof WebGL2RenderingContext;
    }
    return false;
  }

  static getFeatures() {
    const gl = this.testContext;
    return Object.freeze({
      isFloatRead: this.getIsFloatRead(),
      isIntegerDivisionAccurate: this.getIsIntegerDivisionAccurate(),
      isSpeedTacticSupported: this.getIsSpeedTacticSupported(),
      kernelMap: true,
      isTextureFloat: true,
      isDrawBuffers: true,
      channelCount: this.getChannelCount(),
      maxTextureSize: this.getMaxTextureSize(),
      lowIntPrecision: gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.LOW_INT),
      lowFloatPrecision: gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.LOW_FLOAT),
      mediumIntPrecision: gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_INT),
      mediumFloatPrecision: gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT),
      highIntPrecision: gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_INT),
      highFloatPrecision: gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT),
    });
  }

  static getIsTextureFloat() {
    return true;
  }

  static getChannelCount() {
    return testContext.getParameter(testContext.MAX_DRAW_BUFFERS);
  }

  static getMaxTextureSize() {
    return testContext.getParameter(testContext.MAX_TEXTURE_SIZE);
  }

  static lookupKernelValueType(type, dynamic, precision, value) {
    return lookupKernelValueType(type, dynamic, precision, value);
  }

  static get testCanvas() {
    return testCanvas;
  }

  static get testContext() {
    return testContext;
  }

  static get features() {
    return features;
  }

  static get fragmentShader() {
    return fragmentShader;
  }
  static get vertexShader() {
    return vertexShader;
  }

  initContext() {
    const settings = {
      alpha: false,
      depth: false,
      antialias: false
    };
    return this.canvas.getContext('webgl2', settings);
  }

  initExtensions() {
    this.extensions = {
      EXT_color_buffer_float: this.context.getExtension('EXT_color_buffer_float'),
      OES_texture_float_linear: this.context.getExtension('OES_texture_float_linear'),
    };
  }

  validateSettings(args) {
    if (!this.validate) {
      this.texSize = utils.getKernelTextureSize({
        optimizeFloatMemory: this.optimizeFloatMemory,
        precision: this.precision,
      }, this.output);
      return;
    }

    const { features } = this.constructor;
    if (this.precision === 'single' && !features.isFloatRead) {
      throw new Error('Float texture outputs are not supported');
    } else if (!this.graphical && this.precision === null) {
      this.precision = features.isFloatRead ? 'single' : 'unsigned';
    }

    if (this.fixIntegerDivisionAccuracy === null) {
      this.fixIntegerDivisionAccuracy = !features.isIntegerDivisionAccurate;
    } else if (this.fixIntegerDivisionAccuracy && features.isIntegerDivisionAccurate) {
      this.fixIntegerDivisionAccuracy = false;
    }

    this.checkOutput();

    if (!this.output || this.output.length === 0) {
      if (args.length !== 1) {
        throw new Error('Auto output only supported for kernels with only one input');
      }

      const argType = utils.getVariableType(args[0], this.strictIntegers);
      switch (argType) {
        case 'Array':
          this.output = utils.getDimensions(argType);
          break;
        case 'NumberTexture':
        case 'MemoryOptimizedNumberTexture':
        case 'ArrayTexture(1)':
        case 'ArrayTexture(2)':
        case 'ArrayTexture(3)':
        case 'ArrayTexture(4)':
          this.output = args[0].output;
          break;
        default:
          throw new Error('Auto output not supported for input type: ' + argType);
      }
    }

    if (this.graphical) {
      if (this.output.length !== 2) {
        throw new Error('Output must have 2 dimensions on graphical mode');
      }

      if (this.precision === 'single') {
        console.warn('Cannot use graphical mode and single precision at the same time');
        this.precision = 'unsigned';
      }

      this.texSize = utils.clone(this.output);
      return;
    } else if (!this.graphical && this.precision === null && features.isTextureFloat) {
      this.precision = 'single';
    }

    this.texSize = utils.getKernelTextureSize({
      optimizeFloatMemory: this.optimizeFloatMemory,
      precision: this.precision,
    }, this.output);

    this.checkTextureSize();
  }

  translateSource() {
    const functionBuilder = FunctionBuilder.fromKernel(this, WebGL2FunctionNode, {
      fixIntegerDivisionAccuracy: this.fixIntegerDivisionAccuracy
    });
    this.translatedSource = functionBuilder.getPrototypeString('kernel');
    this.setupReturnTypes(functionBuilder);
  }

  drawBuffers() {
    this.context.drawBuffers(this.drawBuffersMap);
  }

  getTextureFormat() {
    const { context: gl } = this;
    switch (this.getInternalFormat()) {
      case gl.R32F:
        return gl.RED;
      case gl.RG32F:
        return gl.RG;
      case gl.RGBA32F:
        return gl.RGBA;
      case gl.RGBA:
        return gl.RGBA;
      default:
        throw new Error('Unknown internal format');
    }
  }
  getInternalFormat() {
    const { context: gl } = this;

    if (this.precision === 'single') {
      if (this.pipeline) {
        switch (this.returnType) {
          case 'Number':
          case 'Float':
          case 'Integer':
            if (this.optimizeFloatMemory) {
              return gl.RGBA32F;
            } else {
              return gl.R32F;
            }
            case 'Array(2)':
              return gl.RG32F;
            case 'Array(3)': 
            case 'Array(4)':
              return gl.RGBA32F;
            default:
              throw new Error('Unhandled return type');
        }
      }
      return gl.RGBA32F;
    }
    return gl.RGBA;
  }

  _setupOutputTexture() {
    const gl = this.context;
    if (this.texture) {
      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.texture.texture, 0);
      return;
    }
    gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer);
    const texture = gl.createTexture();
    const texSize = this.texSize;
    gl.activeTexture(gl.TEXTURE0 + this.constantTextureCount + this.argumentTextureCount);
    gl.bindTexture(gl.TEXTURE_2D, texture);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
    const format = this.getInternalFormat();
    if (this.precision === 'single') {
      gl.texStorage2D(gl.TEXTURE_2D, 1, format, texSize[0], texSize[1]);
    } else {
      gl.texImage2D(gl.TEXTURE_2D, 0, format, texSize[0], texSize[1], 0, format, gl.UNSIGNED_BYTE, null);
    }
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
    this.texture = new this.TextureConstructor({
      texture,
      size: texSize,
      dimensions: this.threadDim,
      output: this.output,
      context: this.context,
      internalFormat: this.getInternalFormat(),
      textureFormat: this.getTextureFormat(),
      kernel: this,
    });
  }

  _setupSubOutputTextures() {
    const gl = this.context;
    if (this.mappedTextures) {
      for (let i = 0; i < this.subKernels.length; i++) {
        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + i + 1, gl.TEXTURE_2D, this.mappedTextures[i].texture, 0);
      }
      return;
    }
    const texSize = this.texSize;
    this.drawBuffersMap = [gl.COLOR_ATTACHMENT0];
    this.mappedTextures = [];
    for (let i = 0; i < this.subKernels.length; i++) {
      const texture = this.createTexture();
      this.drawBuffersMap.push(gl.COLOR_ATTACHMENT0 + i + 1);
      gl.activeTexture(gl.TEXTURE0 + this.constantTextureCount + this.argumentTextureCount + i);
      gl.bindTexture(gl.TEXTURE_2D, texture);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
      const format = this.getInternalFormat();
      if (this.precision === 'single') {
        gl.texStorage2D(gl.TEXTURE_2D, 1, format, texSize[0], texSize[1]);
      } else {
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, texSize[0], texSize[1], 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
      }
      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + i + 1, gl.TEXTURE_2D, texture, 0);

      this.mappedTextures.push(new this.TextureConstructor({
        texture,
        size: texSize,
        dimensions: this.threadDim,
        output: this.output,
        context: this.context,
        internalFormat: this.getInternalFormat(),
        textureFormat: this.getTextureFormat(),
        kernel: this,
      }));
    }
  }

  _getHeaderString() {
    return '';
  }

  _getTextureCoordinate() {
    const subKernels = this.subKernels;
    const variablePrecision = this.getVariablePrecisionString(this.texSize, this.tactic);
    if (subKernels === null || subKernels.length < 1) {
      return `in ${ variablePrecision } vec2 vTexCoord;\n`;
    } else {
      return `out ${ variablePrecision } vec2 vTexCoord;\n`;
    }
  }

  _getMainArgumentsString(args) {
    const result = [];
    const argumentNames = this.argumentNames;
    for (let i = 0; i < argumentNames.length; i++) {
      result.push(this.kernelArguments[i].getSource(args[i]));
    }
    return result.join('');
  }

  getKernelString() {
    const result = [this.getKernelResultDeclaration()];
    const subKernels = this.subKernels;
    if (subKernels !== null) {
      result.push(
        'layout(location = 0) out vec4 data0'
      );
      switch (this.returnType) {
        case 'Number':
        case 'Float':
        case 'Integer':
          for (let i = 0; i < subKernels.length; i++) {
            const subKernel = subKernels[i];
            result.push(
              subKernel.returnType === 'Integer' ?
              `int subKernelResult_${ subKernel.name } = 0` :
              `float subKernelResult_${ subKernel.name } = 0.0`,
              `layout(location = ${ i + 1 }) out vec4 data${ i + 1 }`
            );
          }
          break;
        case 'Array(2)':
          for (let i = 0; i < subKernels.length; i++) {
            result.push(
              `vec2 subKernelResult_${ subKernels[i].name }`,
              `layout(location = ${ i + 1 }) out vec4 data${ i + 1 }`
            );
          }
          break;
        case 'Array(3)':
          for (let i = 0; i < subKernels.length; i++) {
            result.push(
              `vec3 subKernelResult_${ subKernels[i].name }`,
              `layout(location = ${ i + 1 }) out vec4 data${ i + 1 }`
            );
          }
          break;
        case 'Array(4)':
          for (let i = 0; i < subKernels.length; i++) {
            result.push(
              `vec4 subKernelResult_${ subKernels[i].name }`,
              `layout(location = ${ i + 1 }) out vec4 data${ i + 1 }`
            );
          }
          break;
      }
    } else {
      result.push(
        'out vec4 data0'
      );
    }

    return utils.linesToString(result) + this.translatedSource;
  }

  getMainResultGraphical() {
    return utils.linesToString([
      '  threadId = indexTo3D(index, uOutputDim)',
      '  kernel()',
      '  data0 = actualColor',
    ]);
  }

  getMainResultPackedPixels() {
    switch (this.returnType) {
      case 'LiteralInteger':
      case 'Number':
      case 'Integer':
      case 'Float':
        return this.getMainResultKernelPackedPixels() +
          this.getMainResultSubKernelPackedPixels();
      default:
        throw new Error(`packed output only usable with Numbers, "${this.returnType}" specified`);
    }
  }

  getMainResultKernelPackedPixels() {
    return utils.linesToString([
      '  threadId = indexTo3D(index, uOutputDim)',
      '  kernel()',
      `  data0 = ${this.useLegacyEncoder ? 'legacyEncode32' : 'encode32'}(kernelResult)`
    ]);
  }

  getMainResultSubKernelPackedPixels() {
    const result = [];
    if (!this.subKernels) return '';
    for (let i = 0; i < this.subKernels.length; i++) {
      const subKernel = this.subKernels[i];
      if (subKernel.returnType === 'Integer') {
        result.push(
          `  data${i + 1} = ${this.useLegacyEncoder ? 'legacyEncode32' : 'encode32'}(float(subKernelResult_${this.subKernels[i].name}))`
        );
      } else {
        result.push(
          `  data${i + 1} = ${this.useLegacyEncoder ? 'legacyEncode32' : 'encode32'}(subKernelResult_${this.subKernels[i].name})`
        );
      }
    }
    return utils.linesToString(result);
  }

  getMainResultKernelMemoryOptimizedFloats(result, channel) {
    result.push(
      '  threadId = indexTo3D(index, uOutputDim)',
      '  kernel()',
      `  data0.${channel} = kernelResult`
    );
  }

  getMainResultSubKernelMemoryOptimizedFloats(result, channel) {
    if (!this.subKernels) return result;
    for (let i = 0; i < this.subKernels.length; i++) {
      const subKernel = this.subKernels[i];
      if (subKernel.returnType === 'Integer') {
        result.push(
          `  data${i + 1}.${channel} = float(subKernelResult_${subKernel.name})`
        );
      } else {
        result.push(
          `  data${i + 1}.${channel} = subKernelResult_${subKernel.name}`
        );
      }
    }
  }

  getMainResultKernelNumberTexture() {
    return [
      '  threadId = indexTo3D(index, uOutputDim)',
      '  kernel()',
      '  data0[0] = kernelResult',
    ];
  }

  getMainResultSubKernelNumberTexture() {
    const result = [];
    if (!this.subKernels) return result;
    for (let i = 0; i < this.subKernels.length; ++i) {
      const subKernel = this.subKernels[i];
      if (subKernel.returnType === 'Integer') {
        result.push(
          `  data${i + 1}[0] = float(subKernelResult_${subKernel.name})`
        );
      } else {
        result.push(
          `  data${i + 1}[0] = subKernelResult_${subKernel.name}`
        );
      }
    }
    return result;
  }

  getMainResultKernelArray2Texture() {
    return [
      '  threadId = indexTo3D(index, uOutputDim)',
      '  kernel()',
      '  data0[0] = kernelResult[0]',
      '  data0[1] = kernelResult[1]',
    ];
  }

  getMainResultSubKernelArray2Texture() {
    const result = [];
    if (!this.subKernels) return result;
    for (let i = 0; i < this.subKernels.length; ++i) {
      const subKernel = this.subKernels[i];
      result.push(
        `  data${i + 1}[0] = subKernelResult_${subKernel.name}[0]`,
        `  data${i + 1}[1] = subKernelResult_${subKernel.name}[1]`
      );
    }
    return result;
  }

  getMainResultKernelArray3Texture() {
    return [
      '  threadId = indexTo3D(index, uOutputDim)',
      '  kernel()',
      '  data0[0] = kernelResult[0]',
      '  data0[1] = kernelResult[1]',
      '  data0[2] = kernelResult[2]',
    ];
  }

  getMainResultSubKernelArray3Texture() {
    const result = [];
    if (!this.subKernels) return result;
    for (let i = 0; i < this.subKernels.length; ++i) {
      const subKernel = this.subKernels[i];
      result.push(
        `  data${i + 1}[0] = subKernelResult_${subKernel.name}[0]`,
        `  data${i + 1}[1] = subKernelResult_${subKernel.name}[1]`,
        `  data${i + 1}[2] = subKernelResult_${subKernel.name}[2]`
      );
    }
    return result;
  }

  getMainResultKernelArray4Texture() {
    return [
      '  threadId = indexTo3D(index, uOutputDim)',
      '  kernel()',
      '  data0 = kernelResult',
    ];
  }

  getMainResultSubKernelArray4Texture() {
    const result = [];
    if (!this.subKernels) return result;
    for (let i = 0; i < this.subKernels.length; ++i) {
      result.push(
        `  data${i + 1} = subKernelResult_${this.subKernels[i].name}`
      );
    }
    return result;
  }

  destroyExtensions() {
    this.extensions.EXT_color_buffer_float = null;
    this.extensions.OES_texture_float_linear = null;
  }

  toJSON() {
    const json = super.toJSON();
    json.functionNodes = FunctionBuilder.fromKernel(this, WebGL2FunctionNode).toJSON();
    json.settings.threadDim = this.threadDim;
    return json;
  }
}

module.exports = {
  WebGL2Kernel
};
},{"../../utils":114,"../function-builder":9,"../web-gl/kernel":70,"./fragment-shader":72,"./function-node":73,"./kernel-value-maps":74,"./vertex-shader":106}],106:[function(require,module,exports){
const vertexShader = `#version 300 es
__FLOAT_TACTIC_DECLARATION__;
__INT_TACTIC_DECLARATION__;
__SAMPLER_2D_TACTIC_DECLARATION__;

in vec2 aPos;
in vec2 aTexCoord;

out vec2 vTexCoord;
uniform vec2 ratio;

void main(void) {
  gl_Position = vec4((aPos + vec2(1)) * ratio + vec2(-1), 0, 1);
  vTexCoord = aTexCoord;
}`;

module.exports = {
  vertexShader
};
},{}],107:[function(require,module,exports){
const lib = require('./index');
const GPU = lib.GPU;
for (const p in lib) {
  if (!lib.hasOwnProperty(p)) continue;
  if (p === 'GPU') continue; 
  GPU[p] = lib[p];
}

if (typeof window !== 'undefined') {
  bindTo(window);
}
if (typeof self !== 'undefined') {
  bindTo(self);
}

function bindTo(target) {
  if (target.GPU) return;
  Object.defineProperty(target, 'GPU', {
    get() {
      return GPU;
    }
  });
}

module.exports = lib;
},{"./index":109}],108:[function(require,module,exports){
const { gpuMock } = require('gpu-mock.js');
const { utils } = require('./utils');
const { Kernel } = require('./backend/kernel');
const { CPUKernel } = require('./backend/cpu/kernel');
const { HeadlessGLKernel } = require('./backend/headless-gl/kernel');
const { WebGL2Kernel } = require('./backend/web-gl2/kernel');
const { WebGLKernel } = require('./backend/web-gl/kernel');
const { kernelRunShortcut } = require('./kernel-run-shortcut');


const kernelOrder = [HeadlessGLKernel, WebGL2Kernel, WebGLKernel];

const kernelTypes = ['gpu', 'cpu'];

const internalKernels = {
  'headlessgl': HeadlessGLKernel,
  'webgl2': WebGL2Kernel,
  'webgl': WebGLKernel,
};

let validate = true;

class GPU {
  static disableValidation() {
    validate = false;
  }

  static enableValidation() {
    validate = true;
  }

  static get isGPUSupported() {
    return kernelOrder.some(Kernel => Kernel.isSupported);
  }

  static get isKernelMapSupported() {
    return kernelOrder.some(Kernel => Kernel.isSupported && Kernel.features.kernelMap);
  }

  static get isOffscreenCanvasSupported() {
    return (typeof Worker !== 'undefined' && typeof OffscreenCanvas !== 'undefined') || typeof importScripts !== 'undefined';
  }

  static get isWebGLSupported() {
    return WebGLKernel.isSupported;
  }

  static get isWebGL2Supported() {
    return WebGL2Kernel.isSupported;
  }

  static get isHeadlessGLSupported() {
    return HeadlessGLKernel.isSupported;
  }

  static get isCanvasSupported() {
    return typeof HTMLCanvasElement !== 'undefined';
  }

  static get isGPUHTMLImageArraySupported() {
    return WebGL2Kernel.isSupported;
  }

  static get isSinglePrecisionSupported() {
    return kernelOrder.some(Kernel => Kernel.isSupported && Kernel.features.isFloatRead && Kernel.features.isTextureFloat);
  }

  constructor(settings) {
    settings = settings || {};
    this.canvas = settings.canvas || null;
    this.context = settings.context || null;
    this.mode = settings.mode;
    this.Kernel = null;
    this.kernels = [];
    this.functions = [];
    this.nativeFunctions = [];
    this.injectedNative = null;
    if (this.mode === 'dev') return;
    this.chooseKernel();
    if (settings.functions) {
      for (let i = 0; i < settings.functions.length; i++) {
        this.addFunction(settings.functions[i]);
      }
    }

    if (settings.nativeFunctions) {
      for (const p in settings.nativeFunctions) {
        if (!settings.nativeFunctions.hasOwnProperty(p)) continue;
        const s = settings.nativeFunctions[p];
        const { name, source } = s;
        this.addNativeFunction(name, source, s);
      }
    }
  }

  chooseKernel() {
    if (this.Kernel) return;

    let Kernel = null;

    if (this.context) {
      for (let i = 0; i < kernelOrder.length; i++) {
        const ExternalKernel = kernelOrder[i];
        if (ExternalKernel.isContextMatch(this.context)) {
          if (!ExternalKernel.isSupported) {
            throw new Error(`Kernel type ${ExternalKernel.name} not supported`);
          }
          Kernel = ExternalKernel;
          break;
        }
      }
      if (Kernel === null) {
        throw new Error('unknown Context');
      }
    } else if (this.mode) {
      if (this.mode in internalKernels) {
        if (!validate || internalKernels[this.mode].isSupported) {
          Kernel = internalKernels[this.mode];
        }
      } else if (this.mode === 'gpu') {
        for (let i = 0; i < kernelOrder.length; i++) {
          if (kernelOrder[i].isSupported) {
            Kernel = kernelOrder[i];
            break;
          }
        }
      } else if (this.mode === 'cpu') {
        Kernel = CPUKernel;
      }
      if (!Kernel) {
        throw new Error(`A requested mode of "${this.mode}" and is not supported`);
      }
    } else {
      for (let i = 0; i < kernelOrder.length; i++) {
        if (kernelOrder[i].isSupported) {
          Kernel = kernelOrder[i];
          break;
        }
      }
      if (!Kernel) {
        Kernel = CPUKernel;
      }
    }

    if (!this.mode) {
      this.mode = Kernel.mode;
    }
    this.Kernel = Kernel;
  }

  createKernel(source, settings) {
    if (typeof source === 'undefined') {
      throw new Error('Missing source parameter');
    }
    if (typeof source !== 'object' && !utils.isFunction(source) && typeof source !== 'string') {
      throw new Error('source parameter not a function');
    }

    const kernels = this.kernels;
    if (this.mode === 'dev') {
      const devKernel = gpuMock(source, upgradeDeprecatedCreateKernelSettings(settings));
      kernels.push(devKernel);
      return devKernel;
    }

    source = typeof source === 'function' ? source.toString() : source;
    const switchableKernels = {};
    const settingsCopy = upgradeDeprecatedCreateKernelSettings(settings) || {};
    if (settings && typeof settings.argumentTypes === 'object') {
      settingsCopy.argumentTypes = Object.keys(settings.argumentTypes).map(argumentName => settings.argumentTypes[argumentName]);
    }

    function onRequestFallback(args) {
      console.warn('Falling back to CPU');
      const fallbackKernel = new CPUKernel(source, {
        argumentTypes: kernelRun.argumentTypes,
        constantTypes: kernelRun.constantTypes,
        graphical: kernelRun.graphical,
        loopMaxIterations: kernelRun.loopMaxIterations,
        constants: kernelRun.constants,
        dynamicOutput: kernelRun.dynamicOutput,
        dynamicArgument: kernelRun.dynamicArguments,
        output: kernelRun.output,
        precision: kernelRun.precision,
        pipeline: kernelRun.pipeline,
        immutable: kernelRun.immutable,
        optimizeFloatMemory: kernelRun.optimizeFloatMemory,
        fixIntegerDivisionAccuracy: kernelRun.fixIntegerDivisionAccuracy,
        functions: kernelRun.functions,
        nativeFunctions: kernelRun.nativeFunctions,
        injectedNative: kernelRun.injectedNative,
        subKernels: kernelRun.subKernels,
        strictIntegers: kernelRun.strictIntegers,
        debug: kernelRun.debug,
      });
      fallbackKernel.build.apply(fallbackKernel, args);
      const result = fallbackKernel.run.apply(fallbackKernel, args);
      kernelRun.replaceKernel(fallbackKernel);
      return result;
    }

    function onRequestSwitchKernel(reasons, args, _kernel) {
      if (_kernel.debug) {
        console.warn('Switching kernels');
      }
      let newOutput = null;
      if (_kernel.signature && !switchableKernels[_kernel.signature]) {
        switchableKernels[_kernel.signature] = _kernel;
      }
      if (_kernel.dynamicOutput) {
        for (let i = reasons.length - 1; i >= 0; i--) {
          const reason = reasons[i];
          if (reason.type === 'outputPrecisionMismatch') {
            newOutput = reason.needed;
          }
        }
      }

      const Constructor = _kernel.constructor;
      const argumentTypes = Constructor.getArgumentTypes(_kernel, args);
      const signature = Constructor.getSignature(_kernel, argumentTypes);
      const existingKernel = switchableKernels[signature];
      if (existingKernel) {
        existingKernel.onActivate(_kernel);
        return existingKernel;
      }

      const newKernel = switchableKernels[signature] = new Constructor(source, {
        argumentTypes,
        constantTypes: _kernel.constantTypes,
        graphical: _kernel.graphical,
        loopMaxIterations: _kernel.loopMaxIterations,
        constants: _kernel.constants,
        dynamicOutput: _kernel.dynamicOutput,
        dynamicArgument: _kernel.dynamicArguments,
        context: _kernel.context,
        canvas: _kernel.canvas,
        output: newOutput || _kernel.output,
        precision: _kernel.precision,
        pipeline: _kernel.pipeline,
        immutable: _kernel.immutable,
        optimizeFloatMemory: _kernel.optimizeFloatMemory,
        fixIntegerDivisionAccuracy: _kernel.fixIntegerDivisionAccuracy,
        functions: _kernel.functions,
        nativeFunctions: _kernel.nativeFunctions,
        injectedNative: _kernel.injectedNative,
        subKernels: _kernel.subKernels,
        strictIntegers: _kernel.strictIntegers,
        debug: _kernel.debug,
        gpu: _kernel.gpu,
        validate,
        returnType: _kernel.returnType,
        tactic: _kernel.tactic,
        onRequestFallback,
        onRequestSwitchKernel,
        texture: _kernel.texture,
        mappedTextures: _kernel.mappedTextures,
        drawBuffersMap: _kernel.drawBuffersMap,
      });
      newKernel.build.apply(newKernel, args);
      kernelRun.replaceKernel(newKernel);
      kernels.push(newKernel);
      return newKernel;
    }
    const mergedSettings = Object.assign({
      context: this.context,
      canvas: this.canvas,
      functions: this.functions,
      nativeFunctions: this.nativeFunctions,
      injectedNative: this.injectedNative,
      gpu: this,
      validate,
      onRequestFallback,
      onRequestSwitchKernel
    }, settingsCopy);

    const kernel = new this.Kernel(source, mergedSettings);
    const kernelRun = kernelRunShortcut(kernel);

    if (!this.canvas) {
      this.canvas = kernel.canvas;
    }

    if (!this.context) {
      this.context = kernel.context;
    }

    kernels.push(kernel);

    return kernelRun;
  }

  createKernelMap() {
    let fn;
    let settings;
    const argument2Type = typeof arguments[arguments.length - 2];
    if (argument2Type === 'function' || argument2Type === 'string') {
      fn = arguments[arguments.length - 2];
      settings = arguments[arguments.length - 1];
    } else {
      fn = arguments[arguments.length - 1];
    }

    if (this.mode !== 'dev') {
      if (!this.Kernel.isSupported || !this.Kernel.features.kernelMap) {
        if (this.mode && kernelTypes.indexOf(this.mode) < 0) {
          throw new Error(`kernelMap not supported on ${this.Kernel.name}`);
        }
      }
    }

    const settingsCopy = upgradeDeprecatedCreateKernelSettings(settings);
    if (settings && typeof settings.argumentTypes === 'object') {
      settingsCopy.argumentTypes = Object.keys(settings.argumentTypes).map(argumentName => settings.argumentTypes[argumentName]);
    }

    if (Array.isArray(arguments[0])) {
      settingsCopy.subKernels = [];
      const functions = arguments[0];
      for (let i = 0; i < functions.length; i++) {
        const source = functions[i].toString();
        const name = utils.getFunctionNameFromString(source);
        settingsCopy.subKernels.push({
          name,
          source,
          property: i,
        });
      }
    } else {
      settingsCopy.subKernels = [];
      const functions = arguments[0];
      for (let p in functions) {
        if (!functions.hasOwnProperty(p)) continue;
        const source = functions[p].toString();
        const name = utils.getFunctionNameFromString(source);
        settingsCopy.subKernels.push({
          name: name || p,
          source,
          property: p,
        });
      }
    }
    return this.createKernel(fn, settingsCopy);
  }

  combineKernels() {
    const firstKernel = arguments[0];
    const combinedKernel = arguments[arguments.length - 1];
    if (firstKernel.kernel.constructor.mode === 'cpu') return combinedKernel;
    const canvas = arguments[0].canvas;
    const context = arguments[0].context;
    const max = arguments.length - 1;
    for (let i = 0; i < max; i++) {
      arguments[i]
        .setCanvas(canvas)
        .setContext(context)
        .setPipeline(true);
    }

    return function() {
      const texture = combinedKernel.apply(this, arguments);
      if (texture.toArray) {
        return texture.toArray();
      }
      return texture;
    };
  }

  setFunctions(functions) {
    this.functions = functions;
    return this;
  }

  setNativeFunctions(nativeFunctions) {
    this.nativeFunctions = nativeFunctions;
    return this;
  }

  addFunction(source, settings) {
    this.functions.push({ source, settings });
    return this;
  }

  addNativeFunction(name, source, settings) {
    if (this.kernels.length > 0) {
      throw new Error('Cannot call "addNativeFunction" after "createKernels" has been called.');
    }
    this.nativeFunctions.push(Object.assign({ name, source }, settings));
    return this;
  }

  injectNative(source) {
    this.injectedNative = source;
    return this;
  }

  destroy() {
    return new Promise((resolve, reject) => {
      if (!this.kernels) {
        resolve();
      }
      setTimeout(() => {
        try {
          for (let i = 0; i < this.kernels.length; i++) {
            this.kernels[i].destroy(true); 
          }
          let firstKernel = this.kernels[0];
          if (firstKernel) {
            if (firstKernel.kernel) {
              firstKernel = firstKernel.kernel;
            }
            if (firstKernel.constructor.destroyContext) {
              firstKernel.constructor.destroyContext(this.context);
            }
          }
        } catch (e) {
          reject(e);
        }
        resolve();
      }, 0);
    });
  }
}


function upgradeDeprecatedCreateKernelSettings(settings) {
  if (!settings) {
    return {};
  }
  const upgradedSettings = Object.assign({}, settings);

  if (settings.hasOwnProperty('floatOutput')) {
    utils.warnDeprecated('setting', 'floatOutput', 'precision');
    upgradedSettings.precision = settings.floatOutput ? 'single' : 'unsigned';
  }
  if (settings.hasOwnProperty('outputToTexture')) {
    utils.warnDeprecated('setting', 'outputToTexture', 'pipeline');
    upgradedSettings.pipeline = Boolean(settings.outputToTexture);
  }
  if (settings.hasOwnProperty('outputImmutable')) {
    utils.warnDeprecated('setting', 'outputImmutable', 'immutable');
    upgradedSettings.immutable = Boolean(settings.outputImmutable);
  }
  if (settings.hasOwnProperty('floatTextures')) {
    utils.warnDeprecated('setting', 'floatTextures', 'optimizeFloatMemory');
    upgradedSettings.optimizeFloatMemory = Boolean(settings.floatTextures);
  }
  return upgradedSettings;
}

module.exports = {
  GPU,
  kernelOrder,
  kernelTypes
};
},{"./backend/cpu/kernel":8,"./backend/headless-gl/kernel":34,"./backend/kernel":36,"./backend/web-gl/kernel":70,"./backend/web-gl2/kernel":105,"./kernel-run-shortcut":111,"./utils":114,"gpu-mock.js":4}],109:[function(require,module,exports){
const { GPU } = require('./gpu');
const { alias } = require('./alias');
const { utils } = require('./utils');
const { Input, input } = require('./input');
const { Texture } = require('./texture');
const { FunctionBuilder } = require('./backend/function-builder');
const { FunctionNode } = require('./backend/function-node');
const { CPUFunctionNode } = require('./backend/cpu/function-node');
const { CPUKernel } = require('./backend/cpu/kernel');

const { HeadlessGLKernel } = require('./backend/headless-gl/kernel');

const { WebGLFunctionNode } = require('./backend/web-gl/function-node');
const { WebGLKernel } = require('./backend/web-gl/kernel');
const { kernelValueMaps: webGLKernelValueMaps } = require('./backend/web-gl/kernel-value-maps');

const { WebGL2FunctionNode } = require('./backend/web-gl2/function-node');
const { WebGL2Kernel } = require('./backend/web-gl2/kernel');
const { kernelValueMaps: webGL2KernelValueMaps } = require('./backend/web-gl2/kernel-value-maps');

const { GLKernel } = require('./backend/gl/kernel');

const { Kernel } = require('./backend/kernel');

const { FunctionTracer } = require('./backend/function-tracer');

const mathRandom = require('./plugins/math-random-uniformly-distributed');

module.exports = {
  alias,
  CPUFunctionNode,
  CPUKernel,
  GPU,
  FunctionBuilder,
  FunctionNode,
  HeadlessGLKernel,
  Input,
  input,
  Texture,
  utils,

  WebGL2FunctionNode,
  WebGL2Kernel,
  webGL2KernelValueMaps,

  WebGLFunctionNode,
  WebGLKernel,
  webGLKernelValueMaps,

  GLKernel,
  Kernel,
  FunctionTracer,

  plugins: {
    mathRandom
  }
};
},{"./alias":5,"./backend/cpu/function-node":6,"./backend/cpu/kernel":8,"./backend/function-builder":9,"./backend/function-node":10,"./backend/function-tracer":11,"./backend/gl/kernel":13,"./backend/headless-gl/kernel":34,"./backend/kernel":36,"./backend/web-gl/function-node":38,"./backend/web-gl/kernel":70,"./backend/web-gl/kernel-value-maps":39,"./backend/web-gl2/function-node":73,"./backend/web-gl2/kernel":105,"./backend/web-gl2/kernel-value-maps":74,"./gpu":108,"./input":110,"./plugins/math-random-uniformly-distributed":112,"./texture":113,"./utils":114}],110:[function(require,module,exports){
class Input {
  constructor(value, size) {
    this.value = value;
    if (Array.isArray(size)) {
      this.size = size;
    } else {
      this.size = new Int32Array(3);
      if (size.z) {
        this.size = new Int32Array([size.x, size.y, size.z]);
      } else if (size.y) {
        this.size = new Int32Array([size.x, size.y]);
      } else {
        this.size = new Int32Array([size.x]);
      }
    }

    const [w, h, d] = this.size;
    if (d) {
      if (this.value.length !== (w * h * d)) {
        throw new Error(`Input size ${this.value.length} does not match ${w} * ${h} * ${d} = ${(h * w * d)}`);
      }
    } else if (h) {
      if (this.value.length !== (w * h)) {
        throw new Error(`Input size ${this.value.length} does not match ${w} * ${h} = ${(h * w)}`);
      }
    } else {
      if (this.value.length !== w) {
        throw new Error(`Input size ${this.value.length} does not match ${w}`);
      }
    }

  }

  toArray() {
    const { utils } = require('./utils');
    const [w, h, d] = this.size;
    if (d) {
      return utils.erectMemoryOptimized3DFloat(this.value.subarray ? this.value : new Float32Array(this.value), w, h, d);
    } else if (h) {
      return utils.erectMemoryOptimized2DFloat(this.value.subarray ? this.value : new Float32Array(this.value), w, h);
    } else {
      return this.value;
    }
  }
}

function input(value, size) {
  return new Input(value, size);
}

module.exports = {
  Input,
  input
};
},{"./utils":114}],111:[function(require,module,exports){
const { utils } = require('./utils');

function kernelRunShortcut(kernel) {
  let run = function() {
    kernel.build.apply(kernel, arguments);
    run = function() {
      let result = kernel.run.apply(kernel, arguments);
      if (kernel.switchingKernels) {
        const reasons = kernel.resetSwitchingKernels();
        const newKernel = kernel.onRequestSwitchKernel(reasons, arguments, kernel);
        shortcut.kernel = kernel = newKernel;
        result = newKernel.run.apply(newKernel, arguments);
      }
      if (kernel.renderKernels) {
        return kernel.renderKernels();
      } else if (kernel.renderOutput) {
        return kernel.renderOutput();
      } else {
        return result;
      }
    };
    return run.apply(kernel, arguments);
  };
  const shortcut = function() {
    return run.apply(kernel, arguments);
  };
  shortcut.exec = function() {
    return new Promise((accept, reject) => {
      try {
        accept(run.apply(this, arguments));
      } catch (e) {
        reject(e);
      }
    });
  };
  shortcut.replaceKernel = function(replacementKernel) {
    kernel = replacementKernel;
    bindKernelToShortcut(kernel, shortcut);
  };

  bindKernelToShortcut(kernel, shortcut);
  return shortcut;
}

function bindKernelToShortcut(kernel, shortcut) {
  if (shortcut.kernel) {
    shortcut.kernel = kernel;
    return;
  }
  const properties = utils.allPropertiesOf(kernel);
  for (let i = 0; i < properties.length; i++) {
    const property = properties[i];
    if (property[0] === '_' && property[1] === '_') continue;
    if (typeof kernel[property] === 'function') {
      if (property.substring(0, 3) === 'add' || property.substring(0, 3) === 'set') {
        shortcut[property] = function() {
          shortcut.kernel[property].apply(shortcut.kernel, arguments);
          return shortcut;
        };
      } else {
        shortcut[property] = function() {
          return shortcut.kernel[property].apply(shortcut.kernel, arguments);
        };
      }
    } else {
      shortcut.__defineGetter__(property, () => shortcut.kernel[property]);
      shortcut.__defineSetter__(property, (value) => {
        shortcut.kernel[property] = value;
      });
    }
  }
  shortcut.kernel = kernel;
}
module.exports = {
  kernelRunShortcut
};
},{"./utils":114}],112:[function(require,module,exports){
const source = `// https://www.shadertoy.com/view/4t2SDh
//note: uniformly distributed, normalized rand, [0,1]
highp float randomSeedShift = 1.0;
highp float slide = 1.0;
uniform highp float randomSeed1;
uniform highp float randomSeed2;

highp float nrand(highp vec2 n) {
  highp float result = fract(sin(dot((n.xy + 1.0) * vec2(randomSeed1 * slide, randomSeed2 * randomSeedShift), vec2(12.9898, 78.233))) * 43758.5453);
  randomSeedShift = result;
  if (randomSeedShift > 0.5) {
    slide += 0.00009; 
  } else {
    slide += 0.0009;
  }
  return result;
}`;

const name = 'math-random-uniformly-distributed';

const functionMatch = `Math.random()`;

const functionReplace = `nrand(vTexCoord)`;

const functionReturnType = 'Number';
const onBeforeRun = (kernel) => {
  kernel.setUniform1f('randomSeed1', Math.random());
  kernel.setUniform1f('randomSeed2', Math.random());
};

const plugin = {
  name,
  onBeforeRun,
  functionMatch,
  functionReplace,
  functionReturnType,
  source
};

module.exports = plugin;
},{}],113:[function(require,module,exports){
class Texture {
  constructor(settings) {
    const {
      texture,
      size,
      dimensions,
      output,
      context,
      type = 'NumberTexture',
      kernel,
      internalFormat,
      textureFormat
    } = settings;
    if (!output) throw new Error('settings property "output" required.');
    if (!context) throw new Error('settings property "context" required.');
    if (!texture) throw new Error('settings property "texture" required.');
    if (!kernel) throw new Error('settings property "kernel" required.');
    this.texture = texture;
    if (texture._refs) {
      texture._refs++;
    } else {
      texture._refs = 1;
    }
    this.size = size;
    this.dimensions = dimensions;
    this.output = output;
    this.context = context;
    this.kernel = kernel;
    this.type = type;
    this._deleted = false;
    this.internalFormat = internalFormat;
    this.textureFormat = textureFormat;
  }

  toArray() {
    throw new Error(`Not implemented on ${this.constructor.name}`);
  }

  clone() {
    throw new Error(`Not implemented on ${this.constructor.name}`);
  }

  delete() {
    throw new Error(`Not implemented on ${this.constructor.name}`);
  }

  clear() {
    throw new Error(`Not implemented on ${this.constructor.name}`);
  }
}

module.exports = {
  Texture
};
},{}],114:[function(require,module,exports){
const acorn = require('acorn');
const { Input } = require('./input');
const { Texture } = require('./texture');

const FUNCTION_NAME = /function ([^(]*)/;
const STRIP_COMMENTS = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/mg;
const ARGUMENT_NAMES = /([^\s,]+)/g;

const utils = {
  systemEndianness() {
    return _systemEndianness;
  },
  getSystemEndianness() {
    const b = new ArrayBuffer(4);
    const a = new Uint32Array(b);
    const c = new Uint8Array(b);
    a[0] = 0xdeadbeef;
    if (c[0] === 0xef) return 'LE';
    if (c[0] === 0xde) return 'BE';
    throw new Error('unknown endianness');
  },

  isFunction(funcObj) {
    return typeof(funcObj) === 'function';
  },

  isFunctionString(fn) {
    if (typeof fn === 'string') {
      return (fn
        .slice(0, 'function'.length)
        .toLowerCase() === 'function');
    }
    return false;
  },

  getFunctionNameFromString(funcStr) {
    const result = FUNCTION_NAME.exec(funcStr);
    if (!result || result.length === 0) return null;
    return result[1].trim();
  },

  getFunctionBodyFromString(funcStr) {
    return funcStr.substring(funcStr.indexOf('{') + 1, funcStr.lastIndexOf('}'));
  },

  getArgumentNamesFromString(fn) {
    const fnStr = fn.replace(STRIP_COMMENTS, '');
    let result = fnStr.slice(fnStr.indexOf('(') + 1, fnStr.indexOf(')')).match(ARGUMENT_NAMES);
    if (result === null) {
      result = [];
    }
    return result;
  },

  clone(obj) {
    if (obj === null || typeof obj !== 'object' || obj.hasOwnProperty('isActiveClone')) return obj;

    const temp = obj.constructor(); 

    for (let key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        obj.isActiveClone = null;
        temp[key] = utils.clone(obj[key]);
        delete obj.isActiveClone;
      }
    }

    return temp;
  },

  isArray(array) {
    return !isNaN(array.length);
  },

  getVariableType(value, strictIntegers) {
    if (utils.isArray(value)) {
      if (value.length > 0 && value[0].nodeName === 'IMG') {
        return 'HTMLImageArray';
      }
      return 'Array';
    }

    switch (value.constructor) {
      case Boolean:
        return 'Boolean';
      case Number:
        if (strictIntegers && Number.isInteger(value)) {
          return 'Integer';
        }
        return 'Float';
      case Texture:
        return value.type;
      case Input:
        return 'Input';
    }
    switch (value.nodeName) {
      case 'IMG':
        return 'HTMLImage';
      case 'CANVAS':
        return 'HTMLImage';
      case 'VIDEO':
        return 'HTMLVideo';
    }
    if (value.hasOwnProperty('type')) {
      return value.type;
    }
    return 'Unknown';
  },

  getKernelTextureSize(settings, dimensions) {
    let [w, h, d] = dimensions;
    let texelCount = (w || 1) * (h || 1) * (d || 1);

    if (settings.optimizeFloatMemory && settings.precision === 'single') {
      w = texelCount = Math.ceil(texelCount / 4);
    }
    if (h > 1 && w * h === texelCount) {
      return new Int32Array([w, h]);
    }
    return utils.closestSquareDimensions(texelCount);
  },

  closestSquareDimensions(length) {
    const sqrt = Math.sqrt(length);
    let high = Math.ceil(sqrt);
    let low = Math.floor(sqrt);
    while (high * low < length) {
      high--;
      low = Math.ceil(length / high);
    }
    return new Int32Array([low, Math.ceil(length / low)]);
  },

  getMemoryOptimizedFloatTextureSize(dimensions, bitRatio) {
    const totalArea = utils.roundTo((dimensions[0] || 1) * (dimensions[1] || 1) * (dimensions[2] || 1) * (dimensions[3] || 1), 4);
    const texelCount = totalArea / bitRatio;
    return utils.closestSquareDimensions(texelCount);
  },

  getMemoryOptimizedPackedTextureSize(dimensions, bitRatio) {
    const [w, h, d] = dimensions;
    const totalArea = utils.roundTo((w || 1) * (h || 1) * (d || 1), 4);
    const texelCount = totalArea / (4 / bitRatio);
    return utils.closestSquareDimensions(texelCount);
  },

  roundTo(n, d) {
    return Math.floor((n + d - 1) / d) * d;
  },
  getDimensions(x, pad) {
    let ret;
    if (utils.isArray(x)) {
      const dim = [];
      let temp = x;
      while (utils.isArray(temp)) {
        dim.push(temp.length);
        temp = temp[0];
      }
      ret = dim.reverse();
    } else if (x instanceof Texture) {
      ret = x.output;
    } else if (x instanceof Input) {
      ret = x.size;
    } else {
      throw new Error(`Unknown dimensions of ${x}`);
    }

    if (pad) {
      ret = Array.from(ret);
      while (ret.length < 3) {
        ret.push(1);
      }
    }

    return new Int32Array(ret);
  },

  flatten2dArrayTo(array, target) {
    let offset = 0;
    for (let y = 0; y < array.length; y++) {
      target.set(array[y], offset);
      offset += array[y].length;
    }
  },

  flatten3dArrayTo(array, target) {
    let offset = 0;
    for (let z = 0; z < array.length; z++) {
      for (let y = 0; y < array[z].length; y++) {
        target.set(array[z][y], offset);
        offset += array[z][y].length;
      }
    }
  },

  flatten4dArrayTo(array, target) {
    let offset = 0;
    for (let l = 0; l < array.length; l++) {
      for (let z = 0; z < array[l].length; z++) {
        for (let y = 0; y < array[l][z].length; y++) {
          target.set(array[l][z][y], offset);
          offset += array[l][z][y].length;
        }
      }
    }
  },

  flattenTo(array, target) {
    if (utils.isArray(array[0])) {
      if (utils.isArray(array[0][0])) {
        if (utils.isArray(array[0][0][0])) {
          utils.flatten4dArrayTo(array, target);
        } else {
          utils.flatten3dArrayTo(array, target);
        }
      } else {
        utils.flatten2dArrayTo(array, target);
      }
    } else {
      target.set(array);
    }
  },

  splitArray(array, part) {
    const result = [];
    for (let i = 0; i < array.length; i += part) {
      result.push(new array.constructor(array.buffer, i * 4 + array.byteOffset, part));
    }
    return result;
  },

  getAstString(source, ast) {
    const lines = Array.isArray(source) ? source : source.split(/\r?\n/g);
    const start = ast.loc.start;
    const end = ast.loc.end;
    const result = [];
    if (start.line === end.line) {
      result.push(lines[start.line - 1].substring(start.column, end.column));
    } else {
      result.push(lines[start.line - 1].slice(start.column));
      for (let i = start.line; i < end.line; i++) {
        result.push(lines[i]);
      }
      result.push(lines[end.line - 1].slice(0, end.column));
    }
    return result.join('\n');
  },

  allPropertiesOf(obj) {
    const props = [];

    do {
      props.push.apply(props, Object.getOwnPropertyNames(obj));
    } while (obj = Object.getPrototypeOf(obj));

    return props;
  },

  linesToString(lines) {
    if (lines.length > 0) {
      return lines.join(';\n') + ';\n';
    } else {
      return '\n';
    }
  },
  warnDeprecated(type, oldName, newName) {
    if (newName) {
      console.warn(`You are using a deprecated ${ type } "${ oldName }". It has been replaced with "${ newName }". Fixing, but please upgrade as it will soon be removed.`);
    } else {
      console.warn(`You are using a deprecated ${ type } "${ oldName }". It has been removed. Fixing, but please upgrade as it will soon be removed.`);
    }
  },
  flipPixels: (pixels, width, height) => {
    const halfHeight = height / 2 | 0; 
    const bytesPerRow = width * 4;
    const temp = new Uint8ClampedArray(width * 4);
    const result = pixels.slice(0);
    for (let y = 0; y < halfHeight; ++y) {
      const topOffset = y * bytesPerRow;
      const bottomOffset = (height - y - 1) * bytesPerRow;

      temp.set(result.subarray(topOffset, topOffset + bytesPerRow));

      result.copyWithin(topOffset, bottomOffset, bottomOffset + bytesPerRow);

      result.set(temp, bottomOffset);
    }
    return result;
  },
  erectPackedFloat: (array, width) => {
    return array.subarray(0, width);
  },
  erect2DPackedFloat: (array, width, height) => {
    const yResults = new Array(height);
    for (let y = 0; y < height; y++) {
      const xStart = y * width;
      const xEnd = xStart + width;
      yResults[y] = array.subarray(xStart, xEnd);
    }
    return yResults;
  },
  erect3DPackedFloat: (array, width, height, depth) => {
    const zResults = new Array(depth);
    for (let z = 0; z < depth; z++) {
      const yResults = new Array(height);
      for (let y = 0; y < height; y++) {
        const xStart = (z * height * width) + y * width;
        const xEnd = xStart + width;
        yResults[y] = array.subarray(xStart, xEnd);
      }
      zResults[z] = yResults;
    }
    return zResults;
  },
  erectMemoryOptimizedFloat: (array, width) => {
    return array.subarray(0, width);
  },
  erectMemoryOptimized2DFloat: (array, width, height) => {
    const yResults = new Array(height);
    for (let y = 0; y < height; y++) {
      const offset = y * width;
      yResults[y] = array.subarray(offset, offset + width);
    }
    return yResults;
  },
  erectMemoryOptimized3DFloat: (array, width, height, depth) => {
    const zResults = new Array(depth);
    for (let z = 0; z < depth; z++) {
      const yResults = new Array(height);
      for (let y = 0; y < height; y++) {
        const offset = (z * height * width) + (y * width);
        yResults[y] = array.subarray(offset, offset + width);
      }
      zResults[z] = yResults;
    }
    return zResults;
  },
  erectFloat: (array, width) => {
    const xResults = new Float32Array(width);
    let i = 0;
    for (let x = 0; x < width; x++) {
      xResults[x] = array[i];
      i += 4;
    }
    return xResults;
  },
  erect2DFloat: (array, width, height) => {
    const yResults = new Array(height);
    let i = 0;
    for (let y = 0; y < height; y++) {
      const xResults = new Float32Array(width);
      for (let x = 0; x < width; x++) {
        xResults[x] = array[i];
        i += 4;
      }
      yResults[y] = xResults;
    }
    return yResults;
  },
  erect3DFloat: (array, width, height, depth) => {
    const zResults = new Array(depth);
    let i = 0;
    for (let z = 0; z < depth; z++) {
      const yResults = new Array(height);
      for (let y = 0; y < height; y++) {
        const xResults = new Float32Array(width);
        for (let x = 0; x < width; x++) {
          xResults[x] = array[i];
          i += 4;
        }
        yResults[y] = xResults;
      }
      zResults[z] = yResults;
    }
    return zResults;
  },
  erectArray2: (array, width) => {
    const xResults = new Array(width);
    const xResultsMax = width * 4;
    let i = 0;
    for (let x = 0; x < xResultsMax; x += 4) {
      xResults[i++] = array.subarray(x, x + 2);
    }
    return xResults;
  },
  erect2DArray2: (array, width, height) => {
    const yResults = new Array(height);
    const XResultsMax = width * 4;
    for (let y = 0; y < height; y++) {
      const xResults = new Array(width);
      const offset = y * XResultsMax;
      let i = 0;
      for (let x = 0; x < XResultsMax; x += 4) {
        xResults[i++] = array.subarray(x + offset, x + offset + 2);
      }
      yResults[y] = xResults;
    }
    return yResults;
  },
  erect3DArray2: (array, width, height, depth) => {
    const xResultsMax = width * 4;
    const zResults = new Array(depth);
    for (let z = 0; z < depth; z++) {
      const yResults = new Array(height);
      for (let y = 0; y < height; y++) {
        const xResults = new Array(width);
        const offset = (z * xResultsMax * height) + (y * xResultsMax);
        let i = 0;
        for (let x = 0; x < xResultsMax; x += 4) {
          xResults[i++] = array.subarray(x + offset, x + offset + 2);
        }
        yResults[y] = xResults;
      }
      zResults[z] = yResults;
    }
    return zResults;
  },
  erectArray3: (array, width) => {
    const xResults = new Array(width);
    const xResultsMax = width * 4;
    let i = 0;
    for (let x = 0; x < xResultsMax; x += 4) {
      xResults[i++] = array.subarray(x, x + 3);
    }
    return xResults;
  },
  erect2DArray3: (array, width, height) => {
    const xResultsMax = width * 4;
    const yResults = new Array(height);
    for (let y = 0; y < height; y++) {
      const xResults = new Array(width);
      const offset = y * xResultsMax;
      let i = 0;
      for (let x = 0; x < xResultsMax; x += 4) {
        xResults[i++] = array.subarray(x + offset, x + offset + 3);
      }
      yResults[y] = xResults;
    }
    return yResults;
  },
  erect3DArray3: (array, width, height, depth) => {
    const xResultsMax = width * 4;
    const zResults = new Array(depth);
    for (let z = 0; z < depth; z++) {
      const yResults = new Array(height);
      for (let y = 0; y < height; y++) {
        const xResults = new Array(width);
        const offset = (z * xResultsMax * height) + (y * xResultsMax);
        let i = 0;
        for (let x = 0; x < xResultsMax; x += 4) {
          xResults[i++] = array.subarray(x + offset, x + offset + 3);
        }
        yResults[y] = xResults;
      }
      zResults[z] = yResults;
    }
    return zResults;
  },
  erectArray4: (array, width) => {
    const xResults = new Array(array);
    const xResultsMax = width * 4;
    let i = 0;
    for (let x = 0; x < xResultsMax; x += 4) {
      xResults[i++] = array.subarray(x, x + 4);
    }
    return xResults;
  },
  erect2DArray4: (array, width, height) => {
    const xResultsMax = width * 4;
    const yResults = new Array(height);
    for (let y = 0; y < height; y++) {
      const xResults = new Array(width);
      const offset = y * xResultsMax;
      let i = 0;
      for (let x = 0; x < xResultsMax; x += 4) {
        xResults[i++] = array.subarray(x + offset, x + offset + 4);
      }
      yResults[y] = xResults;
    }
    return yResults;
  },
  erect3DArray4: (array, width, height, depth) => {
    const xResultsMax = width * 4;
    const zResults = new Array(depth);
    for (let z = 0; z < depth; z++) {
      const yResults = new Array(height);
      for (let y = 0; y < height; y++) {
        const xResults = new Array(width);
        const offset = (z * xResultsMax * height) + (y * xResultsMax);
        let i = 0;
        for (let x = 0; x < xResultsMax; x += 4) {
          xResults[i++] = array.subarray(x + offset, x + offset + 4);
        }
        yResults[y] = xResults;
      }
      zResults[z] = yResults;
    }
    return zResults;
  },

  flattenFunctionToString: (source, settings) => {
    const { findDependency, thisLookup, doNotDefine } = settings;
    let flattened = settings.flattened;
    if (!flattened) {
      flattened = settings.flattened = {};
    }
    const ast = acorn.parse(source);
    const functionDependencies = [];
    let indent = 0;

    function flatten(ast) {
      if (Array.isArray(ast)) {
        const results = [];
        for (let i = 0; i < ast.length; i++) {
          results.push(flatten(ast[i]));
        }
        return results.join('');
      }
      switch (ast.type) {
        case 'Program':
          return flatten(ast.body) + (ast.body[0].type === 'VariableDeclaration' ? ';' : '');
        case 'FunctionDeclaration':
          return `function ${ast.id.name}(${ast.params.map(flatten).join(', ')}) ${ flatten(ast.body) }`;
        case 'BlockStatement': {
          const result = [];
          indent += 2;
          for (let i = 0; i < ast.body.length; i++) {
            const flat = flatten(ast.body[i]);
            if (flat) {
              result.push(' '.repeat(indent) + flat, ';\n');
            }
          }
          indent -= 2;
          return `{\n${result.join('')}}`;
        }
        case 'VariableDeclaration':
          const declarations = utils.normalizeDeclarations(ast)
            .map(flatten)
            .filter(r => r !== null);
          if (declarations.length < 1) {
            return '';
          } else {
            return `${ast.kind} ${declarations.join(',')}`;
          }
          case 'VariableDeclarator':
            if (ast.init.object && ast.init.object.type === 'ThisExpression') {
              const lookup = thisLookup(ast.init.property.name, true);
              if (lookup) {
                return `${ast.id.name} = ${flatten(ast.init)}`;
              } else {
                return null;
              }
            } else {
              return `${ast.id.name} = ${flatten(ast.init)}`;
            }
            case 'CallExpression': {
              if (ast.callee.property.name === 'subarray') {
                return `${flatten(ast.callee.object)}.${flatten(ast.callee.property)}(${ast.arguments.map(value => flatten(value)).join(', ')})`;
              }
              if (ast.callee.object.name === 'gl' || ast.callee.object.name === 'context') {
                return `${flatten(ast.callee.object)}.${flatten(ast.callee.property)}(${ast.arguments.map(value => flatten(value)).join(', ')})`;
              }
              if (ast.callee.object.type === 'ThisExpression') {
                functionDependencies.push(findDependency('this', ast.callee.property.name));
                return `${ast.callee.property.name}(${ast.arguments.map(value => flatten(value)).join(', ')})`;
              } else if (ast.callee.object.name) {
                const foundSource = findDependency(ast.callee.object.name, ast.callee.property.name);
                if (foundSource === null) {
                  return `${ast.callee.object.name}.${ast.callee.property.name}(${ast.arguments.map(value => flatten(value)).join(', ')})`;
                } else {
                  functionDependencies.push(foundSource);
                  return `${ast.callee.property.name}(${ast.arguments.map(value => flatten(value)).join(', ')})`;
                }
              } else if (ast.callee.object.type === 'MemberExpression') {
                return `${flatten(ast.callee.object)}.${ast.callee.property.name}(${ast.arguments.map(value => flatten(value)).join(', ')})`;
              } else {
                throw new Error('unknown ast.callee');
              }
            }
            case 'ReturnStatement':
              return `return ${flatten(ast.argument)}`;
            case 'BinaryExpression':
              return `(${flatten(ast.left)}${ast.operator}${flatten(ast.right)})`;
            case 'UnaryExpression':
              if (ast.prefix) {
                return `${ast.operator} ${flatten(ast.argument)}`;
              } else {
                return `${flatten(ast.argument)} ${ast.operator}`;
              }
              case 'ExpressionStatement':
                return `${flatten(ast.expression)}`;
              case 'SequenceExpression':
                return `(${flatten(ast.expressions)})`;
              case 'ArrowFunctionExpression':
                return `(${ast.params.map(flatten).join(', ')}) => ${flatten(ast.body)}`;
              case 'Literal':
                return ast.raw;
              case 'Identifier':
                return ast.name;
              case 'MemberExpression':
                if (ast.object.type === 'ThisExpression') {
                  return thisLookup(ast.property.name);
                }
                if (ast.computed) {
                  return `${flatten(ast.object)}[${flatten(ast.property)}]`;
                }
                return flatten(ast.object) + '.' + flatten(ast.property);
              case 'ThisExpression':
                return 'this';
              case 'NewExpression':
                return `new ${flatten(ast.callee)}(${ast.arguments.map(value => flatten(value)).join(', ')})`;
              case 'ForStatement':
                return `for (${flatten(ast.init)};${flatten(ast.test)};${flatten(ast.update)}) ${flatten(ast.body)}`;
              case 'AssignmentExpression':
                return `${flatten(ast.left)}${ast.operator}${flatten(ast.right)}`;
              case 'UpdateExpression':
                return `${flatten(ast.argument)}${ast.operator}`;
              case 'IfStatement':
                return `if (${flatten(ast.test)}) ${flatten(ast.consequent)}`;
              case 'ThrowStatement':
                return `throw ${flatten(ast.argument)}`;
              case 'ObjectPattern':
                return ast.properties.map(flatten).join(', ');
              case 'ArrayPattern':
                return ast.elements.map(flatten).join(', ');
              case 'DebuggerStatement':
                return 'debugger;';
              case 'ConditionalExpression':
                return `${flatten(ast.test)}?${flatten(ast.consequent)}:${flatten(ast.alternate)}`;
              case 'Property':
                if (ast.kind === 'init') {
                  return flatten(ast.key);
                }
      }
      throw new Error(`unhandled ast.type of ${ ast.type }`);
    }
    const result = flatten(ast);
    if (functionDependencies.length > 0) {
      const flattenedFunctionDependencies = [];
      for (let i = 0; i < functionDependencies.length; i++) {
        const functionDependency = functionDependencies[i];
        if (!flattened[functionDependency]) {
          flattened[functionDependency] = true;
        }
        functionDependency ? flattenedFunctionDependencies.push(utils.flattenFunctionToString(functionDependency, settings) + '\n') : '';
      }
      return flattenedFunctionDependencies.join('') + result;
    }
    return result;
  },

  normalizeDeclarations: (ast) => {
    if (ast.type !== 'VariableDeclaration') throw new Error('Ast is not of type "VariableDeclaration"');
    const normalizedDeclarations = [];
    for (let declarationIndex = 0; declarationIndex < ast.declarations.length; declarationIndex++) {
      const declaration = ast.declarations[declarationIndex];
      if (declaration.id && declaration.id.type === 'ObjectPattern' && declaration.id.properties) {
        const { properties } = declaration.id;
        for (let propertyIndex = 0; propertyIndex < properties.length; propertyIndex++) {
          const property = properties[propertyIndex];
          if (property.value.type === 'ObjectPattern' && property.value.properties) {
            for (let subPropertyIndex = 0; subPropertyIndex < property.value.properties.length; subPropertyIndex++) {
              const subProperty = property.value.properties[subPropertyIndex];
              if (subProperty.type === 'Property') {
                normalizedDeclarations.push({
                  type: 'VariableDeclarator',
                  id: {
                    type: 'Identifier',
                    name: subProperty.key.name
                  },
                  init: {
                    type: 'MemberExpression',
                    object: {
                      type: 'MemberExpression',
                      object: declaration.init,
                      property: {
                        type: 'Identifier',
                        name: property.key.name
                      },
                      computed: false
                    },
                    property: {
                      type: 'Identifier',
                      name: subProperty.key.name
                    },
                    computed: false
                  }
                });
              } else {
                throw new Error('unexpected state');
              }
            }
          } else if (property.value.type === 'Identifier') {
            normalizedDeclarations.push({
              type: 'VariableDeclarator',
              id: {
                type: 'Identifier',
                name: property.value && property.value.name ? property.value.name : property.key.name
              },
              init: {
                type: 'MemberExpression',
                object: declaration.init,
                property: {
                  type: 'Identifier',
                  name: property.key.name
                },
                computed: false
              }
            });
          } else {
            throw new Error('unexpected state');
          }
        }
      } else if (declaration.id && declaration.id.type === 'ArrayPattern' && declaration.id.elements) {
        const { elements } = declaration.id;
        for (let elementIndex = 0; elementIndex < elements.length; elementIndex++) {
          const element = elements[elementIndex];
          if (element.type === 'Identifier') {
            normalizedDeclarations.push({
              type: 'VariableDeclarator',
              id: {
                type: 'Identifier',
                name: element.name
              },
              init: {
                type: 'MemberExpression',
                object: declaration.init,
                property: {
                  type: 'Literal',
                  value: elementIndex,
                  raw: elementIndex.toString(),
                  start: element.start,
                  end: element.end
                },
                computed: true
              }
            });
          } else {
            throw new Error('unexpected state');
          }
        }
      } else {
        normalizedDeclarations.push(declaration);
      }
    }
    return normalizedDeclarations;
  },

  splitHTMLImageToRGB: (gpu, image) => {
    const rKernel = gpu.createKernel(function(a) {
      const pixel = a[this.thread.y][this.thread.x];
      return pixel.r * 255;
    }, {
      output: [image.width, image.height],
      precision: 'unsigned',
      argumentTypes: { a: 'HTMLImage' },
    });
    const gKernel = gpu.createKernel(function(a) {
      const pixel = a[this.thread.y][this.thread.x];
      return pixel.g * 255;
    }, {
      output: [image.width, image.height],
      precision: 'unsigned',
      argumentTypes: { a: 'HTMLImage' },
    });
    const bKernel = gpu.createKernel(function(a) {
      const pixel = a[this.thread.y][this.thread.x];
      return pixel.b * 255;
    }, {
      output: [image.width, image.height],
      precision: 'unsigned',
      argumentTypes: { a: 'HTMLImage' },
    });
    const aKernel = gpu.createKernel(function(a) {
      const pixel = a[this.thread.y][this.thread.x];
      return pixel.a * 255;
    }, {
      output: [image.width, image.height],
      precision: 'unsigned',
      argumentTypes: { a: 'HTMLImage' },
    });
    const result = [
      rKernel(image),
      gKernel(image),
      bKernel(image),
      aKernel(image),
    ];
    result.rKernel = rKernel;
    result.gKernel = gKernel;
    result.bKernel = bKernel;
    result.aKernel = aKernel;
    result.gpu = gpu;
    return result;
  },

  splitRGBAToCanvases: (gpu, rgba, width, height) => {
    const visualKernelR = gpu.createKernel(function(v) {
      const pixel = v[this.thread.y][this.thread.x];
      this.color(pixel.r / 255, 0, 0, 255);
    }, {
      output: [width, height],
      graphical: true,
      argumentTypes: { v: 'Array2D(4)' }
    });
    visualKernelR(rgba);

    const visualKernelG = gpu.createKernel(function(v) {
      const pixel = v[this.thread.y][this.thread.x];
      this.color(0, pixel.g / 255, 0, 255);
    }, {
      output: [width, height],
      graphical: true,
      argumentTypes: { v: 'Array2D(4)' }
    });
    visualKernelG(rgba);

    const visualKernelB = gpu.createKernel(function(v) {
      const pixel = v[this.thread.y][this.thread.x];
      this.color(0, 0, pixel.b / 255, 255);
    }, {
      output: [width, height],
      graphical: true,
      argumentTypes: { v: 'Array2D(4)' }
    });
    visualKernelB(rgba);

    const visualKernelA = gpu.createKernel(function(v) {
      const pixel = v[this.thread.y][this.thread.x];
      this.color(255, 255, 255, pixel.a / 255);
    }, {
      output: [width, height],
      graphical: true,
      argumentTypes: { v: 'Array2D(4)' }
    });
    visualKernelA(rgba);
    return [
      visualKernelR.canvas,
      visualKernelG.canvas,
      visualKernelB.canvas,
      visualKernelA.canvas,
    ];
  },

  getMinifySafeName: (fn) => {
    try {
      const ast = acorn.parse(`const value = ${fn.toString()}`);
      const { init } = ast.body[0].declarations[0];
      return init.body.name || init.body.body[0].argument.name;
    } catch (e) {
      throw new Error('Unrecognized function type.  Please use `() => yourFunctionVariableHere` or function() { return yourFunctionVariableHere; }');
    }
  },
  sanitizeName: function(name) {
    if (dollarSign.test(name)) {
      name = name.replace(dollarSign, 'S_S');
    }
    if (doubleUnderscore.test(name)) {
      name = name.replace(doubleUnderscore, 'U_U');
    } else if (singleUnderscore.test(name)) {
      name = name.replace(singleUnderscore, 'u_u');
    }
    return name;
  }
};

const dollarSign = /\$/;
const doubleUnderscore = /__/;
const singleUnderscore = /_/;

const _systemEndianness = utils.getSystemEndianness();

module.exports = {
  utils
};
},{"./input":110,"./texture":113,"acorn":1}]},{},[107])(107)
});


/***/ }),

/***/ "./src/createAntProgram.ts":
/*!*********************************!*\
  !*** ./src/createAntProgram.ts ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.createAntProgram = void 0;
const gpu_js_1 = __webpack_require__(/*! gpu.js */ "./node_modules/gpu.js/dist/gpu-browser.js");
exports.createAntProgram = (config, updateGetter) => (size) => {
    // Create the main update logic
    /** The function that updates the state for the next cycle */
    function updateAnts(data, pixels, size) {
        const speed = this.constants.speed;
        const steerSpeed = this.constants.steerSpeed;
        const sensorSize = this.constants.sensorSize;
        const sensorOffset = this.constants.sensorOffset;
        const sensorAngle = this.constants.sensorAngle;
        const randomBorderBounce = this.constants.randomBorderBounce;
        // Extract data
        let x = data[this.thread.x][0];
        let y = data[this.thread.x][1];
        let angle = data[this.thread.x][2];
        // Movement + border bounce
        let veloX = (Math.cos(angle) * speed) / size;
        let veloY = (Math.sin(angle) * speed) / size;
        x = Math.min(Math.max(0, x + veloX), 1);
        y = Math.min(Math.max(0, y + veloY), 1);
        if (randomBorderBounce) {
            if (x >= 1 || x <= 0 || y >= 1 || y <= 0)
                angle = (Math.random() + 1) * Math.PI * 2;
        }
        else {
            if (x >= 1 || x <= 0)
                angle = Math.PI - angle;
            if (y >= 1 || y <= 0)
                angle = -angle;
        }
        // Compute the sensor values
        const sensors = [0, 0, 0];
        for (let i = -1; i <= 1; i += 1) {
            const baseX = Math.round(x * size + Math.cos(Math.PI * 2 + i * sensorAngle + angle) * sensorOffset);
            const baseY = Math.round(y * size + Math.sin(Math.PI * 2 + i * sensorAngle + angle) * sensorOffset);
            for (let x = -sensorSize + 1; x < sensorSize; x++) {
                for (let y = -sensorSize + 1; y < sensorSize; y++) {
                    sensors[i + 1] += pixels[baseY + y][baseX + x];
                }
            }
        }
        // Update the direction
        const randomSteerStrength = Math.random();
        let right = sensors[0];
        const forward = sensors[1];
        let left = sensors[2];
        if (forward > left && forward > right)
            angle = angle;
        else if (left > forward && right > forward)
            angle += (randomSteerStrength - 0.5) * 2 * steerSpeed;
        else if (left > right)
            angle += randomSteerStrength * steerSpeed;
        else if (right > left)
            angle -= randomSteerStrength * steerSpeed;
        return [x, y, angle];
    }
    /** Updates the image data */
    function updatePixels(pixels) {
        const evaporateSpeed = this.constants.evaporateSpeed;
        const diffusionSpeed = this.constants.diffuseSpeed;
        // Blur the trail
        let avg = 0;
        for (let x = this.thread.x - 1; x <= this.thread.x + 1; x++) {
            for (let y = this.thread.y - 1; y <= this.thread.y + 1; y++) {
                avg += pixels[y][x];
            }
        }
        let result = (1 - diffusionSpeed) * pixels[this.thread.y][this.thread.x] +
            (diffusionSpeed * avg) / 9;
        // Evaporate the trail
        result = Math.max(0, result - evaporateSpeed);
        return result;
    }
    /** Draws the pixels */
    function draw(pixels) {
        const v = Math.min(1, pixels[this.thread.y][this.thread.x]);
        const r = this.constants.r;
        const g = this.constants.g;
        const b = this.constants.b;
        this.color(r * v, g * v, b * v, 1);
    }
    // Create the GPU kernels
    const gpu = new gpu_js_1.GPU();
    let updateAntsK;
    let updatePixelsK;
    let drawK = null;
    const span = document.createElement("span");
    function initShaders() {
        var _a;
        updateAntsK === null || updateAntsK === void 0 ? void 0 : updateAntsK.destroy();
        updateAntsK = gpu
            .createKernel(updateAnts)
            .setOutput([config.ant.count])
            .setConstants(config.ant);
        updatePixelsK === null || updatePixelsK === void 0 ? void 0 : updatePixelsK.destroy();
        updatePixelsK = gpu
            .createKernel(updatePixels)
            .setOutput([size, size])
            .setConstants(config.trails);
        (_a = drawK === null || drawK === void 0 ? void 0 : drawK.canvas) === null || _a === void 0 ? void 0 : _a.remove();
        drawK === null || drawK === void 0 ? void 0 : drawK.destroy();
        drawK = gpu
            .createKernel(draw)
            .setGraphical(true)
            .setOutput([size, size])
            .setConstants({
            r: config.trails.color[0],
            g: config.trails.color[1],
            b: config.trails.color[2],
        });
        span.appendChild(drawK.canvas);
    }
    initShaders();
    updateGetter === null || updateGetter === void 0 ? void 0 : updateGetter((reset) => {
        initShaders();
        if (reset)
            init();
    });
    // Initialize the state
    let ants;
    let pixels;
    function init() {
        const testAnt = config.initialize(config.ant.count);
        ants =
            testAnt[0] instanceof Array
                ? testAnt
                : new Array(config.ant.count)
                    .fill(0)
                    .map(() => config.initialize(1));
        pixels = new Array(size).fill(0).map(() => new Array(size).fill(0));
    }
    init();
    let running = true;
    // Create the render loop
    const render = () => {
        try {
            const antIntensity = config.ant.intensity;
            ants = updateAntsK(ants, pixels, size);
            ants.forEach(([x, y]) => {
                const px = Math.round(x * (size - 1));
                const py = Math.round(y * (size - 1));
                pixels[py][px] = Math.min(pixels[py][px] + antIntensity, 1);
            });
            pixels = updatePixelsK(pixels);
            drawK === null || drawK === void 0 ? void 0 : drawK(pixels);
        }
        catch (e) {
            console.error(e);
        }
        if (running)
            requestAnimationFrame(render);
    };
    if (running)
        render();
    // Return the controls
    return {
        canvas: span,
        start: () => {
            running = true;
            render();
        },
        stop: () => {
            running = false;
        },
    };
};


/***/ }),

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const random_1 = __webpack_require__(/*! ./programs/random */ "./src/programs/random.ts");
const randomTight_1 = __webpack_require__(/*! ./programs/randomTight */ "./src/programs/randomTight.ts");
const circle_1 = __webpack_require__(/*! ./programs/circle */ "./src/programs/circle.ts");
const diagonal_1 = __webpack_require__(/*! ./programs/diagonal */ "./src/programs/diagonal.ts");
const nerves_1 = __webpack_require__(/*! ./programs/nerves */ "./src/programs/nerves.ts");
const blobs_1 = __webpack_require__(/*! ./programs/blobs */ "./src/programs/blobs.ts");
const cells_1 = __webpack_require__(/*! ./programs/cells */ "./src/programs/cells.ts");
const ants_1 = __webpack_require__(/*! ./programs/ants */ "./src/programs/ants.ts");
const rings_1 = __webpack_require__(/*! ./programs/rings */ "./src/programs/rings.ts");
const square_1 = __webpack_require__(/*! ./programs/square */ "./src/programs/square.ts");
const custom_1 = __webpack_require__(/*! ./programs/custom */ "./src/programs/custom.ts");
const programs = {
    random: random_1.random,
    randomTight: randomTight_1.randomTight,
    diagonal: diagonal_1.diagonal,
    circle: circle_1.circle,
    nerves: nerves_1.nerves,
    blobs: blobs_1.blobs,
    cells: cells_1.cells,
    ants: ants_1.ants,
    rings: rings_1.rings,
    square: square_1.square,
    custom: custom_1.custom,
};
// Create a function to change programs
let stopPrev;
function select(programName) {
    const program = programs[programName];
    if (!program)
        return;
    stopPrev === null || stopPrev === void 0 ? void 0 : stopPrev();
    const { canvas, stop } = program(900);
    document.getElementsByTagName("body")[0].appendChild(canvas);
    stopPrev = () => {
        canvas.remove();
        stop();
    };
}
// Create a dropdown to select program
const selectControl = document.createElement("select");
Object.keys(programs).forEach(name => {
    var option = document.createElement("option"), text = document.createTextNode(name);
    option.appendChild(text);
    selectControl.appendChild(option);
});
document.body.appendChild(selectControl);
selectControl.addEventListener("change", () => {
    select(selectControl.value);
});
const newline = document.createElement("br");
document.body.appendChild(newline);
// Initialize the first program
const keys = Object.keys(programs);
select(keys[0]);


/***/ }),

/***/ "./src/programs/ants.ts":
/*!******************************!*\
  !*** ./src/programs/ants.ts ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.ants = void 0;
const createAntProgram_1 = __webpack_require__(/*! ../createAntProgram */ "./src/createAntProgram.ts");
exports.ants = createAntProgram_1.createAntProgram({
    ant: {
        count: 1000,
        intensity: 1,
        speed: 1,
        steerSpeed: 0.2,
        sensorSize: 3,
        sensorAngle: 0.5,
        sensorOffset: 4,
        randomBorderBounce: true,
    },
    trails: {
        diffuseSpeed: 5e-2,
        evaporateSpeed: 1e-3,
        color: [0.8, 0.3, 0.4],
    },
    initialize: () => [Math.random(), Math.random(), Math.random() * Math.PI * 2],
});


/***/ }),

/***/ "./src/programs/blobs.ts":
/*!*******************************!*\
  !*** ./src/programs/blobs.ts ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.blobs = void 0;
const createAntProgram_1 = __webpack_require__(/*! ../createAntProgram */ "./src/createAntProgram.ts");
exports.blobs = createAntProgram_1.createAntProgram({
    ant: {
        count: 10000,
        intensity: 0.3,
        speed: 1,
        steerSpeed: 0.5,
        sensorSize: 10,
        sensorAngle: 1,
        sensorOffset: 4,
        randomBorderBounce: true,
    },
    trails: {
        diffuseSpeed: 2e-2,
        evaporateSpeed: 1e-3,
        color: [0.5, 0.5, 1],
    },
    initialize: () => {
        const dir = Math.random() * Math.PI * 2;
        const dist = Math.random() * 0.5;
        return [0.5 - Math.cos(dir) * dist, 0.5 - Math.sin(dir) * dist, dir];
    },
});


/***/ }),

/***/ "./src/programs/cells.ts":
/*!*******************************!*\
  !*** ./src/programs/cells.ts ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.cells = void 0;
const createAntProgram_1 = __webpack_require__(/*! ../createAntProgram */ "./src/createAntProgram.ts");
exports.cells = createAntProgram_1.createAntProgram({
    ant: {
        count: 10000,
        intensity: 0.3,
        speed: 1,
        steerSpeed: 0.5,
        sensorSize: 3,
        sensorAngle: 1,
        sensorOffset: 4,
        randomBorderBounce: true,
    },
    trails: {
        diffuseSpeed: 2e-2,
        evaporateSpeed: 1e-3,
        color: [0.8, 0.3, 0.4],
    },
    initialize: () => [Math.random(), Math.random(), Math.random() * Math.PI * 2],
});


/***/ }),

/***/ "./src/programs/circle.ts":
/*!********************************!*\
  !*** ./src/programs/circle.ts ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.circle = void 0;
const createAntProgram_1 = __webpack_require__(/*! ../createAntProgram */ "./src/createAntProgram.ts");
exports.circle = createAntProgram_1.createAntProgram({
    ant: {
        count: 50000,
        intensity: 0.05,
        speed: 2,
        steerSpeed: 1,
        sensorSize: 2,
        sensorAngle: 0.2,
        sensorOffset: 10,
        randomBorderBounce: false,
    },
    trails: {
        diffuseSpeed: 2e-1,
        evaporateSpeed: 2e-3,
        color: [0.5, 0.5, 1],
    },
    initialize: () => {
        const dir = Math.random() * Math.PI * 2;
        const dist = Math.random() * 0.3;
        return [0.5 - Math.cos(dir) * dist, 0.5 - Math.sin(dir) * dist, dir];
    },
});


/***/ }),

/***/ "./src/programs/custom.ts":
/*!********************************!*\
  !*** ./src/programs/custom.ts ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.custom = void 0;
const dat = __importStar(__webpack_require__(/*! dat.gui */ "./node_modules/dat.gui/build/dat.gui.module.js"));
const createAntProgram_1 = __webpack_require__(/*! ../createAntProgram */ "./src/createAntProgram.ts");
exports.custom = (size) => {
    // Track the updater to track when props change
    let updateConfig;
    const update = () => updateConfig === null || updateConfig === void 0 ? void 0 : updateConfig();
    const updateReset = () => updateConfig === null || updateConfig === void 0 ? void 0 : updateConfig(true);
    // The initial config
    const config = {
        ant: {
            count: 50000,
            intensity: 0.05,
            speed: 2,
            steerSpeed: 1,
            sensorSize: 2,
            sensorAngle: 0.2,
            sensorOffset: 10,
            randomBorderBounce: false,
        },
        trails: {
            diffuseSpeed: 2e-1,
            evaporateSpeed: 2e-3,
            color: [0.5, 0.5, 1],
        },
        initialize: () => {
            const dir = Math.random() * Math.PI * 2;
            const dist = Math.random() * 0.3;
            return [0.5 - Math.cos(dir) * dist, 0.5 - Math.sin(dir) * dist, dir];
        },
        restart: updateReset,
    };
    // Create the GUI
    const gui = new dat.GUI({ name: "shader props" });
    gui.add(config, "restart");
    // Add ant properties
    const ant = gui.addFolder("ants");
    ant.add(config.ant, "count", 1, 1e5, 1).onChange(updateReset);
    ant.add(config.ant, "intensity", 0, 1);
    ant.add(config.ant, "speed", 0.01, 5).onChange(update);
    ant.add(config.ant, "steerSpeed", 1e-3, 2).onChange(update);
    ant.add(config.ant, "sensorSize", 1, 10, 1).onChange(update);
    ant.add(config.ant, "sensorAngle", 0.05, 2).onChange(update);
    ant.add(config.ant, "sensorOffset", 1, 10).onChange(update);
    ant.add(config.ant, "randomBorderBounce").onChange(update);
    // Add trails properties
    const trails = gui.addFolder("trails");
    trails.add(config.trails, "diffuseSpeed", 1e-2, 0.999).onChange(update);
    trails.add(config.trails, "evaporateSpeed", 2e-3, 0.1).onChange(update);
    const intColor = { color: [128, 128, 255] };
    trails.addColor(intColor, "color").onChange(() => {
        const c = intColor.color;
        config.trails.color = [c[0] / 255, c[1] / 255, c[2] / 255];
        update();
    });
    // Initialize options
    const init = gui.addFolder("init");
    const initConfig = { initialize: "circle", size: 0.3 };
    const updateInit = () => {
        config.initialize = initOptions[initConfig.initialize](initConfig.size);
        updateReset();
    };
    init.add(initConfig, "initialize", Object.keys(initOptions)).onChange(updateInit);
    init.add(initConfig, "size", 0, 1).onChange(updateInit);
    // Wrap the original program and add the controls
    const { canvas, start, stop } = createAntProgram_1.createAntProgram(config, u => {
        updateConfig = u;
    })(size);
    const div = document.createElement("div");
    div.appendChild(canvas);
    div.appendChild(gui.domElement);
    return {
        canvas: div,
        start,
        stop,
    };
};
// The initialization options
const initOptions = {
    circle: size => () => {
        const dir = Math.random() * Math.PI * 2;
        const dist = ((Math.random() * 2 - 1) * size) / 2;
        return [0.5 + Math.cos(dir) * dist, 0.5 + Math.sin(dir) * dist, dir];
    },
    circleIn: size => () => {
        const dir = Math.random() * Math.PI * 2;
        const dist = (-Math.random() * size) / 2;
        return [0.5 + Math.cos(dir) * dist, 0.5 + Math.sin(dir) * dist, dir];
    },
    circleOut: size => () => {
        const dir = Math.random() * Math.PI * 2;
        const dist = (Math.random() * size) / 2;
        return [0.5 + Math.cos(dir) * dist, 0.5 + Math.sin(dir) * dist, dir];
    },
    circleRing: size => () => {
        const dir = Math.random() * Math.PI * 2;
        const dist = (Math.random() * size) / 2;
        return [
            0.5 + Math.cos(dir) * dist,
            0.5 + Math.sin(dir) * dist,
            dir + Math.PI / 2,
        ];
    },
    circleRingDual: size => () => {
        const dir = Math.random() * Math.PI * 2;
        const dist = (Math.random() * size) / 2;
        const side = Math.random() > 0.5 ? 1 : -1;
        return [
            0.5 + Math.cos(dir) * dist,
            0.5 + Math.sin(dir) * dist,
            dir + (side * Math.PI) / 2,
        ];
    },
    circleOutline: size => () => {
        const dir = Math.random() * Math.PI * 2;
        const dist = ((Math.round(Math.random()) * 2 - 1) * size) / 2;
        return [0.5 + Math.cos(dir) * dist, 0.5 + Math.sin(dir) * dist, dir];
    },
    circleOutlineIn: size => () => {
        const dir = Math.random() * Math.PI * 2;
        const dist = -size / 2;
        return [0.5 + Math.cos(dir) * dist, 0.5 + Math.sin(dir) * dist, dir];
    },
    circleOutlineOut: size => () => {
        const dir = Math.random() * Math.PI * 2;
        const dist = size / 2;
        return [0.5 + Math.cos(dir) * dist, 0.5 + Math.sin(dir) * dist, dir];
    },
    circleOutlineRing: size => () => {
        const dir = Math.random() * Math.PI * 2;
        const dist = size / 2;
        return [
            0.5 + Math.cos(dir) * dist,
            0.5 + Math.sin(dir) * dist,
            dir + Math.PI / 2,
        ];
    },
    circleOutlineRingDual: size => () => {
        const dir = Math.random() * Math.PI * 2;
        const dist = size / 2;
        const side = Math.random() > 0.5 ? 1 : -1;
        return [
            0.5 + Math.cos(dir) * dist,
            0.5 + Math.sin(dir) * dist,
            dir + (side * Math.PI) / 2,
        ];
    },
    full: size => () => [Math.random(), Math.random(), Math.random() * Math.PI * 2],
};


/***/ }),

/***/ "./src/programs/diagonal.ts":
/*!**********************************!*\
  !*** ./src/programs/diagonal.ts ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.diagonal = void 0;
const createAntProgram_1 = __webpack_require__(/*! ../createAntProgram */ "./src/createAntProgram.ts");
exports.diagonal = createAntProgram_1.createAntProgram({
    ant: {
        count: 10000,
        intensity: 0.1,
        speed: 2,
        steerSpeed: 0.1,
        sensorSize: 2,
        sensorAngle: 0.2,
        sensorOffset: 10,
        randomBorderBounce: true,
    },
    trails: {
        diffuseSpeed: 2e-1,
        evaporateSpeed: 1e-3,
        color: [1, 0, 0],
    },
    initialize: () => {
        const dir = Math.random() * Math.PI * 2;
        const dist = Math.random() * 0.3;
        return [0.5 - Math.cos(dir) * dist, 0.5 - Math.cos(dir) * dist, dir];
    },
});


/***/ }),

/***/ "./src/programs/nerves.ts":
/*!********************************!*\
  !*** ./src/programs/nerves.ts ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.nerves = void 0;
const createAntProgram_1 = __webpack_require__(/*! ../createAntProgram */ "./src/createAntProgram.ts");
exports.nerves = createAntProgram_1.createAntProgram({
    ant: {
        count: 50000,
        intensity: 0.01,
        speed: 2,
        steerSpeed: 1,
        sensorSize: 2,
        sensorAngle: 0.2,
        sensorOffset: 10,
        randomBorderBounce: true,
    },
    trails: {
        diffuseSpeed: 1e-2,
        evaporateSpeed: 1e-3,
        color: [0.3, 0.4, 1],
    },
    initialize: () => {
        const dir = Math.random() * Math.PI * 2;
        const dist = Math.random() * 0.5;
        return [0.5 - Math.cos(dir) * dist, 0.5 - Math.sin(dir) * dist, dir];
    },
});


/***/ }),

/***/ "./src/programs/random.ts":
/*!********************************!*\
  !*** ./src/programs/random.ts ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.random = void 0;
const createAntProgram_1 = __webpack_require__(/*! ../createAntProgram */ "./src/createAntProgram.ts");
exports.random = createAntProgram_1.createAntProgram({
    ant: {
        count: 10000,
        intensity: 0.1,
        speed: 1,
        steerSpeed: 0.1,
        sensorSize: 1,
        sensorAngle: 0.4,
        sensorOffset: 10,
        randomBorderBounce: false,
    },
    trails: {
        diffuseSpeed: 2e-1,
        evaporateSpeed: 1e-3,
        color: [0.5, 1, 0.5],
    },
    initialize: () => [Math.random(), Math.random(), Math.random() * Math.PI * 2],
});


/***/ }),

/***/ "./src/programs/randomTight.ts":
/*!*************************************!*\
  !*** ./src/programs/randomTight.ts ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.randomTight = void 0;
const createAntProgram_1 = __webpack_require__(/*! ../createAntProgram */ "./src/createAntProgram.ts");
exports.randomTight = createAntProgram_1.createAntProgram({
    ant: {
        count: 50000,
        intensity: 0.05,
        speed: 2,
        steerSpeed: 0.1,
        sensorSize: 2,
        sensorAngle: 0.2,
        sensorOffset: 10,
        randomBorderBounce: false,
    },
    trails: {
        diffuseSpeed: 2e-2,
        evaporateSpeed: 5e-3,
        color: [0.5, 1, 0.5],
    },
    initialize: () => [Math.random(), Math.random(), Math.random() * Math.PI * 2],
});


/***/ }),

/***/ "./src/programs/rings.ts":
/*!*******************************!*\
  !*** ./src/programs/rings.ts ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.rings = void 0;
const createAntProgram_1 = __webpack_require__(/*! ../createAntProgram */ "./src/createAntProgram.ts");
exports.rings = createAntProgram_1.createAntProgram({
    ant: {
        count: 50000,
        intensity: 0.1,
        speed: 0.5,
        steerSpeed: 0.4,
        sensorSize: 2,
        sensorAngle: 1.2,
        sensorOffset: 10,
        randomBorderBounce: true,
    },
    trails: {
        diffuseSpeed: 1e-1,
        evaporateSpeed: 1e-2,
        color: [1, 1, 1],
    },
    initialize: () => {
        const dir = Math.random() * Math.PI * 2;
        const dist = Math.random() * 0.25;
        return [0.5 - Math.cos(dir) * dist, 0.5 - Math.sin(dir) * dist, dir];
    },
});


/***/ }),

/***/ "./src/programs/square.ts":
/*!********************************!*\
  !*** ./src/programs/square.ts ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.square = void 0;
const createAntProgram_1 = __webpack_require__(/*! ../createAntProgram */ "./src/createAntProgram.ts");
exports.square = createAntProgram_1.createAntProgram({
    ant: {
        count: 70000,
        intensity: 0.05,
        speed: 2,
        steerSpeed: 0.05,
        sensorSize: 3,
        sensorAngle: 0.6,
        sensorOffset: 20,
        randomBorderBounce: false,
    },
    trails: {
        diffuseSpeed: 5e-2,
        evaporateSpeed: 5e-3,
        color: [0.5, 0, 1],
    },
    initialize: () => {
        const p = 0.3;
        const axis = Math.random() > 0.5;
        const side = Math.random() > 0.5;
        const pos = Math.random();
        const dir = Math.random() * Math.PI * 2;
        return [
            0.5 + ((axis ? pos : side ? 1 : 0) * 2 - 1) * p,
            0.5 + ((!axis ? pos : side ? 1 : 0) * 2 - 1) * p,
            dir,
        ];
    },
});


/***/ })

/******/ });
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2RhdC5ndWkvYnVpbGQvZGF0Lmd1aS5tb2R1bGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2dwdS5qcy9kaXN0L2dwdS1icm93c2VyLmpzIiwid2VicGFjazovLy8uL3NyYy9jcmVhdGVBbnRQcm9ncmFtLnRzIiwid2VicGFjazovLy8uL3NyYy9pbmRleC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvcHJvZ3JhbXMvYW50cy50cyIsIndlYnBhY2s6Ly8vLi9zcmMvcHJvZ3JhbXMvYmxvYnMudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3Byb2dyYW1zL2NlbGxzLnRzIiwid2VicGFjazovLy8uL3NyYy9wcm9ncmFtcy9jaXJjbGUudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3Byb2dyYW1zL2N1c3RvbS50cyIsIndlYnBhY2s6Ly8vLi9zcmMvcHJvZ3JhbXMvZGlhZ29uYWwudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3Byb2dyYW1zL25lcnZlcy50cyIsIndlYnBhY2s6Ly8vLi9zcmMvcHJvZ3JhbXMvcmFuZG9tLnRzIiwid2VicGFjazovLy8uL3NyYy9wcm9ncmFtcy9yYW5kb21UaWdodC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvcHJvZ3JhbXMvcmluZ3MudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3Byb2dyYW1zL3NxdWFyZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO1FBQUE7UUFDQTs7UUFFQTtRQUNBOztRQUVBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBOztRQUVBO1FBQ0E7O1FBRUE7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7OztRQUdBO1FBQ0E7O1FBRUE7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7UUFDQSwwQ0FBMEMsZ0NBQWdDO1FBQzFFO1FBQ0E7O1FBRUE7UUFDQTtRQUNBO1FBQ0Esd0RBQXdELGtCQUFrQjtRQUMxRTtRQUNBLGlEQUFpRCxjQUFjO1FBQy9EOztRQUVBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQSx5Q0FBeUMsaUNBQWlDO1FBQzFFLGdIQUFnSCxtQkFBbUIsRUFBRTtRQUNySTtRQUNBOztRQUVBO1FBQ0E7UUFDQTtRQUNBLDJCQUEyQiwwQkFBMEIsRUFBRTtRQUN2RCxpQ0FBaUMsZUFBZTtRQUNoRDtRQUNBO1FBQ0E7O1FBRUE7UUFDQSxzREFBc0QsK0RBQStEOztRQUVySDtRQUNBOzs7UUFHQTtRQUNBOzs7Ozs7Ozs7Ozs7O0FDbEZBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0gsYUFBYSxvQ0FBb0M7QUFDakQsR0FBRztBQUNILGFBQWEsZ0RBQWdEO0FBQzdELEdBQUc7QUFDSCxhQUFhLG9DQUFvQztBQUNqRCxHQUFHO0FBQ0gsYUFBYSxnREFBZ0Q7QUFDN0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLFFBQVE7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxtQ0FBbUMsU0FBUztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLCtDQUErQyxFQUFFO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7Ozs7Ozs7Ozs7OztBQVlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1CQUFtQixrQkFBa0I7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7Ozs7Ozs7O0FBUUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7Ozs7Ozs7Ozs7O0FBWUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtS0FBbUssaUNBQWlDO0FBQ3BNO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4R0FBOEc7QUFDOUcsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLDJKQUEySjtBQUMzSix3SkFBd0o7QUFDeEosbUpBQW1KO0FBQ25KLG9KQUFvSjtBQUNwSixnSkFBZ0o7QUFDaEo7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCwyREFBMkQ7QUFDbkg7QUFDQSxzREFBc0QsdUNBQXVDO0FBQzdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7QUFFRCx5Q0FBeUMsZ0JBQWdCLFNBQVMsVUFBVSxXQUFXLFdBQVcsT0FBTyxlQUFlLE1BQU0sT0FBTyxRQUFRLFNBQVMsVUFBVSxtQkFBbUIsZ0JBQWdCLFNBQVMsc0NBQXNDLGlDQUFpQyxtQ0FBbUMsOEJBQThCLDRCQUE0QixnQkFBZ0IsMENBQTBDLFVBQVUsZ0JBQWdCLDZCQUE2QixpQ0FBaUMscUJBQXFCLHlEQUF5RCxVQUFVLHVCQUF1QixzQ0FBc0MsaUNBQWlDLG1DQUFtQyw4QkFBOEIsU0FBUyxpQkFBaUIsWUFBWSxlQUFlLGtCQUFrQixzQkFBc0IsaUNBQWlDLGtCQUFrQixvQ0FBb0Msa0JBQWtCLDZCQUE2QixzQkFBc0IsTUFBTSxZQUFZLGtCQUFrQixtQkFBbUIsNEJBQTRCLGFBQWEsK0JBQStCLGdCQUFnQix5QkFBeUIsYUFBYSxnQkFBZ0IsTUFBTSxhQUFhLDBCQUEwQixrQkFBa0IsNkJBQTZCLGVBQWUsT0FBTyx1Q0FBdUMsa0NBQWtDLG9DQUFvQywrQkFBK0IsdUNBQXVDLGtDQUFrQyxvQ0FBb0MsK0JBQStCLG9CQUFvQixZQUFZLFlBQVksaUJBQWlCLG9CQUFvQixjQUFjLFVBQVUsb0NBQW9DLGFBQWEsZUFBZSxpQkFBaUIsaUVBQWlFLFNBQVMsZ0JBQWdCLFNBQVMsUUFBUSxXQUFXLGlCQUFpQixZQUFZLGdCQUFnQixtQkFBbUIsZUFBZSxXQUFXLFdBQVcsVUFBVSxnQkFBZ0IsdUJBQXVCLE9BQU8sV0FBVyxVQUFVLGtCQUFrQix3QkFBd0IsU0FBUyxlQUFlLFlBQVksV0FBVyxZQUFZLGlDQUFpQyxVQUFVLGNBQWMsWUFBWSxXQUFXLFVBQVUsaUJBQWlCLGVBQWUsWUFBWSxlQUFlLGVBQWUsWUFBWSw0QkFBNEIsZUFBZSxjQUFjLGVBQWUsc0dBQXNHLGVBQWUsY0FBYyxpQkFBaUIsY0FBYyxhQUFhLGtCQUFrQixpQkFBaUIsZ0JBQWdCLFdBQVcsMENBQTBDLGNBQWMsZ0JBQWdCLFVBQVUsd0JBQXdCLHFCQUFxQixnQkFBZ0IsYUFBYSxzQkFBc0IsWUFBWSxhQUFhLGVBQWUsaUJBQWlCLG9CQUFvQixhQUFhLFdBQVcsOEJBQThCLGVBQWUsU0FBUyxZQUFZLGtDQUFrQyxxQkFBcUIsY0FBYyxjQUFjLFlBQVksa0JBQWtCLGFBQWEsa0JBQWtCLGtCQUFrQixhQUFhLGVBQWUsaUJBQWlCLGtCQUFrQixzQkFBc0IsWUFBWSxnQkFBZ0IsdUJBQXVCLGVBQWUsc0JBQXNCLGFBQWEsSUFBSSxXQUFXLHNDQUFzQywwQkFBMEIsNEJBQTRCLFVBQVUsbUJBQW1CLG1DQUFtQyxTQUFTLGFBQWEsa0NBQWtDLGtCQUFrQixtQkFBbUIsb0JBQW9CLG1CQUFtQixnQ0FBZ0MsZ0JBQWdCLGlCQUFpQixtQkFBbUIsU0FBUyx1QkFBdUIsZ0JBQWdCLFlBQVksd0JBQXdCLGdCQUFnQixlQUFlLGtCQUFrQixjQUFjLGdCQUFnQix3QkFBd0IsbUJBQW1CLFdBQVcsNEJBQTRCLDRCQUE0QixlQUFlLDhCQUE4QixzQ0FBc0MsbWZBQW1mLFdBQVcsVUFBVSw4QkFBOEIseUJBQXlCLDRCQUE0QixjQUFjLGdCQUFnQixhQUFhLGtCQUFrQixtQ0FBbUMsd0dBQXdHLGVBQWUsOENBQThDLHFCQUFxQixvQ0FBb0MscUZBQXFGLGdCQUFnQiw4QkFBOEIsY0FBYyxzQkFBc0IsaUJBQWlCLDhCQUE4QixlQUFlLDhCQUE4QixnQ0FBZ0MsY0FBYyxlQUFlLDhCQUE4QixnQ0FBZ0MsY0FBYyw2Q0FBNkMsZ0JBQWdCLHdCQUF3QixtQkFBbUIsYUFBYSw4QkFBOEIsbUJBQW1CLDhCQUE4QixtQkFBbUIsV0FBVyxlQUFlLG1CQUFtQixpQkFBaUIsa0JBQWtCLG1CQUFtQixlQUFlLHFCQUFxQixtQkFBbUIsZ0NBQWdDLG1CQUFtQjs7QUFFbHRMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSwrRUFBK0Usd0VBQXdFO0FBQ3ZKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixvQ0FBb0M7QUFDM0Q7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLG1CQUFtQixrQkFBa0I7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxpQkFBaUI7QUFDckU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTyxzQ0FBc0M7QUFDN0M7QUFDQSxPQUFPLHVDQUF1QztBQUM5QztBQUNBO0FBQ0E7QUFDQSxPQUFPLHNDQUFzQztBQUM3Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsZ0M7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0M7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixZQUFZO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPLHdEQUF3RDtBQUMvRDtBQUNBLE9BQU8sK0JBQStCO0FBQ3RDOzs7QUFHQTs7O0FBR0E7QUFDQTtBQUNBLE9BQU8sc0ZBQXNGO0FBQzdGO0FBQ0EsT0FBTyx1Q0FBdUM7O0FBRTlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtB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O0FBQ0Esd0JBQXdCLHNCQUFzQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQStELFdBQVc7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHlCQUF5QjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrREFBK0QsV0FBVztBQUMxRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxTQUFTO0FBQzVDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQixpQkFBaUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0EsOERBQThELEVBQUU7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGdCQUFnQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNULDREQUE0RCxTQUFTO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxXQUFXO0FBQ2pFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esc0NBQXNDLFdBQVc7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLHVCQUF1QixnQkFBZ0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLE1BQU0sV0FBVyxvQkFBb0IsYUFBYSxvQkFBb0IsTUFBTSxjQUFjO0FBQ2xIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9EQUFvRCx3QkFBd0I7QUFDNUU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsMkJBQTJCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGNBQWM7QUFDekI7QUFDQSxtQkFBbUIsd0JBQXdCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw4Q0FBOEMsV0FBVztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUCx1QkFBdUIsbUJBQW1CO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQLHVCQUF1QixtQkFBbUI7QUFDMUM7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjLFVBQVUsRUFBRSxVQUFVLEVBQUUsUUFBUTtBQUM5QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUMsRUFBRSxnREFBZ0Q7QUFDbkQsT0FBTyxRQUFROztBQUVmO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsMERBQTBELE1BQU07QUFDaEU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNDQUFzQyw4QkFBOEI7QUFDcEU7QUFDQTtBQUNBO0FBQ0EsV0FBVyx5QkFBeUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLDBEQUEwRDtBQUNyRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixnQkFBZ0I7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGlCQUFpQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxTQUFTO0FBQ3BEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLEVBQUUsZUFB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQSwyREFBMkQsWUFBWTtBQUN2RTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxXQUFXO0FBQ3RCO0FBQ0EsdUNBQXVDLGdCQUFnQixHQUFHLGdCQUFnQix1REFBdUQsd0JBQXdCLEdBQUcsd0JBQXdCO0FBQ3BMO0FBQ0E7O0FBRUE7QUFDQSx3REFBd0Qsc0JBQXNCO0FBQzlFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLGlEQUFpRCxlQUFlO0FBQ2hFOztBQUVBLDhDQUE4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RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EseUVBQXlFLElBQUk7QUFDN0U7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCO0FBQ0EscUJBQXFCLG9CQUFvQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLGlDO0FBQ0EsdUJBQXVCLG9CQUFvQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBLFdBQVcsV0FBVzs7QUFFdEI7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0EsV0FBVyxrQkFBa0I7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQSxXQUFXLGNBQWM7QUFDekI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdUJBQXVCLHFCQUFxQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLGNBQWM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsK0JBQStCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQkFBcUIsNEJBQTRCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxvRUFBb0U7O0FBRS9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxtQkFBbUIsdUNBQXVDO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDRCQUE0QjtBQUMvQztBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQkFBcUIseUJBQXlCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxjQUFjO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUIsZ0NBQWdDO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiw0QkFBNEI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsNEJBQTRCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsa0NBQWtDO0FBQzVDLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtB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QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUEsV0FBVyxXQUFXO0FBQ3RCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxjQUFjO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGNBQWM7O0FBRXpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLDRCQUE0QjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiw0QkFB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dC8vIFRoZSBtb2R1bGUgY2FjaGVcbiBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbiBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbiBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKSB7XG4gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4gXHRcdH1cbiBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbiBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuIFx0XHRcdGk6IG1vZHVsZUlkLFxuIFx0XHRcdGw6IGZhbHNlLFxuIFx0XHRcdGV4cG9ydHM6IHt9XG4gXHRcdH07XG5cbiBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG4gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbiBcdFx0bW9kdWxlLmwgPSB0cnVlO1xuXG4gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbiBcdH1cblxuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbiBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbiBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4gXHRcdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGdldHRlciB9KTtcbiBcdFx0fVxuIFx0fTtcblxuIFx0Ly8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yID0gZnVuY3Rpb24oZXhwb3J0cykge1xuIFx0XHRpZih0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcbiBcdFx0fVxuIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuIFx0fTtcblxuIFx0Ly8gY3JlYXRlIGEgZmFrZSBuYW1lc3BhY2Ugb2JqZWN0XG4gXHQvLyBtb2RlICYgMTogdmFsdWUgaXMgYSBtb2R1bGUgaWQsIHJlcXVpcmUgaXRcbiBcdC8vIG1vZGUgJiAyOiBtZXJnZSBhbGwgcHJvcGVydGllcyBvZiB2YWx1ZSBpbnRvIHRoZSBuc1xuIFx0Ly8gbW9kZSAmIDQ6IHJldHVybiB2YWx1ZSB3aGVuIGFscmVhZHkgbnMgb2JqZWN0XG4gXHQvLyBtb2RlICYgOHwxOiBiZWhhdmUgbGlrZSByZXF1aXJlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnQgPSBmdW5jdGlvbih2YWx1ZSwgbW9kZSkge1xuIFx0XHRpZihtb2RlICYgMSkgdmFsdWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKHZhbHVlKTtcbiBcdFx0aWYobW9kZSAmIDgpIHJldHVybiB2YWx1ZTtcbiBcdFx0aWYoKG1vZGUgJiA0KSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICYmIHZhbHVlLl9fZXNNb2R1bGUpIHJldHVybiB2YWx1ZTtcbiBcdFx0dmFyIG5zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yKG5zKTtcbiBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG5zLCAnZGVmYXVsdCcsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHZhbHVlIH0pO1xuIFx0XHRpZihtb2RlICYgMiAmJiB0eXBlb2YgdmFsdWUgIT0gJ3N0cmluZycpIGZvcih2YXIga2V5IGluIHZhbHVlKSBfX3dlYnBhY2tfcmVxdWlyZV9fLmQobnMsIGtleSwgZnVuY3Rpb24oa2V5KSB7IHJldHVybiB2YWx1ZVtrZXldOyB9LmJpbmQobnVsbCwga2V5KSk7XG4gXHRcdHJldHVybiBucztcbiBcdH07XG5cbiBcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcbiBcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcbiBcdFx0XHRmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XG4gXHRcdHJldHVybiBnZXR0ZXI7XG4gXHR9O1xuXG4gXHQvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcblxuIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbiBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG5cblxuIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSBcIi4vc3JjL2luZGV4LnRzXCIpO1xuIiwiLyoqXG4gKiBkYXQtZ3VpIEphdmFTY3JpcHQgQ29udHJvbGxlciBMaWJyYXJ5XG4gKiBodHRwOi8vY29kZS5nb29nbGUuY29tL3AvZGF0LWd1aVxuICpcbiAqIENvcHlyaWdodCAyMDExIERhdGEgQXJ0cyBUZWFtLCBHb29nbGUgQ3JlYXRpdmUgTGFiXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICovXG5cbmZ1bmN0aW9uIF9fXyRpbnNlcnRTdHlsZShjc3MpIHtcbiAgaWYgKCFjc3MpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKTtcblxuICBzdHlsZS5zZXRBdHRyaWJ1dGUoJ3R5cGUnLCAndGV4dC9jc3MnKTtcbiAgc3R5bGUuaW5uZXJIVE1MID0gY3NzO1xuICBkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKHN0eWxlKTtcblxuICByZXR1cm4gY3NzO1xufVxuXG5mdW5jdGlvbiBjb2xvclRvU3RyaW5nIChjb2xvciwgZm9yY2VDU1NIZXgpIHtcbiAgdmFyIGNvbG9yRm9ybWF0ID0gY29sb3IuX19zdGF0ZS5jb252ZXJzaW9uTmFtZS50b1N0cmluZygpO1xuICB2YXIgciA9IE1hdGgucm91bmQoY29sb3Iucik7XG4gIHZhciBnID0gTWF0aC5yb3VuZChjb2xvci5nKTtcbiAgdmFyIGIgPSBNYXRoLnJvdW5kKGNvbG9yLmIpO1xuICB2YXIgYSA9IGNvbG9yLmE7XG4gIHZhciBoID0gTWF0aC5yb3VuZChjb2xvci5oKTtcbiAgdmFyIHMgPSBjb2xvci5zLnRvRml4ZWQoMSk7XG4gIHZhciB2ID0gY29sb3Iudi50b0ZpeGVkKDEpO1xuICBpZiAoZm9yY2VDU1NIZXggfHwgY29sb3JGb3JtYXQgPT09ICdUSFJFRV9DSEFSX0hFWCcgfHwgY29sb3JGb3JtYXQgPT09ICdTSVhfQ0hBUl9IRVgnKSB7XG4gICAgdmFyIHN0ciA9IGNvbG9yLmhleC50b1N0cmluZygxNik7XG4gICAgd2hpbGUgKHN0ci5sZW5ndGggPCA2KSB7XG4gICAgICBzdHIgPSAnMCcgKyBzdHI7XG4gICAgfVxuICAgIHJldHVybiAnIycgKyBzdHI7XG4gIH0gZWxzZSBpZiAoY29sb3JGb3JtYXQgPT09ICdDU1NfUkdCJykge1xuICAgIHJldHVybiAncmdiKCcgKyByICsgJywnICsgZyArICcsJyArIGIgKyAnKSc7XG4gIH0gZWxzZSBpZiAoY29sb3JGb3JtYXQgPT09ICdDU1NfUkdCQScpIHtcbiAgICByZXR1cm4gJ3JnYmEoJyArIHIgKyAnLCcgKyBnICsgJywnICsgYiArICcsJyArIGEgKyAnKSc7XG4gIH0gZWxzZSBpZiAoY29sb3JGb3JtYXQgPT09ICdIRVgnKSB7XG4gICAgcmV0dXJuICcweCcgKyBjb2xvci5oZXgudG9TdHJpbmcoMTYpO1xuICB9IGVsc2UgaWYgKGNvbG9yRm9ybWF0ID09PSAnUkdCX0FSUkFZJykge1xuICAgIHJldHVybiAnWycgKyByICsgJywnICsgZyArICcsJyArIGIgKyAnXSc7XG4gIH0gZWxzZSBpZiAoY29sb3JGb3JtYXQgPT09ICdSR0JBX0FSUkFZJykge1xuICAgIHJldHVybiAnWycgKyByICsgJywnICsgZyArICcsJyArIGIgKyAnLCcgKyBhICsgJ10nO1xuICB9IGVsc2UgaWYgKGNvbG9yRm9ybWF0ID09PSAnUkdCX09CSicpIHtcbiAgICByZXR1cm4gJ3tyOicgKyByICsgJyxnOicgKyBnICsgJyxiOicgKyBiICsgJ30nO1xuICB9IGVsc2UgaWYgKGNvbG9yRm9ybWF0ID09PSAnUkdCQV9PQkonKSB7XG4gICAgcmV0dXJuICd7cjonICsgciArICcsZzonICsgZyArICcsYjonICsgYiArICcsYTonICsgYSArICd9JztcbiAgfSBlbHNlIGlmIChjb2xvckZvcm1hdCA9PT0gJ0hTVl9PQkonKSB7XG4gICAgcmV0dXJuICd7aDonICsgaCArICcsczonICsgcyArICcsdjonICsgdiArICd9JztcbiAgfSBlbHNlIGlmIChjb2xvckZvcm1hdCA9PT0gJ0hTVkFfT0JKJykge1xuICAgIHJldHVybiAne2g6JyArIGggKyAnLHM6JyArIHMgKyAnLHY6JyArIHYgKyAnLGE6JyArIGEgKyAnfSc7XG4gIH1cbiAgcmV0dXJuICd1bmtub3duIGZvcm1hdCc7XG59XG5cbnZhciBBUlJfRUFDSCA9IEFycmF5LnByb3RvdHlwZS5mb3JFYWNoO1xudmFyIEFSUl9TTElDRSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcbnZhciBDb21tb24gPSB7XG4gIEJSRUFLOiB7fSxcbiAgZXh0ZW5kOiBmdW5jdGlvbiBleHRlbmQodGFyZ2V0KSB7XG4gICAgdGhpcy5lYWNoKEFSUl9TTElDRS5jYWxsKGFyZ3VtZW50cywgMSksIGZ1bmN0aW9uIChvYmopIHtcbiAgICAgIHZhciBrZXlzID0gdGhpcy5pc09iamVjdChvYmopID8gT2JqZWN0LmtleXMob2JqKSA6IFtdO1xuICAgICAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzVW5kZWZpbmVkKG9ialtrZXldKSkge1xuICAgICAgICAgIHRhcmdldFtrZXldID0gb2JqW2tleV07XG4gICAgICAgIH1cbiAgICAgIH0uYmluZCh0aGlzKSk7XG4gICAgfSwgdGhpcyk7XG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfSxcbiAgZGVmYXVsdHM6IGZ1bmN0aW9uIGRlZmF1bHRzKHRhcmdldCkge1xuICAgIHRoaXMuZWFjaChBUlJfU0xJQ0UuY2FsbChhcmd1bWVudHMsIDEpLCBmdW5jdGlvbiAob2JqKSB7XG4gICAgICB2YXIga2V5cyA9IHRoaXMuaXNPYmplY3Qob2JqKSA/IE9iamVjdC5rZXlzKG9iaikgOiBbXTtcbiAgICAgIGtleXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIGlmICh0aGlzLmlzVW5kZWZpbmVkKHRhcmdldFtrZXldKSkge1xuICAgICAgICAgIHRhcmdldFtrZXldID0gb2JqW2tleV07XG4gICAgICAgIH1cbiAgICAgIH0uYmluZCh0aGlzKSk7XG4gICAgfSwgdGhpcyk7XG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfSxcbiAgY29tcG9zZTogZnVuY3Rpb24gY29tcG9zZSgpIHtcbiAgICB2YXIgdG9DYWxsID0gQVJSX1NMSUNFLmNhbGwoYXJndW1lbnRzKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGFyZ3MgPSBBUlJfU0xJQ0UuY2FsbChhcmd1bWVudHMpO1xuICAgICAgZm9yICh2YXIgaSA9IHRvQ2FsbC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBhcmdzID0gW3RvQ2FsbFtpXS5hcHBseSh0aGlzLCBhcmdzKV07XG4gICAgICB9XG4gICAgICByZXR1cm4gYXJnc1swXTtcbiAgICB9O1xuICB9LFxuICBlYWNoOiBmdW5jdGlvbiBlYWNoKG9iaiwgaXRyLCBzY29wZSkge1xuICAgIGlmICghb2JqKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChBUlJfRUFDSCAmJiBvYmouZm9yRWFjaCAmJiBvYmouZm9yRWFjaCA9PT0gQVJSX0VBQ0gpIHtcbiAgICAgIG9iai5mb3JFYWNoKGl0ciwgc2NvcGUpO1xuICAgIH0gZWxzZSBpZiAob2JqLmxlbmd0aCA9PT0gb2JqLmxlbmd0aCArIDApIHtcbiAgICAgIHZhciBrZXkgPSB2b2lkIDA7XG4gICAgICB2YXIgbCA9IHZvaWQgMDtcbiAgICAgIGZvciAoa2V5ID0gMCwgbCA9IG9iai5sZW5ndGg7IGtleSA8IGw7IGtleSsrKSB7XG4gICAgICAgIGlmIChrZXkgaW4gb2JqICYmIGl0ci5jYWxsKHNjb3BlLCBvYmpba2V5XSwga2V5KSA9PT0gdGhpcy5CUkVBSykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKHZhciBfa2V5IGluIG9iaikge1xuICAgICAgICBpZiAoaXRyLmNhbGwoc2NvcGUsIG9ialtfa2V5XSwgX2tleSkgPT09IHRoaXMuQlJFQUspIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIGRlZmVyOiBmdW5jdGlvbiBkZWZlcihmbmMpIHtcbiAgICBzZXRUaW1lb3V0KGZuYywgMCk7XG4gIH0sXG4gIGRlYm91bmNlOiBmdW5jdGlvbiBkZWJvdW5jZShmdW5jLCB0aHJlc2hvbGQsIGNhbGxJbW1lZGlhdGVseSkge1xuICAgIHZhciB0aW1lb3V0ID0gdm9pZCAwO1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgb2JqID0gdGhpcztcbiAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgZnVuY3Rpb24gZGVsYXllZCgpIHtcbiAgICAgICAgdGltZW91dCA9IG51bGw7XG4gICAgICAgIGlmICghY2FsbEltbWVkaWF0ZWx5KSBmdW5jLmFwcGx5KG9iaiwgYXJncyk7XG4gICAgICB9XG4gICAgICB2YXIgY2FsbE5vdyA9IGNhbGxJbW1lZGlhdGVseSB8fCAhdGltZW91dDtcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGRlbGF5ZWQsIHRocmVzaG9sZCk7XG4gICAgICBpZiAoY2FsbE5vdykge1xuICAgICAgICBmdW5jLmFwcGx5KG9iaiwgYXJncyk7XG4gICAgICB9XG4gICAgfTtcbiAgfSxcbiAgdG9BcnJheTogZnVuY3Rpb24gdG9BcnJheShvYmopIHtcbiAgICBpZiAob2JqLnRvQXJyYXkpIHJldHVybiBvYmoudG9BcnJheSgpO1xuICAgIHJldHVybiBBUlJfU0xJQ0UuY2FsbChvYmopO1xuICB9LFxuICBpc1VuZGVmaW5lZDogZnVuY3Rpb24gaXNVbmRlZmluZWQob2JqKSB7XG4gICAgcmV0dXJuIG9iaiA9PT0gdW5kZWZpbmVkO1xuICB9LFxuICBpc051bGw6IGZ1bmN0aW9uIGlzTnVsbChvYmopIHtcbiAgICByZXR1cm4gb2JqID09PSBudWxsO1xuICB9LFxuICBpc05hTjogZnVuY3Rpb24gKF9pc05hTikge1xuICAgIGZ1bmN0aW9uIGlzTmFOKF94KSB7XG4gICAgICByZXR1cm4gX2lzTmFOLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIGlzTmFOLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIF9pc05hTi50b1N0cmluZygpO1xuICAgIH07XG4gICAgcmV0dXJuIGlzTmFOO1xuICB9KGZ1bmN0aW9uIChvYmopIHtcbiAgICByZXR1cm4gaXNOYU4ob2JqKTtcbiAgfSksXG4gIGlzQXJyYXk6IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKG9iaikge1xuICAgIHJldHVybiBvYmouY29uc3RydWN0b3IgPT09IEFycmF5O1xuICB9LFxuICBpc09iamVjdDogZnVuY3Rpb24gaXNPYmplY3Qob2JqKSB7XG4gICAgcmV0dXJuIG9iaiA9PT0gT2JqZWN0KG9iaik7XG4gIH0sXG4gIGlzTnVtYmVyOiBmdW5jdGlvbiBpc051bWJlcihvYmopIHtcbiAgICByZXR1cm4gb2JqID09PSBvYmogKyAwO1xuICB9LFxuICBpc1N0cmluZzogZnVuY3Rpb24gaXNTdHJpbmcob2JqKSB7XG4gICAgcmV0dXJuIG9iaiA9PT0gb2JqICsgJyc7XG4gIH0sXG4gIGlzQm9vbGVhbjogZnVuY3Rpb24gaXNCb29sZWFuKG9iaikge1xuICAgIHJldHVybiBvYmogPT09IGZhbHNlIHx8IG9iaiA9PT0gdHJ1ZTtcbiAgfSxcbiAgaXNGdW5jdGlvbjogZnVuY3Rpb24gaXNGdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gb2JqIGluc3RhbmNlb2YgRnVuY3Rpb247XG4gIH1cbn07XG5cbnZhciBJTlRFUlBSRVRBVElPTlMgPSBbXG57XG4gIGxpdG11czogQ29tbW9uLmlzU3RyaW5nLFxuICBjb252ZXJzaW9uczoge1xuICAgIFRIUkVFX0NIQVJfSEVYOiB7XG4gICAgICByZWFkOiBmdW5jdGlvbiByZWFkKG9yaWdpbmFsKSB7XG4gICAgICAgIHZhciB0ZXN0ID0gb3JpZ2luYWwubWF0Y2goL14jKFtBLUYwLTldKShbQS1GMC05XSkoW0EtRjAtOV0pJC9pKTtcbiAgICAgICAgaWYgKHRlc3QgPT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBzcGFjZTogJ0hFWCcsXG4gICAgICAgICAgaGV4OiBwYXJzZUludCgnMHgnICsgdGVzdFsxXS50b1N0cmluZygpICsgdGVzdFsxXS50b1N0cmluZygpICsgdGVzdFsyXS50b1N0cmluZygpICsgdGVzdFsyXS50b1N0cmluZygpICsgdGVzdFszXS50b1N0cmluZygpICsgdGVzdFszXS50b1N0cmluZygpLCAwKVxuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgIHdyaXRlOiBjb2xvclRvU3RyaW5nXG4gICAgfSxcbiAgICBTSVhfQ0hBUl9IRVg6IHtcbiAgICAgIHJlYWQ6IGZ1bmN0aW9uIHJlYWQob3JpZ2luYWwpIHtcbiAgICAgICAgdmFyIHRlc3QgPSBvcmlnaW5hbC5tYXRjaCgvXiMoW0EtRjAtOV17Nn0pJC9pKTtcbiAgICAgICAgaWYgKHRlc3QgPT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBzcGFjZTogJ0hFWCcsXG4gICAgICAgICAgaGV4OiBwYXJzZUludCgnMHgnICsgdGVzdFsxXS50b1N0cmluZygpLCAwKVxuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgIHdyaXRlOiBjb2xvclRvU3RyaW5nXG4gICAgfSxcbiAgICBDU1NfUkdCOiB7XG4gICAgICByZWFkOiBmdW5jdGlvbiByZWFkKG9yaWdpbmFsKSB7XG4gICAgICAgIHZhciB0ZXN0ID0gb3JpZ2luYWwubWF0Y2goL15yZ2JcXChcXHMqKC4rKVxccyosXFxzKiguKylcXHMqLFxccyooLispXFxzKlxcKS8pO1xuICAgICAgICBpZiAodGVzdCA9PT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHNwYWNlOiAnUkdCJyxcbiAgICAgICAgICByOiBwYXJzZUZsb2F0KHRlc3RbMV0pLFxuICAgICAgICAgIGc6IHBhcnNlRmxvYXQodGVzdFsyXSksXG4gICAgICAgICAgYjogcGFyc2VGbG9hdCh0ZXN0WzNdKVxuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgIHdyaXRlOiBjb2xvclRvU3RyaW5nXG4gICAgfSxcbiAgICBDU1NfUkdCQToge1xuICAgICAgcmVhZDogZnVuY3Rpb24gcmVhZChvcmlnaW5hbCkge1xuICAgICAgICB2YXIgdGVzdCA9IG9yaWdpbmFsLm1hdGNoKC9ecmdiYVxcKFxccyooLispXFxzKixcXHMqKC4rKVxccyosXFxzKiguKylcXHMqLFxccyooLispXFxzKlxcKS8pO1xuICAgICAgICBpZiAodGVzdCA9PT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHNwYWNlOiAnUkdCJyxcbiAgICAgICAgICByOiBwYXJzZUZsb2F0KHRlc3RbMV0pLFxuICAgICAgICAgIGc6IHBhcnNlRmxvYXQodGVzdFsyXSksXG4gICAgICAgICAgYjogcGFyc2VGbG9hdCh0ZXN0WzNdKSxcbiAgICAgICAgICBhOiBwYXJzZUZsb2F0KHRlc3RbNF0pXG4gICAgICAgIH07XG4gICAgICB9LFxuICAgICAgd3JpdGU6IGNvbG9yVG9TdHJpbmdcbiAgICB9XG4gIH1cbn0sXG57XG4gIGxpdG11czogQ29tbW9uLmlzTnVtYmVyLFxuICBjb252ZXJzaW9uczoge1xuICAgIEhFWDoge1xuICAgICAgcmVhZDogZnVuY3Rpb24gcmVhZChvcmlnaW5hbCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHNwYWNlOiAnSEVYJyxcbiAgICAgICAgICBoZXg6IG9yaWdpbmFsLFxuICAgICAgICAgIGNvbnZlcnNpb25OYW1lOiAnSEVYJ1xuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgIHdyaXRlOiBmdW5jdGlvbiB3cml0ZShjb2xvcikge1xuICAgICAgICByZXR1cm4gY29sb3IuaGV4O1xuICAgICAgfVxuICAgIH1cbiAgfVxufSxcbntcbiAgbGl0bXVzOiBDb21tb24uaXNBcnJheSxcbiAgY29udmVyc2lvbnM6IHtcbiAgICBSR0JfQVJSQVk6IHtcbiAgICAgIHJlYWQ6IGZ1bmN0aW9uIHJlYWQob3JpZ2luYWwpIHtcbiAgICAgICAgaWYgKG9yaWdpbmFsLmxlbmd0aCAhPT0gMykge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHNwYWNlOiAnUkdCJyxcbiAgICAgICAgICByOiBvcmlnaW5hbFswXSxcbiAgICAgICAgICBnOiBvcmlnaW5hbFsxXSxcbiAgICAgICAgICBiOiBvcmlnaW5hbFsyXVxuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgIHdyaXRlOiBmdW5jdGlvbiB3cml0ZShjb2xvcikge1xuICAgICAgICByZXR1cm4gW2NvbG9yLnIsIGNvbG9yLmcsIGNvbG9yLmJdO1xuICAgICAgfVxuICAgIH0sXG4gICAgUkdCQV9BUlJBWToge1xuICAgICAgcmVhZDogZnVuY3Rpb24gcmVhZChvcmlnaW5hbCkge1xuICAgICAgICBpZiAob3JpZ2luYWwubGVuZ3RoICE9PSA0KSByZXR1cm4gZmFsc2U7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgc3BhY2U6ICdSR0InLFxuICAgICAgICAgIHI6IG9yaWdpbmFsWzBdLFxuICAgICAgICAgIGc6IG9yaWdpbmFsWzFdLFxuICAgICAgICAgIGI6IG9yaWdpbmFsWzJdLFxuICAgICAgICAgIGE6IG9yaWdpbmFsWzNdXG4gICAgICAgIH07XG4gICAgICB9LFxuICAgICAgd3JpdGU6IGZ1bmN0aW9uIHdyaXRlKGNvbG9yKSB7XG4gICAgICAgIHJldHVybiBbY29sb3IuciwgY29sb3IuZywgY29sb3IuYiwgY29sb3IuYV07XG4gICAgICB9XG4gICAgfVxuICB9XG59LFxue1xuICBsaXRtdXM6IENvbW1vbi5pc09iamVjdCxcbiAgY29udmVyc2lvbnM6IHtcbiAgICBSR0JBX09CSjoge1xuICAgICAgcmVhZDogZnVuY3Rpb24gcmVhZChvcmlnaW5hbCkge1xuICAgICAgICBpZiAoQ29tbW9uLmlzTnVtYmVyKG9yaWdpbmFsLnIpICYmIENvbW1vbi5pc051bWJlcihvcmlnaW5hbC5nKSAmJiBDb21tb24uaXNOdW1iZXIob3JpZ2luYWwuYikgJiYgQ29tbW9uLmlzTnVtYmVyKG9yaWdpbmFsLmEpKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHNwYWNlOiAnUkdCJyxcbiAgICAgICAgICAgIHI6IG9yaWdpbmFsLnIsXG4gICAgICAgICAgICBnOiBvcmlnaW5hbC5nLFxuICAgICAgICAgICAgYjogb3JpZ2luYWwuYixcbiAgICAgICAgICAgIGE6IG9yaWdpbmFsLmFcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0sXG4gICAgICB3cml0ZTogZnVuY3Rpb24gd3JpdGUoY29sb3IpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICByOiBjb2xvci5yLFxuICAgICAgICAgIGc6IGNvbG9yLmcsXG4gICAgICAgICAgYjogY29sb3IuYixcbiAgICAgICAgICBhOiBjb2xvci5hXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSxcbiAgICBSR0JfT0JKOiB7XG4gICAgICByZWFkOiBmdW5jdGlvbiByZWFkKG9yaWdpbmFsKSB7XG4gICAgICAgIGlmIChDb21tb24uaXNOdW1iZXIob3JpZ2luYWwucikgJiYgQ29tbW9uLmlzTnVtYmVyKG9yaWdpbmFsLmcpICYmIENvbW1vbi5pc051bWJlcihvcmlnaW5hbC5iKSkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzcGFjZTogJ1JHQicsXG4gICAgICAgICAgICByOiBvcmlnaW5hbC5yLFxuICAgICAgICAgICAgZzogb3JpZ2luYWwuZyxcbiAgICAgICAgICAgIGI6IG9yaWdpbmFsLmJcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0sXG4gICAgICB3cml0ZTogZnVuY3Rpb24gd3JpdGUoY29sb3IpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICByOiBjb2xvci5yLFxuICAgICAgICAgIGc6IGNvbG9yLmcsXG4gICAgICAgICAgYjogY29sb3IuYlxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0sXG4gICAgSFNWQV9PQko6IHtcbiAgICAgIHJlYWQ6IGZ1bmN0aW9uIHJlYWQob3JpZ2luYWwpIHtcbiAgICAgICAgaWYgKENvbW1vbi5pc051bWJlcihvcmlnaW5hbC5oKSAmJiBDb21tb24uaXNOdW1iZXIob3JpZ2luYWwucykgJiYgQ29tbW9uLmlzTnVtYmVyKG9yaWdpbmFsLnYpICYmIENvbW1vbi5pc051bWJlcihvcmlnaW5hbC5hKSkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzcGFjZTogJ0hTVicsXG4gICAgICAgICAgICBoOiBvcmlnaW5hbC5oLFxuICAgICAgICAgICAgczogb3JpZ2luYWwucyxcbiAgICAgICAgICAgIHY6IG9yaWdpbmFsLnYsXG4gICAgICAgICAgICBhOiBvcmlnaW5hbC5hXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9LFxuICAgICAgd3JpdGU6IGZ1bmN0aW9uIHdyaXRlKGNvbG9yKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgaDogY29sb3IuaCxcbiAgICAgICAgICBzOiBjb2xvci5zLFxuICAgICAgICAgIHY6IGNvbG9yLnYsXG4gICAgICAgICAgYTogY29sb3IuYVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0sXG4gICAgSFNWX09CSjoge1xuICAgICAgcmVhZDogZnVuY3Rpb24gcmVhZChvcmlnaW5hbCkge1xuICAgICAgICBpZiAoQ29tbW9uLmlzTnVtYmVyKG9yaWdpbmFsLmgpICYmIENvbW1vbi5pc051bWJlcihvcmlnaW5hbC5zKSAmJiBDb21tb24uaXNOdW1iZXIob3JpZ2luYWwudikpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3BhY2U6ICdIU1YnLFxuICAgICAgICAgICAgaDogb3JpZ2luYWwuaCxcbiAgICAgICAgICAgIHM6IG9yaWdpbmFsLnMsXG4gICAgICAgICAgICB2OiBvcmlnaW5hbC52XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9LFxuICAgICAgd3JpdGU6IGZ1bmN0aW9uIHdyaXRlKGNvbG9yKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgaDogY29sb3IuaCxcbiAgICAgICAgICBzOiBjb2xvci5zLFxuICAgICAgICAgIHY6IGNvbG9yLnZcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1dO1xudmFyIHJlc3VsdCA9IHZvaWQgMDtcbnZhciB0b1JldHVybiA9IHZvaWQgMDtcbnZhciBpbnRlcnByZXQgPSBmdW5jdGlvbiBpbnRlcnByZXQoKSB7XG4gIHRvUmV0dXJuID0gZmFsc2U7XG4gIHZhciBvcmlnaW5hbCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxID8gQ29tbW9uLnRvQXJyYXkoYXJndW1lbnRzKSA6IGFyZ3VtZW50c1swXTtcbiAgQ29tbW9uLmVhY2goSU5URVJQUkVUQVRJT05TLCBmdW5jdGlvbiAoZmFtaWx5KSB7XG4gICAgaWYgKGZhbWlseS5saXRtdXMob3JpZ2luYWwpKSB7XG4gICAgICBDb21tb24uZWFjaChmYW1pbHkuY29udmVyc2lvbnMsIGZ1bmN0aW9uIChjb252ZXJzaW9uLCBjb252ZXJzaW9uTmFtZSkge1xuICAgICAgICByZXN1bHQgPSBjb252ZXJzaW9uLnJlYWQob3JpZ2luYWwpO1xuICAgICAgICBpZiAodG9SZXR1cm4gPT09IGZhbHNlICYmIHJlc3VsdCAhPT0gZmFsc2UpIHtcbiAgICAgICAgICB0b1JldHVybiA9IHJlc3VsdDtcbiAgICAgICAgICByZXN1bHQuY29udmVyc2lvbk5hbWUgPSBjb252ZXJzaW9uTmFtZTtcbiAgICAgICAgICByZXN1bHQuY29udmVyc2lvbiA9IGNvbnZlcnNpb247XG4gICAgICAgICAgcmV0dXJuIENvbW1vbi5CUkVBSztcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gQ29tbW9uLkJSRUFLO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiB0b1JldHVybjtcbn07XG5cbnZhciB0bXBDb21wb25lbnQgPSB2b2lkIDA7XG52YXIgQ29sb3JNYXRoID0ge1xuICBoc3ZfdG9fcmdiOiBmdW5jdGlvbiBoc3ZfdG9fcmdiKGgsIHMsIHYpIHtcbiAgICB2YXIgaGkgPSBNYXRoLmZsb29yKGggLyA2MCkgJSA2O1xuICAgIHZhciBmID0gaCAvIDYwIC0gTWF0aC5mbG9vcihoIC8gNjApO1xuICAgIHZhciBwID0gdiAqICgxLjAgLSBzKTtcbiAgICB2YXIgcSA9IHYgKiAoMS4wIC0gZiAqIHMpO1xuICAgIHZhciB0ID0gdiAqICgxLjAgLSAoMS4wIC0gZikgKiBzKTtcbiAgICB2YXIgYyA9IFtbdiwgdCwgcF0sIFtxLCB2LCBwXSwgW3AsIHYsIHRdLCBbcCwgcSwgdl0sIFt0LCBwLCB2XSwgW3YsIHAsIHFdXVtoaV07XG4gICAgcmV0dXJuIHtcbiAgICAgIHI6IGNbMF0gKiAyNTUsXG4gICAgICBnOiBjWzFdICogMjU1LFxuICAgICAgYjogY1syXSAqIDI1NVxuICAgIH07XG4gIH0sXG4gIHJnYl90b19oc3Y6IGZ1bmN0aW9uIHJnYl90b19oc3YociwgZywgYikge1xuICAgIHZhciBtaW4gPSBNYXRoLm1pbihyLCBnLCBiKTtcbiAgICB2YXIgbWF4ID0gTWF0aC5tYXgociwgZywgYik7XG4gICAgdmFyIGRlbHRhID0gbWF4IC0gbWluO1xuICAgIHZhciBoID0gdm9pZCAwO1xuICAgIHZhciBzID0gdm9pZCAwO1xuICAgIGlmIChtYXggIT09IDApIHtcbiAgICAgIHMgPSBkZWx0YSAvIG1heDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaDogTmFOLFxuICAgICAgICBzOiAwLFxuICAgICAgICB2OiAwXG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAociA9PT0gbWF4KSB7XG4gICAgICBoID0gKGcgLSBiKSAvIGRlbHRhO1xuICAgIH0gZWxzZSBpZiAoZyA9PT0gbWF4KSB7XG4gICAgICBoID0gMiArIChiIC0gcikgLyBkZWx0YTtcbiAgICB9IGVsc2Uge1xuICAgICAgaCA9IDQgKyAociAtIGcpIC8gZGVsdGE7XG4gICAgfVxuICAgIGggLz0gNjtcbiAgICBpZiAoaCA8IDApIHtcbiAgICAgIGggKz0gMTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIGg6IGggKiAzNjAsXG4gICAgICBzOiBzLFxuICAgICAgdjogbWF4IC8gMjU1XG4gICAgfTtcbiAgfSxcbiAgcmdiX3RvX2hleDogZnVuY3Rpb24gcmdiX3RvX2hleChyLCBnLCBiKSB7XG4gICAgdmFyIGhleCA9IHRoaXMuaGV4X3dpdGhfY29tcG9uZW50KDAsIDIsIHIpO1xuICAgIGhleCA9IHRoaXMuaGV4X3dpdGhfY29tcG9uZW50KGhleCwgMSwgZyk7XG4gICAgaGV4ID0gdGhpcy5oZXhfd2l0aF9jb21wb25lbnQoaGV4LCAwLCBiKTtcbiAgICByZXR1cm4gaGV4O1xuICB9LFxuICBjb21wb25lbnRfZnJvbV9oZXg6IGZ1bmN0aW9uIGNvbXBvbmVudF9mcm9tX2hleChoZXgsIGNvbXBvbmVudEluZGV4KSB7XG4gICAgcmV0dXJuIGhleCA+PiBjb21wb25lbnRJbmRleCAqIDggJiAweEZGO1xuICB9LFxuICBoZXhfd2l0aF9jb21wb25lbnQ6IGZ1bmN0aW9uIGhleF93aXRoX2NvbXBvbmVudChoZXgsIGNvbXBvbmVudEluZGV4LCB2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSA8PCAodG1wQ29tcG9uZW50ID0gY29tcG9uZW50SW5kZXggKiA4KSB8IGhleCAmIH4oMHhGRiA8PCB0bXBDb21wb25lbnQpO1xuICB9XG59O1xuXG52YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikge1xuICByZXR1cm4gdHlwZW9mIG9iajtcbn0gOiBmdW5jdGlvbiAob2JqKSB7XG4gIHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqO1xufTtcblxuXG5cblxuXG5cblxuXG5cblxuXG52YXIgY2xhc3NDYWxsQ2hlY2sgPSBmdW5jdGlvbiAoaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgfVxufTtcblxudmFyIGNyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuICAgICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xuICAgICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICAgIGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG4gICAgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG4gICAgcmV0dXJuIENvbnN0cnVjdG9yO1xuICB9O1xufSgpO1xuXG5cblxuXG5cblxuXG52YXIgZ2V0ID0gZnVuY3Rpb24gZ2V0KG9iamVjdCwgcHJvcGVydHksIHJlY2VpdmVyKSB7XG4gIGlmIChvYmplY3QgPT09IG51bGwpIG9iamVjdCA9IEZ1bmN0aW9uLnByb3RvdHlwZTtcbiAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgcHJvcGVydHkpO1xuXG4gIGlmIChkZXNjID09PSB1bmRlZmluZWQpIHtcbiAgICB2YXIgcGFyZW50ID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iamVjdCk7XG5cbiAgICBpZiAocGFyZW50ID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZ2V0KHBhcmVudCwgcHJvcGVydHksIHJlY2VpdmVyKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoXCJ2YWx1ZVwiIGluIGRlc2MpIHtcbiAgICByZXR1cm4gZGVzYy52YWx1ZTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgZ2V0dGVyID0gZGVzYy5nZXQ7XG5cbiAgICBpZiAoZ2V0dGVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIGdldHRlci5jYWxsKHJlY2VpdmVyKTtcbiAgfVxufTtcblxudmFyIGluaGVyaXRzID0gZnVuY3Rpb24gKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7XG4gIGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTtcbiAgfVxuXG4gIHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwge1xuICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICB2YWx1ZTogc3ViQ2xhc3MsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfVxuICB9KTtcbiAgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzO1xufTtcblxuXG5cblxuXG5cblxuXG5cblxuXG52YXIgcG9zc2libGVDb25zdHJ1Y3RvclJldHVybiA9IGZ1bmN0aW9uIChzZWxmLCBjYWxsKSB7XG4gIGlmICghc2VsZikge1xuICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtcbiAgfVxuXG4gIHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmO1xufTtcblxudmFyIENvbG9yID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBDb2xvcigpIHtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBDb2xvcik7XG4gICAgdGhpcy5fX3N0YXRlID0gaW50ZXJwcmV0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgaWYgKHRoaXMuX19zdGF0ZSA9PT0gZmFsc2UpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIGludGVycHJldCBjb2xvciBhcmd1bWVudHMnKTtcbiAgICB9XG4gICAgdGhpcy5fX3N0YXRlLmEgPSB0aGlzLl9fc3RhdGUuYSB8fCAxO1xuICB9XG4gIGNyZWF0ZUNsYXNzKENvbG9yLCBbe1xuICAgIGtleTogJ3RvU3RyaW5nJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICByZXR1cm4gY29sb3JUb1N0cmluZyh0aGlzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICd0b0hleFN0cmluZycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvSGV4U3RyaW5nKCkge1xuICAgICAgcmV0dXJuIGNvbG9yVG9TdHJpbmcodGhpcywgdHJ1ZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAndG9PcmlnaW5hbCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvT3JpZ2luYWwoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fX3N0YXRlLmNvbnZlcnNpb24ud3JpdGUodGhpcyk7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBDb2xvcjtcbn0oKTtcbmZ1bmN0aW9uIGRlZmluZVJHQkNvbXBvbmVudCh0YXJnZXQsIGNvbXBvbmVudCwgY29tcG9uZW50SGV4SW5kZXgpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgY29tcG9uZW50LCB7XG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQkJDEoKSB7XG4gICAgICBpZiAodGhpcy5fX3N0YXRlLnNwYWNlID09PSAnUkdCJykge1xuICAgICAgICByZXR1cm4gdGhpcy5fX3N0YXRlW2NvbXBvbmVudF07XG4gICAgICB9XG4gICAgICBDb2xvci5yZWNhbGN1bGF0ZVJHQih0aGlzLCBjb21wb25lbnQsIGNvbXBvbmVudEhleEluZGV4KTtcbiAgICAgIHJldHVybiB0aGlzLl9fc3RhdGVbY29tcG9uZW50XTtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gc2V0JCQxKHYpIHtcbiAgICAgIGlmICh0aGlzLl9fc3RhdGUuc3BhY2UgIT09ICdSR0InKSB7XG4gICAgICAgIENvbG9yLnJlY2FsY3VsYXRlUkdCKHRoaXMsIGNvbXBvbmVudCwgY29tcG9uZW50SGV4SW5kZXgpO1xuICAgICAgICB0aGlzLl9fc3RhdGUuc3BhY2UgPSAnUkdCJztcbiAgICAgIH1cbiAgICAgIHRoaXMuX19zdGF0ZVtjb21wb25lbnRdID0gdjtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gZGVmaW5lSFNWQ29tcG9uZW50KHRhcmdldCwgY29tcG9uZW50KSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGNvbXBvbmVudCwge1xuICAgIGdldDogZnVuY3Rpb24gZ2V0JCQxKCkge1xuICAgICAgaWYgKHRoaXMuX19zdGF0ZS5zcGFjZSA9PT0gJ0hTVicpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX19zdGF0ZVtjb21wb25lbnRdO1xuICAgICAgfVxuICAgICAgQ29sb3IucmVjYWxjdWxhdGVIU1YodGhpcyk7XG4gICAgICByZXR1cm4gdGhpcy5fX3N0YXRlW2NvbXBvbmVudF07XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldCQkMSh2KSB7XG4gICAgICBpZiAodGhpcy5fX3N0YXRlLnNwYWNlICE9PSAnSFNWJykge1xuICAgICAgICBDb2xvci5yZWNhbGN1bGF0ZUhTVih0aGlzKTtcbiAgICAgICAgdGhpcy5fX3N0YXRlLnNwYWNlID0gJ0hTVic7XG4gICAgICB9XG4gICAgICB0aGlzLl9fc3RhdGVbY29tcG9uZW50XSA9IHY7XG4gICAgfVxuICB9KTtcbn1cbkNvbG9yLnJlY2FsY3VsYXRlUkdCID0gZnVuY3Rpb24gKGNvbG9yLCBjb21wb25lbnQsIGNvbXBvbmVudEhleEluZGV4KSB7XG4gIGlmIChjb2xvci5fX3N0YXRlLnNwYWNlID09PSAnSEVYJykge1xuICAgIGNvbG9yLl9fc3RhdGVbY29tcG9uZW50XSA9IENvbG9yTWF0aC5jb21wb25lbnRfZnJvbV9oZXgoY29sb3IuX19zdGF0ZS5oZXgsIGNvbXBvbmVudEhleEluZGV4KTtcbiAgfSBlbHNlIGlmIChjb2xvci5fX3N0YXRlLnNwYWNlID09PSAnSFNWJykge1xuICAgIENvbW1vbi5leHRlbmQoY29sb3IuX19zdGF0ZSwgQ29sb3JNYXRoLmhzdl90b19yZ2IoY29sb3IuX19zdGF0ZS5oLCBjb2xvci5fX3N0YXRlLnMsIGNvbG9yLl9fc3RhdGUudikpO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcignQ29ycnVwdGVkIGNvbG9yIHN0YXRlJyk7XG4gIH1cbn07XG5Db2xvci5yZWNhbGN1bGF0ZUhTViA9IGZ1bmN0aW9uIChjb2xvcikge1xuICB2YXIgcmVzdWx0ID0gQ29sb3JNYXRoLnJnYl90b19oc3YoY29sb3IuciwgY29sb3IuZywgY29sb3IuYik7XG4gIENvbW1vbi5leHRlbmQoY29sb3IuX19zdGF0ZSwge1xuICAgIHM6IHJlc3VsdC5zLFxuICAgIHY6IHJlc3VsdC52XG4gIH0pO1xuICBpZiAoIUNvbW1vbi5pc05hTihyZXN1bHQuaCkpIHtcbiAgICBjb2xvci5fX3N0YXRlLmggPSByZXN1bHQuaDtcbiAgfSBlbHNlIGlmIChDb21tb24uaXNVbmRlZmluZWQoY29sb3IuX19zdGF0ZS5oKSkge1xuICAgIGNvbG9yLl9fc3RhdGUuaCA9IDA7XG4gIH1cbn07XG5Db2xvci5DT01QT05FTlRTID0gWydyJywgJ2cnLCAnYicsICdoJywgJ3MnLCAndicsICdoZXgnLCAnYSddO1xuZGVmaW5lUkdCQ29tcG9uZW50KENvbG9yLnByb3RvdHlwZSwgJ3InLCAyKTtcbmRlZmluZVJHQkNvbXBvbmVudChDb2xvci5wcm90b3R5cGUsICdnJywgMSk7XG5kZWZpbmVSR0JDb21wb25lbnQoQ29sb3IucHJvdG90eXBlLCAnYicsIDApO1xuZGVmaW5lSFNWQ29tcG9uZW50KENvbG9yLnByb3RvdHlwZSwgJ2gnKTtcbmRlZmluZUhTVkNvbXBvbmVudChDb2xvci5wcm90b3R5cGUsICdzJyk7XG5kZWZpbmVIU1ZDb21wb25lbnQoQ29sb3IucHJvdG90eXBlLCAndicpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbG9yLnByb3RvdHlwZSwgJ2EnLCB7XG4gIGdldDogZnVuY3Rpb24gZ2V0JCQxKCkge1xuICAgIHJldHVybiB0aGlzLl9fc3RhdGUuYTtcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbiBzZXQkJDEodikge1xuICAgIHRoaXMuX19zdGF0ZS5hID0gdjtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoQ29sb3IucHJvdG90eXBlLCAnaGV4Jywge1xuICBnZXQ6IGZ1bmN0aW9uIGdldCQkMSgpIHtcbiAgICBpZiAodGhpcy5fX3N0YXRlLnNwYWNlICE9PSAnSEVYJykge1xuICAgICAgdGhpcy5fX3N0YXRlLmhleCA9IENvbG9yTWF0aC5yZ2JfdG9faGV4KHRoaXMuciwgdGhpcy5nLCB0aGlzLmIpO1xuICAgICAgdGhpcy5fX3N0YXRlLnNwYWNlID0gJ0hFWCc7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9fc3RhdGUuaGV4O1xuICB9LFxuICBzZXQ6IGZ1bmN0aW9uIHNldCQkMSh2KSB7XG4gICAgdGhpcy5fX3N0YXRlLnNwYWNlID0gJ0hFWCc7XG4gICAgdGhpcy5fX3N0YXRlLmhleCA9IHY7XG4gIH1cbn0pO1xuXG52YXIgQ29udHJvbGxlciA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQ29udHJvbGxlcihvYmplY3QsIHByb3BlcnR5KSB7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgQ29udHJvbGxlcik7XG4gICAgdGhpcy5pbml0aWFsVmFsdWUgPSBvYmplY3RbcHJvcGVydHldO1xuICAgIHRoaXMuZG9tRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIHRoaXMub2JqZWN0ID0gb2JqZWN0O1xuICAgIHRoaXMucHJvcGVydHkgPSBwcm9wZXJ0eTtcbiAgICB0aGlzLl9fb25DaGFuZ2UgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fX29uRmluaXNoQ2hhbmdlID0gdW5kZWZpbmVkO1xuICB9XG4gIGNyZWF0ZUNsYXNzKENvbnRyb2xsZXIsIFt7XG4gICAga2V5OiAnb25DaGFuZ2UnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbkNoYW5nZShmbmMpIHtcbiAgICAgIHRoaXMuX19vbkNoYW5nZSA9IGZuYztcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ29uRmluaXNoQ2hhbmdlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25GaW5pc2hDaGFuZ2UoZm5jKSB7XG4gICAgICB0aGlzLl9fb25GaW5pc2hDaGFuZ2UgPSBmbmM7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdzZXRWYWx1ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldFZhbHVlKG5ld1ZhbHVlKSB7XG4gICAgICB0aGlzLm9iamVjdFt0aGlzLnByb3BlcnR5XSA9IG5ld1ZhbHVlO1xuICAgICAgaWYgKHRoaXMuX19vbkNoYW5nZSkge1xuICAgICAgICB0aGlzLl9fb25DaGFuZ2UuY2FsbCh0aGlzLCBuZXdWYWx1ZSk7XG4gICAgICB9XG4gICAgICB0aGlzLnVwZGF0ZURpc3BsYXkoKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2dldFZhbHVlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0VmFsdWUoKSB7XG4gICAgICByZXR1cm4gdGhpcy5vYmplY3RbdGhpcy5wcm9wZXJ0eV07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAndXBkYXRlRGlzcGxheScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZURpc3BsYXkoKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdpc01vZGlmaWVkJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gaXNNb2RpZmllZCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmluaXRpYWxWYWx1ZSAhPT0gdGhpcy5nZXRWYWx1ZSgpO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gQ29udHJvbGxlcjtcbn0oKTtcblxudmFyIEVWRU5UX01BUCA9IHtcbiAgSFRNTEV2ZW50czogWydjaGFuZ2UnXSxcbiAgTW91c2VFdmVudHM6IFsnY2xpY2snLCAnbW91c2Vtb3ZlJywgJ21vdXNlZG93bicsICdtb3VzZXVwJywgJ21vdXNlb3ZlciddLFxuICBLZXlib2FyZEV2ZW50czogWydrZXlkb3duJ11cbn07XG52YXIgRVZFTlRfTUFQX0lOViA9IHt9O1xuQ29tbW9uLmVhY2goRVZFTlRfTUFQLCBmdW5jdGlvbiAodiwgaykge1xuICBDb21tb24uZWFjaCh2LCBmdW5jdGlvbiAoZSkge1xuICAgIEVWRU5UX01BUF9JTlZbZV0gPSBrO1xuICB9KTtcbn0pO1xudmFyIENTU19WQUxVRV9QSVhFTFMgPSAvKFxcZCsoXFwuXFxkKyk/KXB4LztcbmZ1bmN0aW9uIGNzc1ZhbHVlVG9QaXhlbHModmFsKSB7XG4gIGlmICh2YWwgPT09ICcwJyB8fCBDb21tb24uaXNVbmRlZmluZWQodmFsKSkge1xuICAgIHJldHVybiAwO1xuICB9XG4gIHZhciBtYXRjaCA9IHZhbC5tYXRjaChDU1NfVkFMVUVfUElYRUxTKTtcbiAgaWYgKCFDb21tb24uaXNOdWxsKG1hdGNoKSkge1xuICAgIHJldHVybiBwYXJzZUZsb2F0KG1hdGNoWzFdKTtcbiAgfVxuICByZXR1cm4gMDtcbn1cbnZhciBkb20gPSB7XG4gIG1ha2VTZWxlY3RhYmxlOiBmdW5jdGlvbiBtYWtlU2VsZWN0YWJsZShlbGVtLCBzZWxlY3RhYmxlKSB7XG4gICAgaWYgKGVsZW0gPT09IHVuZGVmaW5lZCB8fCBlbGVtLnN0eWxlID09PSB1bmRlZmluZWQpIHJldHVybjtcbiAgICBlbGVtLm9uc2VsZWN0c3RhcnQgPSBzZWxlY3RhYmxlID8gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gOiBmdW5jdGlvbiAoKSB7fTtcbiAgICBlbGVtLnN0eWxlLk1velVzZXJTZWxlY3QgPSBzZWxlY3RhYmxlID8gJ2F1dG8nIDogJ25vbmUnO1xuICAgIGVsZW0uc3R5bGUuS2h0bWxVc2VyU2VsZWN0ID0gc2VsZWN0YWJsZSA/ICdhdXRvJyA6ICdub25lJztcbiAgICBlbGVtLnVuc2VsZWN0YWJsZSA9IHNlbGVjdGFibGUgPyAnb24nIDogJ29mZic7XG4gIH0sXG4gIG1ha2VGdWxsc2NyZWVuOiBmdW5jdGlvbiBtYWtlRnVsbHNjcmVlbihlbGVtLCBob3IsIHZlcnQpIHtcbiAgICB2YXIgdmVydGljYWwgPSB2ZXJ0O1xuICAgIHZhciBob3Jpem9udGFsID0gaG9yO1xuICAgIGlmIChDb21tb24uaXNVbmRlZmluZWQoaG9yaXpvbnRhbCkpIHtcbiAgICAgIGhvcml6b250YWwgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAoQ29tbW9uLmlzVW5kZWZpbmVkKHZlcnRpY2FsKSkge1xuICAgICAgdmVydGljYWwgPSB0cnVlO1xuICAgIH1cbiAgICBlbGVtLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICBpZiAoaG9yaXpvbnRhbCkge1xuICAgICAgZWxlbS5zdHlsZS5sZWZ0ID0gMDtcbiAgICAgIGVsZW0uc3R5bGUucmlnaHQgPSAwO1xuICAgIH1cbiAgICBpZiAodmVydGljYWwpIHtcbiAgICAgIGVsZW0uc3R5bGUudG9wID0gMDtcbiAgICAgIGVsZW0uc3R5bGUuYm90dG9tID0gMDtcbiAgICB9XG4gIH0sXG4gIGZha2VFdmVudDogZnVuY3Rpb24gZmFrZUV2ZW50KGVsZW0sIGV2ZW50VHlwZSwgcGFycywgYXV4KSB7XG4gICAgdmFyIHBhcmFtcyA9IHBhcnMgfHwge307XG4gICAgdmFyIGNsYXNzTmFtZSA9IEVWRU5UX01BUF9JTlZbZXZlbnRUeXBlXTtcbiAgICBpZiAoIWNsYXNzTmFtZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdFdmVudCB0eXBlICcgKyBldmVudFR5cGUgKyAnIG5vdCBzdXBwb3J0ZWQuJyk7XG4gICAgfVxuICAgIHZhciBldnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudChjbGFzc05hbWUpO1xuICAgIHN3aXRjaCAoY2xhc3NOYW1lKSB7XG4gICAgICBjYXNlICdNb3VzZUV2ZW50cyc6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgY2xpZW50WCA9IHBhcmFtcy54IHx8IHBhcmFtcy5jbGllbnRYIHx8IDA7XG4gICAgICAgICAgdmFyIGNsaWVudFkgPSBwYXJhbXMueSB8fCBwYXJhbXMuY2xpZW50WSB8fCAwO1xuICAgICAgICAgIGV2dC5pbml0TW91c2VFdmVudChldmVudFR5cGUsIHBhcmFtcy5idWJibGVzIHx8IGZhbHNlLCBwYXJhbXMuY2FuY2VsYWJsZSB8fCB0cnVlLCB3aW5kb3csIHBhcmFtcy5jbGlja0NvdW50IHx8IDEsIDAsXG4gICAgICAgICAgMCxcbiAgICAgICAgICBjbGllbnRYLFxuICAgICAgICAgIGNsaWVudFksXG4gICAgICAgICAgZmFsc2UsIGZhbHNlLCBmYWxzZSwgZmFsc2UsIDAsIG51bGwpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICBjYXNlICdLZXlib2FyZEV2ZW50cyc6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgaW5pdCA9IGV2dC5pbml0S2V5Ym9hcmRFdmVudCB8fCBldnQuaW5pdEtleUV2ZW50O1xuICAgICAgICAgIENvbW1vbi5kZWZhdWx0cyhwYXJhbXMsIHtcbiAgICAgICAgICAgIGNhbmNlbGFibGU6IHRydWUsXG4gICAgICAgICAgICBjdHJsS2V5OiBmYWxzZSxcbiAgICAgICAgICAgIGFsdEtleTogZmFsc2UsXG4gICAgICAgICAgICBzaGlmdEtleTogZmFsc2UsXG4gICAgICAgICAgICBtZXRhS2V5OiBmYWxzZSxcbiAgICAgICAgICAgIGtleUNvZGU6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGNoYXJDb2RlOiB1bmRlZmluZWRcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBpbml0KGV2ZW50VHlwZSwgcGFyYW1zLmJ1YmJsZXMgfHwgZmFsc2UsIHBhcmFtcy5jYW5jZWxhYmxlLCB3aW5kb3csIHBhcmFtcy5jdHJsS2V5LCBwYXJhbXMuYWx0S2V5LCBwYXJhbXMuc2hpZnRLZXksIHBhcmFtcy5tZXRhS2V5LCBwYXJhbXMua2V5Q29kZSwgcGFyYW1zLmNoYXJDb2RlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgZGVmYXVsdDpcbiAgICAgICAge1xuICAgICAgICAgIGV2dC5pbml0RXZlbnQoZXZlbnRUeXBlLCBwYXJhbXMuYnViYmxlcyB8fCBmYWxzZSwgcGFyYW1zLmNhbmNlbGFibGUgfHwgdHJ1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgQ29tbW9uLmRlZmF1bHRzKGV2dCwgYXV4KTtcbiAgICBlbGVtLmRpc3BhdGNoRXZlbnQoZXZ0KTtcbiAgfSxcbiAgYmluZDogZnVuY3Rpb24gYmluZChlbGVtLCBldmVudCwgZnVuYywgbmV3Qm9vbCkge1xuICAgIHZhciBib29sID0gbmV3Qm9vbCB8fCBmYWxzZTtcbiAgICBpZiAoZWxlbS5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgICBlbGVtLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGZ1bmMsIGJvb2wpO1xuICAgIH0gZWxzZSBpZiAoZWxlbS5hdHRhY2hFdmVudCkge1xuICAgICAgZWxlbS5hdHRhY2hFdmVudCgnb24nICsgZXZlbnQsIGZ1bmMpO1xuICAgIH1cbiAgICByZXR1cm4gZG9tO1xuICB9LFxuICB1bmJpbmQ6IGZ1bmN0aW9uIHVuYmluZChlbGVtLCBldmVudCwgZnVuYywgbmV3Qm9vbCkge1xuICAgIHZhciBib29sID0gbmV3Qm9vbCB8fCBmYWxzZTtcbiAgICBpZiAoZWxlbS5yZW1vdmVFdmVudExpc3RlbmVyKSB7XG4gICAgICBlbGVtLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIGZ1bmMsIGJvb2wpO1xuICAgIH0gZWxzZSBpZiAoZWxlbS5kZXRhY2hFdmVudCkge1xuICAgICAgZWxlbS5kZXRhY2hFdmVudCgnb24nICsgZXZlbnQsIGZ1bmMpO1xuICAgIH1cbiAgICByZXR1cm4gZG9tO1xuICB9LFxuICBhZGRDbGFzczogZnVuY3Rpb24gYWRkQ2xhc3MoZWxlbSwgY2xhc3NOYW1lKSB7XG4gICAgaWYgKGVsZW0uY2xhc3NOYW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGVsZW0uY2xhc3NOYW1lID0gY2xhc3NOYW1lO1xuICAgIH0gZWxzZSBpZiAoZWxlbS5jbGFzc05hbWUgIT09IGNsYXNzTmFtZSkge1xuICAgICAgdmFyIGNsYXNzZXMgPSBlbGVtLmNsYXNzTmFtZS5zcGxpdCgvICsvKTtcbiAgICAgIGlmIChjbGFzc2VzLmluZGV4T2YoY2xhc3NOYW1lKSA9PT0gLTEpIHtcbiAgICAgICAgY2xhc3Nlcy5wdXNoKGNsYXNzTmFtZSk7XG4gICAgICAgIGVsZW0uY2xhc3NOYW1lID0gY2xhc3Nlcy5qb2luKCcgJykucmVwbGFjZSgvXlxccysvLCAnJykucmVwbGFjZSgvXFxzKyQvLCAnJyk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkb207XG4gIH0sXG4gIHJlbW92ZUNsYXNzOiBmdW5jdGlvbiByZW1vdmVDbGFzcyhlbGVtLCBjbGFzc05hbWUpIHtcbiAgICBpZiAoY2xhc3NOYW1lKSB7XG4gICAgICBpZiAoZWxlbS5jbGFzc05hbWUgPT09IGNsYXNzTmFtZSkge1xuICAgICAgICBlbGVtLnJlbW92ZUF0dHJpYnV0ZSgnY2xhc3MnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBjbGFzc2VzID0gZWxlbS5jbGFzc05hbWUuc3BsaXQoLyArLyk7XG4gICAgICAgIHZhciBpbmRleCA9IGNsYXNzZXMuaW5kZXhPZihjbGFzc05hbWUpO1xuICAgICAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgY2xhc3Nlcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgIGVsZW0uY2xhc3NOYW1lID0gY2xhc3Nlcy5qb2luKCcgJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZWxlbS5jbGFzc05hbWUgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHJldHVybiBkb207XG4gIH0sXG4gIGhhc0NsYXNzOiBmdW5jdGlvbiBoYXNDbGFzcyhlbGVtLCBjbGFzc05hbWUpIHtcbiAgICByZXR1cm4gbmV3IFJlZ0V4cCgnKD86XnxcXFxccyspJyArIGNsYXNzTmFtZSArICcoPzpcXFxccyt8JCknKS50ZXN0KGVsZW0uY2xhc3NOYW1lKSB8fCBmYWxzZTtcbiAgfSxcbiAgZ2V0V2lkdGg6IGZ1bmN0aW9uIGdldFdpZHRoKGVsZW0pIHtcbiAgICB2YXIgc3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKGVsZW0pO1xuICAgIHJldHVybiBjc3NWYWx1ZVRvUGl4ZWxzKHN0eWxlWydib3JkZXItbGVmdC13aWR0aCddKSArIGNzc1ZhbHVlVG9QaXhlbHMoc3R5bGVbJ2JvcmRlci1yaWdodC13aWR0aCddKSArIGNzc1ZhbHVlVG9QaXhlbHMoc3R5bGVbJ3BhZGRpbmctbGVmdCddKSArIGNzc1ZhbHVlVG9QaXhlbHMoc3R5bGVbJ3BhZGRpbmctcmlnaHQnXSkgKyBjc3NWYWx1ZVRvUGl4ZWxzKHN0eWxlLndpZHRoKTtcbiAgfSxcbiAgZ2V0SGVpZ2h0OiBmdW5jdGlvbiBnZXRIZWlnaHQoZWxlbSkge1xuICAgIHZhciBzdHlsZSA9IGdldENvbXB1dGVkU3R5bGUoZWxlbSk7XG4gICAgcmV0dXJuIGNzc1ZhbHVlVG9QaXhlbHMoc3R5bGVbJ2JvcmRlci10b3Atd2lkdGgnXSkgKyBjc3NWYWx1ZVRvUGl4ZWxzKHN0eWxlWydib3JkZXItYm90dG9tLXdpZHRoJ10pICsgY3NzVmFsdWVUb1BpeGVscyhzdHlsZVsncGFkZGluZy10b3AnXSkgKyBjc3NWYWx1ZVRvUGl4ZWxzKHN0eWxlWydwYWRkaW5nLWJvdHRvbSddKSArIGNzc1ZhbHVlVG9QaXhlbHMoc3R5bGUuaGVpZ2h0KTtcbiAgfSxcbiAgZ2V0T2Zmc2V0OiBmdW5jdGlvbiBnZXRPZmZzZXQoZWwpIHtcbiAgICB2YXIgZWxlbSA9IGVsO1xuICAgIHZhciBvZmZzZXQgPSB7IGxlZnQ6IDAsIHRvcDogMCB9O1xuICAgIGlmIChlbGVtLm9mZnNldFBhcmVudCkge1xuICAgICAgZG8ge1xuICAgICAgICBvZmZzZXQubGVmdCArPSBlbGVtLm9mZnNldExlZnQ7XG4gICAgICAgIG9mZnNldC50b3AgKz0gZWxlbS5vZmZzZXRUb3A7XG4gICAgICAgIGVsZW0gPSBlbGVtLm9mZnNldFBhcmVudDtcbiAgICAgIH0gd2hpbGUgKGVsZW0pO1xuICAgIH1cbiAgICByZXR1cm4gb2Zmc2V0O1xuICB9LFxuICBpc0FjdGl2ZTogZnVuY3Rpb24gaXNBY3RpdmUoZWxlbSkge1xuICAgIHJldHVybiBlbGVtID09PSBkb2N1bWVudC5hY3RpdmVFbGVtZW50ICYmIChlbGVtLnR5cGUgfHwgZWxlbS5ocmVmKTtcbiAgfVxufTtcblxudmFyIEJvb2xlYW5Db250cm9sbGVyID0gZnVuY3Rpb24gKF9Db250cm9sbGVyKSB7XG4gIGluaGVyaXRzKEJvb2xlYW5Db250cm9sbGVyLCBfQ29udHJvbGxlcik7XG4gIGZ1bmN0aW9uIEJvb2xlYW5Db250cm9sbGVyKG9iamVjdCwgcHJvcGVydHkpIHtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBCb29sZWFuQ29udHJvbGxlcik7XG4gICAgdmFyIF90aGlzMiA9IHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKEJvb2xlYW5Db250cm9sbGVyLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoQm9vbGVhbkNvbnRyb2xsZXIpKS5jYWxsKHRoaXMsIG9iamVjdCwgcHJvcGVydHkpKTtcbiAgICB2YXIgX3RoaXMgPSBfdGhpczI7XG4gICAgX3RoaXMyLl9fcHJldiA9IF90aGlzMi5nZXRWYWx1ZSgpO1xuICAgIF90aGlzMi5fX2NoZWNrYm94ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW5wdXQnKTtcbiAgICBfdGhpczIuX19jaGVja2JveC5zZXRBdHRyaWJ1dGUoJ3R5cGUnLCAnY2hlY2tib3gnKTtcbiAgICBmdW5jdGlvbiBvbkNoYW5nZSgpIHtcbiAgICAgIF90aGlzLnNldFZhbHVlKCFfdGhpcy5fX3ByZXYpO1xuICAgIH1cbiAgICBkb20uYmluZChfdGhpczIuX19jaGVja2JveCwgJ2NoYW5nZScsIG9uQ2hhbmdlLCBmYWxzZSk7XG4gICAgX3RoaXMyLmRvbUVsZW1lbnQuYXBwZW5kQ2hpbGQoX3RoaXMyLl9fY2hlY2tib3gpO1xuICAgIF90aGlzMi51cGRhdGVEaXNwbGF5KCk7XG4gICAgcmV0dXJuIF90aGlzMjtcbiAgfVxuICBjcmVhdGVDbGFzcyhCb29sZWFuQ29udHJvbGxlciwgW3tcbiAgICBrZXk6ICdzZXRWYWx1ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldFZhbHVlKHYpIHtcbiAgICAgIHZhciB0b1JldHVybiA9IGdldChCb29sZWFuQ29udHJvbGxlci5wcm90b3R5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihCb29sZWFuQ29udHJvbGxlci5wcm90b3R5cGUpLCAnc2V0VmFsdWUnLCB0aGlzKS5jYWxsKHRoaXMsIHYpO1xuICAgICAgaWYgKHRoaXMuX19vbkZpbmlzaENoYW5nZSkge1xuICAgICAgICB0aGlzLl9fb25GaW5pc2hDaGFuZ2UuY2FsbCh0aGlzLCB0aGlzLmdldFZhbHVlKCkpO1xuICAgICAgfVxuICAgICAgdGhpcy5fX3ByZXYgPSB0aGlzLmdldFZhbHVlKCk7XG4gICAgICByZXR1cm4gdG9SZXR1cm47XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAndXBkYXRlRGlzcGxheScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZURpc3BsYXkoKSB7XG4gICAgICBpZiAodGhpcy5nZXRWYWx1ZSgpID09PSB0cnVlKSB7XG4gICAgICAgIHRoaXMuX19jaGVja2JveC5zZXRBdHRyaWJ1dGUoJ2NoZWNrZWQnLCAnY2hlY2tlZCcpO1xuICAgICAgICB0aGlzLl9fY2hlY2tib3guY2hlY2tlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuX19wcmV2ID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX19jaGVja2JveC5jaGVja2VkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX19wcmV2ID0gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gZ2V0KEJvb2xlYW5Db250cm9sbGVyLnByb3RvdHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKEJvb2xlYW5Db250cm9sbGVyLnByb3RvdHlwZSksICd1cGRhdGVEaXNwbGF5JywgdGhpcykuY2FsbCh0aGlzKTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIEJvb2xlYW5Db250cm9sbGVyO1xufShDb250cm9sbGVyKTtcblxudmFyIE9wdGlvbkNvbnRyb2xsZXIgPSBmdW5jdGlvbiAoX0NvbnRyb2xsZXIpIHtcbiAgaW5oZXJpdHMoT3B0aW9uQ29udHJvbGxlciwgX0NvbnRyb2xsZXIpO1xuICBmdW5jdGlvbiBPcHRpb25Db250cm9sbGVyKG9iamVjdCwgcHJvcGVydHksIG9wdHMpIHtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBPcHRpb25Db250cm9sbGVyKTtcbiAgICB2YXIgX3RoaXMyID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoT3B0aW9uQ29udHJvbGxlci5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKE9wdGlvbkNvbnRyb2xsZXIpKS5jYWxsKHRoaXMsIG9iamVjdCwgcHJvcGVydHkpKTtcbiAgICB2YXIgb3B0aW9ucyA9IG9wdHM7XG4gICAgdmFyIF90aGlzID0gX3RoaXMyO1xuICAgIF90aGlzMi5fX3NlbGVjdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NlbGVjdCcpO1xuICAgIGlmIChDb21tb24uaXNBcnJheShvcHRpb25zKSkge1xuICAgICAgdmFyIG1hcCA9IHt9O1xuICAgICAgQ29tbW9uLmVhY2gob3B0aW9ucywgZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgICAgbWFwW2VsZW1lbnRdID0gZWxlbWVudDtcbiAgICAgIH0pO1xuICAgICAgb3B0aW9ucyA9IG1hcDtcbiAgICB9XG4gICAgQ29tbW9uLmVhY2gob3B0aW9ucywgZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHtcbiAgICAgIHZhciBvcHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdvcHRpb24nKTtcbiAgICAgIG9wdC5pbm5lckhUTUwgPSBrZXk7XG4gICAgICBvcHQuc2V0QXR0cmlidXRlKCd2YWx1ZScsIHZhbHVlKTtcbiAgICAgIF90aGlzLl9fc2VsZWN0LmFwcGVuZENoaWxkKG9wdCk7XG4gICAgfSk7XG4gICAgX3RoaXMyLnVwZGF0ZURpc3BsYXkoKTtcbiAgICBkb20uYmluZChfdGhpczIuX19zZWxlY3QsICdjaGFuZ2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgZGVzaXJlZFZhbHVlID0gdGhpcy5vcHRpb25zW3RoaXMuc2VsZWN0ZWRJbmRleF0udmFsdWU7XG4gICAgICBfdGhpcy5zZXRWYWx1ZShkZXNpcmVkVmFsdWUpO1xuICAgIH0pO1xuICAgIF90aGlzMi5kb21FbGVtZW50LmFwcGVuZENoaWxkKF90aGlzMi5fX3NlbGVjdCk7XG4gICAgcmV0dXJuIF90aGlzMjtcbiAgfVxuICBjcmVhdGVDbGFzcyhPcHRpb25Db250cm9sbGVyLCBbe1xuICAgIGtleTogJ3NldFZhbHVlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0VmFsdWUodikge1xuICAgICAgdmFyIHRvUmV0dXJuID0gZ2V0KE9wdGlvbkNvbnRyb2xsZXIucHJvdG90eXBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoT3B0aW9uQ29udHJvbGxlci5wcm90b3R5cGUpLCAnc2V0VmFsdWUnLCB0aGlzKS5jYWxsKHRoaXMsIHYpO1xuICAgICAgaWYgKHRoaXMuX19vbkZpbmlzaENoYW5nZSkge1xuICAgICAgICB0aGlzLl9fb25GaW5pc2hDaGFuZ2UuY2FsbCh0aGlzLCB0aGlzLmdldFZhbHVlKCkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRvUmV0dXJuO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3VwZGF0ZURpc3BsYXknLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGVEaXNwbGF5KCkge1xuICAgICAgaWYgKGRvbS5pc0FjdGl2ZSh0aGlzLl9fc2VsZWN0KSkgcmV0dXJuIHRoaXM7XG4gICAgICB0aGlzLl9fc2VsZWN0LnZhbHVlID0gdGhpcy5nZXRWYWx1ZSgpO1xuICAgICAgcmV0dXJuIGdldChPcHRpb25Db250cm9sbGVyLnByb3RvdHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKE9wdGlvbkNvbnRyb2xsZXIucHJvdG90eXBlKSwgJ3VwZGF0ZURpc3BsYXknLCB0aGlzKS5jYWxsKHRoaXMpO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gT3B0aW9uQ29udHJvbGxlcjtcbn0oQ29udHJvbGxlcik7XG5cbnZhciBTdHJpbmdDb250cm9sbGVyID0gZnVuY3Rpb24gKF9Db250cm9sbGVyKSB7XG4gIGluaGVyaXRzKFN0cmluZ0NvbnRyb2xsZXIsIF9Db250cm9sbGVyKTtcbiAgZnVuY3Rpb24gU3RyaW5nQ29udHJvbGxlcihvYmplY3QsIHByb3BlcnR5KSB7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgU3RyaW5nQ29udHJvbGxlcik7XG4gICAgdmFyIF90aGlzMiA9IHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKFN0cmluZ0NvbnRyb2xsZXIuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihTdHJpbmdDb250cm9sbGVyKSkuY2FsbCh0aGlzLCBvYmplY3QsIHByb3BlcnR5KSk7XG4gICAgdmFyIF90aGlzID0gX3RoaXMyO1xuICAgIGZ1bmN0aW9uIG9uQ2hhbmdlKCkge1xuICAgICAgX3RoaXMuc2V0VmFsdWUoX3RoaXMuX19pbnB1dC52YWx1ZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG9uQmx1cigpIHtcbiAgICAgIGlmIChfdGhpcy5fX29uRmluaXNoQ2hhbmdlKSB7XG4gICAgICAgIF90aGlzLl9fb25GaW5pc2hDaGFuZ2UuY2FsbChfdGhpcywgX3RoaXMuZ2V0VmFsdWUoKSk7XG4gICAgICB9XG4gICAgfVxuICAgIF90aGlzMi5fX2lucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW5wdXQnKTtcbiAgICBfdGhpczIuX19pbnB1dC5zZXRBdHRyaWJ1dGUoJ3R5cGUnLCAndGV4dCcpO1xuICAgIGRvbS5iaW5kKF90aGlzMi5fX2lucHV0LCAna2V5dXAnLCBvbkNoYW5nZSk7XG4gICAgZG9tLmJpbmQoX3RoaXMyLl9faW5wdXQsICdjaGFuZ2UnLCBvbkNoYW5nZSk7XG4gICAgZG9tLmJpbmQoX3RoaXMyLl9faW5wdXQsICdibHVyJywgb25CbHVyKTtcbiAgICBkb20uYmluZChfdGhpczIuX19pbnB1dCwgJ2tleWRvd24nLCBmdW5jdGlvbiAoZSkge1xuICAgICAgaWYgKGUua2V5Q29kZSA9PT0gMTMpIHtcbiAgICAgICAgdGhpcy5ibHVyKCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgX3RoaXMyLnVwZGF0ZURpc3BsYXkoKTtcbiAgICBfdGhpczIuZG9tRWxlbWVudC5hcHBlbmRDaGlsZChfdGhpczIuX19pbnB1dCk7XG4gICAgcmV0dXJuIF90aGlzMjtcbiAgfVxuICBjcmVhdGVDbGFzcyhTdHJpbmdDb250cm9sbGVyLCBbe1xuICAgIGtleTogJ3VwZGF0ZURpc3BsYXknLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGVEaXNwbGF5KCkge1xuICAgICAgaWYgKCFkb20uaXNBY3RpdmUodGhpcy5fX2lucHV0KSkge1xuICAgICAgICB0aGlzLl9faW5wdXQudmFsdWUgPSB0aGlzLmdldFZhbHVlKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZ2V0KFN0cmluZ0NvbnRyb2xsZXIucHJvdG90eXBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoU3RyaW5nQ29udHJvbGxlci5wcm90b3R5cGUpLCAndXBkYXRlRGlzcGxheScsIHRoaXMpLmNhbGwodGhpcyk7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBTdHJpbmdDb250cm9sbGVyO1xufShDb250cm9sbGVyKTtcblxuZnVuY3Rpb24gbnVtRGVjaW1hbHMoeCkge1xuICB2YXIgX3ggPSB4LnRvU3RyaW5nKCk7XG4gIGlmIChfeC5pbmRleE9mKCcuJykgPiAtMSkge1xuICAgIHJldHVybiBfeC5sZW5ndGggLSBfeC5pbmRleE9mKCcuJykgLSAxO1xuICB9XG4gIHJldHVybiAwO1xufVxudmFyIE51bWJlckNvbnRyb2xsZXIgPSBmdW5jdGlvbiAoX0NvbnRyb2xsZXIpIHtcbiAgaW5oZXJpdHMoTnVtYmVyQ29udHJvbGxlciwgX0NvbnRyb2xsZXIpO1xuICBmdW5jdGlvbiBOdW1iZXJDb250cm9sbGVyKG9iamVjdCwgcHJvcGVydHksIHBhcmFtcykge1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIE51bWJlckNvbnRyb2xsZXIpO1xuICAgIHZhciBfdGhpcyA9IHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKE51bWJlckNvbnRyb2xsZXIuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihOdW1iZXJDb250cm9sbGVyKSkuY2FsbCh0aGlzLCBvYmplY3QsIHByb3BlcnR5KSk7XG4gICAgdmFyIF9wYXJhbXMgPSBwYXJhbXMgfHwge307XG4gICAgX3RoaXMuX19taW4gPSBfcGFyYW1zLm1pbjtcbiAgICBfdGhpcy5fX21heCA9IF9wYXJhbXMubWF4O1xuICAgIF90aGlzLl9fc3RlcCA9IF9wYXJhbXMuc3RlcDtcbiAgICBpZiAoQ29tbW9uLmlzVW5kZWZpbmVkKF90aGlzLl9fc3RlcCkpIHtcbiAgICAgIGlmIChfdGhpcy5pbml0aWFsVmFsdWUgPT09IDApIHtcbiAgICAgICAgX3RoaXMuX19pbXBsaWVkU3RlcCA9IDE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfdGhpcy5fX2ltcGxpZWRTdGVwID0gTWF0aC5wb3coMTAsIE1hdGguZmxvb3IoTWF0aC5sb2coTWF0aC5hYnMoX3RoaXMuaW5pdGlhbFZhbHVlKSkgLyBNYXRoLkxOMTApKSAvIDEwO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBfdGhpcy5fX2ltcGxpZWRTdGVwID0gX3RoaXMuX19zdGVwO1xuICAgIH1cbiAgICBfdGhpcy5fX3ByZWNpc2lvbiA9IG51bURlY2ltYWxzKF90aGlzLl9faW1wbGllZFN0ZXApO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuICBjcmVhdGVDbGFzcyhOdW1iZXJDb250cm9sbGVyLCBbe1xuICAgIGtleTogJ3NldFZhbHVlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0VmFsdWUodikge1xuICAgICAgdmFyIF92ID0gdjtcbiAgICAgIGlmICh0aGlzLl9fbWluICE9PSB1bmRlZmluZWQgJiYgX3YgPCB0aGlzLl9fbWluKSB7XG4gICAgICAgIF92ID0gdGhpcy5fX21pbjtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5fX21heCAhPT0gdW5kZWZpbmVkICYmIF92ID4gdGhpcy5fX21heCkge1xuICAgICAgICBfdiA9IHRoaXMuX19tYXg7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5fX3N0ZXAgIT09IHVuZGVmaW5lZCAmJiBfdiAlIHRoaXMuX19zdGVwICE9PSAwKSB7XG4gICAgICAgIF92ID0gTWF0aC5yb3VuZChfdiAvIHRoaXMuX19zdGVwKSAqIHRoaXMuX19zdGVwO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGdldChOdW1iZXJDb250cm9sbGVyLnByb3RvdHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKE51bWJlckNvbnRyb2xsZXIucHJvdG90eXBlKSwgJ3NldFZhbHVlJywgdGhpcykuY2FsbCh0aGlzLCBfdik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnbWluJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gbWluKG1pblZhbHVlKSB7XG4gICAgICB0aGlzLl9fbWluID0gbWluVmFsdWU7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdtYXgnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtYXgobWF4VmFsdWUpIHtcbiAgICAgIHRoaXMuX19tYXggPSBtYXhWYWx1ZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3N0ZXAnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzdGVwKHN0ZXBWYWx1ZSkge1xuICAgICAgdGhpcy5fX3N0ZXAgPSBzdGVwVmFsdWU7XG4gICAgICB0aGlzLl9faW1wbGllZFN0ZXAgPSBzdGVwVmFsdWU7XG4gICAgICB0aGlzLl9fcHJlY2lzaW9uID0gbnVtRGVjaW1hbHMoc3RlcFZhbHVlKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gTnVtYmVyQ29udHJvbGxlcjtcbn0oQ29udHJvbGxlcik7XG5cbmZ1bmN0aW9uIHJvdW5kVG9EZWNpbWFsKHZhbHVlLCBkZWNpbWFscykge1xuICB2YXIgdGVuVG8gPSBNYXRoLnBvdygxMCwgZGVjaW1hbHMpO1xuICByZXR1cm4gTWF0aC5yb3VuZCh2YWx1ZSAqIHRlblRvKSAvIHRlblRvO1xufVxudmFyIE51bWJlckNvbnRyb2xsZXJCb3ggPSBmdW5jdGlvbiAoX051bWJlckNvbnRyb2xsZXIpIHtcbiAgaW5oZXJpdHMoTnVtYmVyQ29udHJvbGxlckJveCwgX051bWJlckNvbnRyb2xsZXIpO1xuICBmdW5jdGlvbiBOdW1iZXJDb250cm9sbGVyQm94KG9iamVjdCwgcHJvcGVydHksIHBhcmFtcykge1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIE51bWJlckNvbnRyb2xsZXJCb3gpO1xuICAgIHZhciBfdGhpczIgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChOdW1iZXJDb250cm9sbGVyQm94Ll9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoTnVtYmVyQ29udHJvbGxlckJveCkpLmNhbGwodGhpcywgb2JqZWN0LCBwcm9wZXJ0eSwgcGFyYW1zKSk7XG4gICAgX3RoaXMyLl9fdHJ1bmNhdGlvblN1c3BlbmRlZCA9IGZhbHNlO1xuICAgIHZhciBfdGhpcyA9IF90aGlzMjtcbiAgICB2YXIgcHJldlkgPSB2b2lkIDA7XG4gICAgZnVuY3Rpb24gb25DaGFuZ2UoKSB7XG4gICAgICB2YXIgYXR0ZW1wdGVkID0gcGFyc2VGbG9hdChfdGhpcy5fX2lucHV0LnZhbHVlKTtcbiAgICAgIGlmICghQ29tbW9uLmlzTmFOKGF0dGVtcHRlZCkpIHtcbiAgICAgICAgX3RoaXMuc2V0VmFsdWUoYXR0ZW1wdGVkKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gb25GaW5pc2goKSB7XG4gICAgICBpZiAoX3RoaXMuX19vbkZpbmlzaENoYW5nZSkge1xuICAgICAgICBfdGhpcy5fX29uRmluaXNoQ2hhbmdlLmNhbGwoX3RoaXMsIF90aGlzLmdldFZhbHVlKCkpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBvbkJsdXIoKSB7XG4gICAgICBvbkZpbmlzaCgpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBvbk1vdXNlRHJhZyhlKSB7XG4gICAgICB2YXIgZGlmZiA9IHByZXZZIC0gZS5jbGllbnRZO1xuICAgICAgX3RoaXMuc2V0VmFsdWUoX3RoaXMuZ2V0VmFsdWUoKSArIGRpZmYgKiBfdGhpcy5fX2ltcGxpZWRTdGVwKTtcbiAgICAgIHByZXZZID0gZS5jbGllbnRZO1xuICAgIH1cbiAgICBmdW5jdGlvbiBvbk1vdXNlVXAoKSB7XG4gICAgICBkb20udW5iaW5kKHdpbmRvdywgJ21vdXNlbW92ZScsIG9uTW91c2VEcmFnKTtcbiAgICAgIGRvbS51bmJpbmQod2luZG93LCAnbW91c2V1cCcsIG9uTW91c2VVcCk7XG4gICAgICBvbkZpbmlzaCgpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBvbk1vdXNlRG93bihlKSB7XG4gICAgICBkb20uYmluZCh3aW5kb3csICdtb3VzZW1vdmUnLCBvbk1vdXNlRHJhZyk7XG4gICAgICBkb20uYmluZCh3aW5kb3csICdtb3VzZXVwJywgb25Nb3VzZVVwKTtcbiAgICAgIHByZXZZID0gZS5jbGllbnRZO1xuICAgIH1cbiAgICBfdGhpczIuX19pbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lucHV0Jyk7XG4gICAgX3RoaXMyLl9faW5wdXQuc2V0QXR0cmlidXRlKCd0eXBlJywgJ3RleHQnKTtcbiAgICBkb20uYmluZChfdGhpczIuX19pbnB1dCwgJ2NoYW5nZScsIG9uQ2hhbmdlKTtcbiAgICBkb20uYmluZChfdGhpczIuX19pbnB1dCwgJ2JsdXInLCBvbkJsdXIpO1xuICAgIGRvbS5iaW5kKF90aGlzMi5fX2lucHV0LCAnbW91c2Vkb3duJywgb25Nb3VzZURvd24pO1xuICAgIGRvbS5iaW5kKF90aGlzMi5fX2lucHV0LCAna2V5ZG93bicsIGZ1bmN0aW9uIChlKSB7XG4gICAgICBpZiAoZS5rZXlDb2RlID09PSAxMykge1xuICAgICAgICBfdGhpcy5fX3RydW5jYXRpb25TdXNwZW5kZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLmJsdXIoKTtcbiAgICAgICAgX3RoaXMuX190cnVuY2F0aW9uU3VzcGVuZGVkID0gZmFsc2U7XG4gICAgICAgIG9uRmluaXNoKCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgX3RoaXMyLnVwZGF0ZURpc3BsYXkoKTtcbiAgICBfdGhpczIuZG9tRWxlbWVudC5hcHBlbmRDaGlsZChfdGhpczIuX19pbnB1dCk7XG4gICAgcmV0dXJuIF90aGlzMjtcbiAgfVxuICBjcmVhdGVDbGFzcyhOdW1iZXJDb250cm9sbGVyQm94LCBbe1xuICAgIGtleTogJ3VwZGF0ZURpc3BsYXknLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGVEaXNwbGF5KCkge1xuICAgICAgdGhpcy5fX2lucHV0LnZhbHVlID0gdGhpcy5fX3RydW5jYXRpb25TdXNwZW5kZWQgPyB0aGlzLmdldFZhbHVlKCkgOiByb3VuZFRvRGVjaW1hbCh0aGlzLmdldFZhbHVlKCksIHRoaXMuX19wcmVjaXNpb24pO1xuICAgICAgcmV0dXJuIGdldChOdW1iZXJDb250cm9sbGVyQm94LnByb3RvdHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKE51bWJlckNvbnRyb2xsZXJCb3gucHJvdG90eXBlKSwgJ3VwZGF0ZURpc3BsYXknLCB0aGlzKS5jYWxsKHRoaXMpO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gTnVtYmVyQ29udHJvbGxlckJveDtcbn0oTnVtYmVyQ29udHJvbGxlcik7XG5cbmZ1bmN0aW9uIG1hcCh2LCBpMSwgaTIsIG8xLCBvMikge1xuICByZXR1cm4gbzEgKyAobzIgLSBvMSkgKiAoKHYgLSBpMSkgLyAoaTIgLSBpMSkpO1xufVxudmFyIE51bWJlckNvbnRyb2xsZXJTbGlkZXIgPSBmdW5jdGlvbiAoX051bWJlckNvbnRyb2xsZXIpIHtcbiAgaW5oZXJpdHMoTnVtYmVyQ29udHJvbGxlclNsaWRlciwgX051bWJlckNvbnRyb2xsZXIpO1xuICBmdW5jdGlvbiBOdW1iZXJDb250cm9sbGVyU2xpZGVyKG9iamVjdCwgcHJvcGVydHksIG1pbiwgbWF4LCBzdGVwKSB7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgTnVtYmVyQ29udHJvbGxlclNsaWRlcik7XG4gICAgdmFyIF90aGlzMiA9IHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKE51bWJlckNvbnRyb2xsZXJTbGlkZXIuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihOdW1iZXJDb250cm9sbGVyU2xpZGVyKSkuY2FsbCh0aGlzLCBvYmplY3QsIHByb3BlcnR5LCB7IG1pbjogbWluLCBtYXg6IG1heCwgc3RlcDogc3RlcCB9KSk7XG4gICAgdmFyIF90aGlzID0gX3RoaXMyO1xuICAgIF90aGlzMi5fX2JhY2tncm91bmQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBfdGhpczIuX19mb3JlZ3JvdW5kID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgZG9tLmJpbmQoX3RoaXMyLl9fYmFja2dyb3VuZCwgJ21vdXNlZG93bicsIG9uTW91c2VEb3duKTtcbiAgICBkb20uYmluZChfdGhpczIuX19iYWNrZ3JvdW5kLCAndG91Y2hzdGFydCcsIG9uVG91Y2hTdGFydCk7XG4gICAgZG9tLmFkZENsYXNzKF90aGlzMi5fX2JhY2tncm91bmQsICdzbGlkZXInKTtcbiAgICBkb20uYWRkQ2xhc3MoX3RoaXMyLl9fZm9yZWdyb3VuZCwgJ3NsaWRlci1mZycpO1xuICAgIGZ1bmN0aW9uIG9uTW91c2VEb3duKGUpIHtcbiAgICAgIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQuYmx1cigpO1xuICAgICAgZG9tLmJpbmQod2luZG93LCAnbW91c2Vtb3ZlJywgb25Nb3VzZURyYWcpO1xuICAgICAgZG9tLmJpbmQod2luZG93LCAnbW91c2V1cCcsIG9uTW91c2VVcCk7XG4gICAgICBvbk1vdXNlRHJhZyhlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gb25Nb3VzZURyYWcoZSkge1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgdmFyIGJnUmVjdCA9IF90aGlzLl9fYmFja2dyb3VuZC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIF90aGlzLnNldFZhbHVlKG1hcChlLmNsaWVudFgsIGJnUmVjdC5sZWZ0LCBiZ1JlY3QucmlnaHQsIF90aGlzLl9fbWluLCBfdGhpcy5fX21heCkpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBvbk1vdXNlVXAoKSB7XG4gICAgICBkb20udW5iaW5kKHdpbmRvdywgJ21vdXNlbW92ZScsIG9uTW91c2VEcmFnKTtcbiAgICAgIGRvbS51bmJpbmQod2luZG93LCAnbW91c2V1cCcsIG9uTW91c2VVcCk7XG4gICAgICBpZiAoX3RoaXMuX19vbkZpbmlzaENoYW5nZSkge1xuICAgICAgICBfdGhpcy5fX29uRmluaXNoQ2hhbmdlLmNhbGwoX3RoaXMsIF90aGlzLmdldFZhbHVlKCkpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBvblRvdWNoU3RhcnQoZSkge1xuICAgICAgaWYgKGUudG91Y2hlcy5sZW5ndGggIT09IDEpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZG9tLmJpbmQod2luZG93LCAndG91Y2htb3ZlJywgb25Ub3VjaE1vdmUpO1xuICAgICAgZG9tLmJpbmQod2luZG93LCAndG91Y2hlbmQnLCBvblRvdWNoRW5kKTtcbiAgICAgIG9uVG91Y2hNb3ZlKGUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBvblRvdWNoTW92ZShlKSB7XG4gICAgICB2YXIgY2xpZW50WCA9IGUudG91Y2hlc1swXS5jbGllbnRYO1xuICAgICAgdmFyIGJnUmVjdCA9IF90aGlzLl9fYmFja2dyb3VuZC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIF90aGlzLnNldFZhbHVlKG1hcChjbGllbnRYLCBiZ1JlY3QubGVmdCwgYmdSZWN0LnJpZ2h0LCBfdGhpcy5fX21pbiwgX3RoaXMuX19tYXgpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gb25Ub3VjaEVuZCgpIHtcbiAgICAgIGRvbS51bmJpbmQod2luZG93LCAndG91Y2htb3ZlJywgb25Ub3VjaE1vdmUpO1xuICAgICAgZG9tLnVuYmluZCh3aW5kb3csICd0b3VjaGVuZCcsIG9uVG91Y2hFbmQpO1xuICAgICAgaWYgKF90aGlzLl9fb25GaW5pc2hDaGFuZ2UpIHtcbiAgICAgICAgX3RoaXMuX19vbkZpbmlzaENoYW5nZS5jYWxsKF90aGlzLCBfdGhpcy5nZXRWYWx1ZSgpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgX3RoaXMyLnVwZGF0ZURpc3BsYXkoKTtcbiAgICBfdGhpczIuX19iYWNrZ3JvdW5kLmFwcGVuZENoaWxkKF90aGlzMi5fX2ZvcmVncm91bmQpO1xuICAgIF90aGlzMi5kb21FbGVtZW50LmFwcGVuZENoaWxkKF90aGlzMi5fX2JhY2tncm91bmQpO1xuICAgIHJldHVybiBfdGhpczI7XG4gIH1cbiAgY3JlYXRlQ2xhc3MoTnVtYmVyQ29udHJvbGxlclNsaWRlciwgW3tcbiAgICBrZXk6ICd1cGRhdGVEaXNwbGF5JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlRGlzcGxheSgpIHtcbiAgICAgIHZhciBwY3QgPSAodGhpcy5nZXRWYWx1ZSgpIC0gdGhpcy5fX21pbikgLyAodGhpcy5fX21heCAtIHRoaXMuX19taW4pO1xuICAgICAgdGhpcy5fX2ZvcmVncm91bmQuc3R5bGUud2lkdGggPSBwY3QgKiAxMDAgKyAnJSc7XG4gICAgICByZXR1cm4gZ2V0KE51bWJlckNvbnRyb2xsZXJTbGlkZXIucHJvdG90eXBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoTnVtYmVyQ29udHJvbGxlclNsaWRlci5wcm90b3R5cGUpLCAndXBkYXRlRGlzcGxheScsIHRoaXMpLmNhbGwodGhpcyk7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBOdW1iZXJDb250cm9sbGVyU2xpZGVyO1xufShOdW1iZXJDb250cm9sbGVyKTtcblxudmFyIEZ1bmN0aW9uQ29udHJvbGxlciA9IGZ1bmN0aW9uIChfQ29udHJvbGxlcikge1xuICBpbmhlcml0cyhGdW5jdGlvbkNvbnRyb2xsZXIsIF9Db250cm9sbGVyKTtcbiAgZnVuY3Rpb24gRnVuY3Rpb25Db250cm9sbGVyKG9iamVjdCwgcHJvcGVydHksIHRleHQpIHtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBGdW5jdGlvbkNvbnRyb2xsZXIpO1xuICAgIHZhciBfdGhpczIgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChGdW5jdGlvbkNvbnRyb2xsZXIuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihGdW5jdGlvbkNvbnRyb2xsZXIpKS5jYWxsKHRoaXMsIG9iamVjdCwgcHJvcGVydHkpKTtcbiAgICB2YXIgX3RoaXMgPSBfdGhpczI7XG4gICAgX3RoaXMyLl9fYnV0dG9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgX3RoaXMyLl9fYnV0dG9uLmlubmVySFRNTCA9IHRleHQgPT09IHVuZGVmaW5lZCA/ICdGaXJlJyA6IHRleHQ7XG4gICAgZG9tLmJpbmQoX3RoaXMyLl9fYnV0dG9uLCAnY2xpY2snLCBmdW5jdGlvbiAoZSkge1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgX3RoaXMuZmlyZSgpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0pO1xuICAgIGRvbS5hZGRDbGFzcyhfdGhpczIuX19idXR0b24sICdidXR0b24nKTtcbiAgICBfdGhpczIuZG9tRWxlbWVudC5hcHBlbmRDaGlsZChfdGhpczIuX19idXR0b24pO1xuICAgIHJldHVybiBfdGhpczI7XG4gIH1cbiAgY3JlYXRlQ2xhc3MoRnVuY3Rpb25Db250cm9sbGVyLCBbe1xuICAgIGtleTogJ2ZpcmUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmaXJlKCkge1xuICAgICAgaWYgKHRoaXMuX19vbkNoYW5nZSkge1xuICAgICAgICB0aGlzLl9fb25DaGFuZ2UuY2FsbCh0aGlzKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZ2V0VmFsdWUoKS5jYWxsKHRoaXMub2JqZWN0KTtcbiAgICAgIGlmICh0aGlzLl9fb25GaW5pc2hDaGFuZ2UpIHtcbiAgICAgICAgdGhpcy5fX29uRmluaXNoQ2hhbmdlLmNhbGwodGhpcywgdGhpcy5nZXRWYWx1ZSgpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIEZ1bmN0aW9uQ29udHJvbGxlcjtcbn0oQ29udHJvbGxlcik7XG5cbnZhciBDb2xvckNvbnRyb2xsZXIgPSBmdW5jdGlvbiAoX0NvbnRyb2xsZXIpIHtcbiAgaW5oZXJpdHMoQ29sb3JDb250cm9sbGVyLCBfQ29udHJvbGxlcik7XG4gIGZ1bmN0aW9uIENvbG9yQ29udHJvbGxlcihvYmplY3QsIHByb3BlcnR5KSB7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgQ29sb3JDb250cm9sbGVyKTtcbiAgICB2YXIgX3RoaXMyID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoQ29sb3JDb250cm9sbGVyLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoQ29sb3JDb250cm9sbGVyKSkuY2FsbCh0aGlzLCBvYmplY3QsIHByb3BlcnR5KSk7XG4gICAgX3RoaXMyLl9fY29sb3IgPSBuZXcgQ29sb3IoX3RoaXMyLmdldFZhbHVlKCkpO1xuICAgIF90aGlzMi5fX3RlbXAgPSBuZXcgQ29sb3IoMCk7XG4gICAgdmFyIF90aGlzID0gX3RoaXMyO1xuICAgIF90aGlzMi5kb21FbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgZG9tLm1ha2VTZWxlY3RhYmxlKF90aGlzMi5kb21FbGVtZW50LCBmYWxzZSk7XG4gICAgX3RoaXMyLl9fc2VsZWN0b3IgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBfdGhpczIuX19zZWxlY3Rvci5jbGFzc05hbWUgPSAnc2VsZWN0b3InO1xuICAgIF90aGlzMi5fX3NhdHVyYXRpb25fZmllbGQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBfdGhpczIuX19zYXR1cmF0aW9uX2ZpZWxkLmNsYXNzTmFtZSA9ICdzYXR1cmF0aW9uLWZpZWxkJztcbiAgICBfdGhpczIuX19maWVsZF9rbm9iID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgX3RoaXMyLl9fZmllbGRfa25vYi5jbGFzc05hbWUgPSAnZmllbGQta25vYic7XG4gICAgX3RoaXMyLl9fZmllbGRfa25vYl9ib3JkZXIgPSAnMnB4IHNvbGlkICc7XG4gICAgX3RoaXMyLl9faHVlX2tub2IgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBfdGhpczIuX19odWVfa25vYi5jbGFzc05hbWUgPSAnaHVlLWtub2InO1xuICAgIF90aGlzMi5fX2h1ZV9maWVsZCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIF90aGlzMi5fX2h1ZV9maWVsZC5jbGFzc05hbWUgPSAnaHVlLWZpZWxkJztcbiAgICBfdGhpczIuX19pbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lucHV0Jyk7XG4gICAgX3RoaXMyLl9faW5wdXQudHlwZSA9ICd0ZXh0JztcbiAgICBfdGhpczIuX19pbnB1dF90ZXh0U2hhZG93ID0gJzAgMXB4IDFweCAnO1xuICAgIGRvbS5iaW5kKF90aGlzMi5fX2lucHV0LCAna2V5ZG93bicsIGZ1bmN0aW9uIChlKSB7XG4gICAgICBpZiAoZS5rZXlDb2RlID09PSAxMykge1xuICAgICAgICBvbkJsdXIuY2FsbCh0aGlzKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBkb20uYmluZChfdGhpczIuX19pbnB1dCwgJ2JsdXInLCBvbkJsdXIpO1xuICAgIGRvbS5iaW5kKF90aGlzMi5fX3NlbGVjdG9yLCAnbW91c2Vkb3duJywgZnVuY3Rpb24gKCkgICAgICAgIHtcbiAgICAgIGRvbS5hZGRDbGFzcyh0aGlzLCAnZHJhZycpLmJpbmQod2luZG93LCAnbW91c2V1cCcsIGZ1bmN0aW9uICgpICAgICAgICB7XG4gICAgICAgIGRvbS5yZW1vdmVDbGFzcyhfdGhpcy5fX3NlbGVjdG9yLCAnZHJhZycpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgZG9tLmJpbmQoX3RoaXMyLl9fc2VsZWN0b3IsICd0b3VjaHN0YXJ0JywgZnVuY3Rpb24gKCkgICAgICAgIHtcbiAgICAgIGRvbS5hZGRDbGFzcyh0aGlzLCAnZHJhZycpLmJpbmQod2luZG93LCAndG91Y2hlbmQnLCBmdW5jdGlvbiAoKSAgICAgICAge1xuICAgICAgICBkb20ucmVtb3ZlQ2xhc3MoX3RoaXMuX19zZWxlY3RvciwgJ2RyYWcnKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHZhciB2YWx1ZUZpZWxkID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgQ29tbW9uLmV4dGVuZChfdGhpczIuX19zZWxlY3Rvci5zdHlsZSwge1xuICAgICAgd2lkdGg6ICcxMjJweCcsXG4gICAgICBoZWlnaHQ6ICcxMDJweCcsXG4gICAgICBwYWRkaW5nOiAnM3B4JyxcbiAgICAgIGJhY2tncm91bmRDb2xvcjogJyMyMjInLFxuICAgICAgYm94U2hhZG93OiAnMHB4IDFweCAzcHggcmdiYSgwLDAsMCwwLjMpJ1xuICAgIH0pO1xuICAgIENvbW1vbi5leHRlbmQoX3RoaXMyLl9fZmllbGRfa25vYi5zdHlsZSwge1xuICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgICB3aWR0aDogJzEycHgnLFxuICAgICAgaGVpZ2h0OiAnMTJweCcsXG4gICAgICBib3JkZXI6IF90aGlzMi5fX2ZpZWxkX2tub2JfYm9yZGVyICsgKF90aGlzMi5fX2NvbG9yLnYgPCAwLjUgPyAnI2ZmZicgOiAnIzAwMCcpLFxuICAgICAgYm94U2hhZG93OiAnMHB4IDFweCAzcHggcmdiYSgwLDAsMCwwLjUpJyxcbiAgICAgIGJvcmRlclJhZGl1czogJzEycHgnLFxuICAgICAgekluZGV4OiAxXG4gICAgfSk7XG4gICAgQ29tbW9uLmV4dGVuZChfdGhpczIuX19odWVfa25vYi5zdHlsZSwge1xuICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgICB3aWR0aDogJzE1cHgnLFxuICAgICAgaGVpZ2h0OiAnMnB4JyxcbiAgICAgIGJvcmRlclJpZ2h0OiAnNHB4IHNvbGlkICNmZmYnLFxuICAgICAgekluZGV4OiAxXG4gICAgfSk7XG4gICAgQ29tbW9uLmV4dGVuZChfdGhpczIuX19zYXR1cmF0aW9uX2ZpZWxkLnN0eWxlLCB7XG4gICAgICB3aWR0aDogJzEwMHB4JyxcbiAgICAgIGhlaWdodDogJzEwMHB4JyxcbiAgICAgIGJvcmRlcjogJzFweCBzb2xpZCAjNTU1JyxcbiAgICAgIG1hcmdpblJpZ2h0OiAnM3B4JyxcbiAgICAgIGRpc3BsYXk6ICdpbmxpbmUtYmxvY2snLFxuICAgICAgY3Vyc29yOiAncG9pbnRlcidcbiAgICB9KTtcbiAgICBDb21tb24uZXh0ZW5kKHZhbHVlRmllbGQuc3R5bGUsIHtcbiAgICAgIHdpZHRoOiAnMTAwJScsXG4gICAgICBoZWlnaHQ6ICcxMDAlJyxcbiAgICAgIGJhY2tncm91bmQ6ICdub25lJ1xuICAgIH0pO1xuICAgIGxpbmVhckdyYWRpZW50KHZhbHVlRmllbGQsICd0b3AnLCAncmdiYSgwLDAsMCwwKScsICcjMDAwJyk7XG4gICAgQ29tbW9uLmV4dGVuZChfdGhpczIuX19odWVfZmllbGQuc3R5bGUsIHtcbiAgICAgIHdpZHRoOiAnMTVweCcsXG4gICAgICBoZWlnaHQ6ICcxMDBweCcsXG4gICAgICBib3JkZXI6ICcxcHggc29saWQgIzU1NScsXG4gICAgICBjdXJzb3I6ICducy1yZXNpemUnLFxuICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgICB0b3A6ICczcHgnLFxuICAgICAgcmlnaHQ6ICczcHgnXG4gICAgfSk7XG4gICAgaHVlR3JhZGllbnQoX3RoaXMyLl9faHVlX2ZpZWxkKTtcbiAgICBDb21tb24uZXh0ZW5kKF90aGlzMi5fX2lucHV0LnN0eWxlLCB7XG4gICAgICBvdXRsaW5lOiAnbm9uZScsXG4gICAgICB0ZXh0QWxpZ246ICdjZW50ZXInLFxuICAgICAgY29sb3I6ICcjZmZmJyxcbiAgICAgIGJvcmRlcjogMCxcbiAgICAgIGZvbnRXZWlnaHQ6ICdib2xkJyxcbiAgICAgIHRleHRTaGFkb3c6IF90aGlzMi5fX2lucHV0X3RleHRTaGFkb3cgKyAncmdiYSgwLDAsMCwwLjcpJ1xuICAgIH0pO1xuICAgIGRvbS5iaW5kKF90aGlzMi5fX3NhdHVyYXRpb25fZmllbGQsICdtb3VzZWRvd24nLCBmaWVsZERvd24pO1xuICAgIGRvbS5iaW5kKF90aGlzMi5fX3NhdHVyYXRpb25fZmllbGQsICd0b3VjaHN0YXJ0JywgZmllbGREb3duKTtcbiAgICBkb20uYmluZChfdGhpczIuX19maWVsZF9rbm9iLCAnbW91c2Vkb3duJywgZmllbGREb3duKTtcbiAgICBkb20uYmluZChfdGhpczIuX19maWVsZF9rbm9iLCAndG91Y2hzdGFydCcsIGZpZWxkRG93bik7XG4gICAgZG9tLmJpbmQoX3RoaXMyLl9faHVlX2ZpZWxkLCAnbW91c2Vkb3duJywgZmllbGREb3duSCk7XG4gICAgZG9tLmJpbmQoX3RoaXMyLl9faHVlX2ZpZWxkLCAndG91Y2hzdGFydCcsIGZpZWxkRG93bkgpO1xuICAgIGZ1bmN0aW9uIGZpZWxkRG93bihlKSB7XG4gICAgICBzZXRTVihlKTtcbiAgICAgIGRvbS5iaW5kKHdpbmRvdywgJ21vdXNlbW92ZScsIHNldFNWKTtcbiAgICAgIGRvbS5iaW5kKHdpbmRvdywgJ3RvdWNobW92ZScsIHNldFNWKTtcbiAgICAgIGRvbS5iaW5kKHdpbmRvdywgJ21vdXNldXAnLCBmaWVsZFVwU1YpO1xuICAgICAgZG9tLmJpbmQod2luZG93LCAndG91Y2hlbmQnLCBmaWVsZFVwU1YpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBmaWVsZERvd25IKGUpIHtcbiAgICAgIHNldEgoZSk7XG4gICAgICBkb20uYmluZCh3aW5kb3csICdtb3VzZW1vdmUnLCBzZXRIKTtcbiAgICAgIGRvbS5iaW5kKHdpbmRvdywgJ3RvdWNobW92ZScsIHNldEgpO1xuICAgICAgZG9tLmJpbmQod2luZG93LCAnbW91c2V1cCcsIGZpZWxkVXBIKTtcbiAgICAgIGRvbS5iaW5kKHdpbmRvdywgJ3RvdWNoZW5kJywgZmllbGRVcEgpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBmaWVsZFVwU1YoKSB7XG4gICAgICBkb20udW5iaW5kKHdpbmRvdywgJ21vdXNlbW92ZScsIHNldFNWKTtcbiAgICAgIGRvbS51bmJpbmQod2luZG93LCAndG91Y2htb3ZlJywgc2V0U1YpO1xuICAgICAgZG9tLnVuYmluZCh3aW5kb3csICdtb3VzZXVwJywgZmllbGRVcFNWKTtcbiAgICAgIGRvbS51bmJpbmQod2luZG93LCAndG91Y2hlbmQnLCBmaWVsZFVwU1YpO1xuICAgICAgb25GaW5pc2goKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZmllbGRVcEgoKSB7XG4gICAgICBkb20udW5iaW5kKHdpbmRvdywgJ21vdXNlbW92ZScsIHNldEgpO1xuICAgICAgZG9tLnVuYmluZCh3aW5kb3csICd0b3VjaG1vdmUnLCBzZXRIKTtcbiAgICAgIGRvbS51bmJpbmQod2luZG93LCAnbW91c2V1cCcsIGZpZWxkVXBIKTtcbiAgICAgIGRvbS51bmJpbmQod2luZG93LCAndG91Y2hlbmQnLCBmaWVsZFVwSCk7XG4gICAgICBvbkZpbmlzaCgpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBvbkJsdXIoKSB7XG4gICAgICB2YXIgaSA9IGludGVycHJldCh0aGlzLnZhbHVlKTtcbiAgICAgIGlmIChpICE9PSBmYWxzZSkge1xuICAgICAgICBfdGhpcy5fX2NvbG9yLl9fc3RhdGUgPSBpO1xuICAgICAgICBfdGhpcy5zZXRWYWx1ZShfdGhpcy5fX2NvbG9yLnRvT3JpZ2luYWwoKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnZhbHVlID0gX3RoaXMuX19jb2xvci50b1N0cmluZygpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBvbkZpbmlzaCgpIHtcbiAgICAgIGlmIChfdGhpcy5fX29uRmluaXNoQ2hhbmdlKSB7XG4gICAgICAgIF90aGlzLl9fb25GaW5pc2hDaGFuZ2UuY2FsbChfdGhpcywgX3RoaXMuX19jb2xvci50b09yaWdpbmFsKCkpO1xuICAgICAgfVxuICAgIH1cbiAgICBfdGhpczIuX19zYXR1cmF0aW9uX2ZpZWxkLmFwcGVuZENoaWxkKHZhbHVlRmllbGQpO1xuICAgIF90aGlzMi5fX3NlbGVjdG9yLmFwcGVuZENoaWxkKF90aGlzMi5fX2ZpZWxkX2tub2IpO1xuICAgIF90aGlzMi5fX3NlbGVjdG9yLmFwcGVuZENoaWxkKF90aGlzMi5fX3NhdHVyYXRpb25fZmllbGQpO1xuICAgIF90aGlzMi5fX3NlbGVjdG9yLmFwcGVuZENoaWxkKF90aGlzMi5fX2h1ZV9maWVsZCk7XG4gICAgX3RoaXMyLl9faHVlX2ZpZWxkLmFwcGVuZENoaWxkKF90aGlzMi5fX2h1ZV9rbm9iKTtcbiAgICBfdGhpczIuZG9tRWxlbWVudC5hcHBlbmRDaGlsZChfdGhpczIuX19pbnB1dCk7XG4gICAgX3RoaXMyLmRvbUVsZW1lbnQuYXBwZW5kQ2hpbGQoX3RoaXMyLl9fc2VsZWN0b3IpO1xuICAgIF90aGlzMi51cGRhdGVEaXNwbGF5KCk7XG4gICAgZnVuY3Rpb24gc2V0U1YoZSkge1xuICAgICAgaWYgKGUudHlwZS5pbmRleE9mKCd0b3VjaCcpID09PSAtMSkge1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB9XG4gICAgICB2YXIgZmllbGRSZWN0ID0gX3RoaXMuX19zYXR1cmF0aW9uX2ZpZWxkLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgdmFyIF9yZWYgPSBlLnRvdWNoZXMgJiYgZS50b3VjaGVzWzBdIHx8IGUsXG4gICAgICAgICAgY2xpZW50WCA9IF9yZWYuY2xpZW50WCxcbiAgICAgICAgICBjbGllbnRZID0gX3JlZi5jbGllbnRZO1xuICAgICAgdmFyIHMgPSAoY2xpZW50WCAtIGZpZWxkUmVjdC5sZWZ0KSAvIChmaWVsZFJlY3QucmlnaHQgLSBmaWVsZFJlY3QubGVmdCk7XG4gICAgICB2YXIgdiA9IDEgLSAoY2xpZW50WSAtIGZpZWxkUmVjdC50b3ApIC8gKGZpZWxkUmVjdC5ib3R0b20gLSBmaWVsZFJlY3QudG9wKTtcbiAgICAgIGlmICh2ID4gMSkge1xuICAgICAgICB2ID0gMTtcbiAgICAgIH0gZWxzZSBpZiAodiA8IDApIHtcbiAgICAgICAgdiA9IDA7XG4gICAgICB9XG4gICAgICBpZiAocyA+IDEpIHtcbiAgICAgICAgcyA9IDE7XG4gICAgICB9IGVsc2UgaWYgKHMgPCAwKSB7XG4gICAgICAgIHMgPSAwO1xuICAgICAgfVxuICAgICAgX3RoaXMuX19jb2xvci52ID0gdjtcbiAgICAgIF90aGlzLl9fY29sb3IucyA9IHM7XG4gICAgICBfdGhpcy5zZXRWYWx1ZShfdGhpcy5fX2NvbG9yLnRvT3JpZ2luYWwoKSk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNldEgoZSkge1xuICAgICAgaWYgKGUudHlwZS5pbmRleE9mKCd0b3VjaCcpID09PSAtMSkge1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB9XG4gICAgICB2YXIgZmllbGRSZWN0ID0gX3RoaXMuX19odWVfZmllbGQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICB2YXIgX3JlZjIgPSBlLnRvdWNoZXMgJiYgZS50b3VjaGVzWzBdIHx8IGUsXG4gICAgICAgICAgY2xpZW50WSA9IF9yZWYyLmNsaWVudFk7XG4gICAgICB2YXIgaCA9IDEgLSAoY2xpZW50WSAtIGZpZWxkUmVjdC50b3ApIC8gKGZpZWxkUmVjdC5ib3R0b20gLSBmaWVsZFJlY3QudG9wKTtcbiAgICAgIGlmIChoID4gMSkge1xuICAgICAgICBoID0gMTtcbiAgICAgIH0gZWxzZSBpZiAoaCA8IDApIHtcbiAgICAgICAgaCA9IDA7XG4gICAgICB9XG4gICAgICBfdGhpcy5fX2NvbG9yLmggPSBoICogMzYwO1xuICAgICAgX3RoaXMuc2V0VmFsdWUoX3RoaXMuX19jb2xvci50b09yaWdpbmFsKCkpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gX3RoaXMyO1xuICB9XG4gIGNyZWF0ZUNsYXNzKENvbG9yQ29udHJvbGxlciwgW3tcbiAgICBrZXk6ICd1cGRhdGVEaXNwbGF5JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlRGlzcGxheSgpIHtcbiAgICAgIHZhciBpID0gaW50ZXJwcmV0KHRoaXMuZ2V0VmFsdWUoKSk7XG4gICAgICBpZiAoaSAhPT0gZmFsc2UpIHtcbiAgICAgICAgdmFyIG1pc21hdGNoID0gZmFsc2U7XG4gICAgICAgIENvbW1vbi5lYWNoKENvbG9yLkNPTVBPTkVOVFMsIGZ1bmN0aW9uIChjb21wb25lbnQpIHtcbiAgICAgICAgICBpZiAoIUNvbW1vbi5pc1VuZGVmaW5lZChpW2NvbXBvbmVudF0pICYmICFDb21tb24uaXNVbmRlZmluZWQodGhpcy5fX2NvbG9yLl9fc3RhdGVbY29tcG9uZW50XSkgJiYgaVtjb21wb25lbnRdICE9PSB0aGlzLl9fY29sb3IuX19zdGF0ZVtjb21wb25lbnRdKSB7XG4gICAgICAgICAgICBtaXNtYXRjaCA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm4ge307XG4gICAgICAgICAgfVxuICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgaWYgKG1pc21hdGNoKSB7XG4gICAgICAgICAgQ29tbW9uLmV4dGVuZCh0aGlzLl9fY29sb3IuX19zdGF0ZSwgaSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIENvbW1vbi5leHRlbmQodGhpcy5fX3RlbXAuX19zdGF0ZSwgdGhpcy5fX2NvbG9yLl9fc3RhdGUpO1xuICAgICAgdGhpcy5fX3RlbXAuYSA9IDE7XG4gICAgICB2YXIgZmxpcCA9IHRoaXMuX19jb2xvci52IDwgMC41IHx8IHRoaXMuX19jb2xvci5zID4gMC41ID8gMjU1IDogMDtcbiAgICAgIHZhciBfZmxpcCA9IDI1NSAtIGZsaXA7XG4gICAgICBDb21tb24uZXh0ZW5kKHRoaXMuX19maWVsZF9rbm9iLnN0eWxlLCB7XG4gICAgICAgIG1hcmdpbkxlZnQ6IDEwMCAqIHRoaXMuX19jb2xvci5zIC0gNyArICdweCcsXG4gICAgICAgIG1hcmdpblRvcDogMTAwICogKDEgLSB0aGlzLl9fY29sb3IudikgLSA3ICsgJ3B4JyxcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiB0aGlzLl9fdGVtcC50b0hleFN0cmluZygpLFxuICAgICAgICBib3JkZXI6IHRoaXMuX19maWVsZF9rbm9iX2JvcmRlciArICdyZ2IoJyArIGZsaXAgKyAnLCcgKyBmbGlwICsgJywnICsgZmxpcCArICcpJ1xuICAgICAgfSk7XG4gICAgICB0aGlzLl9faHVlX2tub2Iuc3R5bGUubWFyZ2luVG9wID0gKDEgLSB0aGlzLl9fY29sb3IuaCAvIDM2MCkgKiAxMDAgKyAncHgnO1xuICAgICAgdGhpcy5fX3RlbXAucyA9IDE7XG4gICAgICB0aGlzLl9fdGVtcC52ID0gMTtcbiAgICAgIGxpbmVhckdyYWRpZW50KHRoaXMuX19zYXR1cmF0aW9uX2ZpZWxkLCAnbGVmdCcsICcjZmZmJywgdGhpcy5fX3RlbXAudG9IZXhTdHJpbmcoKSk7XG4gICAgICB0aGlzLl9faW5wdXQudmFsdWUgPSB0aGlzLl9fY29sb3IudG9TdHJpbmcoKTtcbiAgICAgIENvbW1vbi5leHRlbmQodGhpcy5fX2lucHV0LnN0eWxlLCB7XG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogdGhpcy5fX2NvbG9yLnRvSGV4U3RyaW5nKCksXG4gICAgICAgIGNvbG9yOiAncmdiKCcgKyBmbGlwICsgJywnICsgZmxpcCArICcsJyArIGZsaXAgKyAnKScsXG4gICAgICAgIHRleHRTaGFkb3c6IHRoaXMuX19pbnB1dF90ZXh0U2hhZG93ICsgJ3JnYmEoJyArIF9mbGlwICsgJywnICsgX2ZsaXAgKyAnLCcgKyBfZmxpcCArICcsLjcpJ1xuICAgICAgfSk7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBDb2xvckNvbnRyb2xsZXI7XG59KENvbnRyb2xsZXIpO1xudmFyIHZlbmRvcnMgPSBbJy1tb3otJywgJy1vLScsICctd2Via2l0LScsICctbXMtJywgJyddO1xuZnVuY3Rpb24gbGluZWFyR3JhZGllbnQoZWxlbSwgeCwgYSwgYikge1xuICBlbGVtLnN0eWxlLmJhY2tncm91bmQgPSAnJztcbiAgQ29tbW9uLmVhY2godmVuZG9ycywgZnVuY3Rpb24gKHZlbmRvcikge1xuICAgIGVsZW0uc3R5bGUuY3NzVGV4dCArPSAnYmFja2dyb3VuZDogJyArIHZlbmRvciArICdsaW5lYXItZ3JhZGllbnQoJyArIHggKyAnLCAnICsgYSArICcgMCUsICcgKyBiICsgJyAxMDAlKTsgJztcbiAgfSk7XG59XG5mdW5jdGlvbiBodWVHcmFkaWVudChlbGVtKSB7XG4gIGVsZW0uc3R5bGUuYmFja2dyb3VuZCA9ICcnO1xuICBlbGVtLnN0eWxlLmNzc1RleHQgKz0gJ2JhY2tncm91bmQ6IC1tb3otbGluZWFyLWdyYWRpZW50KHRvcCwgICNmZjAwMDAgMCUsICNmZjAwZmYgMTclLCAjMDAwMGZmIDM0JSwgIzAwZmZmZiA1MCUsICMwMGZmMDAgNjclLCAjZmZmZjAwIDg0JSwgI2ZmMDAwMCAxMDAlKTsnO1xuICBlbGVtLnN0eWxlLmNzc1RleHQgKz0gJ2JhY2tncm91bmQ6IC13ZWJraXQtbGluZWFyLWdyYWRpZW50KHRvcCwgICNmZjAwMDAgMCUsI2ZmMDBmZiAxNyUsIzAwMDBmZiAzNCUsIzAwZmZmZiA1MCUsIzAwZmYwMCA2NyUsI2ZmZmYwMCA4NCUsI2ZmMDAwMCAxMDAlKTsnO1xuICBlbGVtLnN0eWxlLmNzc1RleHQgKz0gJ2JhY2tncm91bmQ6IC1vLWxpbmVhci1ncmFkaWVudCh0b3AsICAjZmYwMDAwIDAlLCNmZjAwZmYgMTclLCMwMDAwZmYgMzQlLCMwMGZmZmYgNTAlLCMwMGZmMDAgNjclLCNmZmZmMDAgODQlLCNmZjAwMDAgMTAwJSk7JztcbiAgZWxlbS5zdHlsZS5jc3NUZXh0ICs9ICdiYWNrZ3JvdW5kOiAtbXMtbGluZWFyLWdyYWRpZW50KHRvcCwgICNmZjAwMDAgMCUsI2ZmMDBmZiAxNyUsIzAwMDBmZiAzNCUsIzAwZmZmZiA1MCUsIzAwZmYwMCA2NyUsI2ZmZmYwMCA4NCUsI2ZmMDAwMCAxMDAlKTsnO1xuICBlbGVtLnN0eWxlLmNzc1RleHQgKz0gJ2JhY2tncm91bmQ6IGxpbmVhci1ncmFkaWVudCh0b3AsICAjZmYwMDAwIDAlLCNmZjAwZmYgMTclLCMwMDAwZmYgMzQlLCMwMGZmZmYgNTAlLCMwMGZmMDAgNjclLCNmZmZmMDAgODQlLCNmZjAwMDAgMTAwJSk7Jztcbn1cblxudmFyIGNzcyA9IHtcbiAgbG9hZDogZnVuY3Rpb24gbG9hZCh1cmwsIGluZG9jKSB7XG4gICAgdmFyIGRvYyA9IGluZG9jIHx8IGRvY3VtZW50O1xuICAgIHZhciBsaW5rID0gZG9jLmNyZWF0ZUVsZW1lbnQoJ2xpbmsnKTtcbiAgICBsaW5rLnR5cGUgPSAndGV4dC9jc3MnO1xuICAgIGxpbmsucmVsID0gJ3N0eWxlc2hlZXQnO1xuICAgIGxpbmsuaHJlZiA9IHVybDtcbiAgICBkb2MuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2hlYWQnKVswXS5hcHBlbmRDaGlsZChsaW5rKTtcbiAgfSxcbiAgaW5qZWN0OiBmdW5jdGlvbiBpbmplY3QoY3NzQ29udGVudCwgaW5kb2MpIHtcbiAgICB2YXIgZG9jID0gaW5kb2MgfHwgZG9jdW1lbnQ7XG4gICAgdmFyIGluamVjdGVkID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKTtcbiAgICBpbmplY3RlZC50eXBlID0gJ3RleHQvY3NzJztcbiAgICBpbmplY3RlZC5pbm5lckhUTUwgPSBjc3NDb250ZW50O1xuICAgIHZhciBoZWFkID0gZG9jLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdoZWFkJylbMF07XG4gICAgdHJ5IHtcbiAgICAgIGhlYWQuYXBwZW5kQ2hpbGQoaW5qZWN0ZWQpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICB9XG4gIH1cbn07XG5cbnZhciBzYXZlRGlhbG9nQ29udGVudHMgPSBcIjxkaXYgaWQ9XFxcImRnLXNhdmVcXFwiIGNsYXNzPVxcXCJkZyBkaWFsb2d1ZVxcXCI+XFxuXFxuICBIZXJlJ3MgdGhlIG5ldyBsb2FkIHBhcmFtZXRlciBmb3IgeW91ciA8Y29kZT5HVUk8L2NvZGU+J3MgY29uc3RydWN0b3I6XFxuXFxuICA8dGV4dGFyZWEgaWQ9XFxcImRnLW5ldy1jb25zdHJ1Y3RvclxcXCI+PC90ZXh0YXJlYT5cXG5cXG4gIDxkaXYgaWQ9XFxcImRnLXNhdmUtbG9jYWxseVxcXCI+XFxuXFxuICAgIDxpbnB1dCBpZD1cXFwiZGctbG9jYWwtc3RvcmFnZVxcXCIgdHlwZT1cXFwiY2hlY2tib3hcXFwiLz4gQXV0b21hdGljYWxseSBzYXZlXFxuICAgIHZhbHVlcyB0byA8Y29kZT5sb2NhbFN0b3JhZ2U8L2NvZGU+IG9uIGV4aXQuXFxuXFxuICAgIDxkaXYgaWQ9XFxcImRnLWxvY2FsLWV4cGxhaW5cXFwiPlRoZSB2YWx1ZXMgc2F2ZWQgdG8gPGNvZGU+bG9jYWxTdG9yYWdlPC9jb2RlPiB3aWxsXFxuICAgICAgb3ZlcnJpZGUgdGhvc2UgcGFzc2VkIHRvIDxjb2RlPmRhdC5HVUk8L2NvZGU+J3MgY29uc3RydWN0b3IuIFRoaXMgbWFrZXMgaXRcXG4gICAgICBlYXNpZXIgdG8gd29yayBpbmNyZW1lbnRhbGx5LCBidXQgPGNvZGU+bG9jYWxTdG9yYWdlPC9jb2RlPiBpcyBmcmFnaWxlLFxcbiAgICAgIGFuZCB5b3VyIGZyaWVuZHMgbWF5IG5vdCBzZWUgdGhlIHNhbWUgdmFsdWVzIHlvdSBkby5cXG5cXG4gICAgPC9kaXY+XFxuXFxuICA8L2Rpdj5cXG5cXG48L2Rpdj5cIjtcblxudmFyIENvbnRyb2xsZXJGYWN0b3J5ID0gZnVuY3Rpb24gQ29udHJvbGxlckZhY3Rvcnkob2JqZWN0LCBwcm9wZXJ0eSkge1xuICB2YXIgaW5pdGlhbFZhbHVlID0gb2JqZWN0W3Byb3BlcnR5XTtcbiAgaWYgKENvbW1vbi5pc0FycmF5KGFyZ3VtZW50c1syXSkgfHwgQ29tbW9uLmlzT2JqZWN0KGFyZ3VtZW50c1syXSkpIHtcbiAgICByZXR1cm4gbmV3IE9wdGlvbkNvbnRyb2xsZXIob2JqZWN0LCBwcm9wZXJ0eSwgYXJndW1lbnRzWzJdKTtcbiAgfVxuICBpZiAoQ29tbW9uLmlzTnVtYmVyKGluaXRpYWxWYWx1ZSkpIHtcbiAgICBpZiAoQ29tbW9uLmlzTnVtYmVyKGFyZ3VtZW50c1syXSkgJiYgQ29tbW9uLmlzTnVtYmVyKGFyZ3VtZW50c1szXSkpIHtcbiAgICAgIGlmIChDb21tb24uaXNOdW1iZXIoYXJndW1lbnRzWzRdKSkge1xuICAgICAgICByZXR1cm4gbmV3IE51bWJlckNvbnRyb2xsZXJTbGlkZXIob2JqZWN0LCBwcm9wZXJ0eSwgYXJndW1lbnRzWzJdLCBhcmd1bWVudHNbM10sIGFyZ3VtZW50c1s0XSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IE51bWJlckNvbnRyb2xsZXJTbGlkZXIob2JqZWN0LCBwcm9wZXJ0eSwgYXJndW1lbnRzWzJdLCBhcmd1bWVudHNbM10pO1xuICAgIH1cbiAgICBpZiAoQ29tbW9uLmlzTnVtYmVyKGFyZ3VtZW50c1s0XSkpIHtcbiAgICAgIHJldHVybiBuZXcgTnVtYmVyQ29udHJvbGxlckJveChvYmplY3QsIHByb3BlcnR5LCB7IG1pbjogYXJndW1lbnRzWzJdLCBtYXg6IGFyZ3VtZW50c1szXSwgc3RlcDogYXJndW1lbnRzWzRdIH0pO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IE51bWJlckNvbnRyb2xsZXJCb3gob2JqZWN0LCBwcm9wZXJ0eSwgeyBtaW46IGFyZ3VtZW50c1syXSwgbWF4OiBhcmd1bWVudHNbM10gfSk7XG4gIH1cbiAgaWYgKENvbW1vbi5pc1N0cmluZyhpbml0aWFsVmFsdWUpKSB7XG4gICAgcmV0dXJuIG5ldyBTdHJpbmdDb250cm9sbGVyKG9iamVjdCwgcHJvcGVydHkpO1xuICB9XG4gIGlmIChDb21tb24uaXNGdW5jdGlvbihpbml0aWFsVmFsdWUpKSB7XG4gICAgcmV0dXJuIG5ldyBGdW5jdGlvbkNvbnRyb2xsZXIob2JqZWN0LCBwcm9wZXJ0eSwgJycpO1xuICB9XG4gIGlmIChDb21tb24uaXNCb29sZWFuKGluaXRpYWxWYWx1ZSkpIHtcbiAgICByZXR1cm4gbmV3IEJvb2xlYW5Db250cm9sbGVyKG9iamVjdCwgcHJvcGVydHkpO1xuICB9XG4gIHJldHVybiBudWxsO1xufTtcblxuZnVuY3Rpb24gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGNhbGxiYWNrKSB7XG4gIHNldFRpbWVvdXQoY2FsbGJhY2ssIDEwMDAgLyA2MCk7XG59XG52YXIgcmVxdWVzdEFuaW1hdGlvbkZyYW1lJDEgPSB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8IHdpbmRvdy53ZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHwgd2luZG93Lm1velJlcXVlc3RBbmltYXRpb25GcmFtZSB8fCB3aW5kb3cub1JlcXVlc3RBbmltYXRpb25GcmFtZSB8fCB3aW5kb3cubXNSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHwgcmVxdWVzdEFuaW1hdGlvbkZyYW1lO1xuXG52YXIgQ2VudGVyZWREaXYgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIENlbnRlcmVkRGl2KCkge1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIENlbnRlcmVkRGl2KTtcbiAgICB0aGlzLmJhY2tncm91bmRFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgQ29tbW9uLmV4dGVuZCh0aGlzLmJhY2tncm91bmRFbGVtZW50LnN0eWxlLCB7XG4gICAgICBiYWNrZ3JvdW5kQ29sb3I6ICdyZ2JhKDAsMCwwLDAuOCknLFxuICAgICAgdG9wOiAwLFxuICAgICAgbGVmdDogMCxcbiAgICAgIGRpc3BsYXk6ICdub25lJyxcbiAgICAgIHpJbmRleDogJzEwMDAnLFxuICAgICAgb3BhY2l0eTogMCxcbiAgICAgIFdlYmtpdFRyYW5zaXRpb246ICdvcGFjaXR5IDAuMnMgbGluZWFyJyxcbiAgICAgIHRyYW5zaXRpb246ICdvcGFjaXR5IDAuMnMgbGluZWFyJ1xuICAgIH0pO1xuICAgIGRvbS5tYWtlRnVsbHNjcmVlbih0aGlzLmJhY2tncm91bmRFbGVtZW50KTtcbiAgICB0aGlzLmJhY2tncm91bmRFbGVtZW50LnN0eWxlLnBvc2l0aW9uID0gJ2ZpeGVkJztcbiAgICB0aGlzLmRvbUVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBDb21tb24uZXh0ZW5kKHRoaXMuZG9tRWxlbWVudC5zdHlsZSwge1xuICAgICAgcG9zaXRpb246ICdmaXhlZCcsXG4gICAgICBkaXNwbGF5OiAnbm9uZScsXG4gICAgICB6SW5kZXg6ICcxMDAxJyxcbiAgICAgIG9wYWNpdHk6IDAsXG4gICAgICBXZWJraXRUcmFuc2l0aW9uOiAnLXdlYmtpdC10cmFuc2Zvcm0gMC4ycyBlYXNlLW91dCwgb3BhY2l0eSAwLjJzIGxpbmVhcicsXG4gICAgICB0cmFuc2l0aW9uOiAndHJhbnNmb3JtIDAuMnMgZWFzZS1vdXQsIG9wYWNpdHkgMC4ycyBsaW5lYXInXG4gICAgfSk7XG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh0aGlzLmJhY2tncm91bmRFbGVtZW50KTtcbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHRoaXMuZG9tRWxlbWVudCk7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICBkb20uYmluZCh0aGlzLmJhY2tncm91bmRFbGVtZW50LCAnY2xpY2snLCBmdW5jdGlvbiAoKSB7XG4gICAgICBfdGhpcy5oaWRlKCk7XG4gICAgfSk7XG4gIH1cbiAgY3JlYXRlQ2xhc3MoQ2VudGVyZWREaXYsIFt7XG4gICAga2V5OiAnc2hvdycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNob3coKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgdGhpcy5iYWNrZ3JvdW5kRWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcbiAgICAgIHRoaXMuZG9tRWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcbiAgICAgIHRoaXMuZG9tRWxlbWVudC5zdHlsZS5vcGFjaXR5ID0gMDtcbiAgICAgIHRoaXMuZG9tRWxlbWVudC5zdHlsZS53ZWJraXRUcmFuc2Zvcm0gPSAnc2NhbGUoMS4xKSc7XG4gICAgICB0aGlzLmxheW91dCgpO1xuICAgICAgQ29tbW9uLmRlZmVyKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMuYmFja2dyb3VuZEVsZW1lbnQuc3R5bGUub3BhY2l0eSA9IDE7XG4gICAgICAgIF90aGlzLmRvbUVsZW1lbnQuc3R5bGUub3BhY2l0eSA9IDE7XG4gICAgICAgIF90aGlzLmRvbUVsZW1lbnQuc3R5bGUud2Via2l0VHJhbnNmb3JtID0gJ3NjYWxlKDEpJztcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2hpZGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoaWRlKCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgIHZhciBoaWRlID0gZnVuY3Rpb24gaGlkZSgpIHtcbiAgICAgICAgX3RoaXMuZG9tRWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICBfdGhpcy5iYWNrZ3JvdW5kRWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICBkb20udW5iaW5kKF90aGlzLmRvbUVsZW1lbnQsICd3ZWJraXRUcmFuc2l0aW9uRW5kJywgaGlkZSk7XG4gICAgICAgIGRvbS51bmJpbmQoX3RoaXMuZG9tRWxlbWVudCwgJ3RyYW5zaXRpb25lbmQnLCBoaWRlKTtcbiAgICAgICAgZG9tLnVuYmluZChfdGhpcy5kb21FbGVtZW50LCAnb1RyYW5zaXRpb25FbmQnLCBoaWRlKTtcbiAgICAgIH07XG4gICAgICBkb20uYmluZCh0aGlzLmRvbUVsZW1lbnQsICd3ZWJraXRUcmFuc2l0aW9uRW5kJywgaGlkZSk7XG4gICAgICBkb20uYmluZCh0aGlzLmRvbUVsZW1lbnQsICd0cmFuc2l0aW9uZW5kJywgaGlkZSk7XG4gICAgICBkb20uYmluZCh0aGlzLmRvbUVsZW1lbnQsICdvVHJhbnNpdGlvbkVuZCcsIGhpZGUpO1xuICAgICAgdGhpcy5iYWNrZ3JvdW5kRWxlbWVudC5zdHlsZS5vcGFjaXR5ID0gMDtcbiAgICAgIHRoaXMuZG9tRWxlbWVudC5zdHlsZS5vcGFjaXR5ID0gMDtcbiAgICAgIHRoaXMuZG9tRWxlbWVudC5zdHlsZS53ZWJraXRUcmFuc2Zvcm0gPSAnc2NhbGUoMS4xKSc7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnbGF5b3V0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gbGF5b3V0KCkge1xuICAgICAgdGhpcy5kb21FbGVtZW50LnN0eWxlLmxlZnQgPSB3aW5kb3cuaW5uZXJXaWR0aCAvIDIgLSBkb20uZ2V0V2lkdGgodGhpcy5kb21FbGVtZW50KSAvIDIgKyAncHgnO1xuICAgICAgdGhpcy5kb21FbGVtZW50LnN0eWxlLnRvcCA9IHdpbmRvdy5pbm5lckhlaWdodCAvIDIgLSBkb20uZ2V0SGVpZ2h0KHRoaXMuZG9tRWxlbWVudCkgLyAyICsgJ3B4JztcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIENlbnRlcmVkRGl2O1xufSgpO1xuXG52YXIgc3R5bGVTaGVldCA9IF9fXyRpbnNlcnRTdHlsZShcIi5kZyB1bHtsaXN0LXN0eWxlOm5vbmU7bWFyZ2luOjA7cGFkZGluZzowO3dpZHRoOjEwMCU7Y2xlYXI6Ym90aH0uZGcuYWN7cG9zaXRpb246Zml4ZWQ7dG9wOjA7bGVmdDowO3JpZ2h0OjA7aGVpZ2h0OjA7ei1pbmRleDowfS5kZzpub3QoLmFjKSAubWFpbntvdmVyZmxvdzpoaWRkZW59LmRnLm1haW57LXdlYmtpdC10cmFuc2l0aW9uOm9wYWNpdHkgLjFzIGxpbmVhcjstby10cmFuc2l0aW9uOm9wYWNpdHkgLjFzIGxpbmVhcjstbW96LXRyYW5zaXRpb246b3BhY2l0eSAuMXMgbGluZWFyO3RyYW5zaXRpb246b3BhY2l0eSAuMXMgbGluZWFyfS5kZy5tYWluLnRhbGxlci10aGFuLXdpbmRvd3tvdmVyZmxvdy15OmF1dG99LmRnLm1haW4udGFsbGVyLXRoYW4td2luZG93IC5jbG9zZS1idXR0b257b3BhY2l0eToxO21hcmdpbi10b3A6LTFweDtib3JkZXItdG9wOjFweCBzb2xpZCAjMmMyYzJjfS5kZy5tYWluIHVsLmNsb3NlZCAuY2xvc2UtYnV0dG9ue29wYWNpdHk6MSAhaW1wb3J0YW50fS5kZy5tYWluOmhvdmVyIC5jbG9zZS1idXR0b24sLmRnLm1haW4gLmNsb3NlLWJ1dHRvbi5kcmFne29wYWNpdHk6MX0uZGcubWFpbiAuY2xvc2UtYnV0dG9uey13ZWJraXQtdHJhbnNpdGlvbjpvcGFjaXR5IC4xcyBsaW5lYXI7LW8tdHJhbnNpdGlvbjpvcGFjaXR5IC4xcyBsaW5lYXI7LW1vei10cmFuc2l0aW9uOm9wYWNpdHkgLjFzIGxpbmVhcjt0cmFuc2l0aW9uOm9wYWNpdHkgLjFzIGxpbmVhcjtib3JkZXI6MDtsaW5lLWhlaWdodDoxOXB4O2hlaWdodDoyMHB4O2N1cnNvcjpwb2ludGVyO3RleHQtYWxpZ246Y2VudGVyO2JhY2tncm91bmQtY29sb3I6IzAwMH0uZGcubWFpbiAuY2xvc2UtYnV0dG9uLmNsb3NlLXRvcHtwb3NpdGlvbjpyZWxhdGl2ZX0uZGcubWFpbiAuY2xvc2UtYnV0dG9uLmNsb3NlLWJvdHRvbXtwb3NpdGlvbjphYnNvbHV0ZX0uZGcubWFpbiAuY2xvc2UtYnV0dG9uOmhvdmVye2JhY2tncm91bmQtY29sb3I6IzExMX0uZGcuYXtmbG9hdDpyaWdodDttYXJnaW4tcmlnaHQ6MTVweDtvdmVyZmxvdy15OnZpc2libGV9LmRnLmEuaGFzLXNhdmU+dWwuY2xvc2UtdG9we21hcmdpbi10b3A6MH0uZGcuYS5oYXMtc2F2ZT51bC5jbG9zZS1ib3R0b217bWFyZ2luLXRvcDoyN3B4fS5kZy5hLmhhcy1zYXZlPnVsLmNsb3NlZHttYXJnaW4tdG9wOjB9LmRnLmEgLnNhdmUtcm93e3RvcDowO3otaW5kZXg6MTAwMn0uZGcuYSAuc2F2ZS1yb3cuY2xvc2UtdG9we3Bvc2l0aW9uOnJlbGF0aXZlfS5kZy5hIC5zYXZlLXJvdy5jbG9zZS1ib3R0b217cG9zaXRpb246Zml4ZWR9LmRnIGxpey13ZWJraXQtdHJhbnNpdGlvbjpoZWlnaHQgLjFzIGVhc2Utb3V0Oy1vLXRyYW5zaXRpb246aGVpZ2h0IC4xcyBlYXNlLW91dDstbW96LXRyYW5zaXRpb246aGVpZ2h0IC4xcyBlYXNlLW91dDt0cmFuc2l0aW9uOmhlaWdodCAuMXMgZWFzZS1vdXQ7LXdlYmtpdC10cmFuc2l0aW9uOm92ZXJmbG93IC4xcyBsaW5lYXI7LW8tdHJhbnNpdGlvbjpvdmVyZmxvdyAuMXMgbGluZWFyOy1tb3otdHJhbnNpdGlvbjpvdmVyZmxvdyAuMXMgbGluZWFyO3RyYW5zaXRpb246b3ZlcmZsb3cgLjFzIGxpbmVhcn0uZGcgbGk6bm90KC5mb2xkZXIpe2N1cnNvcjphdXRvO2hlaWdodDoyN3B4O2xpbmUtaGVpZ2h0OjI3cHg7cGFkZGluZzowIDRweCAwIDVweH0uZGcgbGkuZm9sZGVye3BhZGRpbmc6MDtib3JkZXItbGVmdDo0cHggc29saWQgcmdiYSgwLDAsMCwwKX0uZGcgbGkudGl0bGV7Y3Vyc29yOnBvaW50ZXI7bWFyZ2luLWxlZnQ6LTRweH0uZGcgLmNsb3NlZCBsaTpub3QoLnRpdGxlKSwuZGcgLmNsb3NlZCB1bCBsaSwuZGcgLmNsb3NlZCB1bCBsaT4qe2hlaWdodDowO292ZXJmbG93OmhpZGRlbjtib3JkZXI6MH0uZGcgLmNye2NsZWFyOmJvdGg7cGFkZGluZy1sZWZ0OjNweDtoZWlnaHQ6MjdweDtvdmVyZmxvdzpoaWRkZW59LmRnIC5wcm9wZXJ0eS1uYW1le2N1cnNvcjpkZWZhdWx0O2Zsb2F0OmxlZnQ7Y2xlYXI6bGVmdDt3aWR0aDo0MCU7b3ZlcmZsb3c6aGlkZGVuO3RleHQtb3ZlcmZsb3c6ZWxsaXBzaXN9LmRnIC5je2Zsb2F0OmxlZnQ7d2lkdGg6NjAlO3Bvc2l0aW9uOnJlbGF0aXZlfS5kZyAuYyBpbnB1dFt0eXBlPXRleHRde2JvcmRlcjowO21hcmdpbi10b3A6NHB4O3BhZGRpbmc6M3B4O3dpZHRoOjEwMCU7ZmxvYXQ6cmlnaHR9LmRnIC5oYXMtc2xpZGVyIGlucHV0W3R5cGU9dGV4dF17d2lkdGg6MzAlO21hcmdpbi1sZWZ0OjB9LmRnIC5zbGlkZXJ7ZmxvYXQ6bGVmdDt3aWR0aDo2NiU7bWFyZ2luLWxlZnQ6LTVweDttYXJnaW4tcmlnaHQ6MDtoZWlnaHQ6MTlweDttYXJnaW4tdG9wOjRweH0uZGcgLnNsaWRlci1mZ3toZWlnaHQ6MTAwJX0uZGcgLmMgaW5wdXRbdHlwZT1jaGVja2JveF17bWFyZ2luLXRvcDo3cHh9LmRnIC5jIHNlbGVjdHttYXJnaW4tdG9wOjVweH0uZGcgLmNyLmZ1bmN0aW9uLC5kZyAuY3IuZnVuY3Rpb24gLnByb3BlcnR5LW5hbWUsLmRnIC5jci5mdW5jdGlvbiAqLC5kZyAuY3IuYm9vbGVhbiwuZGcgLmNyLmJvb2xlYW4gKntjdXJzb3I6cG9pbnRlcn0uZGcgLmNyLmNvbG9ye292ZXJmbG93OnZpc2libGV9LmRnIC5zZWxlY3RvcntkaXNwbGF5Om5vbmU7cG9zaXRpb246YWJzb2x1dGU7bWFyZ2luLWxlZnQ6LTlweDttYXJnaW4tdG9wOjIzcHg7ei1pbmRleDoxMH0uZGcgLmM6aG92ZXIgLnNlbGVjdG9yLC5kZyAuc2VsZWN0b3IuZHJhZ3tkaXNwbGF5OmJsb2NrfS5kZyBsaS5zYXZlLXJvd3twYWRkaW5nOjB9LmRnIGxpLnNhdmUtcm93IC5idXR0b257ZGlzcGxheTppbmxpbmUtYmxvY2s7cGFkZGluZzowcHggNnB4fS5kZy5kaWFsb2d1ZXtiYWNrZ3JvdW5kLWNvbG9yOiMyMjI7d2lkdGg6NDYwcHg7cGFkZGluZzoxNXB4O2ZvbnQtc2l6ZToxM3B4O2xpbmUtaGVpZ2h0OjE1cHh9I2RnLW5ldy1jb25zdHJ1Y3RvcntwYWRkaW5nOjEwcHg7Y29sb3I6IzIyMjtmb250LWZhbWlseTpNb25hY28sIG1vbm9zcGFjZTtmb250LXNpemU6MTBweDtib3JkZXI6MDtyZXNpemU6bm9uZTtib3gtc2hhZG93Omluc2V0IDFweCAxcHggMXB4ICM4ODg7d29yZC13cmFwOmJyZWFrLXdvcmQ7bWFyZ2luOjEycHggMDtkaXNwbGF5OmJsb2NrO3dpZHRoOjQ0MHB4O292ZXJmbG93LXk6c2Nyb2xsO2hlaWdodDoxMDBweDtwb3NpdGlvbjpyZWxhdGl2ZX0jZGctbG9jYWwtZXhwbGFpbntkaXNwbGF5Om5vbmU7Zm9udC1zaXplOjExcHg7bGluZS1oZWlnaHQ6MTdweDtib3JkZXItcmFkaXVzOjNweDtiYWNrZ3JvdW5kLWNvbG9yOiMzMzM7cGFkZGluZzo4cHg7bWFyZ2luLXRvcDoxMHB4fSNkZy1sb2NhbC1leHBsYWluIGNvZGV7Zm9udC1zaXplOjEwcHh9I2RhdC1ndWktc2F2ZS1sb2NhbGx5e2Rpc3BsYXk6bm9uZX0uZGd7Y29sb3I6I2VlZTtmb250OjExcHggJ0x1Y2lkYSBHcmFuZGUnLCBzYW5zLXNlcmlmO3RleHQtc2hhZG93OjAgLTFweCAwICMxMTF9LmRnLm1haW46Oi13ZWJraXQtc2Nyb2xsYmFye3dpZHRoOjVweDtiYWNrZ3JvdW5kOiMxYTFhMWF9LmRnLm1haW46Oi13ZWJraXQtc2Nyb2xsYmFyLWNvcm5lcntoZWlnaHQ6MDtkaXNwbGF5Om5vbmV9LmRnLm1haW46Oi13ZWJraXQtc2Nyb2xsYmFyLXRodW1ie2JvcmRlci1yYWRpdXM6NXB4O2JhY2tncm91bmQ6IzY3Njc2N30uZGcgbGk6bm90KC5mb2xkZXIpe2JhY2tncm91bmQ6IzFhMWExYTtib3JkZXItYm90dG9tOjFweCBzb2xpZCAjMmMyYzJjfS5kZyBsaS5zYXZlLXJvd3tsaW5lLWhlaWdodDoyNXB4O2JhY2tncm91bmQ6I2RhZDVjYjtib3JkZXI6MH0uZGcgbGkuc2F2ZS1yb3cgc2VsZWN0e21hcmdpbi1sZWZ0OjVweDt3aWR0aDoxMDhweH0uZGcgbGkuc2F2ZS1yb3cgLmJ1dHRvbnttYXJnaW4tbGVmdDo1cHg7bWFyZ2luLXRvcDoxcHg7Ym9yZGVyLXJhZGl1czoycHg7Zm9udC1zaXplOjlweDtsaW5lLWhlaWdodDo3cHg7cGFkZGluZzo0cHggNHB4IDVweCA0cHg7YmFja2dyb3VuZDojYzViZGFkO2NvbG9yOiNmZmY7dGV4dC1zaGFkb3c6MCAxcHggMCAjYjBhNThmO2JveC1zaGFkb3c6MCAtMXB4IDAgI2IwYTU4ZjtjdXJzb3I6cG9pbnRlcn0uZGcgbGkuc2F2ZS1yb3cgLmJ1dHRvbi5nZWFyc3tiYWNrZ3JvdW5kOiNjNWJkYWQgdXJsKGRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBQXNBQUFBTkNBWUFBQUIvOVpRN0FBQUFHWFJGV0hSVGIyWjBkMkZ5WlFCQlpHOWlaU0JKYldGblpWSmxZV1I1Y2NsbFBBQUFBUUpKUkVGVWVOcGlZS0FVL1AvL1B3R0lDL0FwQ0FCaUJTQVcrSThBQ2xBY2dLeFE0VDlob01BRVVyeHgyUVNHTjYrZWdEWCsvdldUNGU3TjgyQU1Zb1BBeC9ldndXb1lvU1liQUNYMnM3S3hDeHpjc2V6RGgzZXZGb0RFQllURUVxeWNnZ1dBekE5QXVVU1FRZ2VZUGE5ZlB2Ni9ZV20vQWN4NUlQYjd0eS9mdytRWmJsdzY3dkRzOFIwWUh5UWhnT2J4K3lBSmtCcW1HNWRQUERoMWFQT0dSL2V1Z1cwRzR2bElvVElmeUZjQStRZWtoaEhKaFBkUXhiaUFJZ3VNQlRRWnJQRDcxMDhNNnJvV1lERlFpSUFBdjZBb3cvMWJGd1hnaXMrZjJMVUF5bndvSWFOY3o4WE54M0RsN01FSlVER1FweDlndFE4WUN1ZUIrRDI2T0VDQUFRRGFkdDdlNDZENDJRQUFBQUJKUlU1RXJrSmdnZz09KSAycHggMXB4IG5vLXJlcGVhdDtoZWlnaHQ6N3B4O3dpZHRoOjhweH0uZGcgbGkuc2F2ZS1yb3cgLmJ1dHRvbjpob3ZlcntiYWNrZ3JvdW5kLWNvbG9yOiNiYWIxOWU7Ym94LXNoYWRvdzowIC0xcHggMCAjYjBhNThmfS5kZyBsaS5mb2xkZXJ7Ym9yZGVyLWJvdHRvbTowfS5kZyBsaS50aXRsZXtwYWRkaW5nLWxlZnQ6MTZweDtiYWNrZ3JvdW5kOiMwMDAgdXJsKGRhdGE6aW1hZ2UvZ2lmO2Jhc2U2NCxSMGxHT0RsaEJRQUZBSkVBQVAvLy8vUHo4Ly8vLy8vLy95SDVCQUVBQUFJQUxBQUFBQUFGQUFVQUFBSUlsSStoS2dGeG9DZ0FPdz09KSA2cHggMTBweCBuby1yZXBlYXQ7Y3Vyc29yOnBvaW50ZXI7Ym9yZGVyLWJvdHRvbToxcHggc29saWQgcmdiYSgyNTUsMjU1LDI1NSwwLjIpfS5kZyAuY2xvc2VkIGxpLnRpdGxle2JhY2tncm91bmQtaW1hZ2U6dXJsKGRhdGE6aW1hZ2UvZ2lmO2Jhc2U2NCxSMGxHT0RsaEJRQUZBSkVBQVAvLy8vUHo4Ly8vLy8vLy95SDVCQUVBQUFJQUxBQUFBQUFGQUFVQUFBSUlsR0lXcU1DYldBRUFPdz09KX0uZGcgLmNyLmJvb2xlYW57Ym9yZGVyLWxlZnQ6M3B4IHNvbGlkICM4MDY3ODd9LmRnIC5jci5jb2xvcntib3JkZXItbGVmdDozcHggc29saWR9LmRnIC5jci5mdW5jdGlvbntib3JkZXItbGVmdDozcHggc29saWQgI2U2MWQ1Zn0uZGcgLmNyLm51bWJlcntib3JkZXItbGVmdDozcHggc29saWQgIzJGQTFENn0uZGcgLmNyLm51bWJlciBpbnB1dFt0eXBlPXRleHRde2NvbG9yOiMyRkExRDZ9LmRnIC5jci5zdHJpbmd7Ym9yZGVyLWxlZnQ6M3B4IHNvbGlkICMxZWQzNmZ9LmRnIC5jci5zdHJpbmcgaW5wdXRbdHlwZT10ZXh0XXtjb2xvcjojMWVkMzZmfS5kZyAuY3IuZnVuY3Rpb246aG92ZXIsLmRnIC5jci5ib29sZWFuOmhvdmVye2JhY2tncm91bmQ6IzExMX0uZGcgLmMgaW5wdXRbdHlwZT10ZXh0XXtiYWNrZ3JvdW5kOiMzMDMwMzA7b3V0bGluZTpub25lfS5kZyAuYyBpbnB1dFt0eXBlPXRleHRdOmhvdmVye2JhY2tncm91bmQ6IzNjM2MzY30uZGcgLmMgaW5wdXRbdHlwZT10ZXh0XTpmb2N1c3tiYWNrZ3JvdW5kOiM0OTQ5NDk7Y29sb3I6I2ZmZn0uZGcgLmMgLnNsaWRlcntiYWNrZ3JvdW5kOiMzMDMwMzA7Y3Vyc29yOmV3LXJlc2l6ZX0uZGcgLmMgLnNsaWRlci1mZ3tiYWNrZ3JvdW5kOiMyRkExRDY7bWF4LXdpZHRoOjEwMCV9LmRnIC5jIC5zbGlkZXI6aG92ZXJ7YmFja2dyb3VuZDojM2MzYzNjfS5kZyAuYyAuc2xpZGVyOmhvdmVyIC5zbGlkZXItZmd7YmFja2dyb3VuZDojNDRhYmRhfVxcblwiKTtcblxuY3NzLmluamVjdChzdHlsZVNoZWV0KTtcbnZhciBDU1NfTkFNRVNQQUNFID0gJ2RnJztcbnZhciBISURFX0tFWV9DT0RFID0gNzI7XG52YXIgQ0xPU0VfQlVUVE9OX0hFSUdIVCA9IDIwO1xudmFyIERFRkFVTFRfREVGQVVMVF9QUkVTRVRfTkFNRSA9ICdEZWZhdWx0JztcbnZhciBTVVBQT1JUU19MT0NBTF9TVE9SQUdFID0gZnVuY3Rpb24gKCkge1xuICB0cnkge1xuICAgIHJldHVybiAhIXdpbmRvdy5sb2NhbFN0b3JhZ2U7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn0oKTtcbnZhciBTQVZFX0RJQUxPR1VFID0gdm9pZCAwO1xudmFyIGF1dG9QbGFjZVZpcmdpbiA9IHRydWU7XG52YXIgYXV0b1BsYWNlQ29udGFpbmVyID0gdm9pZCAwO1xudmFyIGhpZGUgPSBmYWxzZTtcbnZhciBoaWRlYWJsZUd1aXMgPSBbXTtcbnZhciBHVUkgPSBmdW5jdGlvbiBHVUkocGFycykge1xuICB2YXIgX3RoaXMgPSB0aGlzO1xuICB2YXIgcGFyYW1zID0gcGFycyB8fCB7fTtcbiAgdGhpcy5kb21FbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIHRoaXMuX191bCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3VsJyk7XG4gIHRoaXMuZG9tRWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLl9fdWwpO1xuICBkb20uYWRkQ2xhc3ModGhpcy5kb21FbGVtZW50LCBDU1NfTkFNRVNQQUNFKTtcbiAgdGhpcy5fX2ZvbGRlcnMgPSB7fTtcbiAgdGhpcy5fX2NvbnRyb2xsZXJzID0gW107XG4gIHRoaXMuX19yZW1lbWJlcmVkT2JqZWN0cyA9IFtdO1xuICB0aGlzLl9fcmVtZW1iZXJlZE9iamVjdEluZGVjZXNUb0NvbnRyb2xsZXJzID0gW107XG4gIHRoaXMuX19saXN0ZW5pbmcgPSBbXTtcbiAgcGFyYW1zID0gQ29tbW9uLmRlZmF1bHRzKHBhcmFtcywge1xuICAgIGNsb3NlT25Ub3A6IGZhbHNlLFxuICAgIGF1dG9QbGFjZTogdHJ1ZSxcbiAgICB3aWR0aDogR1VJLkRFRkFVTFRfV0lEVEhcbiAgfSk7XG4gIHBhcmFtcyA9IENvbW1vbi5kZWZhdWx0cyhwYXJhbXMsIHtcbiAgICByZXNpemFibGU6IHBhcmFtcy5hdXRvUGxhY2UsXG4gICAgaGlkZWFibGU6IHBhcmFtcy5hdXRvUGxhY2VcbiAgfSk7XG4gIGlmICghQ29tbW9uLmlzVW5kZWZpbmVkKHBhcmFtcy5sb2FkKSkge1xuICAgIGlmIChwYXJhbXMucHJlc2V0KSB7XG4gICAgICBwYXJhbXMubG9hZC5wcmVzZXQgPSBwYXJhbXMucHJlc2V0O1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBwYXJhbXMubG9hZCA9IHsgcHJlc2V0OiBERUZBVUxUX0RFRkFVTFRfUFJFU0VUX05BTUUgfTtcbiAgfVxuICBpZiAoQ29tbW9uLmlzVW5kZWZpbmVkKHBhcmFtcy5wYXJlbnQpICYmIHBhcmFtcy5oaWRlYWJsZSkge1xuICAgIGhpZGVhYmxlR3Vpcy5wdXNoKHRoaXMpO1xuICB9XG4gIHBhcmFtcy5yZXNpemFibGUgPSBDb21tb24uaXNVbmRlZmluZWQocGFyYW1zLnBhcmVudCkgJiYgcGFyYW1zLnJlc2l6YWJsZTtcbiAgaWYgKHBhcmFtcy5hdXRvUGxhY2UgJiYgQ29tbW9uLmlzVW5kZWZpbmVkKHBhcmFtcy5zY3JvbGxhYmxlKSkge1xuICAgIHBhcmFtcy5zY3JvbGxhYmxlID0gdHJ1ZTtcbiAgfVxuICB2YXIgdXNlTG9jYWxTdG9yYWdlID0gU1VQUE9SVFNfTE9DQUxfU1RPUkFHRSAmJiBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShnZXRMb2NhbFN0b3JhZ2VIYXNoKHRoaXMsICdpc0xvY2FsJykpID09PSAndHJ1ZSc7XG4gIHZhciBzYXZlVG9Mb2NhbFN0b3JhZ2UgPSB2b2lkIDA7XG4gIHZhciB0aXRsZVJvdyA9IHZvaWQgMDtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGhpcyxcbiAge1xuICAgIHBhcmVudDoge1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQkJDEoKSB7XG4gICAgICAgIHJldHVybiBwYXJhbXMucGFyZW50O1xuICAgICAgfVxuICAgIH0sXG4gICAgc2Nyb2xsYWJsZToge1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQkJDEoKSB7XG4gICAgICAgIHJldHVybiBwYXJhbXMuc2Nyb2xsYWJsZTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGF1dG9QbGFjZToge1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQkJDEoKSB7XG4gICAgICAgIHJldHVybiBwYXJhbXMuYXV0b1BsYWNlO1xuICAgICAgfVxuICAgIH0sXG4gICAgY2xvc2VPblRvcDoge1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQkJDEoKSB7XG4gICAgICAgIHJldHVybiBwYXJhbXMuY2xvc2VPblRvcDtcbiAgICAgIH1cbiAgICB9LFxuICAgIHByZXNldDoge1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQkJDEoKSB7XG4gICAgICAgIGlmIChfdGhpcy5wYXJlbnQpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXMuZ2V0Um9vdCgpLnByZXNldDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGFyYW1zLmxvYWQucHJlc2V0O1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gc2V0JCQxKHYpIHtcbiAgICAgICAgaWYgKF90aGlzLnBhcmVudCkge1xuICAgICAgICAgIF90aGlzLmdldFJvb3QoKS5wcmVzZXQgPSB2O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBhcmFtcy5sb2FkLnByZXNldCA9IHY7XG4gICAgICAgIH1cbiAgICAgICAgc2V0UHJlc2V0U2VsZWN0SW5kZXgodGhpcyk7XG4gICAgICAgIF90aGlzLnJldmVydCgpO1xuICAgICAgfVxuICAgIH0sXG4gICAgd2lkdGg6IHtcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0JCQxKCkge1xuICAgICAgICByZXR1cm4gcGFyYW1zLndpZHRoO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gc2V0JCQxKHYpIHtcbiAgICAgICAgcGFyYW1zLndpZHRoID0gdjtcbiAgICAgICAgc2V0V2lkdGgoX3RoaXMsIHYpO1xuICAgICAgfVxuICAgIH0sXG4gICAgbmFtZToge1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQkJDEoKSB7XG4gICAgICAgIHJldHVybiBwYXJhbXMubmFtZTtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uIHNldCQkMSh2KSB7XG4gICAgICAgIHBhcmFtcy5uYW1lID0gdjtcbiAgICAgICAgaWYgKHRpdGxlUm93KSB7XG4gICAgICAgICAgdGl0bGVSb3cuaW5uZXJIVE1MID0gcGFyYW1zLm5hbWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIGNsb3NlZDoge1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQkJDEoKSB7XG4gICAgICAgIHJldHVybiBwYXJhbXMuY2xvc2VkO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gc2V0JCQxKHYpIHtcbiAgICAgICAgcGFyYW1zLmNsb3NlZCA9IHY7XG4gICAgICAgIGlmIChwYXJhbXMuY2xvc2VkKSB7XG4gICAgICAgICAgZG9tLmFkZENsYXNzKF90aGlzLl9fdWwsIEdVSS5DTEFTU19DTE9TRUQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRvbS5yZW1vdmVDbGFzcyhfdGhpcy5fX3VsLCBHVUkuQ0xBU1NfQ0xPU0VEKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9uUmVzaXplKCk7XG4gICAgICAgIGlmIChfdGhpcy5fX2Nsb3NlQnV0dG9uKSB7XG4gICAgICAgICAgX3RoaXMuX19jbG9zZUJ1dHRvbi5pbm5lckhUTUwgPSB2ID8gR1VJLlRFWFRfT1BFTiA6IEdVSS5URVhUX0NMT1NFRDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgbG9hZDoge1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQkJDEoKSB7XG4gICAgICAgIHJldHVybiBwYXJhbXMubG9hZDtcbiAgICAgIH1cbiAgICB9LFxuICAgIHVzZUxvY2FsU3RvcmFnZToge1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQkJDEoKSB7XG4gICAgICAgIHJldHVybiB1c2VMb2NhbFN0b3JhZ2U7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQkJDEoYm9vbCkge1xuICAgICAgICBpZiAoU1VQUE9SVFNfTE9DQUxfU1RPUkFHRSkge1xuICAgICAgICAgIHVzZUxvY2FsU3RvcmFnZSA9IGJvb2w7XG4gICAgICAgICAgaWYgKGJvb2wpIHtcbiAgICAgICAgICAgIGRvbS5iaW5kKHdpbmRvdywgJ3VubG9hZCcsIHNhdmVUb0xvY2FsU3RvcmFnZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRvbS51bmJpbmQod2luZG93LCAndW5sb2FkJywgc2F2ZVRvTG9jYWxTdG9yYWdlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oZ2V0TG9jYWxTdG9yYWdlSGFzaChfdGhpcywgJ2lzTG9jYWwnKSwgYm9vbCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICBpZiAoQ29tbW9uLmlzVW5kZWZpbmVkKHBhcmFtcy5wYXJlbnQpKSB7XG4gICAgdGhpcy5jbG9zZWQgPSBwYXJhbXMuY2xvc2VkIHx8IGZhbHNlO1xuICAgIGRvbS5hZGRDbGFzcyh0aGlzLmRvbUVsZW1lbnQsIEdVSS5DTEFTU19NQUlOKTtcbiAgICBkb20ubWFrZVNlbGVjdGFibGUodGhpcy5kb21FbGVtZW50LCBmYWxzZSk7XG4gICAgaWYgKFNVUFBPUlRTX0xPQ0FMX1NUT1JBR0UpIHtcbiAgICAgIGlmICh1c2VMb2NhbFN0b3JhZ2UpIHtcbiAgICAgICAgX3RoaXMudXNlTG9jYWxTdG9yYWdlID0gdHJ1ZTtcbiAgICAgICAgdmFyIHNhdmVkR3VpID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oZ2V0TG9jYWxTdG9yYWdlSGFzaCh0aGlzLCAnZ3VpJykpO1xuICAgICAgICBpZiAoc2F2ZWRHdWkpIHtcbiAgICAgICAgICBwYXJhbXMubG9hZCA9IEpTT04ucGFyc2Uoc2F2ZWRHdWkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuX19jbG9zZUJ1dHRvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIHRoaXMuX19jbG9zZUJ1dHRvbi5pbm5lckhUTUwgPSBHVUkuVEVYVF9DTE9TRUQ7XG4gICAgZG9tLmFkZENsYXNzKHRoaXMuX19jbG9zZUJ1dHRvbiwgR1VJLkNMQVNTX0NMT1NFX0JVVFRPTik7XG4gICAgaWYgKHBhcmFtcy5jbG9zZU9uVG9wKSB7XG4gICAgICBkb20uYWRkQ2xhc3ModGhpcy5fX2Nsb3NlQnV0dG9uLCBHVUkuQ0xBU1NfQ0xPU0VfVE9QKTtcbiAgICAgIHRoaXMuZG9tRWxlbWVudC5pbnNlcnRCZWZvcmUodGhpcy5fX2Nsb3NlQnV0dG9uLCB0aGlzLmRvbUVsZW1lbnQuY2hpbGROb2Rlc1swXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRvbS5hZGRDbGFzcyh0aGlzLl9fY2xvc2VCdXR0b24sIEdVSS5DTEFTU19DTE9TRV9CT1RUT00pO1xuICAgICAgdGhpcy5kb21FbGVtZW50LmFwcGVuZENoaWxkKHRoaXMuX19jbG9zZUJ1dHRvbik7XG4gICAgfVxuICAgIGRvbS5iaW5kKHRoaXMuX19jbG9zZUJ1dHRvbiwgJ2NsaWNrJywgZnVuY3Rpb24gKCkge1xuICAgICAgX3RoaXMuY2xvc2VkID0gIV90aGlzLmNsb3NlZDtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBpZiAocGFyYW1zLmNsb3NlZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBwYXJhbXMuY2xvc2VkID0gdHJ1ZTtcbiAgICB9XG4gICAgdmFyIHRpdGxlUm93TmFtZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHBhcmFtcy5uYW1lKTtcbiAgICBkb20uYWRkQ2xhc3ModGl0bGVSb3dOYW1lLCAnY29udHJvbGxlci1uYW1lJyk7XG4gICAgdGl0bGVSb3cgPSBhZGRSb3coX3RoaXMsIHRpdGxlUm93TmFtZSk7XG4gICAgdmFyIG9uQ2xpY2tUaXRsZSA9IGZ1bmN0aW9uIG9uQ2xpY2tUaXRsZShlKSB7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBfdGhpcy5jbG9zZWQgPSAhX3RoaXMuY2xvc2VkO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgZG9tLmFkZENsYXNzKHRoaXMuX191bCwgR1VJLkNMQVNTX0NMT1NFRCk7XG4gICAgZG9tLmFkZENsYXNzKHRpdGxlUm93LCAndGl0bGUnKTtcbiAgICBkb20uYmluZCh0aXRsZVJvdywgJ2NsaWNrJywgb25DbGlja1RpdGxlKTtcbiAgICBpZiAoIXBhcmFtcy5jbG9zZWQpIHtcbiAgICAgIHRoaXMuY2xvc2VkID0gZmFsc2U7XG4gICAgfVxuICB9XG4gIGlmIChwYXJhbXMuYXV0b1BsYWNlKSB7XG4gICAgaWYgKENvbW1vbi5pc1VuZGVmaW5lZChwYXJhbXMucGFyZW50KSkge1xuICAgICAgaWYgKGF1dG9QbGFjZVZpcmdpbikge1xuICAgICAgICBhdXRvUGxhY2VDb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgZG9tLmFkZENsYXNzKGF1dG9QbGFjZUNvbnRhaW5lciwgQ1NTX05BTUVTUEFDRSk7XG4gICAgICAgIGRvbS5hZGRDbGFzcyhhdXRvUGxhY2VDb250YWluZXIsIEdVSS5DTEFTU19BVVRPX1BMQUNFX0NPTlRBSU5FUik7XG4gICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoYXV0b1BsYWNlQ29udGFpbmVyKTtcbiAgICAgICAgYXV0b1BsYWNlVmlyZ2luID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBhdXRvUGxhY2VDb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5kb21FbGVtZW50KTtcbiAgICAgIGRvbS5hZGRDbGFzcyh0aGlzLmRvbUVsZW1lbnQsIEdVSS5DTEFTU19BVVRPX1BMQUNFKTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLnBhcmVudCkge1xuICAgICAgc2V0V2lkdGgoX3RoaXMsIHBhcmFtcy53aWR0aCk7XG4gICAgfVxuICB9XG4gIHRoaXMuX19yZXNpemVIYW5kbGVyID0gZnVuY3Rpb24gKCkge1xuICAgIF90aGlzLm9uUmVzaXplRGVib3VuY2VkKCk7XG4gIH07XG4gIGRvbS5iaW5kKHdpbmRvdywgJ3Jlc2l6ZScsIHRoaXMuX19yZXNpemVIYW5kbGVyKTtcbiAgZG9tLmJpbmQodGhpcy5fX3VsLCAnd2Via2l0VHJhbnNpdGlvbkVuZCcsIHRoaXMuX19yZXNpemVIYW5kbGVyKTtcbiAgZG9tLmJpbmQodGhpcy5fX3VsLCAndHJhbnNpdGlvbmVuZCcsIHRoaXMuX19yZXNpemVIYW5kbGVyKTtcbiAgZG9tLmJpbmQodGhpcy5fX3VsLCAnb1RyYW5zaXRpb25FbmQnLCB0aGlzLl9fcmVzaXplSGFuZGxlcik7XG4gIHRoaXMub25SZXNpemUoKTtcbiAgaWYgKHBhcmFtcy5yZXNpemFibGUpIHtcbiAgICBhZGRSZXNpemVIYW5kbGUodGhpcyk7XG4gIH1cbiAgc2F2ZVRvTG9jYWxTdG9yYWdlID0gZnVuY3Rpb24gc2F2ZVRvTG9jYWxTdG9yYWdlKCkge1xuICAgIGlmIChTVVBQT1JUU19MT0NBTF9TVE9SQUdFICYmIGxvY2FsU3RvcmFnZS5nZXRJdGVtKGdldExvY2FsU3RvcmFnZUhhc2goX3RoaXMsICdpc0xvY2FsJykpID09PSAndHJ1ZScpIHtcbiAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKGdldExvY2FsU3RvcmFnZUhhc2goX3RoaXMsICdndWknKSwgSlNPTi5zdHJpbmdpZnkoX3RoaXMuZ2V0U2F2ZU9iamVjdCgpKSk7XG4gICAgfVxuICB9O1xuICB0aGlzLnNhdmVUb0xvY2FsU3RvcmFnZUlmUG9zc2libGUgPSBzYXZlVG9Mb2NhbFN0b3JhZ2U7XG4gIGZ1bmN0aW9uIHJlc2V0V2lkdGgoKSB7XG4gICAgdmFyIHJvb3QgPSBfdGhpcy5nZXRSb290KCk7XG4gICAgcm9vdC53aWR0aCArPSAxO1xuICAgIENvbW1vbi5kZWZlcihmdW5jdGlvbiAoKSB7XG4gICAgICByb290LndpZHRoIC09IDE7XG4gICAgfSk7XG4gIH1cbiAgaWYgKCFwYXJhbXMucGFyZW50KSB7XG4gICAgcmVzZXRXaWR0aCgpO1xuICB9XG59O1xuR1VJLnRvZ2dsZUhpZGUgPSBmdW5jdGlvbiAoKSB7XG4gIGhpZGUgPSAhaGlkZTtcbiAgQ29tbW9uLmVhY2goaGlkZWFibGVHdWlzLCBmdW5jdGlvbiAoZ3VpKSB7XG4gICAgZ3VpLmRvbUVsZW1lbnQuc3R5bGUuZGlzcGxheSA9IGhpZGUgPyAnbm9uZScgOiAnJztcbiAgfSk7XG59O1xuR1VJLkNMQVNTX0FVVE9fUExBQ0UgPSAnYSc7XG5HVUkuQ0xBU1NfQVVUT19QTEFDRV9DT05UQUlORVIgPSAnYWMnO1xuR1VJLkNMQVNTX01BSU4gPSAnbWFpbic7XG5HVUkuQ0xBU1NfQ09OVFJPTExFUl9ST1cgPSAnY3InO1xuR1VJLkNMQVNTX1RPT19UQUxMID0gJ3RhbGxlci10aGFuLXdpbmRvdyc7XG5HVUkuQ0xBU1NfQ0xPU0VEID0gJ2Nsb3NlZCc7XG5HVUkuQ0xBU1NfQ0xPU0VfQlVUVE9OID0gJ2Nsb3NlLWJ1dHRvbic7XG5HVUkuQ0xBU1NfQ0xPU0VfVE9QID0gJ2Nsb3NlLXRvcCc7XG5HVUkuQ0xBU1NfQ0xPU0VfQk9UVE9NID0gJ2Nsb3NlLWJvdHRvbSc7XG5HVUkuQ0xBU1NfRFJBRyA9ICdkcmFnJztcbkdVSS5ERUZBVUxUX1dJRFRIID0gMjQ1O1xuR1VJLlRFWFRfQ0xPU0VEID0gJ0Nsb3NlIENvbnRyb2xzJztcbkdVSS5URVhUX09QRU4gPSAnT3BlbiBDb250cm9scyc7XG5HVUkuX2tleWRvd25IYW5kbGVyID0gZnVuY3Rpb24gKGUpIHtcbiAgaWYgKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQudHlwZSAhPT0gJ3RleHQnICYmIChlLndoaWNoID09PSBISURFX0tFWV9DT0RFIHx8IGUua2V5Q29kZSA9PT0gSElERV9LRVlfQ09ERSkpIHtcbiAgICBHVUkudG9nZ2xlSGlkZSgpO1xuICB9XG59O1xuZG9tLmJpbmQod2luZG93LCAna2V5ZG93bicsIEdVSS5fa2V5ZG93bkhhbmRsZXIsIGZhbHNlKTtcbkNvbW1vbi5leHRlbmQoR1VJLnByb3RvdHlwZSxcbntcbiAgYWRkOiBmdW5jdGlvbiBhZGQob2JqZWN0LCBwcm9wZXJ0eSkge1xuICAgIHJldHVybiBfYWRkKHRoaXMsIG9iamVjdCwgcHJvcGVydHksIHtcbiAgICAgIGZhY3RvcnlBcmdzOiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpXG4gICAgfSk7XG4gIH0sXG4gIGFkZENvbG9yOiBmdW5jdGlvbiBhZGRDb2xvcihvYmplY3QsIHByb3BlcnR5KSB7XG4gICAgcmV0dXJuIF9hZGQodGhpcywgb2JqZWN0LCBwcm9wZXJ0eSwge1xuICAgICAgY29sb3I6IHRydWVcbiAgICB9KTtcbiAgfSxcbiAgcmVtb3ZlOiBmdW5jdGlvbiByZW1vdmUoY29udHJvbGxlcikge1xuICAgIHRoaXMuX191bC5yZW1vdmVDaGlsZChjb250cm9sbGVyLl9fbGkpO1xuICAgIHRoaXMuX19jb250cm9sbGVycy5zcGxpY2UodGhpcy5fX2NvbnRyb2xsZXJzLmluZGV4T2YoY29udHJvbGxlciksIDEpO1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgQ29tbW9uLmRlZmVyKGZ1bmN0aW9uICgpIHtcbiAgICAgIF90aGlzLm9uUmVzaXplKCk7XG4gICAgfSk7XG4gIH0sXG4gIGRlc3Ryb3k6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgaWYgKHRoaXMucGFyZW50KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ09ubHkgdGhlIHJvb3QgR1VJIHNob3VsZCBiZSByZW1vdmVkIHdpdGggLmRlc3Ryb3koKS4gJyArICdGb3Igc3ViZm9sZGVycywgdXNlIGd1aS5yZW1vdmVGb2xkZXIoZm9sZGVyKSBpbnN0ZWFkLicpO1xuICAgIH1cbiAgICBpZiAodGhpcy5hdXRvUGxhY2UpIHtcbiAgICAgIGF1dG9QbGFjZUNvbnRhaW5lci5yZW1vdmVDaGlsZCh0aGlzLmRvbUVsZW1lbnQpO1xuICAgIH1cbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIENvbW1vbi5lYWNoKHRoaXMuX19mb2xkZXJzLCBmdW5jdGlvbiAoc3ViZm9sZGVyKSB7XG4gICAgICBfdGhpcy5yZW1vdmVGb2xkZXIoc3ViZm9sZGVyKTtcbiAgICB9KTtcbiAgICBkb20udW5iaW5kKHdpbmRvdywgJ2tleWRvd24nLCBHVUkuX2tleWRvd25IYW5kbGVyLCBmYWxzZSk7XG4gICAgcmVtb3ZlTGlzdGVuZXJzKHRoaXMpO1xuICB9LFxuICBhZGRGb2xkZXI6IGZ1bmN0aW9uIGFkZEZvbGRlcihuYW1lKSB7XG4gICAgaWYgKHRoaXMuX19mb2xkZXJzW25hbWVdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignWW91IGFscmVhZHkgaGF2ZSBhIGZvbGRlciBpbiB0aGlzIEdVSSBieSB0aGUnICsgJyBuYW1lIFwiJyArIG5hbWUgKyAnXCInKTtcbiAgICB9XG4gICAgdmFyIG5ld0d1aVBhcmFtcyA9IHsgbmFtZTogbmFtZSwgcGFyZW50OiB0aGlzIH07XG4gICAgbmV3R3VpUGFyYW1zLmF1dG9QbGFjZSA9IHRoaXMuYXV0b1BsYWNlO1xuICAgIGlmICh0aGlzLmxvYWQgJiZcbiAgICB0aGlzLmxvYWQuZm9sZGVycyAmJlxuICAgIHRoaXMubG9hZC5mb2xkZXJzW25hbWVdKSB7XG4gICAgICBuZXdHdWlQYXJhbXMuY2xvc2VkID0gdGhpcy5sb2FkLmZvbGRlcnNbbmFtZV0uY2xvc2VkO1xuICAgICAgbmV3R3VpUGFyYW1zLmxvYWQgPSB0aGlzLmxvYWQuZm9sZGVyc1tuYW1lXTtcbiAgICB9XG4gICAgdmFyIGd1aSA9IG5ldyBHVUkobmV3R3VpUGFyYW1zKTtcbiAgICB0aGlzLl9fZm9sZGVyc1tuYW1lXSA9IGd1aTtcbiAgICB2YXIgbGkgPSBhZGRSb3codGhpcywgZ3VpLmRvbUVsZW1lbnQpO1xuICAgIGRvbS5hZGRDbGFzcyhsaSwgJ2ZvbGRlcicpO1xuICAgIHJldHVybiBndWk7XG4gIH0sXG4gIHJlbW92ZUZvbGRlcjogZnVuY3Rpb24gcmVtb3ZlRm9sZGVyKGZvbGRlcikge1xuICAgIHRoaXMuX191bC5yZW1vdmVDaGlsZChmb2xkZXIuZG9tRWxlbWVudC5wYXJlbnRFbGVtZW50KTtcbiAgICBkZWxldGUgdGhpcy5fX2ZvbGRlcnNbZm9sZGVyLm5hbWVdO1xuICAgIGlmICh0aGlzLmxvYWQgJiZcbiAgICB0aGlzLmxvYWQuZm9sZGVycyAmJlxuICAgIHRoaXMubG9hZC5mb2xkZXJzW2ZvbGRlci5uYW1lXSkge1xuICAgICAgZGVsZXRlIHRoaXMubG9hZC5mb2xkZXJzW2ZvbGRlci5uYW1lXTtcbiAgICB9XG4gICAgcmVtb3ZlTGlzdGVuZXJzKGZvbGRlcik7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICBDb21tb24uZWFjaChmb2xkZXIuX19mb2xkZXJzLCBmdW5jdGlvbiAoc3ViZm9sZGVyKSB7XG4gICAgICBmb2xkZXIucmVtb3ZlRm9sZGVyKHN1YmZvbGRlcik7XG4gICAgfSk7XG4gICAgQ29tbW9uLmRlZmVyKGZ1bmN0aW9uICgpIHtcbiAgICAgIF90aGlzLm9uUmVzaXplKCk7XG4gICAgfSk7XG4gIH0sXG4gIG9wZW46IGZ1bmN0aW9uIG9wZW4oKSB7XG4gICAgdGhpcy5jbG9zZWQgPSBmYWxzZTtcbiAgfSxcbiAgY2xvc2U6IGZ1bmN0aW9uIGNsb3NlKCkge1xuICAgIHRoaXMuY2xvc2VkID0gdHJ1ZTtcbiAgfSxcbiAgaGlkZTogZnVuY3Rpb24gaGlkZSgpIHtcbiAgICB0aGlzLmRvbUVsZW1lbnQuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgfSxcbiAgc2hvdzogZnVuY3Rpb24gc2hvdygpIHtcbiAgICB0aGlzLmRvbUVsZW1lbnQuc3R5bGUuZGlzcGxheSA9ICcnO1xuICB9LFxuICBvblJlc2l6ZTogZnVuY3Rpb24gb25SZXNpemUoKSB7XG4gICAgdmFyIHJvb3QgPSB0aGlzLmdldFJvb3QoKTtcbiAgICBpZiAocm9vdC5zY3JvbGxhYmxlKSB7XG4gICAgICB2YXIgdG9wID0gZG9tLmdldE9mZnNldChyb290Ll9fdWwpLnRvcDtcbiAgICAgIHZhciBoID0gMDtcbiAgICAgIENvbW1vbi5lYWNoKHJvb3QuX191bC5jaGlsZE5vZGVzLCBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICBpZiAoIShyb290LmF1dG9QbGFjZSAmJiBub2RlID09PSByb290Ll9fc2F2ZV9yb3cpKSB7XG4gICAgICAgICAgaCArPSBkb20uZ2V0SGVpZ2h0KG5vZGUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGlmICh3aW5kb3cuaW5uZXJIZWlnaHQgLSB0b3AgLSBDTE9TRV9CVVRUT05fSEVJR0hUIDwgaCkge1xuICAgICAgICBkb20uYWRkQ2xhc3Mocm9vdC5kb21FbGVtZW50LCBHVUkuQ0xBU1NfVE9PX1RBTEwpO1xuICAgICAgICByb290Ll9fdWwuc3R5bGUuaGVpZ2h0ID0gd2luZG93LmlubmVySGVpZ2h0IC0gdG9wIC0gQ0xPU0VfQlVUVE9OX0hFSUdIVCArICdweCc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkb20ucmVtb3ZlQ2xhc3Mocm9vdC5kb21FbGVtZW50LCBHVUkuQ0xBU1NfVE9PX1RBTEwpO1xuICAgICAgICByb290Ll9fdWwuc3R5bGUuaGVpZ2h0ID0gJ2F1dG8nO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAocm9vdC5fX3Jlc2l6ZV9oYW5kbGUpIHtcbiAgICAgIENvbW1vbi5kZWZlcihmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJvb3QuX19yZXNpemVfaGFuZGxlLnN0eWxlLmhlaWdodCA9IHJvb3QuX191bC5vZmZzZXRIZWlnaHQgKyAncHgnO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChyb290Ll9fY2xvc2VCdXR0b24pIHtcbiAgICAgIHJvb3QuX19jbG9zZUJ1dHRvbi5zdHlsZS53aWR0aCA9IHJvb3Qud2lkdGggKyAncHgnO1xuICAgIH1cbiAgfSxcbiAgb25SZXNpemVEZWJvdW5jZWQ6IENvbW1vbi5kZWJvdW5jZShmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5vblJlc2l6ZSgpO1xuICB9LCA1MCksXG4gIHJlbWVtYmVyOiBmdW5jdGlvbiByZW1lbWJlcigpIHtcbiAgICBpZiAoQ29tbW9uLmlzVW5kZWZpbmVkKFNBVkVfRElBTE9HVUUpKSB7XG4gICAgICBTQVZFX0RJQUxPR1VFID0gbmV3IENlbnRlcmVkRGl2KCk7XG4gICAgICBTQVZFX0RJQUxPR1VFLmRvbUVsZW1lbnQuaW5uZXJIVE1MID0gc2F2ZURpYWxvZ0NvbnRlbnRzO1xuICAgIH1cbiAgICBpZiAodGhpcy5wYXJlbnQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignWW91IGNhbiBvbmx5IGNhbGwgcmVtZW1iZXIgb24gYSB0b3AgbGV2ZWwgR1VJLicpO1xuICAgIH1cbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIENvbW1vbi5lYWNoKEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyksIGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICAgIGlmIChfdGhpcy5fX3JlbWVtYmVyZWRPYmplY3RzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBhZGRTYXZlTWVudShfdGhpcyk7XG4gICAgICB9XG4gICAgICBpZiAoX3RoaXMuX19yZW1lbWJlcmVkT2JqZWN0cy5pbmRleE9mKG9iamVjdCkgPT09IC0xKSB7XG4gICAgICAgIF90aGlzLl9fcmVtZW1iZXJlZE9iamVjdHMucHVzaChvYmplY3QpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGlmICh0aGlzLmF1dG9QbGFjZSkge1xuICAgICAgc2V0V2lkdGgodGhpcywgdGhpcy53aWR0aCk7XG4gICAgfVxuICB9LFxuICBnZXRSb290OiBmdW5jdGlvbiBnZXRSb290KCkge1xuICAgIHZhciBndWkgPSB0aGlzO1xuICAgIHdoaWxlIChndWkucGFyZW50KSB7XG4gICAgICBndWkgPSBndWkucGFyZW50O1xuICAgIH1cbiAgICByZXR1cm4gZ3VpO1xuICB9LFxuICBnZXRTYXZlT2JqZWN0OiBmdW5jdGlvbiBnZXRTYXZlT2JqZWN0KCkge1xuICAgIHZhciB0b1JldHVybiA9IHRoaXMubG9hZDtcbiAgICB0b1JldHVybi5jbG9zZWQgPSB0aGlzLmNsb3NlZDtcbiAgICBpZiAodGhpcy5fX3JlbWVtYmVyZWRPYmplY3RzLmxlbmd0aCA+IDApIHtcbiAgICAgIHRvUmV0dXJuLnByZXNldCA9IHRoaXMucHJlc2V0O1xuICAgICAgaWYgKCF0b1JldHVybi5yZW1lbWJlcmVkKSB7XG4gICAgICAgIHRvUmV0dXJuLnJlbWVtYmVyZWQgPSB7fTtcbiAgICAgIH1cbiAgICAgIHRvUmV0dXJuLnJlbWVtYmVyZWRbdGhpcy5wcmVzZXRdID0gZ2V0Q3VycmVudFByZXNldCh0aGlzKTtcbiAgICB9XG4gICAgdG9SZXR1cm4uZm9sZGVycyA9IHt9O1xuICAgIENvbW1vbi5lYWNoKHRoaXMuX19mb2xkZXJzLCBmdW5jdGlvbiAoZWxlbWVudCwga2V5KSB7XG4gICAgICB0b1JldHVybi5mb2xkZXJzW2tleV0gPSBlbGVtZW50LmdldFNhdmVPYmplY3QoKTtcbiAgICB9KTtcbiAgICByZXR1cm4gdG9SZXR1cm47XG4gIH0sXG4gIHNhdmU6IGZ1bmN0aW9uIHNhdmUoKSB7XG4gICAgaWYgKCF0aGlzLmxvYWQucmVtZW1iZXJlZCkge1xuICAgICAgdGhpcy5sb2FkLnJlbWVtYmVyZWQgPSB7fTtcbiAgICB9XG4gICAgdGhpcy5sb2FkLnJlbWVtYmVyZWRbdGhpcy5wcmVzZXRdID0gZ2V0Q3VycmVudFByZXNldCh0aGlzKTtcbiAgICBtYXJrUHJlc2V0TW9kaWZpZWQodGhpcywgZmFsc2UpO1xuICAgIHRoaXMuc2F2ZVRvTG9jYWxTdG9yYWdlSWZQb3NzaWJsZSgpO1xuICB9LFxuICBzYXZlQXM6IGZ1bmN0aW9uIHNhdmVBcyhwcmVzZXROYW1lKSB7XG4gICAgaWYgKCF0aGlzLmxvYWQucmVtZW1iZXJlZCkge1xuICAgICAgdGhpcy5sb2FkLnJlbWVtYmVyZWQgPSB7fTtcbiAgICAgIHRoaXMubG9hZC5yZW1lbWJlcmVkW0RFRkFVTFRfREVGQVVMVF9QUkVTRVRfTkFNRV0gPSBnZXRDdXJyZW50UHJlc2V0KHRoaXMsIHRydWUpO1xuICAgIH1cbiAgICB0aGlzLmxvYWQucmVtZW1iZXJlZFtwcmVzZXROYW1lXSA9IGdldEN1cnJlbnRQcmVzZXQodGhpcyk7XG4gICAgdGhpcy5wcmVzZXQgPSBwcmVzZXROYW1lO1xuICAgIGFkZFByZXNldE9wdGlvbih0aGlzLCBwcmVzZXROYW1lLCB0cnVlKTtcbiAgICB0aGlzLnNhdmVUb0xvY2FsU3RvcmFnZUlmUG9zc2libGUoKTtcbiAgfSxcbiAgcmV2ZXJ0OiBmdW5jdGlvbiByZXZlcnQoZ3VpKSB7XG4gICAgQ29tbW9uLmVhY2godGhpcy5fX2NvbnRyb2xsZXJzLCBmdW5jdGlvbiAoY29udHJvbGxlcikge1xuICAgICAgaWYgKCF0aGlzLmdldFJvb3QoKS5sb2FkLnJlbWVtYmVyZWQpIHtcbiAgICAgICAgY29udHJvbGxlci5zZXRWYWx1ZShjb250cm9sbGVyLmluaXRpYWxWYWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZWNhbGxTYXZlZFZhbHVlKGd1aSB8fCB0aGlzLmdldFJvb3QoKSwgY29udHJvbGxlcik7XG4gICAgICB9XG4gICAgICBpZiAoY29udHJvbGxlci5fX29uRmluaXNoQ2hhbmdlKSB7XG4gICAgICAgIGNvbnRyb2xsZXIuX19vbkZpbmlzaENoYW5nZS5jYWxsKGNvbnRyb2xsZXIsIGNvbnRyb2xsZXIuZ2V0VmFsdWUoKSk7XG4gICAgICB9XG4gICAgfSwgdGhpcyk7XG4gICAgQ29tbW9uLmVhY2godGhpcy5fX2ZvbGRlcnMsIGZ1bmN0aW9uIChmb2xkZXIpIHtcbiAgICAgIGZvbGRlci5yZXZlcnQoZm9sZGVyKTtcbiAgICB9KTtcbiAgICBpZiAoIWd1aSkge1xuICAgICAgbWFya1ByZXNldE1vZGlmaWVkKHRoaXMuZ2V0Um9vdCgpLCBmYWxzZSk7XG4gICAgfVxuICB9LFxuICBsaXN0ZW46IGZ1bmN0aW9uIGxpc3Rlbihjb250cm9sbGVyKSB7XG4gICAgdmFyIGluaXQgPSB0aGlzLl9fbGlzdGVuaW5nLmxlbmd0aCA9PT0gMDtcbiAgICB0aGlzLl9fbGlzdGVuaW5nLnB1c2goY29udHJvbGxlcik7XG4gICAgaWYgKGluaXQpIHtcbiAgICAgIHVwZGF0ZURpc3BsYXlzKHRoaXMuX19saXN0ZW5pbmcpO1xuICAgIH1cbiAgfSxcbiAgdXBkYXRlRGlzcGxheTogZnVuY3Rpb24gdXBkYXRlRGlzcGxheSgpIHtcbiAgICBDb21tb24uZWFjaCh0aGlzLl9fY29udHJvbGxlcnMsIGZ1bmN0aW9uIChjb250cm9sbGVyKSB7XG4gICAgICBjb250cm9sbGVyLnVwZGF0ZURpc3BsYXkoKTtcbiAgICB9KTtcbiAgICBDb21tb24uZWFjaCh0aGlzLl9fZm9sZGVycywgZnVuY3Rpb24gKGZvbGRlcikge1xuICAgICAgZm9sZGVyLnVwZGF0ZURpc3BsYXkoKTtcbiAgICB9KTtcbiAgfVxufSk7XG5mdW5jdGlvbiBhZGRSb3coZ3VpLCBuZXdEb20sIGxpQmVmb3JlKSB7XG4gIHZhciBsaSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xpJyk7XG4gIGlmIChuZXdEb20pIHtcbiAgICBsaS5hcHBlbmRDaGlsZChuZXdEb20pO1xuICB9XG4gIGlmIChsaUJlZm9yZSkge1xuICAgIGd1aS5fX3VsLmluc2VydEJlZm9yZShsaSwgbGlCZWZvcmUpO1xuICB9IGVsc2Uge1xuICAgIGd1aS5fX3VsLmFwcGVuZENoaWxkKGxpKTtcbiAgfVxuICBndWkub25SZXNpemUoKTtcbiAgcmV0dXJuIGxpO1xufVxuZnVuY3Rpb24gcmVtb3ZlTGlzdGVuZXJzKGd1aSkge1xuICBkb20udW5iaW5kKHdpbmRvdywgJ3Jlc2l6ZScsIGd1aS5fX3Jlc2l6ZUhhbmRsZXIpO1xuICBpZiAoZ3VpLnNhdmVUb0xvY2FsU3RvcmFnZUlmUG9zc2libGUpIHtcbiAgICBkb20udW5iaW5kKHdpbmRvdywgJ3VubG9hZCcsIGd1aS5zYXZlVG9Mb2NhbFN0b3JhZ2VJZlBvc3NpYmxlKTtcbiAgfVxufVxuZnVuY3Rpb24gbWFya1ByZXNldE1vZGlmaWVkKGd1aSwgbW9kaWZpZWQpIHtcbiAgdmFyIG9wdCA9IGd1aS5fX3ByZXNldF9zZWxlY3RbZ3VpLl9fcHJlc2V0X3NlbGVjdC5zZWxlY3RlZEluZGV4XTtcbiAgaWYgKG1vZGlmaWVkKSB7XG4gICAgb3B0LmlubmVySFRNTCA9IG9wdC52YWx1ZSArICcqJztcbiAgfSBlbHNlIHtcbiAgICBvcHQuaW5uZXJIVE1MID0gb3B0LnZhbHVlO1xuICB9XG59XG5mdW5jdGlvbiBhdWdtZW50Q29udHJvbGxlcihndWksIGxpLCBjb250cm9sbGVyKSB7XG4gIGNvbnRyb2xsZXIuX19saSA9IGxpO1xuICBjb250cm9sbGVyLl9fZ3VpID0gZ3VpO1xuICBDb21tb24uZXh0ZW5kKGNvbnRyb2xsZXIsICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgb3B0aW9uczogZnVuY3Rpb24gb3B0aW9ucyhfb3B0aW9ucykge1xuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIHZhciBuZXh0U2libGluZyA9IGNvbnRyb2xsZXIuX19saS5uZXh0RWxlbWVudFNpYmxpbmc7XG4gICAgICAgIGNvbnRyb2xsZXIucmVtb3ZlKCk7XG4gICAgICAgIHJldHVybiBfYWRkKGd1aSwgY29udHJvbGxlci5vYmplY3QsIGNvbnRyb2xsZXIucHJvcGVydHksIHtcbiAgICAgICAgICBiZWZvcmU6IG5leHRTaWJsaW5nLFxuICAgICAgICAgIGZhY3RvcnlBcmdzOiBbQ29tbW9uLnRvQXJyYXkoYXJndW1lbnRzKV1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAoQ29tbW9uLmlzQXJyYXkoX29wdGlvbnMpIHx8IENvbW1vbi5pc09iamVjdChfb3B0aW9ucykpIHtcbiAgICAgICAgdmFyIF9uZXh0U2libGluZyA9IGNvbnRyb2xsZXIuX19saS5uZXh0RWxlbWVudFNpYmxpbmc7XG4gICAgICAgIGNvbnRyb2xsZXIucmVtb3ZlKCk7XG4gICAgICAgIHJldHVybiBfYWRkKGd1aSwgY29udHJvbGxlci5vYmplY3QsIGNvbnRyb2xsZXIucHJvcGVydHksIHtcbiAgICAgICAgICBiZWZvcmU6IF9uZXh0U2libGluZyxcbiAgICAgICAgICBmYWN0b3J5QXJnczogW19vcHRpb25zXVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIG5hbWU6IGZ1bmN0aW9uIG5hbWUoX25hbWUpIHtcbiAgICAgIGNvbnRyb2xsZXIuX19saS5maXJzdEVsZW1lbnRDaGlsZC5maXJzdEVsZW1lbnRDaGlsZC5pbm5lckhUTUwgPSBfbmFtZTtcbiAgICAgIHJldHVybiBjb250cm9sbGVyO1xuICAgIH0sXG4gICAgbGlzdGVuOiBmdW5jdGlvbiBsaXN0ZW4oKSB7XG4gICAgICBjb250cm9sbGVyLl9fZ3VpLmxpc3Rlbihjb250cm9sbGVyKTtcbiAgICAgIHJldHVybiBjb250cm9sbGVyO1xuICAgIH0sXG4gICAgcmVtb3ZlOiBmdW5jdGlvbiByZW1vdmUoKSB7XG4gICAgICBjb250cm9sbGVyLl9fZ3VpLnJlbW92ZShjb250cm9sbGVyKTtcbiAgICAgIHJldHVybiBjb250cm9sbGVyO1xuICAgIH1cbiAgfSk7XG4gIGlmIChjb250cm9sbGVyIGluc3RhbmNlb2YgTnVtYmVyQ29udHJvbGxlclNsaWRlcikge1xuICAgIHZhciBib3ggPSBuZXcgTnVtYmVyQ29udHJvbGxlckJveChjb250cm9sbGVyLm9iamVjdCwgY29udHJvbGxlci5wcm9wZXJ0eSwgeyBtaW46IGNvbnRyb2xsZXIuX19taW4sIG1heDogY29udHJvbGxlci5fX21heCwgc3RlcDogY29udHJvbGxlci5fX3N0ZXAgfSk7XG4gICAgQ29tbW9uLmVhY2goWyd1cGRhdGVEaXNwbGF5JywgJ29uQ2hhbmdlJywgJ29uRmluaXNoQ2hhbmdlJywgJ3N0ZXAnLCAnbWluJywgJ21heCddLCBmdW5jdGlvbiAobWV0aG9kKSB7XG4gICAgICB2YXIgcGMgPSBjb250cm9sbGVyW21ldGhvZF07XG4gICAgICB2YXIgcGIgPSBib3hbbWV0aG9kXTtcbiAgICAgIGNvbnRyb2xsZXJbbWV0aG9kXSA9IGJveFttZXRob2RdID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgICAgIHBiLmFwcGx5KGJveCwgYXJncyk7XG4gICAgICAgIHJldHVybiBwYy5hcHBseShjb250cm9sbGVyLCBhcmdzKTtcbiAgICAgIH07XG4gICAgfSk7XG4gICAgZG9tLmFkZENsYXNzKGxpLCAnaGFzLXNsaWRlcicpO1xuICAgIGNvbnRyb2xsZXIuZG9tRWxlbWVudC5pbnNlcnRCZWZvcmUoYm94LmRvbUVsZW1lbnQsIGNvbnRyb2xsZXIuZG9tRWxlbWVudC5maXJzdEVsZW1lbnRDaGlsZCk7XG4gIH0gZWxzZSBpZiAoY29udHJvbGxlciBpbnN0YW5jZW9mIE51bWJlckNvbnRyb2xsZXJCb3gpIHtcbiAgICB2YXIgciA9IGZ1bmN0aW9uIHIocmV0dXJuZWQpIHtcbiAgICAgIGlmIChDb21tb24uaXNOdW1iZXIoY29udHJvbGxlci5fX21pbikgJiYgQ29tbW9uLmlzTnVtYmVyKGNvbnRyb2xsZXIuX19tYXgpKSB7XG4gICAgICAgIHZhciBvbGROYW1lID0gY29udHJvbGxlci5fX2xpLmZpcnN0RWxlbWVudENoaWxkLmZpcnN0RWxlbWVudENoaWxkLmlubmVySFRNTDtcbiAgICAgICAgdmFyIHdhc0xpc3RlbmluZyA9IGNvbnRyb2xsZXIuX19ndWkuX19saXN0ZW5pbmcuaW5kZXhPZihjb250cm9sbGVyKSA+IC0xO1xuICAgICAgICBjb250cm9sbGVyLnJlbW92ZSgpO1xuICAgICAgICB2YXIgbmV3Q29udHJvbGxlciA9IF9hZGQoZ3VpLCBjb250cm9sbGVyLm9iamVjdCwgY29udHJvbGxlci5wcm9wZXJ0eSwge1xuICAgICAgICAgIGJlZm9yZTogY29udHJvbGxlci5fX2xpLm5leHRFbGVtZW50U2libGluZyxcbiAgICAgICAgICBmYWN0b3J5QXJnczogW2NvbnRyb2xsZXIuX19taW4sIGNvbnRyb2xsZXIuX19tYXgsIGNvbnRyb2xsZXIuX19zdGVwXVxuICAgICAgICB9KTtcbiAgICAgICAgbmV3Q29udHJvbGxlci5uYW1lKG9sZE5hbWUpO1xuICAgICAgICBpZiAod2FzTGlzdGVuaW5nKSBuZXdDb250cm9sbGVyLmxpc3RlbigpO1xuICAgICAgICByZXR1cm4gbmV3Q29udHJvbGxlcjtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXR1cm5lZDtcbiAgICB9O1xuICAgIGNvbnRyb2xsZXIubWluID0gQ29tbW9uLmNvbXBvc2UociwgY29udHJvbGxlci5taW4pO1xuICAgIGNvbnRyb2xsZXIubWF4ID0gQ29tbW9uLmNvbXBvc2UociwgY29udHJvbGxlci5tYXgpO1xuICB9IGVsc2UgaWYgKGNvbnRyb2xsZXIgaW5zdGFuY2VvZiBCb29sZWFuQ29udHJvbGxlcikge1xuICAgIGRvbS5iaW5kKGxpLCAnY2xpY2snLCBmdW5jdGlvbiAoKSB7XG4gICAgICBkb20uZmFrZUV2ZW50KGNvbnRyb2xsZXIuX19jaGVja2JveCwgJ2NsaWNrJyk7XG4gICAgfSk7XG4gICAgZG9tLmJpbmQoY29udHJvbGxlci5fX2NoZWNrYm94LCAnY2xpY2snLCBmdW5jdGlvbiAoZSkge1xuICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICB9KTtcbiAgfSBlbHNlIGlmIChjb250cm9sbGVyIGluc3RhbmNlb2YgRnVuY3Rpb25Db250cm9sbGVyKSB7XG4gICAgZG9tLmJpbmQobGksICdjbGljaycsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGRvbS5mYWtlRXZlbnQoY29udHJvbGxlci5fX2J1dHRvbiwgJ2NsaWNrJyk7XG4gICAgfSk7XG4gICAgZG9tLmJpbmQobGksICdtb3VzZW92ZXInLCBmdW5jdGlvbiAoKSB7XG4gICAgICBkb20uYWRkQ2xhc3MoY29udHJvbGxlci5fX2J1dHRvbiwgJ2hvdmVyJyk7XG4gICAgfSk7XG4gICAgZG9tLmJpbmQobGksICdtb3VzZW91dCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGRvbS5yZW1vdmVDbGFzcyhjb250cm9sbGVyLl9fYnV0dG9uLCAnaG92ZXInKTtcbiAgICB9KTtcbiAgfSBlbHNlIGlmIChjb250cm9sbGVyIGluc3RhbmNlb2YgQ29sb3JDb250cm9sbGVyKSB7XG4gICAgZG9tLmFkZENsYXNzKGxpLCAnY29sb3InKTtcbiAgICBjb250cm9sbGVyLnVwZGF0ZURpc3BsYXkgPSBDb21tb24uY29tcG9zZShmdW5jdGlvbiAodmFsKSB7XG4gICAgICBsaS5zdHlsZS5ib3JkZXJMZWZ0Q29sb3IgPSBjb250cm9sbGVyLl9fY29sb3IudG9TdHJpbmcoKTtcbiAgICAgIHJldHVybiB2YWw7XG4gICAgfSwgY29udHJvbGxlci51cGRhdGVEaXNwbGF5KTtcbiAgICBjb250cm9sbGVyLnVwZGF0ZURpc3BsYXkoKTtcbiAgfVxuICBjb250cm9sbGVyLnNldFZhbHVlID0gQ29tbW9uLmNvbXBvc2UoZnVuY3Rpb24gKHZhbCkge1xuICAgIGlmIChndWkuZ2V0Um9vdCgpLl9fcHJlc2V0X3NlbGVjdCAmJiBjb250cm9sbGVyLmlzTW9kaWZpZWQoKSkge1xuICAgICAgbWFya1ByZXNldE1vZGlmaWVkKGd1aS5nZXRSb290KCksIHRydWUpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsO1xuICB9LCBjb250cm9sbGVyLnNldFZhbHVlKTtcbn1cbmZ1bmN0aW9uIHJlY2FsbFNhdmVkVmFsdWUoZ3VpLCBjb250cm9sbGVyKSB7XG4gIHZhciByb290ID0gZ3VpLmdldFJvb3QoKTtcbiAgdmFyIG1hdGNoZWRJbmRleCA9IHJvb3QuX19yZW1lbWJlcmVkT2JqZWN0cy5pbmRleE9mKGNvbnRyb2xsZXIub2JqZWN0KTtcbiAgaWYgKG1hdGNoZWRJbmRleCAhPT0gLTEpIHtcbiAgICB2YXIgY29udHJvbGxlck1hcCA9IHJvb3QuX19yZW1lbWJlcmVkT2JqZWN0SW5kZWNlc1RvQ29udHJvbGxlcnNbbWF0Y2hlZEluZGV4XTtcbiAgICBpZiAoY29udHJvbGxlck1hcCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBjb250cm9sbGVyTWFwID0ge307XG4gICAgICByb290Ll9fcmVtZW1iZXJlZE9iamVjdEluZGVjZXNUb0NvbnRyb2xsZXJzW21hdGNoZWRJbmRleF0gPSBjb250cm9sbGVyTWFwO1xuICAgIH1cbiAgICBjb250cm9sbGVyTWFwW2NvbnRyb2xsZXIucHJvcGVydHldID0gY29udHJvbGxlcjtcbiAgICBpZiAocm9vdC5sb2FkICYmIHJvb3QubG9hZC5yZW1lbWJlcmVkKSB7XG4gICAgICB2YXIgcHJlc2V0TWFwID0gcm9vdC5sb2FkLnJlbWVtYmVyZWQ7XG4gICAgICB2YXIgcHJlc2V0ID0gdm9pZCAwO1xuICAgICAgaWYgKHByZXNldE1hcFtndWkucHJlc2V0XSkge1xuICAgICAgICBwcmVzZXQgPSBwcmVzZXRNYXBbZ3VpLnByZXNldF07XG4gICAgICB9IGVsc2UgaWYgKHByZXNldE1hcFtERUZBVUxUX0RFRkFVTFRfUFJFU0VUX05BTUVdKSB7XG4gICAgICAgIHByZXNldCA9IHByZXNldE1hcFtERUZBVUxUX0RFRkFVTFRfUFJFU0VUX05BTUVdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHByZXNldFttYXRjaGVkSW5kZXhdICYmIHByZXNldFttYXRjaGVkSW5kZXhdW2NvbnRyb2xsZXIucHJvcGVydHldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gcHJlc2V0W21hdGNoZWRJbmRleF1bY29udHJvbGxlci5wcm9wZXJ0eV07XG4gICAgICAgIGNvbnRyb2xsZXIuaW5pdGlhbFZhbHVlID0gdmFsdWU7XG4gICAgICAgIGNvbnRyb2xsZXIuc2V0VmFsdWUodmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gX2FkZChndWksIG9iamVjdCwgcHJvcGVydHksIHBhcmFtcykge1xuICBpZiAob2JqZWN0W3Byb3BlcnR5XSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdPYmplY3QgXCInICsgb2JqZWN0ICsgJ1wiIGhhcyBubyBwcm9wZXJ0eSBcIicgKyBwcm9wZXJ0eSArICdcIicpO1xuICB9XG4gIHZhciBjb250cm9sbGVyID0gdm9pZCAwO1xuICBpZiAocGFyYW1zLmNvbG9yKSB7XG4gICAgY29udHJvbGxlciA9IG5ldyBDb2xvckNvbnRyb2xsZXIob2JqZWN0LCBwcm9wZXJ0eSk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGZhY3RvcnlBcmdzID0gW29iamVjdCwgcHJvcGVydHldLmNvbmNhdChwYXJhbXMuZmFjdG9yeUFyZ3MpO1xuICAgIGNvbnRyb2xsZXIgPSBDb250cm9sbGVyRmFjdG9yeS5hcHBseShndWksIGZhY3RvcnlBcmdzKTtcbiAgfVxuICBpZiAocGFyYW1zLmJlZm9yZSBpbnN0YW5jZW9mIENvbnRyb2xsZXIpIHtcbiAgICBwYXJhbXMuYmVmb3JlID0gcGFyYW1zLmJlZm9yZS5fX2xpO1xuICB9XG4gIHJlY2FsbFNhdmVkVmFsdWUoZ3VpLCBjb250cm9sbGVyKTtcbiAgZG9tLmFkZENsYXNzKGNvbnRyb2xsZXIuZG9tRWxlbWVudCwgJ2MnKTtcbiAgdmFyIG5hbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG4gIGRvbS5hZGRDbGFzcyhuYW1lLCAncHJvcGVydHktbmFtZScpO1xuICBuYW1lLmlubmVySFRNTCA9IGNvbnRyb2xsZXIucHJvcGVydHk7XG4gIHZhciBjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgY29udGFpbmVyLmFwcGVuZENoaWxkKG5hbWUpO1xuICBjb250YWluZXIuYXBwZW5kQ2hpbGQoY29udHJvbGxlci5kb21FbGVtZW50KTtcbiAgdmFyIGxpID0gYWRkUm93KGd1aSwgY29udGFpbmVyLCBwYXJhbXMuYmVmb3JlKTtcbiAgZG9tLmFkZENsYXNzKGxpLCBHVUkuQ0xBU1NfQ09OVFJPTExFUl9ST1cpO1xuICBpZiAoY29udHJvbGxlciBpbnN0YW5jZW9mIENvbG9yQ29udHJvbGxlcikge1xuICAgIGRvbS5hZGRDbGFzcyhsaSwgJ2NvbG9yJyk7XG4gIH0gZWxzZSB7XG4gICAgZG9tLmFkZENsYXNzKGxpLCBfdHlwZW9mKGNvbnRyb2xsZXIuZ2V0VmFsdWUoKSkpO1xuICB9XG4gIGF1Z21lbnRDb250cm9sbGVyKGd1aSwgbGksIGNvbnRyb2xsZXIpO1xuICBndWkuX19jb250cm9sbGVycy5wdXNoKGNvbnRyb2xsZXIpO1xuICByZXR1cm4gY29udHJvbGxlcjtcbn1cbmZ1bmN0aW9uIGdldExvY2FsU3RvcmFnZUhhc2goZ3VpLCBrZXkpIHtcbiAgcmV0dXJuIGRvY3VtZW50LmxvY2F0aW9uLmhyZWYgKyAnLicgKyBrZXk7XG59XG5mdW5jdGlvbiBhZGRQcmVzZXRPcHRpb24oZ3VpLCBuYW1lLCBzZXRTZWxlY3RlZCkge1xuICB2YXIgb3B0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnb3B0aW9uJyk7XG4gIG9wdC5pbm5lckhUTUwgPSBuYW1lO1xuICBvcHQudmFsdWUgPSBuYW1lO1xuICBndWkuX19wcmVzZXRfc2VsZWN0LmFwcGVuZENoaWxkKG9wdCk7XG4gIGlmIChzZXRTZWxlY3RlZCkge1xuICAgIGd1aS5fX3ByZXNldF9zZWxlY3Quc2VsZWN0ZWRJbmRleCA9IGd1aS5fX3ByZXNldF9zZWxlY3QubGVuZ3RoIC0gMTtcbiAgfVxufVxuZnVuY3Rpb24gc2hvd0hpZGVFeHBsYWluKGd1aSwgZXhwbGFpbikge1xuICBleHBsYWluLnN0eWxlLmRpc3BsYXkgPSBndWkudXNlTG9jYWxTdG9yYWdlID8gJ2Jsb2NrJyA6ICdub25lJztcbn1cbmZ1bmN0aW9uIGFkZFNhdmVNZW51KGd1aSkge1xuICB2YXIgZGl2ID0gZ3VpLl9fc2F2ZV9yb3cgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsaScpO1xuICBkb20uYWRkQ2xhc3MoZ3VpLmRvbUVsZW1lbnQsICdoYXMtc2F2ZScpO1xuICBndWkuX191bC5pbnNlcnRCZWZvcmUoZGl2LCBndWkuX191bC5maXJzdENoaWxkKTtcbiAgZG9tLmFkZENsYXNzKGRpdiwgJ3NhdmUtcm93Jyk7XG4gIHZhciBnZWFycyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcbiAgZ2VhcnMuaW5uZXJIVE1MID0gJyZuYnNwOyc7XG4gIGRvbS5hZGRDbGFzcyhnZWFycywgJ2J1dHRvbiBnZWFycycpO1xuICB2YXIgYnV0dG9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuICBidXR0b24uaW5uZXJIVE1MID0gJ1NhdmUnO1xuICBkb20uYWRkQ2xhc3MoYnV0dG9uLCAnYnV0dG9uJyk7XG4gIGRvbS5hZGRDbGFzcyhidXR0b24sICdzYXZlJyk7XG4gIHZhciBidXR0b24yID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuICBidXR0b24yLmlubmVySFRNTCA9ICdOZXcnO1xuICBkb20uYWRkQ2xhc3MoYnV0dG9uMiwgJ2J1dHRvbicpO1xuICBkb20uYWRkQ2xhc3MoYnV0dG9uMiwgJ3NhdmUtYXMnKTtcbiAgdmFyIGJ1dHRvbjMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG4gIGJ1dHRvbjMuaW5uZXJIVE1MID0gJ1JldmVydCc7XG4gIGRvbS5hZGRDbGFzcyhidXR0b24zLCAnYnV0dG9uJyk7XG4gIGRvbS5hZGRDbGFzcyhidXR0b24zLCAncmV2ZXJ0Jyk7XG4gIHZhciBzZWxlY3QgPSBndWkuX19wcmVzZXRfc2VsZWN0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2VsZWN0Jyk7XG4gIGlmIChndWkubG9hZCAmJiBndWkubG9hZC5yZW1lbWJlcmVkKSB7XG4gICAgQ29tbW9uLmVhY2goZ3VpLmxvYWQucmVtZW1iZXJlZCwgZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHtcbiAgICAgIGFkZFByZXNldE9wdGlvbihndWksIGtleSwga2V5ID09PSBndWkucHJlc2V0KTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBhZGRQcmVzZXRPcHRpb24oZ3VpLCBERUZBVUxUX0RFRkFVTFRfUFJFU0VUX05BTUUsIGZhbHNlKTtcbiAgfVxuICBkb20uYmluZChzZWxlY3QsICdjaGFuZ2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IGd1aS5fX3ByZXNldF9zZWxlY3QubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICBndWkuX19wcmVzZXRfc2VsZWN0W2luZGV4XS5pbm5lckhUTUwgPSBndWkuX19wcmVzZXRfc2VsZWN0W2luZGV4XS52YWx1ZTtcbiAgICB9XG4gICAgZ3VpLnByZXNldCA9IHRoaXMudmFsdWU7XG4gIH0pO1xuICBkaXYuYXBwZW5kQ2hpbGQoc2VsZWN0KTtcbiAgZGl2LmFwcGVuZENoaWxkKGdlYXJzKTtcbiAgZGl2LmFwcGVuZENoaWxkKGJ1dHRvbik7XG4gIGRpdi5hcHBlbmRDaGlsZChidXR0b24yKTtcbiAgZGl2LmFwcGVuZENoaWxkKGJ1dHRvbjMpO1xuICBpZiAoU1VQUE9SVFNfTE9DQUxfU1RPUkFHRSkge1xuICAgIHZhciBleHBsYWluID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2RnLWxvY2FsLWV4cGxhaW4nKTtcbiAgICB2YXIgbG9jYWxTdG9yYWdlQ2hlY2tCb3ggPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZGctbG9jYWwtc3RvcmFnZScpO1xuICAgIHZhciBzYXZlTG9jYWxseSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdkZy1zYXZlLWxvY2FsbHknKTtcbiAgICBzYXZlTG9jYWxseS5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcbiAgICBpZiAobG9jYWxTdG9yYWdlLmdldEl0ZW0oZ2V0TG9jYWxTdG9yYWdlSGFzaChndWksICdpc0xvY2FsJykpID09PSAndHJ1ZScpIHtcbiAgICAgIGxvY2FsU3RvcmFnZUNoZWNrQm94LnNldEF0dHJpYnV0ZSgnY2hlY2tlZCcsICdjaGVja2VkJyk7XG4gICAgfVxuICAgIHNob3dIaWRlRXhwbGFpbihndWksIGV4cGxhaW4pO1xuICAgIGRvbS5iaW5kKGxvY2FsU3RvcmFnZUNoZWNrQm94LCAnY2hhbmdlJywgZnVuY3Rpb24gKCkge1xuICAgICAgZ3VpLnVzZUxvY2FsU3RvcmFnZSA9ICFndWkudXNlTG9jYWxTdG9yYWdlO1xuICAgICAgc2hvd0hpZGVFeHBsYWluKGd1aSwgZXhwbGFpbik7XG4gICAgfSk7XG4gIH1cbiAgdmFyIG5ld0NvbnN0cnVjdG9yVGV4dEFyZWEgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZGctbmV3LWNvbnN0cnVjdG9yJyk7XG4gIGRvbS5iaW5kKG5ld0NvbnN0cnVjdG9yVGV4dEFyZWEsICdrZXlkb3duJywgZnVuY3Rpb24gKGUpIHtcbiAgICBpZiAoZS5tZXRhS2V5ICYmIChlLndoaWNoID09PSA2NyB8fCBlLmtleUNvZGUgPT09IDY3KSkge1xuICAgICAgU0FWRV9ESUFMT0dVRS5oaWRlKCk7XG4gICAgfVxuICB9KTtcbiAgZG9tLmJpbmQoZ2VhcnMsICdjbGljaycsIGZ1bmN0aW9uICgpIHtcbiAgICBuZXdDb25zdHJ1Y3RvclRleHRBcmVhLmlubmVySFRNTCA9IEpTT04uc3RyaW5naWZ5KGd1aS5nZXRTYXZlT2JqZWN0KCksIHVuZGVmaW5lZCwgMik7XG4gICAgU0FWRV9ESUFMT0dVRS5zaG93KCk7XG4gICAgbmV3Q29uc3RydWN0b3JUZXh0QXJlYS5mb2N1cygpO1xuICAgIG5ld0NvbnN0cnVjdG9yVGV4dEFyZWEuc2VsZWN0KCk7XG4gIH0pO1xuICBkb20uYmluZChidXR0b24sICdjbGljaycsIGZ1bmN0aW9uICgpIHtcbiAgICBndWkuc2F2ZSgpO1xuICB9KTtcbiAgZG9tLmJpbmQoYnV0dG9uMiwgJ2NsaWNrJywgZnVuY3Rpb24gKCkge1xuICAgIHZhciBwcmVzZXROYW1lID0gcHJvbXB0KCdFbnRlciBhIG5ldyBwcmVzZXQgbmFtZS4nKTtcbiAgICBpZiAocHJlc2V0TmFtZSkge1xuICAgICAgZ3VpLnNhdmVBcyhwcmVzZXROYW1lKTtcbiAgICB9XG4gIH0pO1xuICBkb20uYmluZChidXR0b24zLCAnY2xpY2snLCBmdW5jdGlvbiAoKSB7XG4gICAgZ3VpLnJldmVydCgpO1xuICB9KTtcbn1cbmZ1bmN0aW9uIGFkZFJlc2l6ZUhhbmRsZShndWkpIHtcbiAgdmFyIHBtb3VzZVggPSB2b2lkIDA7XG4gIGd1aS5fX3Jlc2l6ZV9oYW5kbGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgQ29tbW9uLmV4dGVuZChndWkuX19yZXNpemVfaGFuZGxlLnN0eWxlLCB7XG4gICAgd2lkdGg6ICc2cHgnLFxuICAgIG1hcmdpbkxlZnQ6ICctM3B4JyxcbiAgICBoZWlnaHQ6ICcyMDBweCcsXG4gICAgY3Vyc29yOiAnZXctcmVzaXplJyxcbiAgICBwb3NpdGlvbjogJ2Fic29sdXRlJ1xuICB9KTtcbiAgZnVuY3Rpb24gZHJhZyhlKSB7XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGd1aS53aWR0aCArPSBwbW91c2VYIC0gZS5jbGllbnRYO1xuICAgIGd1aS5vblJlc2l6ZSgpO1xuICAgIHBtb3VzZVggPSBlLmNsaWVudFg7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGZ1bmN0aW9uIGRyYWdTdG9wKCkge1xuICAgIGRvbS5yZW1vdmVDbGFzcyhndWkuX19jbG9zZUJ1dHRvbiwgR1VJLkNMQVNTX0RSQUcpO1xuICAgIGRvbS51bmJpbmQod2luZG93LCAnbW91c2Vtb3ZlJywgZHJhZyk7XG4gICAgZG9tLnVuYmluZCh3aW5kb3csICdtb3VzZXVwJywgZHJhZ1N0b3ApO1xuICB9XG4gIGZ1bmN0aW9uIGRyYWdTdGFydChlKSB7XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIHBtb3VzZVggPSBlLmNsaWVudFg7XG4gICAgZG9tLmFkZENsYXNzKGd1aS5fX2Nsb3NlQnV0dG9uLCBHVUkuQ0xBU1NfRFJBRyk7XG4gICAgZG9tLmJpbmQod2luZG93LCAnbW91c2Vtb3ZlJywgZHJhZyk7XG4gICAgZG9tLmJpbmQod2luZG93LCAnbW91c2V1cCcsIGRyYWdTdG9wKTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZG9tLmJpbmQoZ3VpLl9fcmVzaXplX2hhbmRsZSwgJ21vdXNlZG93bicsIGRyYWdTdGFydCk7XG4gIGRvbS5iaW5kKGd1aS5fX2Nsb3NlQnV0dG9uLCAnbW91c2Vkb3duJywgZHJhZ1N0YXJ0KTtcbiAgZ3VpLmRvbUVsZW1lbnQuaW5zZXJ0QmVmb3JlKGd1aS5fX3Jlc2l6ZV9oYW5kbGUsIGd1aS5kb21FbGVtZW50LmZpcnN0RWxlbWVudENoaWxkKTtcbn1cbmZ1bmN0aW9uIHNldFdpZHRoKGd1aSwgdykge1xuICBndWkuZG9tRWxlbWVudC5zdHlsZS53aWR0aCA9IHcgKyAncHgnO1xuICBpZiAoZ3VpLl9fc2F2ZV9yb3cgJiYgZ3VpLmF1dG9QbGFjZSkge1xuICAgIGd1aS5fX3NhdmVfcm93LnN0eWxlLndpZHRoID0gdyArICdweCc7XG4gIH1cbiAgaWYgKGd1aS5fX2Nsb3NlQnV0dG9uKSB7XG4gICAgZ3VpLl9fY2xvc2VCdXR0b24uc3R5bGUud2lkdGggPSB3ICsgJ3B4JztcbiAgfVxufVxuZnVuY3Rpb24gZ2V0Q3VycmVudFByZXNldChndWksIHVzZUluaXRpYWxWYWx1ZXMpIHtcbiAgdmFyIHRvUmV0dXJuID0ge307XG4gIENvbW1vbi5lYWNoKGd1aS5fX3JlbWVtYmVyZWRPYmplY3RzLCBmdW5jdGlvbiAodmFsLCBpbmRleCkge1xuICAgIHZhciBzYXZlZFZhbHVlcyA9IHt9O1xuICAgIHZhciBjb250cm9sbGVyTWFwID0gZ3VpLl9fcmVtZW1iZXJlZE9iamVjdEluZGVjZXNUb0NvbnRyb2xsZXJzW2luZGV4XTtcbiAgICBDb21tb24uZWFjaChjb250cm9sbGVyTWFwLCBmdW5jdGlvbiAoY29udHJvbGxlciwgcHJvcGVydHkpIHtcbiAgICAgIHNhdmVkVmFsdWVzW3Byb3BlcnR5XSA9IHVzZUluaXRpYWxWYWx1ZXMgPyBjb250cm9sbGVyLmluaXRpYWxWYWx1ZSA6IGNvbnRyb2xsZXIuZ2V0VmFsdWUoKTtcbiAgICB9KTtcbiAgICB0b1JldHVybltpbmRleF0gPSBzYXZlZFZhbHVlcztcbiAgfSk7XG4gIHJldHVybiB0b1JldHVybjtcbn1cbmZ1bmN0aW9uIHNldFByZXNldFNlbGVjdEluZGV4KGd1aSkge1xuICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgZ3VpLl9fcHJlc2V0X3NlbGVjdC5sZW5ndGg7IGluZGV4KyspIHtcbiAgICBpZiAoZ3VpLl9fcHJlc2V0X3NlbGVjdFtpbmRleF0udmFsdWUgPT09IGd1aS5wcmVzZXQpIHtcbiAgICAgIGd1aS5fX3ByZXNldF9zZWxlY3Quc2VsZWN0ZWRJbmRleCA9IGluZGV4O1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gdXBkYXRlRGlzcGxheXMoY29udHJvbGxlckFycmF5KSB7XG4gIGlmIChjb250cm9sbGVyQXJyYXkubGVuZ3RoICE9PSAwKSB7XG4gICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lJDEuY2FsbCh3aW5kb3csIGZ1bmN0aW9uICgpIHtcbiAgICAgIHVwZGF0ZURpc3BsYXlzKGNvbnRyb2xsZXJBcnJheSk7XG4gICAgfSk7XG4gIH1cbiAgQ29tbW9uLmVhY2goY29udHJvbGxlckFycmF5LCBmdW5jdGlvbiAoYykge1xuICAgIGMudXBkYXRlRGlzcGxheSgpO1xuICB9KTtcbn1cblxudmFyIGNvbG9yID0ge1xuICBDb2xvcjogQ29sb3IsXG4gIG1hdGg6IENvbG9yTWF0aCxcbiAgaW50ZXJwcmV0OiBpbnRlcnByZXRcbn07XG52YXIgY29udHJvbGxlcnMgPSB7XG4gIENvbnRyb2xsZXI6IENvbnRyb2xsZXIsXG4gIEJvb2xlYW5Db250cm9sbGVyOiBCb29sZWFuQ29udHJvbGxlcixcbiAgT3B0aW9uQ29udHJvbGxlcjogT3B0aW9uQ29udHJvbGxlcixcbiAgU3RyaW5nQ29udHJvbGxlcjogU3RyaW5nQ29udHJvbGxlcixcbiAgTnVtYmVyQ29udHJvbGxlcjogTnVtYmVyQ29udHJvbGxlcixcbiAgTnVtYmVyQ29udHJvbGxlckJveDogTnVtYmVyQ29udHJvbGxlckJveCxcbiAgTnVtYmVyQ29udHJvbGxlclNsaWRlcjogTnVtYmVyQ29udHJvbGxlclNsaWRlcixcbiAgRnVuY3Rpb25Db250cm9sbGVyOiBGdW5jdGlvbkNvbnRyb2xsZXIsXG4gIENvbG9yQ29udHJvbGxlcjogQ29sb3JDb250cm9sbGVyXG59O1xudmFyIGRvbSQxID0geyBkb206IGRvbSB9O1xudmFyIGd1aSA9IHsgR1VJOiBHVUkgfTtcbnZhciBHVUkkMSA9IEdVSTtcbnZhciBpbmRleCA9IHtcbiAgY29sb3I6IGNvbG9yLFxuICBjb250cm9sbGVyczogY29udHJvbGxlcnMsXG4gIGRvbTogZG9tJDEsXG4gIGd1aTogZ3VpLFxuICBHVUk6IEdVSSQxXG59O1xuXG5leHBvcnQgeyBjb2xvciwgY29udHJvbGxlcnMsIGRvbSQxIGFzIGRvbSwgZ3VpLCBHVUkkMSBhcyBHVUkgfTtcbmV4cG9ydCBkZWZhdWx0IGluZGV4O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0Lmd1aS5tb2R1bGUuanMubWFwXG4iLCIvKipcbiAqIGdwdS5qc1xuICogaHR0cDovL2dwdS5yb2Nrcy9cbiAqXG4gKiBHUFUgQWNjZWxlcmF0ZWQgSmF2YVNjcmlwdFxuICpcbiAqIEB2ZXJzaW9uIDIuMTEuMlxuICogQGRhdGUgVHVlIEphbiAxOSAyMDIxIDExOjI3OjAyIEdNVC0wNTAwIChFYXN0ZXJuIFN0YW5kYXJkIFRpbWUpXG4gKlxuICogQGxpY2Vuc2UgTUlUXG4gKiBUaGUgTUlUIExpY2Vuc2VcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMjEgZ3B1LmpzIFRlYW1cbiAqLyhmdW5jdGlvbihmKXtpZih0eXBlb2YgZXhwb3J0cz09PVwib2JqZWN0XCImJnR5cGVvZiBtb2R1bGUhPT1cInVuZGVmaW5lZFwiKXttb2R1bGUuZXhwb3J0cz1mKCl9ZWxzZSBpZih0eXBlb2YgZGVmaW5lPT09XCJmdW5jdGlvblwiJiZkZWZpbmUuYW1kKXtkZWZpbmUoW10sZil9ZWxzZXt2YXIgZztpZih0eXBlb2Ygd2luZG93IT09XCJ1bmRlZmluZWRcIil7Zz13aW5kb3d9ZWxzZSBpZih0eXBlb2YgZ2xvYmFsIT09XCJ1bmRlZmluZWRcIil7Zz1nbG9iYWx9ZWxzZSBpZih0eXBlb2Ygc2VsZiE9PVwidW5kZWZpbmVkXCIpe2c9c2VsZn1lbHNle2c9dGhpc31nLkdQVSA9IGYoKX19KShmdW5jdGlvbigpe3ZhciBkZWZpbmUsbW9kdWxlLGV4cG9ydHM7cmV0dXJuIChmdW5jdGlvbigpe2Z1bmN0aW9uIHIoZSxuLHQpe2Z1bmN0aW9uIG8oaSxmKXtpZighbltpXSl7aWYoIWVbaV0pe3ZhciBjPVwiZnVuY3Rpb25cIj09dHlwZW9mIHJlcXVpcmUmJnJlcXVpcmU7aWYoIWYmJmMpcmV0dXJuIGMoaSwhMCk7aWYodSlyZXR1cm4gdShpLCEwKTt2YXIgYT1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK2krXCInXCIpO3Rocm93IGEuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixhfXZhciBwPW5baV09e2V4cG9ydHM6e319O2VbaV1bMF0uY2FsbChwLmV4cG9ydHMsZnVuY3Rpb24ocil7dmFyIG49ZVtpXVsxXVtyXTtyZXR1cm4gbyhufHxyKX0scCxwLmV4cG9ydHMscixlLG4sdCl9cmV0dXJuIG5baV0uZXhwb3J0c31mb3IodmFyIHU9XCJmdW5jdGlvblwiPT10eXBlb2YgcmVxdWlyZSYmcmVxdWlyZSxpPTA7aTx0Lmxlbmd0aDtpKyspbyh0W2ldKTtyZXR1cm4gb31yZXR1cm4gcn0pKCkoezE6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gZmFjdG9yeShleHBvcnRzKSA6XG4gIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJ2V4cG9ydHMnXSwgZmFjdG9yeSkgOlxuICAoZ2xvYmFsID0gZ2xvYmFsIHx8IHNlbGYsIGZhY3RvcnkoZ2xvYmFsLmFjb3JuID0ge30pKTtcbn0odGhpcywgZnVuY3Rpb24gKGV4cG9ydHMpIHsgJ3VzZSBzdHJpY3QnO1xuXG5cbiAgdmFyIHJlc2VydmVkV29yZHMgPSB7XG4gICAgMzogXCJhYnN0cmFjdCBib29sZWFuIGJ5dGUgY2hhciBjbGFzcyBkb3VibGUgZW51bSBleHBvcnQgZXh0ZW5kcyBmaW5hbCBmbG9hdCBnb3RvIGltcGxlbWVudHMgaW1wb3J0IGludCBpbnRlcmZhY2UgbG9uZyBuYXRpdmUgcGFja2FnZSBwcml2YXRlIHByb3RlY3RlZCBwdWJsaWMgc2hvcnQgc3RhdGljIHN1cGVyIHN5bmNocm9uaXplZCB0aHJvd3MgdHJhbnNpZW50IHZvbGF0aWxlXCIsXG4gICAgNTogXCJjbGFzcyBlbnVtIGV4dGVuZHMgc3VwZXIgY29uc3QgZXhwb3J0IGltcG9ydFwiLFxuICAgIDY6IFwiZW51bVwiLFxuICAgIHN0cmljdDogXCJpbXBsZW1lbnRzIGludGVyZmFjZSBsZXQgcGFja2FnZSBwcml2YXRlIHByb3RlY3RlZCBwdWJsaWMgc3RhdGljIHlpZWxkXCIsXG4gICAgc3RyaWN0QmluZDogXCJldmFsIGFyZ3VtZW50c1wiXG4gIH07XG5cblxuICB2YXIgZWNtYTVBbmRMZXNzS2V5d29yZHMgPSBcImJyZWFrIGNhc2UgY2F0Y2ggY29udGludWUgZGVidWdnZXIgZGVmYXVsdCBkbyBlbHNlIGZpbmFsbHkgZm9yIGZ1bmN0aW9uIGlmIHJldHVybiBzd2l0Y2ggdGhyb3cgdHJ5IHZhciB3aGlsZSB3aXRoIG51bGwgdHJ1ZSBmYWxzZSBpbnN0YW5jZW9mIHR5cGVvZiB2b2lkIGRlbGV0ZSBuZXcgaW4gdGhpc1wiO1xuXG4gIHZhciBrZXl3b3JkcyA9IHtcbiAgICA1OiBlY21hNUFuZExlc3NLZXl3b3JkcyxcbiAgICBcIjVtb2R1bGVcIjogZWNtYTVBbmRMZXNzS2V5d29yZHMgKyBcIiBleHBvcnQgaW1wb3J0XCIsXG4gICAgNjogZWNtYTVBbmRMZXNzS2V5d29yZHMgKyBcIiBjb25zdCBjbGFzcyBleHRlbmRzIGV4cG9ydCBpbXBvcnQgc3VwZXJcIlxuICB9O1xuXG4gIHZhciBrZXl3b3JkUmVsYXRpb25hbE9wZXJhdG9yID0gL15pbihzdGFuY2VvZik/JC87XG5cblxuICB2YXIgbm9uQVNDSUlpZGVudGlmaWVyU3RhcnRDaGFycyA9IFwiXFx4YWFcXHhiNVxceGJhXFx4YzAtXFx4ZDZcXHhkOC1cXHhmNlxceGY4LVxcdTAyYzFcXHUwMmM2LVxcdTAyZDFcXHUwMmUwLVxcdTAyZTRcXHUwMmVjXFx1MDJlZVxcdTAzNzAtXFx1MDM3NFxcdTAzNzZcXHUwMzc3XFx1MDM3YS1cXHUwMzdkXFx1MDM3ZlxcdTAzODZcXHUwMzg4LVxcdTAzOGFcXHUwMzhjXFx1MDM4ZS1cXHUwM2ExXFx1MDNhMy1cXHUwM2Y1XFx1MDNmNy1cXHUwNDgxXFx1MDQ4YS1cXHUwNTJmXFx1MDUzMS1cXHUwNTU2XFx1MDU1OVxcdTA1NjAtXFx1MDU4OFxcdTA1ZDAtXFx1MDVlYVxcdTA1ZWYtXFx1MDVmMlxcdTA2MjAtXFx1MDY0YVxcdTA2NmVcXHUwNjZmXFx1MDY3MS1cXHUwNmQzXFx1MDZkNVxcdTA2ZTVcXHUwNmU2XFx1MDZlZVxcdTA2ZWZcXHUwNmZhLVxcdTA2ZmNcXHUwNmZmXFx1MDcxMFxcdTA3MTItXFx1MDcyZlxcdTA3NGQtXFx1MDdhNVxcdTA3YjFcXHUwN2NhLVxcdTA3ZWFcXHUwN2Y0XFx1MDdmNVxcdTA3ZmFcXHUwODAwLVxcdTA4MTVcXHUwODFhXFx1MDgyNFxcdTA4MjhcXHUwODQwLVxcdTA4NThcXHUwODYwLVxcdTA4NmFcXHUwOGEwLVxcdTA4YjRcXHUwOGI2LVxcdTA4YmRcXHUwOTA0LVxcdTA5MzlcXHUwOTNkXFx1MDk1MFxcdTA5NTgtXFx1MDk2MVxcdTA5NzEtXFx1MDk4MFxcdTA5ODUtXFx1MDk4Y1xcdTA5OGZcXHUwOTkwXFx1MDk5My1cXHUwOWE4XFx1MDlhYS1cXHUwOWIwXFx1MDliMlxcdTA5YjYtXFx1MDliOVxcdTA5YmRcXHUwOWNlXFx1MDlkY1xcdTA5ZGRcXHUwOWRmLVxcdTA5ZTFcXHUwOWYwXFx1MDlmMVxcdTA5ZmNcXHUwYTA1LVxcdTBhMGFcXHUwYTBmXFx1MGExMFxcdTBhMTMtXFx1MGEyOFxcdTBhMmEtXFx1MGEzMFxcdTBhMzJcXHUwYTMzXFx1MGEzNVxcdTBhMzZcXHUwYTM4XFx1MGEzOVxcdTBhNTktXFx1MGE1Y1xcdTBhNWVcXHUwYTcyLVxcdTBhNzRcXHUwYTg1LVxcdTBhOGRcXHUwYThmLVxcdTBhOTFcXHUwYTkzLVxcdTBhYThcXHUwYWFhLVxcdTBhYjBcXHUwYWIyXFx1MGFiM1xcdTBhYjUtXFx1MGFiOVxcdTBhYmRcXHUwYWQwXFx1MGFlMFxcdTBhZTFcXHUwYWY5XFx1MGIwNS1cXHUwYjBjXFx1MGIwZlxcdTBiMTBcXHUwYjEzLVxcdTBiMjhcXHUwYjJhLVxcdTBiMzBcXHUwYjMyXFx1MGIzM1xcdTBiMzUtXFx1MGIzOVxcdTBiM2RcXHUwYjVjXFx1MGI1ZFxcdTBiNWYtXFx1MGI2MVxcdTBiNzFcXHUwYjgzXFx1MGI4NS1cXHUwYjhhXFx1MGI4ZS1cXHUwYjkwXFx1MGI5Mi1cXHUwYjk1XFx1MGI5OVxcdTBiOWFcXHUwYjljXFx1MGI5ZVxcdTBiOWZcXHUwYmEzXFx1MGJhNFxcdTBiYTgtXFx1MGJhYVxcdTBiYWUtXFx1MGJiOVxcdTBiZDBcXHUwYzA1LVxcdTBjMGNcXHUwYzBlLVxcdTBjMTBcXHUwYzEyLVxcdTBjMjhcXHUwYzJhLVxcdTBjMzlcXHUwYzNkXFx1MGM1OC1cXHUwYzVhXFx1MGM2MFxcdTBjNjFcXHUwYzgwXFx1MGM4NS1cXHUwYzhjXFx1MGM4ZS1cXHUwYzkwXFx1MGM5Mi1cXHUwY2E4XFx1MGNhYS1cXHUwY2IzXFx1MGNiNS1cXHUwY2I5XFx1MGNiZFxcdTBjZGVcXHUwY2UwXFx1MGNlMVxcdTBjZjFcXHUwY2YyXFx1MGQwNS1cXHUwZDBjXFx1MGQwZS1cXHUwZDEwXFx1MGQxMi1cXHUwZDNhXFx1MGQzZFxcdTBkNGVcXHUwZDU0LVxcdTBkNTZcXHUwZDVmLVxcdTBkNjFcXHUwZDdhLVxcdTBkN2ZcXHUwZDg1LVxcdTBkOTZcXHUwZDlhLVxcdTBkYjFcXHUwZGIzLVxcdTBkYmJcXHUwZGJkXFx1MGRjMC1cXHUwZGM2XFx1MGUwMS1cXHUwZTMwXFx1MGUzMlxcdTBlMzNcXHUwZTQwLVxcdTBlNDZcXHUwZTgxXFx1MGU4MlxcdTBlODRcXHUwZTg2LVxcdTBlOGFcXHUwZThjLVxcdTBlYTNcXHUwZWE1XFx1MGVhNy1cXHUwZWIwXFx1MGViMlxcdTBlYjNcXHUwZWJkXFx1MGVjMC1cXHUwZWM0XFx1MGVjNlxcdTBlZGMtXFx1MGVkZlxcdTBmMDBcXHUwZjQwLVxcdTBmNDdcXHUwZjQ5LVxcdTBmNmNcXHUwZjg4LVxcdTBmOGNcXHUxMDAwLVxcdTEwMmFcXHUxMDNmXFx1MTA1MC1cXHUxMDU1XFx1MTA1YS1cXHUxMDVkXFx1MTA2MVxcdTEwNjVcXHUxMDY2XFx1MTA2ZS1cXHUxMDcwXFx1MTA3NS1cXHUxMDgxXFx1MTA4ZVxcdTEwYTAtXFx1MTBjNVxcdTEwYzdcXHUxMGNkXFx1MTBkMC1cXHUxMGZhXFx1MTBmYy1cXHUxMjQ4XFx1MTI0YS1cXHUxMjRkXFx1MTI1MC1cXHUxMjU2XFx1MTI1OFxcdTEyNWEtXFx1MTI1ZFxcdTEyNjAtXFx1MTI4OFxcdTEyOGEtXFx1MTI4ZFxcdTEyOTAtXFx1MTJiMFxcdTEyYjItXFx1MTJiNVxcdTEyYjgtXFx1MTJiZVxcdTEyYzBcXHUxMmMyLVxcdTEyYzVcXHUxMmM4LVxcdTEyZDZcXHUxMmQ4LVxcdTEzMTBcXHUxMzEyLVxcdTEzMTVcXHUxMzE4LVxcdTEzNWFcXHUxMzgwLVxcdTEzOGZcXHUxM2EwLVxcdTEzZjVcXHUxM2Y4LVxcdTEzZmRcXHUxNDAxLVxcdTE2NmNcXHUxNjZmLVxcdTE2N2ZcXHUxNjgxLVxcdTE2OWFcXHUxNmEwLVxcdTE2ZWFcXHUxNmVlLVxcdTE2ZjhcXHUxNzAwLVxcdTE3MGNcXHUxNzBlLVxcdTE3MTFcXHUxNzIwLVxcdTE3MzFcXHUxNzQwLVxcdTE3NTFcXHUxNzYwLVxcdTE3NmNcXHUxNzZlLVxcdTE3NzBcXHUxNzgwLVxcdTE3YjNcXHUxN2Q3XFx1MTdkY1xcdTE4MjAtXFx1MTg3OFxcdTE4ODAtXFx1MThhOFxcdTE4YWFcXHUxOGIwLVxcdTE4ZjVcXHUxOTAwLVxcdTE5MWVcXHUxOTUwLVxcdTE5NmRcXHUxOTcwLVxcdTE5NzRcXHUxOTgwLVxcdTE5YWJcXHUxOWIwLVxcdTE5YzlcXHUxYTAwLVxcdTFhMTZcXHUxYTIwLVxcdTFhNTRcXHUxYWE3XFx1MWIwNS1cXHUxYjMzXFx1MWI0NS1cXHUxYjRiXFx1MWI4My1cXHUxYmEwXFx1MWJhZVxcdTFiYWZcXHUxYmJhLVxcdTFiZTVcXHUxYzAwLVxcdTFjMjNcXHUxYzRkLVxcdTFjNGZcXHUxYzVhLVxcdTFjN2RcXHUxYzgwLVxcdTFjODhcXHUxYzkwLVxcdTFjYmFcXHUxY2JkLVxcdTFjYmZcXHUxY2U5LVxcdTFjZWNcXHUxY2VlLVxcdTFjZjNcXHUxY2Y1XFx1MWNmNlxcdTFjZmFcXHUxZDAwLVxcdTFkYmZcXHUxZTAwLVxcdTFmMTVcXHUxZjE4LVxcdTFmMWRcXHUxZjIwLVxcdTFmNDVcXHUxZjQ4LVxcdTFmNGRcXHUxZjUwLVxcdTFmNTdcXHUxZjU5XFx1MWY1YlxcdTFmNWRcXHUxZjVmLVxcdTFmN2RcXHUxZjgwLVxcdTFmYjRcXHUxZmI2LVxcdTFmYmNcXHUxZmJlXFx1MWZjMi1cXHUxZmM0XFx1MWZjNi1cXHUxZmNjXFx1MWZkMC1cXHUxZmQzXFx1MWZkNi1cXHUxZmRiXFx1MWZlMC1cXHUxZmVjXFx1MWZmMi1cXHUxZmY0XFx1MWZmNi1cXHUxZmZjXFx1MjA3MVxcdTIwN2ZcXHUyMDkwLVxcdTIwOWNcXHUyMTAyXFx1MjEwN1xcdTIxMGEtXFx1MjExM1xcdTIxMTVcXHUyMTE4LVxcdTIxMWRcXHUyMTI0XFx1MjEyNlxcdTIxMjhcXHUyMTJhLVxcdTIxMzlcXHUyMTNjLVxcdTIxM2ZcXHUyMTQ1LVxcdTIxNDlcXHUyMTRlXFx1MjE2MC1cXHUyMTg4XFx1MmMwMC1cXHUyYzJlXFx1MmMzMC1cXHUyYzVlXFx1MmM2MC1cXHUyY2U0XFx1MmNlYi1cXHUyY2VlXFx1MmNmMlxcdTJjZjNcXHUyZDAwLVxcdTJkMjVcXHUyZDI3XFx1MmQyZFxcdTJkMzAtXFx1MmQ2N1xcdTJkNmZcXHUyZDgwLVxcdTJkOTZcXHUyZGEwLVxcdTJkYTZcXHUyZGE4LVxcdTJkYWVcXHUyZGIwLVxcdTJkYjZcXHUyZGI4LVxcdTJkYmVcXHUyZGMwLVxcdTJkYzZcXHUyZGM4LVxcdTJkY2VcXHUyZGQwLVxcdTJkZDZcXHUyZGQ4LVxcdTJkZGVcXHUzMDA1LVxcdTMwMDdcXHUzMDIxLVxcdTMwMjlcXHUzMDMxLVxcdTMwMzVcXHUzMDM4LVxcdTMwM2NcXHUzMDQxLVxcdTMwOTZcXHUzMDliLVxcdTMwOWZcXHUzMGExLVxcdTMwZmFcXHUzMGZjLVxcdTMwZmZcXHUzMTA1LVxcdTMxMmZcXHUzMTMxLVxcdTMxOGVcXHUzMWEwLVxcdTMxYmFcXHUzMWYwLVxcdTMxZmZcXHUzNDAwLVxcdTRkYjVcXHU0ZTAwLVxcdTlmZWZcXHVhMDAwLVxcdWE0OGNcXHVhNGQwLVxcdWE0ZmRcXHVhNTAwLVxcdWE2MGNcXHVhNjEwLVxcdWE2MWZcXHVhNjJhXFx1YTYyYlxcdWE2NDAtXFx1YTY2ZVxcdWE2N2YtXFx1YTY5ZFxcdWE2YTAtXFx1YTZlZlxcdWE3MTctXFx1YTcxZlxcdWE3MjItXFx1YTc4OFxcdWE3OGItXFx1YTdiZlxcdWE3YzItXFx1YTdjNlxcdWE3ZjctXFx1YTgwMVxcdWE4MDMtXFx1YTgwNVxcdWE4MDctXFx1YTgwYVxcdWE4MGMtXFx1YTgyMlxcdWE4NDAtXFx1YTg3M1xcdWE4ODItXFx1YThiM1xcdWE4ZjItXFx1YThmN1xcdWE4ZmJcXHVhOGZkXFx1YThmZVxcdWE5MGEtXFx1YTkyNVxcdWE5MzAtXFx1YTk0NlxcdWE5NjAtXFx1YTk3Y1xcdWE5ODQtXFx1YTliMlxcdWE5Y2ZcXHVhOWUwLVxcdWE5ZTRcXHVhOWU2LVxcdWE5ZWZcXHVhOWZhLVxcdWE5ZmVcXHVhYTAwLVxcdWFhMjhcXHVhYTQwLVxcdWFhNDJcXHVhYTQ0LVxcdWFhNGJcXHVhYTYwLVxcdWFhNzZcXHVhYTdhXFx1YWE3ZS1cXHVhYWFmXFx1YWFiMVxcdWFhYjVcXHVhYWI2XFx1YWFiOS1cXHVhYWJkXFx1YWFjMFxcdWFhYzJcXHVhYWRiLVxcdWFhZGRcXHVhYWUwLVxcdWFhZWFcXHVhYWYyLVxcdWFhZjRcXHVhYjAxLVxcdWFiMDZcXHVhYjA5LVxcdWFiMGVcXHVhYjExLVxcdWFiMTZcXHVhYjIwLVxcdWFiMjZcXHVhYjI4LVxcdWFiMmVcXHVhYjMwLVxcdWFiNWFcXHVhYjVjLVxcdWFiNjdcXHVhYjcwLVxcdWFiZTJcXHVhYzAwLVxcdWQ3YTNcXHVkN2IwLVxcdWQ3YzZcXHVkN2NiLVxcdWQ3ZmJcXHVmOTAwLVxcdWZhNmRcXHVmYTcwLVxcdWZhZDlcXHVmYjAwLVxcdWZiMDZcXHVmYjEzLVxcdWZiMTdcXHVmYjFkXFx1ZmIxZi1cXHVmYjI4XFx1ZmIyYS1cXHVmYjM2XFx1ZmIzOC1cXHVmYjNjXFx1ZmIzZVxcdWZiNDBcXHVmYjQxXFx1ZmI0M1xcdWZiNDRcXHVmYjQ2LVxcdWZiYjFcXHVmYmQzLVxcdWZkM2RcXHVmZDUwLVxcdWZkOGZcXHVmZDkyLVxcdWZkYzdcXHVmZGYwLVxcdWZkZmJcXHVmZTcwLVxcdWZlNzRcXHVmZTc2LVxcdWZlZmNcXHVmZjIxLVxcdWZmM2FcXHVmZjQxLVxcdWZmNWFcXHVmZjY2LVxcdWZmYmVcXHVmZmMyLVxcdWZmYzdcXHVmZmNhLVxcdWZmY2ZcXHVmZmQyLVxcdWZmZDdcXHVmZmRhLVxcdWZmZGNcIjtcbiAgdmFyIG5vbkFTQ0lJaWRlbnRpZmllckNoYXJzID0gXCJcXHUyMDBjXFx1MjAwZFxceGI3XFx1MDMwMC1cXHUwMzZmXFx1MDM4N1xcdTA0ODMtXFx1MDQ4N1xcdTA1OTEtXFx1MDViZFxcdTA1YmZcXHUwNWMxXFx1MDVjMlxcdTA1YzRcXHUwNWM1XFx1MDVjN1xcdTA2MTAtXFx1MDYxYVxcdTA2NGItXFx1MDY2OVxcdTA2NzBcXHUwNmQ2LVxcdTA2ZGNcXHUwNmRmLVxcdTA2ZTRcXHUwNmU3XFx1MDZlOFxcdTA2ZWEtXFx1MDZlZFxcdTA2ZjAtXFx1MDZmOVxcdTA3MTFcXHUwNzMwLVxcdTA3NGFcXHUwN2E2LVxcdTA3YjBcXHUwN2MwLVxcdTA3YzlcXHUwN2ViLVxcdTA3ZjNcXHUwN2ZkXFx1MDgxNi1cXHUwODE5XFx1MDgxYi1cXHUwODIzXFx1MDgyNS1cXHUwODI3XFx1MDgyOS1cXHUwODJkXFx1MDg1OS1cXHUwODViXFx1MDhkMy1cXHUwOGUxXFx1MDhlMy1cXHUwOTAzXFx1MDkzYS1cXHUwOTNjXFx1MDkzZS1cXHUwOTRmXFx1MDk1MS1cXHUwOTU3XFx1MDk2MlxcdTA5NjNcXHUwOTY2LVxcdTA5NmZcXHUwOTgxLVxcdTA5ODNcXHUwOWJjXFx1MDliZS1cXHUwOWM0XFx1MDljN1xcdTA5YzhcXHUwOWNiLVxcdTA5Y2RcXHUwOWQ3XFx1MDllMlxcdTA5ZTNcXHUwOWU2LVxcdTA5ZWZcXHUwOWZlXFx1MGEwMS1cXHUwYTAzXFx1MGEzY1xcdTBhM2UtXFx1MGE0MlxcdTBhNDdcXHUwYTQ4XFx1MGE0Yi1cXHUwYTRkXFx1MGE1MVxcdTBhNjYtXFx1MGE3MVxcdTBhNzVcXHUwYTgxLVxcdTBhODNcXHUwYWJjXFx1MGFiZS1cXHUwYWM1XFx1MGFjNy1cXHUwYWM5XFx1MGFjYi1cXHUwYWNkXFx1MGFlMlxcdTBhZTNcXHUwYWU2LVxcdTBhZWZcXHUwYWZhLVxcdTBhZmZcXHUwYjAxLVxcdTBiMDNcXHUwYjNjXFx1MGIzZS1cXHUwYjQ0XFx1MGI0N1xcdTBiNDhcXHUwYjRiLVxcdTBiNGRcXHUwYjU2XFx1MGI1N1xcdTBiNjJcXHUwYjYzXFx1MGI2Ni1cXHUwYjZmXFx1MGI4MlxcdTBiYmUtXFx1MGJjMlxcdTBiYzYtXFx1MGJjOFxcdTBiY2EtXFx1MGJjZFxcdTBiZDdcXHUwYmU2LVxcdTBiZWZcXHUwYzAwLVxcdTBjMDRcXHUwYzNlLVxcdTBjNDRcXHUwYzQ2LVxcdTBjNDhcXHUwYzRhLVxcdTBjNGRcXHUwYzU1XFx1MGM1NlxcdTBjNjJcXHUwYzYzXFx1MGM2Ni1cXHUwYzZmXFx1MGM4MS1cXHUwYzgzXFx1MGNiY1xcdTBjYmUtXFx1MGNjNFxcdTBjYzYtXFx1MGNjOFxcdTBjY2EtXFx1MGNjZFxcdTBjZDVcXHUwY2Q2XFx1MGNlMlxcdTBjZTNcXHUwY2U2LVxcdTBjZWZcXHUwZDAwLVxcdTBkMDNcXHUwZDNiXFx1MGQzY1xcdTBkM2UtXFx1MGQ0NFxcdTBkNDYtXFx1MGQ0OFxcdTBkNGEtXFx1MGQ0ZFxcdTBkNTdcXHUwZDYyXFx1MGQ2M1xcdTBkNjYtXFx1MGQ2ZlxcdTBkODJcXHUwZDgzXFx1MGRjYVxcdTBkY2YtXFx1MGRkNFxcdTBkZDZcXHUwZGQ4LVxcdTBkZGZcXHUwZGU2LVxcdTBkZWZcXHUwZGYyXFx1MGRmM1xcdTBlMzFcXHUwZTM0LVxcdTBlM2FcXHUwZTQ3LVxcdTBlNGVcXHUwZTUwLVxcdTBlNTlcXHUwZWIxXFx1MGViNC1cXHUwZWJjXFx1MGVjOC1cXHUwZWNkXFx1MGVkMC1cXHUwZWQ5XFx1MGYxOFxcdTBmMTlcXHUwZjIwLVxcdTBmMjlcXHUwZjM1XFx1MGYzN1xcdTBmMzlcXHUwZjNlXFx1MGYzZlxcdTBmNzEtXFx1MGY4NFxcdTBmODZcXHUwZjg3XFx1MGY4ZC1cXHUwZjk3XFx1MGY5OS1cXHUwZmJjXFx1MGZjNlxcdTEwMmItXFx1MTAzZVxcdTEwNDAtXFx1MTA0OVxcdTEwNTYtXFx1MTA1OVxcdTEwNWUtXFx1MTA2MFxcdTEwNjItXFx1MTA2NFxcdTEwNjctXFx1MTA2ZFxcdTEwNzEtXFx1MTA3NFxcdTEwODItXFx1MTA4ZFxcdTEwOGYtXFx1MTA5ZFxcdTEzNWQtXFx1MTM1ZlxcdTEzNjktXFx1MTM3MVxcdTE3MTItXFx1MTcxNFxcdTE3MzItXFx1MTczNFxcdTE3NTJcXHUxNzUzXFx1MTc3MlxcdTE3NzNcXHUxN2I0LVxcdTE3ZDNcXHUxN2RkXFx1MTdlMC1cXHUxN2U5XFx1MTgwYi1cXHUxODBkXFx1MTgxMC1cXHUxODE5XFx1MThhOVxcdTE5MjAtXFx1MTkyYlxcdTE5MzAtXFx1MTkzYlxcdTE5NDYtXFx1MTk0ZlxcdTE5ZDAtXFx1MTlkYVxcdTFhMTctXFx1MWExYlxcdTFhNTUtXFx1MWE1ZVxcdTFhNjAtXFx1MWE3Y1xcdTFhN2YtXFx1MWE4OVxcdTFhOTAtXFx1MWE5OVxcdTFhYjAtXFx1MWFiZFxcdTFiMDAtXFx1MWIwNFxcdTFiMzQtXFx1MWI0NFxcdTFiNTAtXFx1MWI1OVxcdTFiNmItXFx1MWI3M1xcdTFiODAtXFx1MWI4MlxcdTFiYTEtXFx1MWJhZFxcdTFiYjAtXFx1MWJiOVxcdTFiZTYtXFx1MWJmM1xcdTFjMjQtXFx1MWMzN1xcdTFjNDAtXFx1MWM0OVxcdTFjNTAtXFx1MWM1OVxcdTFjZDAtXFx1MWNkMlxcdTFjZDQtXFx1MWNlOFxcdTFjZWRcXHUxY2Y0XFx1MWNmNy1cXHUxY2Y5XFx1MWRjMC1cXHUxZGY5XFx1MWRmYi1cXHUxZGZmXFx1MjAzZlxcdTIwNDBcXHUyMDU0XFx1MjBkMC1cXHUyMGRjXFx1MjBlMVxcdTIwZTUtXFx1MjBmMFxcdTJjZWYtXFx1MmNmMVxcdTJkN2ZcXHUyZGUwLVxcdTJkZmZcXHUzMDJhLVxcdTMwMmZcXHUzMDk5XFx1MzA5YVxcdWE2MjAtXFx1YTYyOVxcdWE2NmZcXHVhNjc0LVxcdWE2N2RcXHVhNjllXFx1YTY5ZlxcdWE2ZjBcXHVhNmYxXFx1YTgwMlxcdWE4MDZcXHVhODBiXFx1YTgyMy1cXHVhODI3XFx1YTg4MFxcdWE4ODFcXHVhOGI0LVxcdWE4YzVcXHVhOGQwLVxcdWE4ZDlcXHVhOGUwLVxcdWE4ZjFcXHVhOGZmLVxcdWE5MDlcXHVhOTI2LVxcdWE5MmRcXHVhOTQ3LVxcdWE5NTNcXHVhOTgwLVxcdWE5ODNcXHVhOWIzLVxcdWE5YzBcXHVhOWQwLVxcdWE5ZDlcXHVhOWU1XFx1YTlmMC1cXHVhOWY5XFx1YWEyOS1cXHVhYTM2XFx1YWE0M1xcdWFhNGNcXHVhYTRkXFx1YWE1MC1cXHVhYTU5XFx1YWE3Yi1cXHVhYTdkXFx1YWFiMFxcdWFhYjItXFx1YWFiNFxcdWFhYjdcXHVhYWI4XFx1YWFiZVxcdWFhYmZcXHVhYWMxXFx1YWFlYi1cXHVhYWVmXFx1YWFmNVxcdWFhZjZcXHVhYmUzLVxcdWFiZWFcXHVhYmVjXFx1YWJlZFxcdWFiZjAtXFx1YWJmOVxcdWZiMWVcXHVmZTAwLVxcdWZlMGZcXHVmZTIwLVxcdWZlMmZcXHVmZTMzXFx1ZmUzNFxcdWZlNGQtXFx1ZmU0ZlxcdWZmMTAtXFx1ZmYxOVxcdWZmM2ZcIjtcblxuICB2YXIgbm9uQVNDSUlpZGVudGlmaWVyU3RhcnQgPSBuZXcgUmVnRXhwKFwiW1wiICsgbm9uQVNDSUlpZGVudGlmaWVyU3RhcnRDaGFycyArIFwiXVwiKTtcbiAgdmFyIG5vbkFTQ0lJaWRlbnRpZmllciA9IG5ldyBSZWdFeHAoXCJbXCIgKyBub25BU0NJSWlkZW50aWZpZXJTdGFydENoYXJzICsgbm9uQVNDSUlpZGVudGlmaWVyQ2hhcnMgKyBcIl1cIik7XG5cbiAgbm9uQVNDSUlpZGVudGlmaWVyU3RhcnRDaGFycyA9IG5vbkFTQ0lJaWRlbnRpZmllckNoYXJzID0gbnVsbDtcblxuXG4gIHZhciBhc3RyYWxJZGVudGlmaWVyU3RhcnRDb2RlcyA9IFswLDExLDIsMjUsMiwxOCwyLDEsMiwxNCwzLDEzLDM1LDEyMiw3MCw1MiwyNjgsMjgsNCw0OCw0OCwzMSwxNCwyOSw2LDM3LDExLDI5LDMsMzUsNSw3LDIsNCw0MywxNTcsMTksMzUsNSwzNSw1LDM5LDksNTEsMTU3LDMxMCwxMCwyMSwxMSw3LDE1Myw1LDMsMCwyLDQzLDIsMSw0LDAsMywyMiwxMSwyMiwxMCwzMCw2NiwxOCwyLDEsMTEsMjEsMTEsMjUsNzEsNTUsNywxLDY1LDAsMTYsMywyLDIsMiwyOCw0MywyOCw0LDI4LDM2LDcsMiwyNywyOCw1MywxMSwyMSwxMSwxOCwxNCwxNywxMTEsNzIsNTYsNTAsMTQsNTAsMTQsMzUsNDc3LDI4LDExLDAsOSwyMSwxNTUsMjIsMTMsNTIsNzYsNDQsMzMsMjQsMjcsMzUsMzAsMCwxMiwzNCw0LDAsMTMsNDcsMTUsMywyMiwwLDIsMCwzNiwxNywyLDI0LDg1LDYsMiwwLDIsMywyLDE0LDIsOSw4LDQ2LDM5LDcsMywxLDMsMjEsMiw2LDIsMSwyLDQsNCwwLDE5LDAsMTMsNCwxNTksNTIsMTksMywyMSwwLDMzLDQ3LDIxLDEsMiwwLDE4NSw0Niw0MiwzLDM3LDQ3LDIxLDAsNjAsNDIsMTQsMCw3MiwyNiwyMzAsNDMsMTE3LDYzLDMyLDAsMTYxLDcsMywzOCwxNywwLDIsMCwyOSwwLDExLDM5LDgsMCwyMiwwLDEyLDQ1LDIwLDAsMzUsNTYsMjY0LDgsMiwzNiwxOCwwLDUwLDI5LDExMyw2LDIsMSwyLDM3LDIyLDAsMjYsNSwyLDEsMiwzMSwxNSwwLDMyOCwxOCwyNzAsOTIxLDEwMywxMTAsMTgsMTk1LDI3NDksMTA3MCw0MDUwLDU4Miw4NjM0LDU2OCw4LDMwLDExNCwyOSwxOSw0NywxNywzLDMyLDIwLDYsMTgsNjg5LDYzLDEyOSw3NCw2LDAsNjcsMTIsNjUsMSwyLDAsMjksNjEzNSw5LDc1NCw5NDg2LDI4Niw1MCwyLDE4LDMsOSwzOTUsMjMwOSwxMDYsNiwxMiw0LDgsOCw5LDU5OTEsODQsMiw3MCwyLDEsMywwLDMsMSwzLDMsMiwxMSwyLDAsMiw2LDIsNjQsMiwzLDMsNywyLDYsMiwyNywyLDMsMiw0LDIsMCw0LDYsMiwzMzksMywyNCwyLDI0LDIsMzAsMiwyNCwyLDMwLDIsMjQsMiwzMCwyLDI0LDIsMzAsMiwyNCwyLDcsMjM1Nyw0NCwxMSw2LDE3LDAsMzcwLDQzLDEzMDEsMTk2LDYwLDY3LDgsMCwxMjA1LDMsMiwyNiwyLDEsMiwwLDMsMCwyLDksMiwzLDIsMCwyLDAsNywwLDUsMCwyLDAsMiwwLDIsMiwyLDEsMiwwLDMsMCwyLDAsMiwwLDIsMCwyLDAsMiwxLDIsMCwzLDMsMiw2LDIsMywyLDMsMiwwLDIsOSwyLDE2LDYsMiwyLDQsMiwxNiw0NDIxLDQyNzEwLDQyLDQxNDgsMTIsMjIxLDMsNTc2MSwxNSw3NDcyLDMxMDQsNTQxXTtcblxuICB2YXIgYXN0cmFsSWRlbnRpZmllckNvZGVzID0gWzUwOSwwLDIyNywwLDE1MCw0LDI5NCw5LDEzNjgsMiwyLDEsNiwzLDQxLDIsNSwwLDE2NiwxLDU3NCwzLDksOSw1MjUsMTAsMTc2LDIsNTQsMTQsMzIsOSwxNiwzLDQ2LDEwLDU0LDksNywyLDM3LDEzLDIsOSw2LDEsNDUsMCwxMywyLDQ5LDEzLDksMyw0LDksODMsMTEsNywwLDE2MSwxMSw2LDksNywzLDU2LDEsMiw2LDMsMSwzLDIsMTAsMCwxMSwxLDMsNiw0LDQsMTkzLDE3LDEwLDksNSwwLDgyLDE5LDEzLDksMjE0LDYsMyw4LDI4LDEsODMsMTYsMTYsOSw4MiwxMiw5LDksODQsMTQsNSw5LDI0MywxNCwxNjYsOSwyMzIsNiwzLDYsNCwwLDI5LDksNDEsNiwyLDMsOSwwLDEwLDEwLDQ3LDE1LDQwNiw3LDIsNywxNyw5LDU3LDIxLDIsMTMsMTIzLDUsNCwwLDIsMSwyLDYsMiwwLDksOSw0OSw0LDIsMSwyLDQsOSw5LDMzMCwzLDE5MzA2LDksMTM1LDQsNjAsNiwyNiw5LDEwMTQsMCwyLDU0LDgsMywxOTcyMywxLDUzMTksNCw0LDUsOSw3LDMsNiwzMSwzLDE0OSwyLDE0MTgsNDksNTEzLDU0LDUsNDksOSwwLDE1LDAsMjMsNCwyLDE0LDEzNjEsNiwyLDE2LDMsNiwyLDEsMiw0LDI2Miw2LDEwLDksNDE5LDEzLDE0OTUsNiwxMTAsNiw2LDksNzkyNDg3LDIzOV07XG5cbiAgZnVuY3Rpb24gaXNJbkFzdHJhbFNldChjb2RlLCBzZXQpIHtcbiAgICB2YXIgcG9zID0gMHgxMDAwMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNldC5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgcG9zICs9IHNldFtpXTtcbiAgICAgIGlmIChwb3MgPiBjb2RlKSB7IHJldHVybiBmYWxzZSB9XG4gICAgICBwb3MgKz0gc2V0W2kgKyAxXTtcbiAgICAgIGlmIChwb3MgPj0gY29kZSkgeyByZXR1cm4gdHJ1ZSB9XG4gICAgfVxuICB9XG5cblxuICBmdW5jdGlvbiBpc0lkZW50aWZpZXJTdGFydChjb2RlLCBhc3RyYWwpIHtcbiAgICBpZiAoY29kZSA8IDY1KSB7IHJldHVybiBjb2RlID09PSAzNiB9XG4gICAgaWYgKGNvZGUgPCA5MSkgeyByZXR1cm4gdHJ1ZSB9XG4gICAgaWYgKGNvZGUgPCA5NykgeyByZXR1cm4gY29kZSA9PT0gOTUgfVxuICAgIGlmIChjb2RlIDwgMTIzKSB7IHJldHVybiB0cnVlIH1cbiAgICBpZiAoY29kZSA8PSAweGZmZmYpIHsgcmV0dXJuIGNvZGUgPj0gMHhhYSAmJiBub25BU0NJSWlkZW50aWZpZXJTdGFydC50ZXN0KFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSkpIH1cbiAgICBpZiAoYXN0cmFsID09PSBmYWxzZSkgeyByZXR1cm4gZmFsc2UgfVxuICAgIHJldHVybiBpc0luQXN0cmFsU2V0KGNvZGUsIGFzdHJhbElkZW50aWZpZXJTdGFydENvZGVzKVxuICB9XG5cblxuICBmdW5jdGlvbiBpc0lkZW50aWZpZXJDaGFyKGNvZGUsIGFzdHJhbCkge1xuICAgIGlmIChjb2RlIDwgNDgpIHsgcmV0dXJuIGNvZGUgPT09IDM2IH1cbiAgICBpZiAoY29kZSA8IDU4KSB7IHJldHVybiB0cnVlIH1cbiAgICBpZiAoY29kZSA8IDY1KSB7IHJldHVybiBmYWxzZSB9XG4gICAgaWYgKGNvZGUgPCA5MSkgeyByZXR1cm4gdHJ1ZSB9XG4gICAgaWYgKGNvZGUgPCA5NykgeyByZXR1cm4gY29kZSA9PT0gOTUgfVxuICAgIGlmIChjb2RlIDwgMTIzKSB7IHJldHVybiB0cnVlIH1cbiAgICBpZiAoY29kZSA8PSAweGZmZmYpIHsgcmV0dXJuIGNvZGUgPj0gMHhhYSAmJiBub25BU0NJSWlkZW50aWZpZXIudGVzdChTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpKSB9XG4gICAgaWYgKGFzdHJhbCA9PT0gZmFsc2UpIHsgcmV0dXJuIGZhbHNlIH1cbiAgICByZXR1cm4gaXNJbkFzdHJhbFNldChjb2RlLCBhc3RyYWxJZGVudGlmaWVyU3RhcnRDb2RlcykgfHwgaXNJbkFzdHJhbFNldChjb2RlLCBhc3RyYWxJZGVudGlmaWVyQ29kZXMpXG4gIH1cblxuXG5cblxuXG4gIHZhciBUb2tlblR5cGUgPSBmdW5jdGlvbiBUb2tlblR5cGUobGFiZWwsIGNvbmYpIHtcbiAgICBpZiAoIGNvbmYgPT09IHZvaWQgMCApIGNvbmYgPSB7fTtcblxuICAgIHRoaXMubGFiZWwgPSBsYWJlbDtcbiAgICB0aGlzLmtleXdvcmQgPSBjb25mLmtleXdvcmQ7XG4gICAgdGhpcy5iZWZvcmVFeHByID0gISFjb25mLmJlZm9yZUV4cHI7XG4gICAgdGhpcy5zdGFydHNFeHByID0gISFjb25mLnN0YXJ0c0V4cHI7XG4gICAgdGhpcy5pc0xvb3AgPSAhIWNvbmYuaXNMb29wO1xuICAgIHRoaXMuaXNBc3NpZ24gPSAhIWNvbmYuaXNBc3NpZ247XG4gICAgdGhpcy5wcmVmaXggPSAhIWNvbmYucHJlZml4O1xuICAgIHRoaXMucG9zdGZpeCA9ICEhY29uZi5wb3N0Zml4O1xuICAgIHRoaXMuYmlub3AgPSBjb25mLmJpbm9wIHx8IG51bGw7XG4gICAgdGhpcy51cGRhdGVDb250ZXh0ID0gbnVsbDtcbiAgfTtcblxuICBmdW5jdGlvbiBiaW5vcChuYW1lLCBwcmVjKSB7XG4gICAgcmV0dXJuIG5ldyBUb2tlblR5cGUobmFtZSwge2JlZm9yZUV4cHI6IHRydWUsIGJpbm9wOiBwcmVjfSlcbiAgfVxuICB2YXIgYmVmb3JlRXhwciA9IHtiZWZvcmVFeHByOiB0cnVlfSwgc3RhcnRzRXhwciA9IHtzdGFydHNFeHByOiB0cnVlfTtcblxuXG4gIHZhciBrZXl3b3JkcyQxID0ge307XG5cbiAgZnVuY3Rpb24ga3cobmFtZSwgb3B0aW9ucykge1xuICAgIGlmICggb3B0aW9ucyA9PT0gdm9pZCAwICkgb3B0aW9ucyA9IHt9O1xuXG4gICAgb3B0aW9ucy5rZXl3b3JkID0gbmFtZTtcbiAgICByZXR1cm4ga2V5d29yZHMkMVtuYW1lXSA9IG5ldyBUb2tlblR5cGUobmFtZSwgb3B0aW9ucylcbiAgfVxuXG4gIHZhciB0eXBlcyA9IHtcbiAgICBudW06IG5ldyBUb2tlblR5cGUoXCJudW1cIiwgc3RhcnRzRXhwciksXG4gICAgcmVnZXhwOiBuZXcgVG9rZW5UeXBlKFwicmVnZXhwXCIsIHN0YXJ0c0V4cHIpLFxuICAgIHN0cmluZzogbmV3IFRva2VuVHlwZShcInN0cmluZ1wiLCBzdGFydHNFeHByKSxcbiAgICBuYW1lOiBuZXcgVG9rZW5UeXBlKFwibmFtZVwiLCBzdGFydHNFeHByKSxcbiAgICBlb2Y6IG5ldyBUb2tlblR5cGUoXCJlb2ZcIiksXG5cbiAgICBicmFja2V0TDogbmV3IFRva2VuVHlwZShcIltcIiwge2JlZm9yZUV4cHI6IHRydWUsIHN0YXJ0c0V4cHI6IHRydWV9KSxcbiAgICBicmFja2V0UjogbmV3IFRva2VuVHlwZShcIl1cIiksXG4gICAgYnJhY2VMOiBuZXcgVG9rZW5UeXBlKFwie1wiLCB7YmVmb3JlRXhwcjogdHJ1ZSwgc3RhcnRzRXhwcjogdHJ1ZX0pLFxuICAgIGJyYWNlUjogbmV3IFRva2VuVHlwZShcIn1cIiksXG4gICAgcGFyZW5MOiBuZXcgVG9rZW5UeXBlKFwiKFwiLCB7YmVmb3JlRXhwcjogdHJ1ZSwgc3RhcnRzRXhwcjogdHJ1ZX0pLFxuICAgIHBhcmVuUjogbmV3IFRva2VuVHlwZShcIilcIiksXG4gICAgY29tbWE6IG5ldyBUb2tlblR5cGUoXCIsXCIsIGJlZm9yZUV4cHIpLFxuICAgIHNlbWk6IG5ldyBUb2tlblR5cGUoXCI7XCIsIGJlZm9yZUV4cHIpLFxuICAgIGNvbG9uOiBuZXcgVG9rZW5UeXBlKFwiOlwiLCBiZWZvcmVFeHByKSxcbiAgICBkb3Q6IG5ldyBUb2tlblR5cGUoXCIuXCIpLFxuICAgIHF1ZXN0aW9uOiBuZXcgVG9rZW5UeXBlKFwiP1wiLCBiZWZvcmVFeHByKSxcbiAgICBhcnJvdzogbmV3IFRva2VuVHlwZShcIj0+XCIsIGJlZm9yZUV4cHIpLFxuICAgIHRlbXBsYXRlOiBuZXcgVG9rZW5UeXBlKFwidGVtcGxhdGVcIiksXG4gICAgaW52YWxpZFRlbXBsYXRlOiBuZXcgVG9rZW5UeXBlKFwiaW52YWxpZFRlbXBsYXRlXCIpLFxuICAgIGVsbGlwc2lzOiBuZXcgVG9rZW5UeXBlKFwiLi4uXCIsIGJlZm9yZUV4cHIpLFxuICAgIGJhY2tRdW90ZTogbmV3IFRva2VuVHlwZShcImBcIiwgc3RhcnRzRXhwciksXG4gICAgZG9sbGFyQnJhY2VMOiBuZXcgVG9rZW5UeXBlKFwiJHtcIiwge2JlZm9yZUV4cHI6IHRydWUsIHN0YXJ0c0V4cHI6IHRydWV9KSxcblxuXG4gICAgZXE6IG5ldyBUb2tlblR5cGUoXCI9XCIsIHtiZWZvcmVFeHByOiB0cnVlLCBpc0Fzc2lnbjogdHJ1ZX0pLFxuICAgIGFzc2lnbjogbmV3IFRva2VuVHlwZShcIl89XCIsIHtiZWZvcmVFeHByOiB0cnVlLCBpc0Fzc2lnbjogdHJ1ZX0pLFxuICAgIGluY0RlYzogbmV3IFRva2VuVHlwZShcIisrLy0tXCIsIHtwcmVmaXg6IHRydWUsIHBvc3RmaXg6IHRydWUsIHN0YXJ0c0V4cHI6IHRydWV9KSxcbiAgICBwcmVmaXg6IG5ldyBUb2tlblR5cGUoXCIhL35cIiwge2JlZm9yZUV4cHI6IHRydWUsIHByZWZpeDogdHJ1ZSwgc3RhcnRzRXhwcjogdHJ1ZX0pLFxuICAgIGxvZ2ljYWxPUjogYmlub3AoXCJ8fFwiLCAxKSxcbiAgICBsb2dpY2FsQU5EOiBiaW5vcChcIiYmXCIsIDIpLFxuICAgIGJpdHdpc2VPUjogYmlub3AoXCJ8XCIsIDMpLFxuICAgIGJpdHdpc2VYT1I6IGJpbm9wKFwiXlwiLCA0KSxcbiAgICBiaXR3aXNlQU5EOiBiaW5vcChcIiZcIiwgNSksXG4gICAgZXF1YWxpdHk6IGJpbm9wKFwiPT0vIT0vPT09LyE9PVwiLCA2KSxcbiAgICByZWxhdGlvbmFsOiBiaW5vcChcIjwvPi88PS8+PVwiLCA3KSxcbiAgICBiaXRTaGlmdDogYmlub3AoXCI8PC8+Pi8+Pj5cIiwgOCksXG4gICAgcGx1c01pbjogbmV3IFRva2VuVHlwZShcIisvLVwiLCB7YmVmb3JlRXhwcjogdHJ1ZSwgYmlub3A6IDksIHByZWZpeDogdHJ1ZSwgc3RhcnRzRXhwcjogdHJ1ZX0pLFxuICAgIG1vZHVsbzogYmlub3AoXCIlXCIsIDEwKSxcbiAgICBzdGFyOiBiaW5vcChcIipcIiwgMTApLFxuICAgIHNsYXNoOiBiaW5vcChcIi9cIiwgMTApLFxuICAgIHN0YXJzdGFyOiBuZXcgVG9rZW5UeXBlKFwiKipcIiwge2JlZm9yZUV4cHI6IHRydWV9KSxcblxuICAgIF9icmVhazoga3coXCJicmVha1wiKSxcbiAgICBfY2FzZToga3coXCJjYXNlXCIsIGJlZm9yZUV4cHIpLFxuICAgIF9jYXRjaDoga3coXCJjYXRjaFwiKSxcbiAgICBfY29udGludWU6IGt3KFwiY29udGludWVcIiksXG4gICAgX2RlYnVnZ2VyOiBrdyhcImRlYnVnZ2VyXCIpLFxuICAgIF9kZWZhdWx0OiBrdyhcImRlZmF1bHRcIiwgYmVmb3JlRXhwciksXG4gICAgX2RvOiBrdyhcImRvXCIsIHtpc0xvb3A6IHRydWUsIGJlZm9yZUV4cHI6IHRydWV9KSxcbiAgICBfZWxzZToga3coXCJlbHNlXCIsIGJlZm9yZUV4cHIpLFxuICAgIF9maW5hbGx5OiBrdyhcImZpbmFsbHlcIiksXG4gICAgX2Zvcjoga3coXCJmb3JcIiwge2lzTG9vcDogdHJ1ZX0pLFxuICAgIF9mdW5jdGlvbjoga3coXCJmdW5jdGlvblwiLCBzdGFydHNFeHByKSxcbiAgICBfaWY6IGt3KFwiaWZcIiksXG4gICAgX3JldHVybjoga3coXCJyZXR1cm5cIiwgYmVmb3JlRXhwciksXG4gICAgX3N3aXRjaDoga3coXCJzd2l0Y2hcIiksXG4gICAgX3Rocm93OiBrdyhcInRocm93XCIsIGJlZm9yZUV4cHIpLFxuICAgIF90cnk6IGt3KFwidHJ5XCIpLFxuICAgIF92YXI6IGt3KFwidmFyXCIpLFxuICAgIF9jb25zdDoga3coXCJjb25zdFwiKSxcbiAgICBfd2hpbGU6IGt3KFwid2hpbGVcIiwge2lzTG9vcDogdHJ1ZX0pLFxuICAgIF93aXRoOiBrdyhcIndpdGhcIiksXG4gICAgX25ldzoga3coXCJuZXdcIiwge2JlZm9yZUV4cHI6IHRydWUsIHN0YXJ0c0V4cHI6IHRydWV9KSxcbiAgICBfdGhpczoga3coXCJ0aGlzXCIsIHN0YXJ0c0V4cHIpLFxuICAgIF9zdXBlcjoga3coXCJzdXBlclwiLCBzdGFydHNFeHByKSxcbiAgICBfY2xhc3M6IGt3KFwiY2xhc3NcIiwgc3RhcnRzRXhwciksXG4gICAgX2V4dGVuZHM6IGt3KFwiZXh0ZW5kc1wiLCBiZWZvcmVFeHByKSxcbiAgICBfZXhwb3J0OiBrdyhcImV4cG9ydFwiKSxcbiAgICBfaW1wb3J0OiBrdyhcImltcG9ydFwiLCBzdGFydHNFeHByKSxcbiAgICBfbnVsbDoga3coXCJudWxsXCIsIHN0YXJ0c0V4cHIpLFxuICAgIF90cnVlOiBrdyhcInRydWVcIiwgc3RhcnRzRXhwciksXG4gICAgX2ZhbHNlOiBrdyhcImZhbHNlXCIsIHN0YXJ0c0V4cHIpLFxuICAgIF9pbjoga3coXCJpblwiLCB7YmVmb3JlRXhwcjogdHJ1ZSwgYmlub3A6IDd9KSxcbiAgICBfaW5zdGFuY2VvZjoga3coXCJpbnN0YW5jZW9mXCIsIHtiZWZvcmVFeHByOiB0cnVlLCBiaW5vcDogN30pLFxuICAgIF90eXBlb2Y6IGt3KFwidHlwZW9mXCIsIHtiZWZvcmVFeHByOiB0cnVlLCBwcmVmaXg6IHRydWUsIHN0YXJ0c0V4cHI6IHRydWV9KSxcbiAgICBfdm9pZDoga3coXCJ2b2lkXCIsIHtiZWZvcmVFeHByOiB0cnVlLCBwcmVmaXg6IHRydWUsIHN0YXJ0c0V4cHI6IHRydWV9KSxcbiAgICBfZGVsZXRlOiBrdyhcImRlbGV0ZVwiLCB7YmVmb3JlRXhwcjogdHJ1ZSwgcHJlZml4OiB0cnVlLCBzdGFydHNFeHByOiB0cnVlfSlcbiAgfTtcblxuXG4gIHZhciBsaW5lQnJlYWsgPSAvXFxyXFxuP3xcXG58XFx1MjAyOHxcXHUyMDI5LztcbiAgdmFyIGxpbmVCcmVha0cgPSBuZXcgUmVnRXhwKGxpbmVCcmVhay5zb3VyY2UsIFwiZ1wiKTtcblxuICBmdW5jdGlvbiBpc05ld0xpbmUoY29kZSwgZWNtYTIwMTlTdHJpbmcpIHtcbiAgICByZXR1cm4gY29kZSA9PT0gMTAgfHwgY29kZSA9PT0gMTMgfHwgKCFlY21hMjAxOVN0cmluZyAmJiAoY29kZSA9PT0gMHgyMDI4IHx8IGNvZGUgPT09IDB4MjAyOSkpXG4gIH1cblxuICB2YXIgbm9uQVNDSUl3aGl0ZXNwYWNlID0gL1tcXHUxNjgwXFx1MjAwMC1cXHUyMDBhXFx1MjAyZlxcdTIwNWZcXHUzMDAwXFx1ZmVmZl0vO1xuXG4gIHZhciBza2lwV2hpdGVTcGFjZSA9IC8oPzpcXHN8XFwvXFwvLip8XFwvXFwqW15dKj9cXCpcXC8pKi9nO1xuXG4gIHZhciByZWYgPSBPYmplY3QucHJvdG90eXBlO1xuICB2YXIgaGFzT3duUHJvcGVydHkgPSByZWYuaGFzT3duUHJvcGVydHk7XG4gIHZhciB0b1N0cmluZyA9IHJlZi50b1N0cmluZztcblxuXG4gIGZ1bmN0aW9uIGhhcyhvYmosIHByb3BOYW1lKSB7XG4gICAgcmV0dXJuIGhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wTmFtZSlcbiAgfVxuXG4gIHZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheSB8fCAoZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gKFxuICAgIHRvU3RyaW5nLmNhbGwob2JqKSA9PT0gXCJbb2JqZWN0IEFycmF5XVwiXG4gICk7IH0pO1xuXG4gIGZ1bmN0aW9uIHdvcmRzUmVnZXhwKHdvcmRzKSB7XG4gICAgcmV0dXJuIG5ldyBSZWdFeHAoXCJeKD86XCIgKyB3b3Jkcy5yZXBsYWNlKC8gL2csIFwifFwiKSArIFwiKSRcIilcbiAgfVxuXG5cbiAgdmFyIFBvc2l0aW9uID0gZnVuY3Rpb24gUG9zaXRpb24obGluZSwgY29sKSB7XG4gICAgdGhpcy5saW5lID0gbGluZTtcbiAgICB0aGlzLmNvbHVtbiA9IGNvbDtcbiAgfTtcblxuICBQb3NpdGlvbi5wcm90b3R5cGUub2Zmc2V0ID0gZnVuY3Rpb24gb2Zmc2V0IChuKSB7XG4gICAgcmV0dXJuIG5ldyBQb3NpdGlvbih0aGlzLmxpbmUsIHRoaXMuY29sdW1uICsgbilcbiAgfTtcblxuICB2YXIgU291cmNlTG9jYXRpb24gPSBmdW5jdGlvbiBTb3VyY2VMb2NhdGlvbihwLCBzdGFydCwgZW5kKSB7XG4gICAgdGhpcy5zdGFydCA9IHN0YXJ0O1xuICAgIHRoaXMuZW5kID0gZW5kO1xuICAgIGlmIChwLnNvdXJjZUZpbGUgIT09IG51bGwpIHsgdGhpcy5zb3VyY2UgPSBwLnNvdXJjZUZpbGU7IH1cbiAgfTtcblxuXG4gIGZ1bmN0aW9uIGdldExpbmVJbmZvKGlucHV0LCBvZmZzZXQpIHtcbiAgICBmb3IgKHZhciBsaW5lID0gMSwgY3VyID0gMDs7KSB7XG4gICAgICBsaW5lQnJlYWtHLmxhc3RJbmRleCA9IGN1cjtcbiAgICAgIHZhciBtYXRjaCA9IGxpbmVCcmVha0cuZXhlYyhpbnB1dCk7XG4gICAgICBpZiAobWF0Y2ggJiYgbWF0Y2guaW5kZXggPCBvZmZzZXQpIHtcbiAgICAgICAgKytsaW5lO1xuICAgICAgICBjdXIgPSBtYXRjaC5pbmRleCArIG1hdGNoWzBdLmxlbmd0aDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBuZXcgUG9zaXRpb24obGluZSwgb2Zmc2V0IC0gY3VyKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG5cbiAgdmFyIGRlZmF1bHRPcHRpb25zID0ge1xuICAgIGVjbWFWZXJzaW9uOiAxMCxcbiAgICBzb3VyY2VUeXBlOiBcInNjcmlwdFwiLFxuICAgIG9uSW5zZXJ0ZWRTZW1pY29sb246IG51bGwsXG4gICAgb25UcmFpbGluZ0NvbW1hOiBudWxsLFxuICAgIGFsbG93UmVzZXJ2ZWQ6IG51bGwsXG4gICAgYWxsb3dSZXR1cm5PdXRzaWRlRnVuY3Rpb246IGZhbHNlLFxuICAgIGFsbG93SW1wb3J0RXhwb3J0RXZlcnl3aGVyZTogZmFsc2UsXG4gICAgYWxsb3dBd2FpdE91dHNpZGVGdW5jdGlvbjogZmFsc2UsXG4gICAgYWxsb3dIYXNoQmFuZzogZmFsc2UsXG4gICAgbG9jYXRpb25zOiBmYWxzZSxcbiAgICBvblRva2VuOiBudWxsLFxuICAgIG9uQ29tbWVudDogbnVsbCxcbiAgICByYW5nZXM6IGZhbHNlLFxuICAgIHByb2dyYW06IG51bGwsXG4gICAgc291cmNlRmlsZTogbnVsbCxcbiAgICBkaXJlY3RTb3VyY2VGaWxlOiBudWxsLFxuICAgIHByZXNlcnZlUGFyZW5zOiBmYWxzZVxuICB9O1xuXG5cbiAgZnVuY3Rpb24gZ2V0T3B0aW9ucyhvcHRzKSB7XG4gICAgdmFyIG9wdGlvbnMgPSB7fTtcblxuICAgIGZvciAodmFyIG9wdCBpbiBkZWZhdWx0T3B0aW9ucylcbiAgICAgIHsgb3B0aW9uc1tvcHRdID0gb3B0cyAmJiBoYXMob3B0cywgb3B0KSA/IG9wdHNbb3B0XSA6IGRlZmF1bHRPcHRpb25zW29wdF07IH1cblxuICAgIGlmIChvcHRpb25zLmVjbWFWZXJzaW9uID49IDIwMTUpXG4gICAgICB7IG9wdGlvbnMuZWNtYVZlcnNpb24gLT0gMjAwOTsgfVxuXG4gICAgaWYgKG9wdGlvbnMuYWxsb3dSZXNlcnZlZCA9PSBudWxsKVxuICAgICAgeyBvcHRpb25zLmFsbG93UmVzZXJ2ZWQgPSBvcHRpb25zLmVjbWFWZXJzaW9uIDwgNTsgfVxuXG4gICAgaWYgKGlzQXJyYXkob3B0aW9ucy5vblRva2VuKSkge1xuICAgICAgdmFyIHRva2VucyA9IG9wdGlvbnMub25Ub2tlbjtcbiAgICAgIG9wdGlvbnMub25Ub2tlbiA9IGZ1bmN0aW9uICh0b2tlbikgeyByZXR1cm4gdG9rZW5zLnB1c2godG9rZW4pOyB9O1xuICAgIH1cbiAgICBpZiAoaXNBcnJheShvcHRpb25zLm9uQ29tbWVudCkpXG4gICAgICB7IG9wdGlvbnMub25Db21tZW50ID0gcHVzaENvbW1lbnQob3B0aW9ucywgb3B0aW9ucy5vbkNvbW1lbnQpOyB9XG5cbiAgICByZXR1cm4gb3B0aW9uc1xuICB9XG5cbiAgZnVuY3Rpb24gcHVzaENvbW1lbnQob3B0aW9ucywgYXJyYXkpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oYmxvY2ssIHRleHQsIHN0YXJ0LCBlbmQsIHN0YXJ0TG9jLCBlbmRMb2MpIHtcbiAgICAgIHZhciBjb21tZW50ID0ge1xuICAgICAgICB0eXBlOiBibG9jayA/IFwiQmxvY2tcIiA6IFwiTGluZVwiLFxuICAgICAgICB2YWx1ZTogdGV4dCxcbiAgICAgICAgc3RhcnQ6IHN0YXJ0LFxuICAgICAgICBlbmQ6IGVuZFxuICAgICAgfTtcbiAgICAgIGlmIChvcHRpb25zLmxvY2F0aW9ucylcbiAgICAgICAgeyBjb21tZW50LmxvYyA9IG5ldyBTb3VyY2VMb2NhdGlvbih0aGlzLCBzdGFydExvYywgZW5kTG9jKTsgfVxuICAgICAgaWYgKG9wdGlvbnMucmFuZ2VzKVxuICAgICAgICB7IGNvbW1lbnQucmFuZ2UgPSBbc3RhcnQsIGVuZF07IH1cbiAgICAgIGFycmF5LnB1c2goY29tbWVudCk7XG4gICAgfVxuICB9XG5cbiAgdmFyXG4gICAgICBTQ09QRV9UT1AgPSAxLFxuICAgICAgU0NPUEVfRlVOQ1RJT04gPSAyLFxuICAgICAgU0NPUEVfVkFSID0gU0NPUEVfVE9QIHwgU0NPUEVfRlVOQ1RJT04sXG4gICAgICBTQ09QRV9BU1lOQyA9IDQsXG4gICAgICBTQ09QRV9HRU5FUkFUT1IgPSA4LFxuICAgICAgU0NPUEVfQVJST1cgPSAxNixcbiAgICAgIFNDT1BFX1NJTVBMRV9DQVRDSCA9IDMyLFxuICAgICAgU0NPUEVfU1VQRVIgPSA2NCxcbiAgICAgIFNDT1BFX0RJUkVDVF9TVVBFUiA9IDEyODtcblxuICBmdW5jdGlvbiBmdW5jdGlvbkZsYWdzKGFzeW5jLCBnZW5lcmF0b3IpIHtcbiAgICByZXR1cm4gU0NPUEVfRlVOQ1RJT04gfCAoYXN5bmMgPyBTQ09QRV9BU1lOQyA6IDApIHwgKGdlbmVyYXRvciA/IFNDT1BFX0dFTkVSQVRPUiA6IDApXG4gIH1cblxuICB2YXJcbiAgICAgIEJJTkRfTk9ORSA9IDAsIFxuICAgICAgQklORF9WQVIgPSAxLCBcbiAgICAgIEJJTkRfTEVYSUNBTCA9IDIsIFxuICAgICAgQklORF9GVU5DVElPTiA9IDMsIFxuICAgICAgQklORF9TSU1QTEVfQ0FUQ0ggPSA0LCBcbiAgICAgIEJJTkRfT1VUU0lERSA9IDU7IFxuXG4gIHZhciBQYXJzZXIgPSBmdW5jdGlvbiBQYXJzZXIob3B0aW9ucywgaW5wdXQsIHN0YXJ0UG9zKSB7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucyA9IGdldE9wdGlvbnMob3B0aW9ucyk7XG4gICAgdGhpcy5zb3VyY2VGaWxlID0gb3B0aW9ucy5zb3VyY2VGaWxlO1xuICAgIHRoaXMua2V5d29yZHMgPSB3b3Jkc1JlZ2V4cChrZXl3b3Jkc1tvcHRpb25zLmVjbWFWZXJzaW9uID49IDYgPyA2IDogb3B0aW9ucy5zb3VyY2VUeXBlID09PSBcIm1vZHVsZVwiID8gXCI1bW9kdWxlXCIgOiA1XSk7XG4gICAgdmFyIHJlc2VydmVkID0gXCJcIjtcbiAgICBpZiAob3B0aW9ucy5hbGxvd1Jlc2VydmVkICE9PSB0cnVlKSB7XG4gICAgICBmb3IgKHZhciB2ID0gb3B0aW9ucy5lY21hVmVyc2lvbjs7IHYtLSlcbiAgICAgICAgeyBpZiAocmVzZXJ2ZWQgPSByZXNlcnZlZFdvcmRzW3ZdKSB7IGJyZWFrIH0gfVxuICAgICAgaWYgKG9wdGlvbnMuc291cmNlVHlwZSA9PT0gXCJtb2R1bGVcIikgeyByZXNlcnZlZCArPSBcIiBhd2FpdFwiOyB9XG4gICAgfVxuICAgIHRoaXMucmVzZXJ2ZWRXb3JkcyA9IHdvcmRzUmVnZXhwKHJlc2VydmVkKTtcbiAgICB2YXIgcmVzZXJ2ZWRTdHJpY3QgPSAocmVzZXJ2ZWQgPyByZXNlcnZlZCArIFwiIFwiIDogXCJcIikgKyByZXNlcnZlZFdvcmRzLnN0cmljdDtcbiAgICB0aGlzLnJlc2VydmVkV29yZHNTdHJpY3QgPSB3b3Jkc1JlZ2V4cChyZXNlcnZlZFN0cmljdCk7XG4gICAgdGhpcy5yZXNlcnZlZFdvcmRzU3RyaWN0QmluZCA9IHdvcmRzUmVnZXhwKHJlc2VydmVkU3RyaWN0ICsgXCIgXCIgKyByZXNlcnZlZFdvcmRzLnN0cmljdEJpbmQpO1xuICAgIHRoaXMuaW5wdXQgPSBTdHJpbmcoaW5wdXQpO1xuXG4gICAgdGhpcy5jb250YWluc0VzYyA9IGZhbHNlO1xuXG5cbiAgICBpZiAoc3RhcnRQb3MpIHtcbiAgICAgIHRoaXMucG9zID0gc3RhcnRQb3M7XG4gICAgICB0aGlzLmxpbmVTdGFydCA9IHRoaXMuaW5wdXQubGFzdEluZGV4T2YoXCJcXG5cIiwgc3RhcnRQb3MgLSAxKSArIDE7XG4gICAgICB0aGlzLmN1ckxpbmUgPSB0aGlzLmlucHV0LnNsaWNlKDAsIHRoaXMubGluZVN0YXJ0KS5zcGxpdChsaW5lQnJlYWspLmxlbmd0aDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5wb3MgPSB0aGlzLmxpbmVTdGFydCA9IDA7XG4gICAgICB0aGlzLmN1ckxpbmUgPSAxO1xuICAgIH1cblxuICAgIHRoaXMudHlwZSA9IHR5cGVzLmVvZjtcbiAgICB0aGlzLnZhbHVlID0gbnVsbDtcbiAgICB0aGlzLnN0YXJ0ID0gdGhpcy5lbmQgPSB0aGlzLnBvcztcbiAgICB0aGlzLnN0YXJ0TG9jID0gdGhpcy5lbmRMb2MgPSB0aGlzLmN1clBvc2l0aW9uKCk7XG5cbiAgICB0aGlzLmxhc3RUb2tFbmRMb2MgPSB0aGlzLmxhc3RUb2tTdGFydExvYyA9IG51bGw7XG4gICAgdGhpcy5sYXN0VG9rU3RhcnQgPSB0aGlzLmxhc3RUb2tFbmQgPSB0aGlzLnBvcztcblxuICAgIHRoaXMuY29udGV4dCA9IHRoaXMuaW5pdGlhbENvbnRleHQoKTtcbiAgICB0aGlzLmV4cHJBbGxvd2VkID0gdHJ1ZTtcblxuICAgIHRoaXMuaW5Nb2R1bGUgPSBvcHRpb25zLnNvdXJjZVR5cGUgPT09IFwibW9kdWxlXCI7XG4gICAgdGhpcy5zdHJpY3QgPSB0aGlzLmluTW9kdWxlIHx8IHRoaXMuc3RyaWN0RGlyZWN0aXZlKHRoaXMucG9zKTtcblxuICAgIHRoaXMucG90ZW50aWFsQXJyb3dBdCA9IC0xO1xuXG4gICAgdGhpcy55aWVsZFBvcyA9IHRoaXMuYXdhaXRQb3MgPSB0aGlzLmF3YWl0SWRlbnRQb3MgPSAwO1xuICAgIHRoaXMubGFiZWxzID0gW107XG4gICAgdGhpcy51bmRlZmluZWRFeHBvcnRzID0ge307XG5cbiAgICBpZiAodGhpcy5wb3MgPT09IDAgJiYgb3B0aW9ucy5hbGxvd0hhc2hCYW5nICYmIHRoaXMuaW5wdXQuc2xpY2UoMCwgMikgPT09IFwiIyFcIilcbiAgICAgIHsgdGhpcy5za2lwTGluZUNvbW1lbnQoMik7IH1cblxuICAgIHRoaXMuc2NvcGVTdGFjayA9IFtdO1xuICAgIHRoaXMuZW50ZXJTY29wZShTQ09QRV9UT1ApO1xuXG4gICAgdGhpcy5yZWdleHBTdGF0ZSA9IG51bGw7XG4gIH07XG5cbiAgdmFyIHByb3RvdHlwZUFjY2Vzc29ycyA9IHsgaW5GdW5jdGlvbjogeyBjb25maWd1cmFibGU6IHRydWUgfSxpbkdlbmVyYXRvcjogeyBjb25maWd1cmFibGU6IHRydWUgfSxpbkFzeW5jOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LGFsbG93U3VwZXI6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0sYWxsb3dEaXJlY3RTdXBlcjogeyBjb25maWd1cmFibGU6IHRydWUgfSx0cmVhdEZ1bmN0aW9uc0FzVmFyOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH07XG5cbiAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uIHBhcnNlICgpIHtcbiAgICB2YXIgbm9kZSA9IHRoaXMub3B0aW9ucy5wcm9ncmFtIHx8IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgdGhpcy5uZXh0VG9rZW4oKTtcbiAgICByZXR1cm4gdGhpcy5wYXJzZVRvcExldmVsKG5vZGUpXG4gIH07XG5cbiAgcHJvdG90eXBlQWNjZXNzb3JzLmluRnVuY3Rpb24uZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gKHRoaXMuY3VycmVudFZhclNjb3BlKCkuZmxhZ3MgJiBTQ09QRV9GVU5DVElPTikgPiAwIH07XG4gIHByb3RvdHlwZUFjY2Vzc29ycy5pbkdlbmVyYXRvci5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAodGhpcy5jdXJyZW50VmFyU2NvcGUoKS5mbGFncyAmIFNDT1BFX0dFTkVSQVRPUikgPiAwIH07XG4gIHByb3RvdHlwZUFjY2Vzc29ycy5pbkFzeW5jLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICh0aGlzLmN1cnJlbnRWYXJTY29wZSgpLmZsYWdzICYgU0NPUEVfQVNZTkMpID4gMCB9O1xuICBwcm90b3R5cGVBY2Nlc3NvcnMuYWxsb3dTdXBlci5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAodGhpcy5jdXJyZW50VGhpc1Njb3BlKCkuZmxhZ3MgJiBTQ09QRV9TVVBFUikgPiAwIH07XG4gIHByb3RvdHlwZUFjY2Vzc29ycy5hbGxvd0RpcmVjdFN1cGVyLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICh0aGlzLmN1cnJlbnRUaGlzU2NvcGUoKS5mbGFncyAmIFNDT1BFX0RJUkVDVF9TVVBFUikgPiAwIH07XG4gIHByb3RvdHlwZUFjY2Vzc29ycy50cmVhdEZ1bmN0aW9uc0FzVmFyLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMudHJlYXRGdW5jdGlvbnNBc1ZhckluU2NvcGUodGhpcy5jdXJyZW50U2NvcGUoKSkgfTtcblxuICBQYXJzZXIucHJvdG90eXBlLmluTm9uQXJyb3dGdW5jdGlvbiA9IGZ1bmN0aW9uIGluTm9uQXJyb3dGdW5jdGlvbiAoKSB7IHJldHVybiAodGhpcy5jdXJyZW50VGhpc1Njb3BlKCkuZmxhZ3MgJiBTQ09QRV9GVU5DVElPTikgPiAwIH07XG5cbiAgUGFyc2VyLmV4dGVuZCA9IGZ1bmN0aW9uIGV4dGVuZCAoKSB7XG4gICAgICB2YXIgcGx1Z2lucyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgd2hpbGUgKCBsZW4tLSApIHBsdWdpbnNbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gXTtcblxuICAgIHZhciBjbHMgPSB0aGlzO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGx1Z2lucy5sZW5ndGg7IGkrKykgeyBjbHMgPSBwbHVnaW5zW2ldKGNscyk7IH1cbiAgICByZXR1cm4gY2xzXG4gIH07XG5cbiAgUGFyc2VyLnBhcnNlID0gZnVuY3Rpb24gcGFyc2UgKGlucHV0LCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyB0aGlzKG9wdGlvbnMsIGlucHV0KS5wYXJzZSgpXG4gIH07XG5cbiAgUGFyc2VyLnBhcnNlRXhwcmVzc2lvbkF0ID0gZnVuY3Rpb24gcGFyc2VFeHByZXNzaW9uQXQgKGlucHV0LCBwb3MsIG9wdGlvbnMpIHtcbiAgICB2YXIgcGFyc2VyID0gbmV3IHRoaXMob3B0aW9ucywgaW5wdXQsIHBvcyk7XG4gICAgcGFyc2VyLm5leHRUb2tlbigpO1xuICAgIHJldHVybiBwYXJzZXIucGFyc2VFeHByZXNzaW9uKClcbiAgfTtcblxuICBQYXJzZXIudG9rZW5pemVyID0gZnVuY3Rpb24gdG9rZW5pemVyIChpbnB1dCwgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgdGhpcyhvcHRpb25zLCBpbnB1dClcbiAgfTtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyggUGFyc2VyLnByb3RvdHlwZSwgcHJvdG90eXBlQWNjZXNzb3JzICk7XG5cbiAgdmFyIHBwID0gUGFyc2VyLnByb3RvdHlwZTtcblxuXG4gIHZhciBsaXRlcmFsID0gL14oPzonKCg/OlxcXFwufFteJ10pKj8pJ3xcIigoPzpcXFxcLnxbXlwiXSkqPylcIikvO1xuICBwcC5zdHJpY3REaXJlY3RpdmUgPSBmdW5jdGlvbihzdGFydCkge1xuICAgIGZvciAoOzspIHtcbiAgICAgIHNraXBXaGl0ZVNwYWNlLmxhc3RJbmRleCA9IHN0YXJ0O1xuICAgICAgc3RhcnQgKz0gc2tpcFdoaXRlU3BhY2UuZXhlYyh0aGlzLmlucHV0KVswXS5sZW5ndGg7XG4gICAgICB2YXIgbWF0Y2ggPSBsaXRlcmFsLmV4ZWModGhpcy5pbnB1dC5zbGljZShzdGFydCkpO1xuICAgICAgaWYgKCFtYXRjaCkgeyByZXR1cm4gZmFsc2UgfVxuICAgICAgaWYgKChtYXRjaFsxXSB8fCBtYXRjaFsyXSkgPT09IFwidXNlIHN0cmljdFwiKSB7IHJldHVybiB0cnVlIH1cbiAgICAgIHN0YXJ0ICs9IG1hdGNoWzBdLmxlbmd0aDtcblxuICAgICAgc2tpcFdoaXRlU3BhY2UubGFzdEluZGV4ID0gc3RhcnQ7XG4gICAgICBzdGFydCArPSBza2lwV2hpdGVTcGFjZS5leGVjKHRoaXMuaW5wdXQpWzBdLmxlbmd0aDtcbiAgICAgIGlmICh0aGlzLmlucHV0W3N0YXJ0XSA9PT0gXCI7XCIpXG4gICAgICAgIHsgc3RhcnQrKzsgfVxuICAgIH1cbiAgfTtcblxuXG4gIHBwLmVhdCA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgICBpZiAodGhpcy50eXBlID09PSB0eXBlKSB7XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgfTtcblxuXG4gIHBwLmlzQ29udGV4dHVhbCA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICByZXR1cm4gdGhpcy50eXBlID09PSB0eXBlcy5uYW1lICYmIHRoaXMudmFsdWUgPT09IG5hbWUgJiYgIXRoaXMuY29udGFpbnNFc2NcbiAgfTtcblxuXG4gIHBwLmVhdENvbnRleHR1YWwgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgaWYgKCF0aGlzLmlzQ29udGV4dHVhbChuYW1lKSkgeyByZXR1cm4gZmFsc2UgfVxuICAgIHRoaXMubmV4dCgpO1xuICAgIHJldHVybiB0cnVlXG4gIH07XG5cblxuICBwcC5leHBlY3RDb250ZXh0dWFsID0gZnVuY3Rpb24obmFtZSkge1xuICAgIGlmICghdGhpcy5lYXRDb250ZXh0dWFsKG5hbWUpKSB7IHRoaXMudW5leHBlY3RlZCgpOyB9XG4gIH07XG5cblxuICBwcC5jYW5JbnNlcnRTZW1pY29sb24gPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy50eXBlID09PSB0eXBlcy5lb2YgfHxcbiAgICAgIHRoaXMudHlwZSA9PT0gdHlwZXMuYnJhY2VSIHx8XG4gICAgICBsaW5lQnJlYWsudGVzdCh0aGlzLmlucHV0LnNsaWNlKHRoaXMubGFzdFRva0VuZCwgdGhpcy5zdGFydCkpXG4gIH07XG5cbiAgcHAuaW5zZXJ0U2VtaWNvbG9uID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuY2FuSW5zZXJ0U2VtaWNvbG9uKCkpIHtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMub25JbnNlcnRlZFNlbWljb2xvbilcbiAgICAgICAgeyB0aGlzLm9wdGlvbnMub25JbnNlcnRlZFNlbWljb2xvbih0aGlzLmxhc3RUb2tFbmQsIHRoaXMubGFzdFRva0VuZExvYyk7IH1cbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICB9O1xuXG5cbiAgcHAuc2VtaWNvbG9uID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKCF0aGlzLmVhdCh0eXBlcy5zZW1pKSAmJiAhdGhpcy5pbnNlcnRTZW1pY29sb24oKSkgeyB0aGlzLnVuZXhwZWN0ZWQoKTsgfVxuICB9O1xuXG4gIHBwLmFmdGVyVHJhaWxpbmdDb21tYSA9IGZ1bmN0aW9uKHRva1R5cGUsIG5vdE5leHQpIHtcbiAgICBpZiAodGhpcy50eXBlID09PSB0b2tUeXBlKSB7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLm9uVHJhaWxpbmdDb21tYSlcbiAgICAgICAgeyB0aGlzLm9wdGlvbnMub25UcmFpbGluZ0NvbW1hKHRoaXMubGFzdFRva1N0YXJ0LCB0aGlzLmxhc3RUb2tTdGFydExvYyk7IH1cbiAgICAgIGlmICghbm90TmV4dClcbiAgICAgICAgeyB0aGlzLm5leHQoKTsgfVxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gIH07XG5cblxuICBwcC5leHBlY3QgPSBmdW5jdGlvbih0eXBlKSB7XG4gICAgdGhpcy5lYXQodHlwZSkgfHwgdGhpcy51bmV4cGVjdGVkKCk7XG4gIH07XG5cblxuICBwcC51bmV4cGVjdGVkID0gZnVuY3Rpb24ocG9zKSB7XG4gICAgdGhpcy5yYWlzZShwb3MgIT0gbnVsbCA/IHBvcyA6IHRoaXMuc3RhcnQsIFwiVW5leHBlY3RlZCB0b2tlblwiKTtcbiAgfTtcblxuICBmdW5jdGlvbiBEZXN0cnVjdHVyaW5nRXJyb3JzKCkge1xuICAgIHRoaXMuc2hvcnRoYW5kQXNzaWduID1cbiAgICB0aGlzLnRyYWlsaW5nQ29tbWEgPVxuICAgIHRoaXMucGFyZW50aGVzaXplZEFzc2lnbiA9XG4gICAgdGhpcy5wYXJlbnRoZXNpemVkQmluZCA9XG4gICAgdGhpcy5kb3VibGVQcm90byA9XG4gICAgICAtMTtcbiAgfVxuXG4gIHBwLmNoZWNrUGF0dGVybkVycm9ycyA9IGZ1bmN0aW9uKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMsIGlzQXNzaWduKSB7XG4gICAgaWYgKCFyZWZEZXN0cnVjdHVyaW5nRXJyb3JzKSB7IHJldHVybiB9XG4gICAgaWYgKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMudHJhaWxpbmdDb21tYSA+IC0xKVxuICAgICAgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy50cmFpbGluZ0NvbW1hLCBcIkNvbW1hIGlzIG5vdCBwZXJtaXR0ZWQgYWZ0ZXIgdGhlIHJlc3QgZWxlbWVudFwiKTsgfVxuICAgIHZhciBwYXJlbnMgPSBpc0Fzc2lnbiA/IHJlZkRlc3RydWN0dXJpbmdFcnJvcnMucGFyZW50aGVzaXplZEFzc2lnbiA6IHJlZkRlc3RydWN0dXJpbmdFcnJvcnMucGFyZW50aGVzaXplZEJpbmQ7XG4gICAgaWYgKHBhcmVucyA+IC0xKSB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZShwYXJlbnMsIFwiUGFyZW50aGVzaXplZCBwYXR0ZXJuXCIpOyB9XG4gIH07XG5cbiAgcHAuY2hlY2tFeHByZXNzaW9uRXJyb3JzID0gZnVuY3Rpb24ocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycywgYW5kVGhyb3cpIHtcbiAgICBpZiAoIXJlZkRlc3RydWN0dXJpbmdFcnJvcnMpIHsgcmV0dXJuIGZhbHNlIH1cbiAgICB2YXIgc2hvcnRoYW5kQXNzaWduID0gcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy5zaG9ydGhhbmRBc3NpZ247XG4gICAgdmFyIGRvdWJsZVByb3RvID0gcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy5kb3VibGVQcm90bztcbiAgICBpZiAoIWFuZFRocm93KSB7IHJldHVybiBzaG9ydGhhbmRBc3NpZ24gPj0gMCB8fCBkb3VibGVQcm90byA+PSAwIH1cbiAgICBpZiAoc2hvcnRoYW5kQXNzaWduID49IDApXG4gICAgICB7IHRoaXMucmFpc2Uoc2hvcnRoYW5kQXNzaWduLCBcIlNob3J0aGFuZCBwcm9wZXJ0eSBhc3NpZ25tZW50cyBhcmUgdmFsaWQgb25seSBpbiBkZXN0cnVjdHVyaW5nIHBhdHRlcm5zXCIpOyB9XG4gICAgaWYgKGRvdWJsZVByb3RvID49IDApXG4gICAgICB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZShkb3VibGVQcm90bywgXCJSZWRlZmluaXRpb24gb2YgX19wcm90b19fIHByb3BlcnR5XCIpOyB9XG4gIH07XG5cbiAgcHAuY2hlY2tZaWVsZEF3YWl0SW5EZWZhdWx0UGFyYW1zID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMueWllbGRQb3MgJiYgKCF0aGlzLmF3YWl0UG9zIHx8IHRoaXMueWllbGRQb3MgPCB0aGlzLmF3YWl0UG9zKSlcbiAgICAgIHsgdGhpcy5yYWlzZSh0aGlzLnlpZWxkUG9zLCBcIllpZWxkIGV4cHJlc3Npb24gY2Fubm90IGJlIGEgZGVmYXVsdCB2YWx1ZVwiKTsgfVxuICAgIGlmICh0aGlzLmF3YWl0UG9zKVxuICAgICAgeyB0aGlzLnJhaXNlKHRoaXMuYXdhaXRQb3MsIFwiQXdhaXQgZXhwcmVzc2lvbiBjYW5ub3QgYmUgYSBkZWZhdWx0IHZhbHVlXCIpOyB9XG4gIH07XG5cbiAgcHAuaXNTaW1wbGVBc3NpZ25UYXJnZXQgPSBmdW5jdGlvbihleHByKSB7XG4gICAgaWYgKGV4cHIudHlwZSA9PT0gXCJQYXJlbnRoZXNpemVkRXhwcmVzc2lvblwiKVxuICAgICAgeyByZXR1cm4gdGhpcy5pc1NpbXBsZUFzc2lnblRhcmdldChleHByLmV4cHJlc3Npb24pIH1cbiAgICByZXR1cm4gZXhwci50eXBlID09PSBcIklkZW50aWZpZXJcIiB8fCBleHByLnR5cGUgPT09IFwiTWVtYmVyRXhwcmVzc2lvblwiXG4gIH07XG5cbiAgdmFyIHBwJDEgPSBQYXJzZXIucHJvdG90eXBlO1xuXG5cblxuICBwcCQxLnBhcnNlVG9wTGV2ZWwgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgdmFyIGV4cG9ydHMgPSB7fTtcbiAgICBpZiAoIW5vZGUuYm9keSkgeyBub2RlLmJvZHkgPSBbXTsgfVxuICAgIHdoaWxlICh0aGlzLnR5cGUgIT09IHR5cGVzLmVvZikge1xuICAgICAgdmFyIHN0bXQgPSB0aGlzLnBhcnNlU3RhdGVtZW50KG51bGwsIHRydWUsIGV4cG9ydHMpO1xuICAgICAgbm9kZS5ib2R5LnB1c2goc3RtdCk7XG4gICAgfVxuICAgIGlmICh0aGlzLmluTW9kdWxlKVxuICAgICAgeyBmb3IgKHZhciBpID0gMCwgbGlzdCA9IE9iamVjdC5rZXlzKHRoaXMudW5kZWZpbmVkRXhwb3J0cyk7IGkgPCBsaXN0Lmxlbmd0aDsgaSArPSAxKVxuICAgICAgICB7XG4gICAgICAgICAgdmFyIG5hbWUgPSBsaXN0W2ldO1xuXG4gICAgICAgICAgdGhpcy5yYWlzZVJlY292ZXJhYmxlKHRoaXMudW5kZWZpbmVkRXhwb3J0c1tuYW1lXS5zdGFydCwgKFwiRXhwb3J0ICdcIiArIG5hbWUgKyBcIicgaXMgbm90IGRlZmluZWRcIikpO1xuICAgICAgICB9IH1cbiAgICB0aGlzLmFkYXB0RGlyZWN0aXZlUHJvbG9ndWUobm9kZS5ib2R5KTtcbiAgICB0aGlzLm5leHQoKTtcbiAgICBub2RlLnNvdXJjZVR5cGUgPSB0aGlzLm9wdGlvbnMuc291cmNlVHlwZTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiUHJvZ3JhbVwiKVxuICB9O1xuXG4gIHZhciBsb29wTGFiZWwgPSB7a2luZDogXCJsb29wXCJ9LCBzd2l0Y2hMYWJlbCA9IHtraW5kOiBcInN3aXRjaFwifTtcblxuICBwcCQxLmlzTGV0ID0gZnVuY3Rpb24oY29udGV4dCkge1xuICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPCA2IHx8ICF0aGlzLmlzQ29udGV4dHVhbChcImxldFwiKSkgeyByZXR1cm4gZmFsc2UgfVxuICAgIHNraXBXaGl0ZVNwYWNlLmxhc3RJbmRleCA9IHRoaXMucG9zO1xuICAgIHZhciBza2lwID0gc2tpcFdoaXRlU3BhY2UuZXhlYyh0aGlzLmlucHV0KTtcbiAgICB2YXIgbmV4dCA9IHRoaXMucG9zICsgc2tpcFswXS5sZW5ndGgsIG5leHRDaCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdChuZXh0KTtcbiAgICBpZiAobmV4dENoID09PSA5MSkgeyByZXR1cm4gdHJ1ZSB9IFxuICAgIGlmIChjb250ZXh0KSB7IHJldHVybiBmYWxzZSB9XG5cbiAgICBpZiAobmV4dENoID09PSAxMjMpIHsgcmV0dXJuIHRydWUgfSBcbiAgICBpZiAoaXNJZGVudGlmaWVyU3RhcnQobmV4dENoLCB0cnVlKSkge1xuICAgICAgdmFyIHBvcyA9IG5leHQgKyAxO1xuICAgICAgd2hpbGUgKGlzSWRlbnRpZmllckNoYXIodGhpcy5pbnB1dC5jaGFyQ29kZUF0KHBvcyksIHRydWUpKSB7ICsrcG9zOyB9XG4gICAgICB2YXIgaWRlbnQgPSB0aGlzLmlucHV0LnNsaWNlKG5leHQsIHBvcyk7XG4gICAgICBpZiAoIWtleXdvcmRSZWxhdGlvbmFsT3BlcmF0b3IudGVzdChpZGVudCkpIHsgcmV0dXJuIHRydWUgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2VcbiAgfTtcblxuICBwcCQxLmlzQXN5bmNGdW5jdGlvbiA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPCA4IHx8ICF0aGlzLmlzQ29udGV4dHVhbChcImFzeW5jXCIpKVxuICAgICAgeyByZXR1cm4gZmFsc2UgfVxuXG4gICAgc2tpcFdoaXRlU3BhY2UubGFzdEluZGV4ID0gdGhpcy5wb3M7XG4gICAgdmFyIHNraXAgPSBza2lwV2hpdGVTcGFjZS5leGVjKHRoaXMuaW5wdXQpO1xuICAgIHZhciBuZXh0ID0gdGhpcy5wb3MgKyBza2lwWzBdLmxlbmd0aDtcbiAgICByZXR1cm4gIWxpbmVCcmVhay50ZXN0KHRoaXMuaW5wdXQuc2xpY2UodGhpcy5wb3MsIG5leHQpKSAmJlxuICAgICAgdGhpcy5pbnB1dC5zbGljZShuZXh0LCBuZXh0ICsgOCkgPT09IFwiZnVuY3Rpb25cIiAmJlxuICAgICAgKG5leHQgKyA4ID09PSB0aGlzLmlucHV0Lmxlbmd0aCB8fCAhaXNJZGVudGlmaWVyQ2hhcih0aGlzLmlucHV0LmNoYXJBdChuZXh0ICsgOCkpKVxuICB9O1xuXG5cbiAgcHAkMS5wYXJzZVN0YXRlbWVudCA9IGZ1bmN0aW9uKGNvbnRleHQsIHRvcExldmVsLCBleHBvcnRzKSB7XG4gICAgdmFyIHN0YXJ0dHlwZSA9IHRoaXMudHlwZSwgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCksIGtpbmQ7XG5cbiAgICBpZiAodGhpcy5pc0xldChjb250ZXh0KSkge1xuICAgICAgc3RhcnR0eXBlID0gdHlwZXMuX3ZhcjtcbiAgICAgIGtpbmQgPSBcImxldFwiO1xuICAgIH1cblxuXG4gICAgc3dpdGNoIChzdGFydHR5cGUpIHtcbiAgICBjYXNlIHR5cGVzLl9icmVhazogY2FzZSB0eXBlcy5fY29udGludWU6IHJldHVybiB0aGlzLnBhcnNlQnJlYWtDb250aW51ZVN0YXRlbWVudChub2RlLCBzdGFydHR5cGUua2V5d29yZClcbiAgICBjYXNlIHR5cGVzLl9kZWJ1Z2dlcjogcmV0dXJuIHRoaXMucGFyc2VEZWJ1Z2dlclN0YXRlbWVudChub2RlKVxuICAgIGNhc2UgdHlwZXMuX2RvOiByZXR1cm4gdGhpcy5wYXJzZURvU3RhdGVtZW50KG5vZGUpXG4gICAgY2FzZSB0eXBlcy5fZm9yOiByZXR1cm4gdGhpcy5wYXJzZUZvclN0YXRlbWVudChub2RlKVxuICAgIGNhc2UgdHlwZXMuX2Z1bmN0aW9uOlxuICAgICAgaWYgKChjb250ZXh0ICYmICh0aGlzLnN0cmljdCB8fCBjb250ZXh0ICE9PSBcImlmXCIgJiYgY29udGV4dCAhPT0gXCJsYWJlbFwiKSkgJiYgdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDYpIHsgdGhpcy51bmV4cGVjdGVkKCk7IH1cbiAgICAgIHJldHVybiB0aGlzLnBhcnNlRnVuY3Rpb25TdGF0ZW1lbnQobm9kZSwgZmFsc2UsICFjb250ZXh0KVxuICAgIGNhc2UgdHlwZXMuX2NsYXNzOlxuICAgICAgaWYgKGNvbnRleHQpIHsgdGhpcy51bmV4cGVjdGVkKCk7IH1cbiAgICAgIHJldHVybiB0aGlzLnBhcnNlQ2xhc3Mobm9kZSwgdHJ1ZSlcbiAgICBjYXNlIHR5cGVzLl9pZjogcmV0dXJuIHRoaXMucGFyc2VJZlN0YXRlbWVudChub2RlKVxuICAgIGNhc2UgdHlwZXMuX3JldHVybjogcmV0dXJuIHRoaXMucGFyc2VSZXR1cm5TdGF0ZW1lbnQobm9kZSlcbiAgICBjYXNlIHR5cGVzLl9zd2l0Y2g6IHJldHVybiB0aGlzLnBhcnNlU3dpdGNoU3RhdGVtZW50KG5vZGUpXG4gICAgY2FzZSB0eXBlcy5fdGhyb3c6IHJldHVybiB0aGlzLnBhcnNlVGhyb3dTdGF0ZW1lbnQobm9kZSlcbiAgICBjYXNlIHR5cGVzLl90cnk6IHJldHVybiB0aGlzLnBhcnNlVHJ5U3RhdGVtZW50KG5vZGUpXG4gICAgY2FzZSB0eXBlcy5fY29uc3Q6IGNhc2UgdHlwZXMuX3ZhcjpcbiAgICAgIGtpbmQgPSBraW5kIHx8IHRoaXMudmFsdWU7XG4gICAgICBpZiAoY29udGV4dCAmJiBraW5kICE9PSBcInZhclwiKSB7IHRoaXMudW5leHBlY3RlZCgpOyB9XG4gICAgICByZXR1cm4gdGhpcy5wYXJzZVZhclN0YXRlbWVudChub2RlLCBraW5kKVxuICAgIGNhc2UgdHlwZXMuX3doaWxlOiByZXR1cm4gdGhpcy5wYXJzZVdoaWxlU3RhdGVtZW50KG5vZGUpXG4gICAgY2FzZSB0eXBlcy5fd2l0aDogcmV0dXJuIHRoaXMucGFyc2VXaXRoU3RhdGVtZW50KG5vZGUpXG4gICAgY2FzZSB0eXBlcy5icmFjZUw6IHJldHVybiB0aGlzLnBhcnNlQmxvY2sodHJ1ZSwgbm9kZSlcbiAgICBjYXNlIHR5cGVzLnNlbWk6IHJldHVybiB0aGlzLnBhcnNlRW1wdHlTdGF0ZW1lbnQobm9kZSlcbiAgICBjYXNlIHR5cGVzLl9leHBvcnQ6XG4gICAgY2FzZSB0eXBlcy5faW1wb3J0OlxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+IDEwICYmIHN0YXJ0dHlwZSA9PT0gdHlwZXMuX2ltcG9ydCkge1xuICAgICAgICBza2lwV2hpdGVTcGFjZS5sYXN0SW5kZXggPSB0aGlzLnBvcztcbiAgICAgICAgdmFyIHNraXAgPSBza2lwV2hpdGVTcGFjZS5leGVjKHRoaXMuaW5wdXQpO1xuICAgICAgICB2YXIgbmV4dCA9IHRoaXMucG9zICsgc2tpcFswXS5sZW5ndGgsIG5leHRDaCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdChuZXh0KTtcbiAgICAgICAgaWYgKG5leHRDaCA9PT0gNDApIFxuICAgICAgICAgIHsgcmV0dXJuIHRoaXMucGFyc2VFeHByZXNzaW9uU3RhdGVtZW50KG5vZGUsIHRoaXMucGFyc2VFeHByZXNzaW9uKCkpIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCF0aGlzLm9wdGlvbnMuYWxsb3dJbXBvcnRFeHBvcnRFdmVyeXdoZXJlKSB7XG4gICAgICAgIGlmICghdG9wTGV2ZWwpXG4gICAgICAgICAgeyB0aGlzLnJhaXNlKHRoaXMuc3RhcnQsIFwiJ2ltcG9ydCcgYW5kICdleHBvcnQnIG1heSBvbmx5IGFwcGVhciBhdCB0aGUgdG9wIGxldmVsXCIpOyB9XG4gICAgICAgIGlmICghdGhpcy5pbk1vZHVsZSlcbiAgICAgICAgICB7IHRoaXMucmFpc2UodGhpcy5zdGFydCwgXCInaW1wb3J0JyBhbmQgJ2V4cG9ydCcgbWF5IGFwcGVhciBvbmx5IHdpdGggJ3NvdXJjZVR5cGU6IG1vZHVsZSdcIik7IH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBzdGFydHR5cGUgPT09IHR5cGVzLl9pbXBvcnQgPyB0aGlzLnBhcnNlSW1wb3J0KG5vZGUpIDogdGhpcy5wYXJzZUV4cG9ydChub2RlLCBleHBvcnRzKVxuXG4gICAgZGVmYXVsdDpcbiAgICAgIGlmICh0aGlzLmlzQXN5bmNGdW5jdGlvbigpKSB7XG4gICAgICAgIGlmIChjb250ZXh0KSB7IHRoaXMudW5leHBlY3RlZCgpOyB9XG4gICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUZ1bmN0aW9uU3RhdGVtZW50KG5vZGUsIHRydWUsICFjb250ZXh0KVxuICAgICAgfVxuXG4gICAgICB2YXIgbWF5YmVOYW1lID0gdGhpcy52YWx1ZSwgZXhwciA9IHRoaXMucGFyc2VFeHByZXNzaW9uKCk7XG4gICAgICBpZiAoc3RhcnR0eXBlID09PSB0eXBlcy5uYW1lICYmIGV4cHIudHlwZSA9PT0gXCJJZGVudGlmaWVyXCIgJiYgdGhpcy5lYXQodHlwZXMuY29sb24pKVxuICAgICAgICB7IHJldHVybiB0aGlzLnBhcnNlTGFiZWxlZFN0YXRlbWVudChub2RlLCBtYXliZU5hbWUsIGV4cHIsIGNvbnRleHQpIH1cbiAgICAgIGVsc2UgeyByZXR1cm4gdGhpcy5wYXJzZUV4cHJlc3Npb25TdGF0ZW1lbnQobm9kZSwgZXhwcikgfVxuICAgIH1cbiAgfTtcblxuICBwcCQxLnBhcnNlQnJlYWtDb250aW51ZVN0YXRlbWVudCA9IGZ1bmN0aW9uKG5vZGUsIGtleXdvcmQpIHtcbiAgICB2YXIgaXNCcmVhayA9IGtleXdvcmQgPT09IFwiYnJlYWtcIjtcbiAgICB0aGlzLm5leHQoKTtcbiAgICBpZiAodGhpcy5lYXQodHlwZXMuc2VtaSkgfHwgdGhpcy5pbnNlcnRTZW1pY29sb24oKSkgeyBub2RlLmxhYmVsID0gbnVsbDsgfVxuICAgIGVsc2UgaWYgKHRoaXMudHlwZSAhPT0gdHlwZXMubmFtZSkgeyB0aGlzLnVuZXhwZWN0ZWQoKTsgfVxuICAgIGVsc2Uge1xuICAgICAgbm9kZS5sYWJlbCA9IHRoaXMucGFyc2VJZGVudCgpO1xuICAgICAgdGhpcy5zZW1pY29sb24oKTtcbiAgICB9XG5cbiAgICB2YXIgaSA9IDA7XG4gICAgZm9yICg7IGkgPCB0aGlzLmxhYmVscy5sZW5ndGg7ICsraSkge1xuICAgICAgdmFyIGxhYiA9IHRoaXMubGFiZWxzW2ldO1xuICAgICAgaWYgKG5vZGUubGFiZWwgPT0gbnVsbCB8fCBsYWIubmFtZSA9PT0gbm9kZS5sYWJlbC5uYW1lKSB7XG4gICAgICAgIGlmIChsYWIua2luZCAhPSBudWxsICYmIChpc0JyZWFrIHx8IGxhYi5raW5kID09PSBcImxvb3BcIikpIHsgYnJlYWsgfVxuICAgICAgICBpZiAobm9kZS5sYWJlbCAmJiBpc0JyZWFrKSB7IGJyZWFrIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGkgPT09IHRoaXMubGFiZWxzLmxlbmd0aCkgeyB0aGlzLnJhaXNlKG5vZGUuc3RhcnQsIFwiVW5zeW50YWN0aWMgXCIgKyBrZXl3b3JkKTsgfVxuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgaXNCcmVhayA/IFwiQnJlYWtTdGF0ZW1lbnRcIiA6IFwiQ29udGludWVTdGF0ZW1lbnRcIilcbiAgfTtcblxuICBwcCQxLnBhcnNlRGVidWdnZXJTdGF0ZW1lbnQgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgdGhpcy5zZW1pY29sb24oKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiRGVidWdnZXJTdGF0ZW1lbnRcIilcbiAgfTtcblxuICBwcCQxLnBhcnNlRG9TdGF0ZW1lbnQgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgdGhpcy5sYWJlbHMucHVzaChsb29wTGFiZWwpO1xuICAgIG5vZGUuYm9keSA9IHRoaXMucGFyc2VTdGF0ZW1lbnQoXCJkb1wiKTtcbiAgICB0aGlzLmxhYmVscy5wb3AoKTtcbiAgICB0aGlzLmV4cGVjdCh0eXBlcy5fd2hpbGUpO1xuICAgIG5vZGUudGVzdCA9IHRoaXMucGFyc2VQYXJlbkV4cHJlc3Npb24oKTtcbiAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDYpXG4gICAgICB7IHRoaXMuZWF0KHR5cGVzLnNlbWkpOyB9XG4gICAgZWxzZVxuICAgICAgeyB0aGlzLnNlbWljb2xvbigpOyB9XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkRvV2hpbGVTdGF0ZW1lbnRcIilcbiAgfTtcblxuXG4gIHBwJDEucGFyc2VGb3JTdGF0ZW1lbnQgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgdmFyIGF3YWl0QXQgPSAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDkgJiYgKHRoaXMuaW5Bc3luYyB8fCAoIXRoaXMuaW5GdW5jdGlvbiAmJiB0aGlzLm9wdGlvbnMuYWxsb3dBd2FpdE91dHNpZGVGdW5jdGlvbikpICYmIHRoaXMuZWF0Q29udGV4dHVhbChcImF3YWl0XCIpKSA/IHRoaXMubGFzdFRva1N0YXJ0IDogLTE7XG4gICAgdGhpcy5sYWJlbHMucHVzaChsb29wTGFiZWwpO1xuICAgIHRoaXMuZW50ZXJTY29wZSgwKTtcbiAgICB0aGlzLmV4cGVjdCh0eXBlcy5wYXJlbkwpO1xuICAgIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzLnNlbWkpIHtcbiAgICAgIGlmIChhd2FpdEF0ID4gLTEpIHsgdGhpcy51bmV4cGVjdGVkKGF3YWl0QXQpOyB9XG4gICAgICByZXR1cm4gdGhpcy5wYXJzZUZvcihub2RlLCBudWxsKVxuICAgIH1cbiAgICB2YXIgaXNMZXQgPSB0aGlzLmlzTGV0KCk7XG4gICAgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMuX3ZhciB8fCB0aGlzLnR5cGUgPT09IHR5cGVzLl9jb25zdCB8fCBpc0xldCkge1xuICAgICAgdmFyIGluaXQkMSA9IHRoaXMuc3RhcnROb2RlKCksIGtpbmQgPSBpc0xldCA/IFwibGV0XCIgOiB0aGlzLnZhbHVlO1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICB0aGlzLnBhcnNlVmFyKGluaXQkMSwgdHJ1ZSwga2luZCk7XG4gICAgICB0aGlzLmZpbmlzaE5vZGUoaW5pdCQxLCBcIlZhcmlhYmxlRGVjbGFyYXRpb25cIik7XG4gICAgICBpZiAoKHRoaXMudHlwZSA9PT0gdHlwZXMuX2luIHx8ICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNiAmJiB0aGlzLmlzQ29udGV4dHVhbChcIm9mXCIpKSkgJiYgaW5pdCQxLmRlY2xhcmF0aW9ucy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA5KSB7XG4gICAgICAgICAgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMuX2luKSB7XG4gICAgICAgICAgICBpZiAoYXdhaXRBdCA+IC0xKSB7IHRoaXMudW5leHBlY3RlZChhd2FpdEF0KTsgfVxuICAgICAgICAgIH0gZWxzZSB7IG5vZGUuYXdhaXQgPSBhd2FpdEF0ID4gLTE7IH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUZvckluKG5vZGUsIGluaXQkMSlcbiAgICAgIH1cbiAgICAgIGlmIChhd2FpdEF0ID4gLTEpIHsgdGhpcy51bmV4cGVjdGVkKGF3YWl0QXQpOyB9XG4gICAgICByZXR1cm4gdGhpcy5wYXJzZUZvcihub2RlLCBpbml0JDEpXG4gICAgfVxuICAgIHZhciByZWZEZXN0cnVjdHVyaW5nRXJyb3JzID0gbmV3IERlc3RydWN0dXJpbmdFcnJvcnM7XG4gICAgdmFyIGluaXQgPSB0aGlzLnBhcnNlRXhwcmVzc2lvbih0cnVlLCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKTtcbiAgICBpZiAodGhpcy50eXBlID09PSB0eXBlcy5faW4gfHwgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2ICYmIHRoaXMuaXNDb250ZXh0dWFsKFwib2ZcIikpKSB7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDkpIHtcbiAgICAgICAgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMuX2luKSB7XG4gICAgICAgICAgaWYgKGF3YWl0QXQgPiAtMSkgeyB0aGlzLnVuZXhwZWN0ZWQoYXdhaXRBdCk7IH1cbiAgICAgICAgfSBlbHNlIHsgbm9kZS5hd2FpdCA9IGF3YWl0QXQgPiAtMTsgfVxuICAgICAgfVxuICAgICAgdGhpcy50b0Fzc2lnbmFibGUoaW5pdCwgZmFsc2UsIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpO1xuICAgICAgdGhpcy5jaGVja0xWYWwoaW5pdCk7XG4gICAgICByZXR1cm4gdGhpcy5wYXJzZUZvckluKG5vZGUsIGluaXQpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuY2hlY2tFeHByZXNzaW9uRXJyb3JzKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMsIHRydWUpO1xuICAgIH1cbiAgICBpZiAoYXdhaXRBdCA+IC0xKSB7IHRoaXMudW5leHBlY3RlZChhd2FpdEF0KTsgfVxuICAgIHJldHVybiB0aGlzLnBhcnNlRm9yKG5vZGUsIGluaXQpXG4gIH07XG5cbiAgcHAkMS5wYXJzZUZ1bmN0aW9uU3RhdGVtZW50ID0gZnVuY3Rpb24obm9kZSwgaXNBc3luYywgZGVjbGFyYXRpb25Qb3NpdGlvbikge1xuICAgIHRoaXMubmV4dCgpO1xuICAgIHJldHVybiB0aGlzLnBhcnNlRnVuY3Rpb24obm9kZSwgRlVOQ19TVEFURU1FTlQgfCAoZGVjbGFyYXRpb25Qb3NpdGlvbiA/IDAgOiBGVU5DX0hBTkdJTkdfU1RBVEVNRU5UKSwgZmFsc2UsIGlzQXN5bmMpXG4gIH07XG5cbiAgcHAkMS5wYXJzZUlmU3RhdGVtZW50ID0gZnVuY3Rpb24obm9kZSkge1xuICAgIHRoaXMubmV4dCgpO1xuICAgIG5vZGUudGVzdCA9IHRoaXMucGFyc2VQYXJlbkV4cHJlc3Npb24oKTtcbiAgICBub2RlLmNvbnNlcXVlbnQgPSB0aGlzLnBhcnNlU3RhdGVtZW50KFwiaWZcIik7XG4gICAgbm9kZS5hbHRlcm5hdGUgPSB0aGlzLmVhdCh0eXBlcy5fZWxzZSkgPyB0aGlzLnBhcnNlU3RhdGVtZW50KFwiaWZcIikgOiBudWxsO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJJZlN0YXRlbWVudFwiKVxuICB9O1xuXG4gIHBwJDEucGFyc2VSZXR1cm5TdGF0ZW1lbnQgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgaWYgKCF0aGlzLmluRnVuY3Rpb24gJiYgIXRoaXMub3B0aW9ucy5hbGxvd1JldHVybk91dHNpZGVGdW5jdGlvbilcbiAgICAgIHsgdGhpcy5yYWlzZSh0aGlzLnN0YXJ0LCBcIidyZXR1cm4nIG91dHNpZGUgb2YgZnVuY3Rpb25cIik7IH1cbiAgICB0aGlzLm5leHQoKTtcblxuXG4gICAgaWYgKHRoaXMuZWF0KHR5cGVzLnNlbWkpIHx8IHRoaXMuaW5zZXJ0U2VtaWNvbG9uKCkpIHsgbm9kZS5hcmd1bWVudCA9IG51bGw7IH1cbiAgICBlbHNlIHsgbm9kZS5hcmd1bWVudCA9IHRoaXMucGFyc2VFeHByZXNzaW9uKCk7IHRoaXMuc2VtaWNvbG9uKCk7IH1cbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiUmV0dXJuU3RhdGVtZW50XCIpXG4gIH07XG5cbiAgcHAkMS5wYXJzZVN3aXRjaFN0YXRlbWVudCA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICB0aGlzLm5leHQoKTtcbiAgICBub2RlLmRpc2NyaW1pbmFudCA9IHRoaXMucGFyc2VQYXJlbkV4cHJlc3Npb24oKTtcbiAgICBub2RlLmNhc2VzID0gW107XG4gICAgdGhpcy5leHBlY3QodHlwZXMuYnJhY2VMKTtcbiAgICB0aGlzLmxhYmVscy5wdXNoKHN3aXRjaExhYmVsKTtcbiAgICB0aGlzLmVudGVyU2NvcGUoMCk7XG5cblxuICAgIHZhciBjdXI7XG4gICAgZm9yICh2YXIgc2F3RGVmYXVsdCA9IGZhbHNlOyB0aGlzLnR5cGUgIT09IHR5cGVzLmJyYWNlUjspIHtcbiAgICAgIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzLl9jYXNlIHx8IHRoaXMudHlwZSA9PT0gdHlwZXMuX2RlZmF1bHQpIHtcbiAgICAgICAgdmFyIGlzQ2FzZSA9IHRoaXMudHlwZSA9PT0gdHlwZXMuX2Nhc2U7XG4gICAgICAgIGlmIChjdXIpIHsgdGhpcy5maW5pc2hOb2RlKGN1ciwgXCJTd2l0Y2hDYXNlXCIpOyB9XG4gICAgICAgIG5vZGUuY2FzZXMucHVzaChjdXIgPSB0aGlzLnN0YXJ0Tm9kZSgpKTtcbiAgICAgICAgY3VyLmNvbnNlcXVlbnQgPSBbXTtcbiAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgIGlmIChpc0Nhc2UpIHtcbiAgICAgICAgICBjdXIudGVzdCA9IHRoaXMucGFyc2VFeHByZXNzaW9uKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHNhd0RlZmF1bHQpIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKHRoaXMubGFzdFRva1N0YXJ0LCBcIk11bHRpcGxlIGRlZmF1bHQgY2xhdXNlc1wiKTsgfVxuICAgICAgICAgIHNhd0RlZmF1bHQgPSB0cnVlO1xuICAgICAgICAgIGN1ci50ZXN0ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmV4cGVjdCh0eXBlcy5jb2xvbik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoIWN1cikgeyB0aGlzLnVuZXhwZWN0ZWQoKTsgfVxuICAgICAgICBjdXIuY29uc2VxdWVudC5wdXNoKHRoaXMucGFyc2VTdGF0ZW1lbnQobnVsbCkpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmV4aXRTY29wZSgpO1xuICAgIGlmIChjdXIpIHsgdGhpcy5maW5pc2hOb2RlKGN1ciwgXCJTd2l0Y2hDYXNlXCIpOyB9XG4gICAgdGhpcy5uZXh0KCk7IFxuICAgIHRoaXMubGFiZWxzLnBvcCgpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJTd2l0Y2hTdGF0ZW1lbnRcIilcbiAgfTtcblxuICBwcCQxLnBhcnNlVGhyb3dTdGF0ZW1lbnQgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgaWYgKGxpbmVCcmVhay50ZXN0KHRoaXMuaW5wdXQuc2xpY2UodGhpcy5sYXN0VG9rRW5kLCB0aGlzLnN0YXJ0KSkpXG4gICAgICB7IHRoaXMucmFpc2UodGhpcy5sYXN0VG9rRW5kLCBcIklsbGVnYWwgbmV3bGluZSBhZnRlciB0aHJvd1wiKTsgfVxuICAgIG5vZGUuYXJndW1lbnQgPSB0aGlzLnBhcnNlRXhwcmVzc2lvbigpO1xuICAgIHRoaXMuc2VtaWNvbG9uKCk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlRocm93U3RhdGVtZW50XCIpXG4gIH07XG5cblxuICB2YXIgZW1wdHkgPSBbXTtcblxuICBwcCQxLnBhcnNlVHJ5U3RhdGVtZW50ID0gZnVuY3Rpb24obm9kZSkge1xuICAgIHRoaXMubmV4dCgpO1xuICAgIG5vZGUuYmxvY2sgPSB0aGlzLnBhcnNlQmxvY2soKTtcbiAgICBub2RlLmhhbmRsZXIgPSBudWxsO1xuICAgIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzLl9jYXRjaCkge1xuICAgICAgdmFyIGNsYXVzZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICAgIGlmICh0aGlzLmVhdCh0eXBlcy5wYXJlbkwpKSB7XG4gICAgICAgIGNsYXVzZS5wYXJhbSA9IHRoaXMucGFyc2VCaW5kaW5nQXRvbSgpO1xuICAgICAgICB2YXIgc2ltcGxlID0gY2xhdXNlLnBhcmFtLnR5cGUgPT09IFwiSWRlbnRpZmllclwiO1xuICAgICAgICB0aGlzLmVudGVyU2NvcGUoc2ltcGxlID8gU0NPUEVfU0lNUExFX0NBVENIIDogMCk7XG4gICAgICAgIHRoaXMuY2hlY2tMVmFsKGNsYXVzZS5wYXJhbSwgc2ltcGxlID8gQklORF9TSU1QTEVfQ0FUQ0ggOiBCSU5EX0xFWElDQUwpO1xuICAgICAgICB0aGlzLmV4cGVjdCh0eXBlcy5wYXJlblIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA8IDEwKSB7IHRoaXMudW5leHBlY3RlZCgpOyB9XG4gICAgICAgIGNsYXVzZS5wYXJhbSA9IG51bGw7XG4gICAgICAgIHRoaXMuZW50ZXJTY29wZSgwKTtcbiAgICAgIH1cbiAgICAgIGNsYXVzZS5ib2R5ID0gdGhpcy5wYXJzZUJsb2NrKGZhbHNlKTtcbiAgICAgIHRoaXMuZXhpdFNjb3BlKCk7XG4gICAgICBub2RlLmhhbmRsZXIgPSB0aGlzLmZpbmlzaE5vZGUoY2xhdXNlLCBcIkNhdGNoQ2xhdXNlXCIpO1xuICAgIH1cbiAgICBub2RlLmZpbmFsaXplciA9IHRoaXMuZWF0KHR5cGVzLl9maW5hbGx5KSA/IHRoaXMucGFyc2VCbG9jaygpIDogbnVsbDtcbiAgICBpZiAoIW5vZGUuaGFuZGxlciAmJiAhbm9kZS5maW5hbGl6ZXIpXG4gICAgICB7IHRoaXMucmFpc2Uobm9kZS5zdGFydCwgXCJNaXNzaW5nIGNhdGNoIG9yIGZpbmFsbHkgY2xhdXNlXCIpOyB9XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlRyeVN0YXRlbWVudFwiKVxuICB9O1xuXG4gIHBwJDEucGFyc2VWYXJTdGF0ZW1lbnQgPSBmdW5jdGlvbihub2RlLCBraW5kKSB7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgdGhpcy5wYXJzZVZhcihub2RlLCBmYWxzZSwga2luZCk7XG4gICAgdGhpcy5zZW1pY29sb24oKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiVmFyaWFibGVEZWNsYXJhdGlvblwiKVxuICB9O1xuXG4gIHBwJDEucGFyc2VXaGlsZVN0YXRlbWVudCA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICB0aGlzLm5leHQoKTtcbiAgICBub2RlLnRlc3QgPSB0aGlzLnBhcnNlUGFyZW5FeHByZXNzaW9uKCk7XG4gICAgdGhpcy5sYWJlbHMucHVzaChsb29wTGFiZWwpO1xuICAgIG5vZGUuYm9keSA9IHRoaXMucGFyc2VTdGF0ZW1lbnQoXCJ3aGlsZVwiKTtcbiAgICB0aGlzLmxhYmVscy5wb3AoKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiV2hpbGVTdGF0ZW1lbnRcIilcbiAgfTtcblxuICBwcCQxLnBhcnNlV2l0aFN0YXRlbWVudCA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICBpZiAodGhpcy5zdHJpY3QpIHsgdGhpcy5yYWlzZSh0aGlzLnN0YXJ0LCBcIid3aXRoJyBpbiBzdHJpY3QgbW9kZVwiKTsgfVxuICAgIHRoaXMubmV4dCgpO1xuICAgIG5vZGUub2JqZWN0ID0gdGhpcy5wYXJzZVBhcmVuRXhwcmVzc2lvbigpO1xuICAgIG5vZGUuYm9keSA9IHRoaXMucGFyc2VTdGF0ZW1lbnQoXCJ3aXRoXCIpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJXaXRoU3RhdGVtZW50XCIpXG4gIH07XG5cbiAgcHAkMS5wYXJzZUVtcHR5U3RhdGVtZW50ID0gZnVuY3Rpb24obm9kZSkge1xuICAgIHRoaXMubmV4dCgpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJFbXB0eVN0YXRlbWVudFwiKVxuICB9O1xuXG4gIHBwJDEucGFyc2VMYWJlbGVkU3RhdGVtZW50ID0gZnVuY3Rpb24obm9kZSwgbWF5YmVOYW1lLCBleHByLCBjb250ZXh0KSB7XG4gICAgZm9yICh2YXIgaSQxID0gMCwgbGlzdCA9IHRoaXMubGFiZWxzOyBpJDEgPCBsaXN0Lmxlbmd0aDsgaSQxICs9IDEpXG4gICAgICB7XG4gICAgICB2YXIgbGFiZWwgPSBsaXN0W2kkMV07XG5cbiAgICAgIGlmIChsYWJlbC5uYW1lID09PSBtYXliZU5hbWUpXG4gICAgICAgIHsgdGhpcy5yYWlzZShleHByLnN0YXJ0LCBcIkxhYmVsICdcIiArIG1heWJlTmFtZSArIFwiJyBpcyBhbHJlYWR5IGRlY2xhcmVkXCIpO1xuICAgIH0gfVxuICAgIHZhciBraW5kID0gdGhpcy50eXBlLmlzTG9vcCA/IFwibG9vcFwiIDogdGhpcy50eXBlID09PSB0eXBlcy5fc3dpdGNoID8gXCJzd2l0Y2hcIiA6IG51bGw7XG4gICAgZm9yICh2YXIgaSA9IHRoaXMubGFiZWxzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB2YXIgbGFiZWwkMSA9IHRoaXMubGFiZWxzW2ldO1xuICAgICAgaWYgKGxhYmVsJDEuc3RhdGVtZW50U3RhcnQgPT09IG5vZGUuc3RhcnQpIHtcbiAgICAgICAgbGFiZWwkMS5zdGF0ZW1lbnRTdGFydCA9IHRoaXMuc3RhcnQ7XG4gICAgICAgIGxhYmVsJDEua2luZCA9IGtpbmQ7XG4gICAgICB9IGVsc2UgeyBicmVhayB9XG4gICAgfVxuICAgIHRoaXMubGFiZWxzLnB1c2goe25hbWU6IG1heWJlTmFtZSwga2luZDoga2luZCwgc3RhdGVtZW50U3RhcnQ6IHRoaXMuc3RhcnR9KTtcbiAgICBub2RlLmJvZHkgPSB0aGlzLnBhcnNlU3RhdGVtZW50KGNvbnRleHQgPyBjb250ZXh0LmluZGV4T2YoXCJsYWJlbFwiKSA9PT0gLTEgPyBjb250ZXh0ICsgXCJsYWJlbFwiIDogY29udGV4dCA6IFwibGFiZWxcIik7XG4gICAgdGhpcy5sYWJlbHMucG9wKCk7XG4gICAgbm9kZS5sYWJlbCA9IGV4cHI7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkxhYmVsZWRTdGF0ZW1lbnRcIilcbiAgfTtcblxuICBwcCQxLnBhcnNlRXhwcmVzc2lvblN0YXRlbWVudCA9IGZ1bmN0aW9uKG5vZGUsIGV4cHIpIHtcbiAgICBub2RlLmV4cHJlc3Npb24gPSBleHByO1xuICAgIHRoaXMuc2VtaWNvbG9uKCk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkV4cHJlc3Npb25TdGF0ZW1lbnRcIilcbiAgfTtcblxuXG4gIHBwJDEucGFyc2VCbG9jayA9IGZ1bmN0aW9uKGNyZWF0ZU5ld0xleGljYWxTY29wZSwgbm9kZSkge1xuICAgIGlmICggY3JlYXRlTmV3TGV4aWNhbFNjb3BlID09PSB2b2lkIDAgKSBjcmVhdGVOZXdMZXhpY2FsU2NvcGUgPSB0cnVlO1xuICAgIGlmICggbm9kZSA9PT0gdm9pZCAwICkgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG5cbiAgICBub2RlLmJvZHkgPSBbXTtcbiAgICB0aGlzLmV4cGVjdCh0eXBlcy5icmFjZUwpO1xuICAgIGlmIChjcmVhdGVOZXdMZXhpY2FsU2NvcGUpIHsgdGhpcy5lbnRlclNjb3BlKDApOyB9XG4gICAgd2hpbGUgKCF0aGlzLmVhdCh0eXBlcy5icmFjZVIpKSB7XG4gICAgICB2YXIgc3RtdCA9IHRoaXMucGFyc2VTdGF0ZW1lbnQobnVsbCk7XG4gICAgICBub2RlLmJvZHkucHVzaChzdG10KTtcbiAgICB9XG4gICAgaWYgKGNyZWF0ZU5ld0xleGljYWxTY29wZSkgeyB0aGlzLmV4aXRTY29wZSgpOyB9XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkJsb2NrU3RhdGVtZW50XCIpXG4gIH07XG5cblxuICBwcCQxLnBhcnNlRm9yID0gZnVuY3Rpb24obm9kZSwgaW5pdCkge1xuICAgIG5vZGUuaW5pdCA9IGluaXQ7XG4gICAgdGhpcy5leHBlY3QodHlwZXMuc2VtaSk7XG4gICAgbm9kZS50ZXN0ID0gdGhpcy50eXBlID09PSB0eXBlcy5zZW1pID8gbnVsbCA6IHRoaXMucGFyc2VFeHByZXNzaW9uKCk7XG4gICAgdGhpcy5leHBlY3QodHlwZXMuc2VtaSk7XG4gICAgbm9kZS51cGRhdGUgPSB0aGlzLnR5cGUgPT09IHR5cGVzLnBhcmVuUiA/IG51bGwgOiB0aGlzLnBhcnNlRXhwcmVzc2lvbigpO1xuICAgIHRoaXMuZXhwZWN0KHR5cGVzLnBhcmVuUik7XG4gICAgbm9kZS5ib2R5ID0gdGhpcy5wYXJzZVN0YXRlbWVudChcImZvclwiKTtcbiAgICB0aGlzLmV4aXRTY29wZSgpO1xuICAgIHRoaXMubGFiZWxzLnBvcCgpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJGb3JTdGF0ZW1lbnRcIilcbiAgfTtcblxuXG4gIHBwJDEucGFyc2VGb3JJbiA9IGZ1bmN0aW9uKG5vZGUsIGluaXQpIHtcbiAgICB2YXIgaXNGb3JJbiA9IHRoaXMudHlwZSA9PT0gdHlwZXMuX2luO1xuICAgIHRoaXMubmV4dCgpO1xuXG4gICAgaWYgKFxuICAgICAgaW5pdC50eXBlID09PSBcIlZhcmlhYmxlRGVjbGFyYXRpb25cIiAmJlxuICAgICAgaW5pdC5kZWNsYXJhdGlvbnNbMF0uaW5pdCAhPSBudWxsICYmXG4gICAgICAoXG4gICAgICAgICFpc0ZvckluIHx8XG4gICAgICAgIHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA8IDggfHxcbiAgICAgICAgdGhpcy5zdHJpY3QgfHxcbiAgICAgICAgaW5pdC5raW5kICE9PSBcInZhclwiIHx8XG4gICAgICAgIGluaXQuZGVjbGFyYXRpb25zWzBdLmlkLnR5cGUgIT09IFwiSWRlbnRpZmllclwiXG4gICAgICApXG4gICAgKSB7XG4gICAgICB0aGlzLnJhaXNlKFxuICAgICAgICBpbml0LnN0YXJ0LFxuICAgICAgICAoKGlzRm9ySW4gPyBcImZvci1pblwiIDogXCJmb3Itb2ZcIikgKyBcIiBsb29wIHZhcmlhYmxlIGRlY2xhcmF0aW9uIG1heSBub3QgaGF2ZSBhbiBpbml0aWFsaXplclwiKVxuICAgICAgKTtcbiAgICB9IGVsc2UgaWYgKGluaXQudHlwZSA9PT0gXCJBc3NpZ25tZW50UGF0dGVyblwiKSB7XG4gICAgICB0aGlzLnJhaXNlKGluaXQuc3RhcnQsIFwiSW52YWxpZCBsZWZ0LWhhbmQgc2lkZSBpbiBmb3ItbG9vcFwiKTtcbiAgICB9XG4gICAgbm9kZS5sZWZ0ID0gaW5pdDtcbiAgICBub2RlLnJpZ2h0ID0gaXNGb3JJbiA/IHRoaXMucGFyc2VFeHByZXNzaW9uKCkgOiB0aGlzLnBhcnNlTWF5YmVBc3NpZ24oKTtcbiAgICB0aGlzLmV4cGVjdCh0eXBlcy5wYXJlblIpO1xuICAgIG5vZGUuYm9keSA9IHRoaXMucGFyc2VTdGF0ZW1lbnQoXCJmb3JcIik7XG4gICAgdGhpcy5leGl0U2NvcGUoKTtcbiAgICB0aGlzLmxhYmVscy5wb3AoKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIGlzRm9ySW4gPyBcIkZvckluU3RhdGVtZW50XCIgOiBcIkZvck9mU3RhdGVtZW50XCIpXG4gIH07XG5cblxuICBwcCQxLnBhcnNlVmFyID0gZnVuY3Rpb24obm9kZSwgaXNGb3IsIGtpbmQpIHtcbiAgICBub2RlLmRlY2xhcmF0aW9ucyA9IFtdO1xuICAgIG5vZGUua2luZCA9IGtpbmQ7XG4gICAgZm9yICg7Oykge1xuICAgICAgdmFyIGRlY2wgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgICAgdGhpcy5wYXJzZVZhcklkKGRlY2wsIGtpbmQpO1xuICAgICAgaWYgKHRoaXMuZWF0KHR5cGVzLmVxKSkge1xuICAgICAgICBkZWNsLmluaXQgPSB0aGlzLnBhcnNlTWF5YmVBc3NpZ24oaXNGb3IpO1xuICAgICAgfSBlbHNlIGlmIChraW5kID09PSBcImNvbnN0XCIgJiYgISh0aGlzLnR5cGUgPT09IHR5cGVzLl9pbiB8fCAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDYgJiYgdGhpcy5pc0NvbnRleHR1YWwoXCJvZlwiKSkpKSB7XG4gICAgICAgIHRoaXMudW5leHBlY3RlZCgpO1xuICAgICAgfSBlbHNlIGlmIChkZWNsLmlkLnR5cGUgIT09IFwiSWRlbnRpZmllclwiICYmICEoaXNGb3IgJiYgKHRoaXMudHlwZSA9PT0gdHlwZXMuX2luIHx8IHRoaXMuaXNDb250ZXh0dWFsKFwib2ZcIikpKSkge1xuICAgICAgICB0aGlzLnJhaXNlKHRoaXMubGFzdFRva0VuZCwgXCJDb21wbGV4IGJpbmRpbmcgcGF0dGVybnMgcmVxdWlyZSBhbiBpbml0aWFsaXphdGlvbiB2YWx1ZVwiKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlY2wuaW5pdCA9IG51bGw7XG4gICAgICB9XG4gICAgICBub2RlLmRlY2xhcmF0aW9ucy5wdXNoKHRoaXMuZmluaXNoTm9kZShkZWNsLCBcIlZhcmlhYmxlRGVjbGFyYXRvclwiKSk7XG4gICAgICBpZiAoIXRoaXMuZWF0KHR5cGVzLmNvbW1hKSkgeyBicmVhayB9XG4gICAgfVxuICAgIHJldHVybiBub2RlXG4gIH07XG5cbiAgcHAkMS5wYXJzZVZhcklkID0gZnVuY3Rpb24oZGVjbCwga2luZCkge1xuICAgIGRlY2wuaWQgPSB0aGlzLnBhcnNlQmluZGluZ0F0b20oKTtcbiAgICB0aGlzLmNoZWNrTFZhbChkZWNsLmlkLCBraW5kID09PSBcInZhclwiID8gQklORF9WQVIgOiBCSU5EX0xFWElDQUwsIGZhbHNlKTtcbiAgfTtcblxuICB2YXIgRlVOQ19TVEFURU1FTlQgPSAxLCBGVU5DX0hBTkdJTkdfU1RBVEVNRU5UID0gMiwgRlVOQ19OVUxMQUJMRV9JRCA9IDQ7XG5cblxuICBwcCQxLnBhcnNlRnVuY3Rpb24gPSBmdW5jdGlvbihub2RlLCBzdGF0ZW1lbnQsIGFsbG93RXhwcmVzc2lvbkJvZHksIGlzQXN5bmMpIHtcbiAgICB0aGlzLmluaXRGdW5jdGlvbihub2RlKTtcbiAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDkgfHwgdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDYgJiYgIWlzQXN5bmMpIHtcbiAgICAgIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzLnN0YXIgJiYgKHN0YXRlbWVudCAmIEZVTkNfSEFOR0lOR19TVEFURU1FTlQpKVxuICAgICAgICB7IHRoaXMudW5leHBlY3RlZCgpOyB9XG4gICAgICBub2RlLmdlbmVyYXRvciA9IHRoaXMuZWF0KHR5cGVzLnN0YXIpO1xuICAgIH1cbiAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDgpXG4gICAgICB7IG5vZGUuYXN5bmMgPSAhIWlzQXN5bmM7IH1cblxuICAgIGlmIChzdGF0ZW1lbnQgJiBGVU5DX1NUQVRFTUVOVCkge1xuICAgICAgbm9kZS5pZCA9IChzdGF0ZW1lbnQgJiBGVU5DX05VTExBQkxFX0lEKSAmJiB0aGlzLnR5cGUgIT09IHR5cGVzLm5hbWUgPyBudWxsIDogdGhpcy5wYXJzZUlkZW50KCk7XG4gICAgICBpZiAobm9kZS5pZCAmJiAhKHN0YXRlbWVudCAmIEZVTkNfSEFOR0lOR19TVEFURU1FTlQpKVxuICAgICAgICB7IHRoaXMuY2hlY2tMVmFsKG5vZGUuaWQsICh0aGlzLnN0cmljdCB8fCBub2RlLmdlbmVyYXRvciB8fCBub2RlLmFzeW5jKSA/IHRoaXMudHJlYXRGdW5jdGlvbnNBc1ZhciA/IEJJTkRfVkFSIDogQklORF9MRVhJQ0FMIDogQklORF9GVU5DVElPTik7IH1cbiAgICB9XG5cbiAgICB2YXIgb2xkWWllbGRQb3MgPSB0aGlzLnlpZWxkUG9zLCBvbGRBd2FpdFBvcyA9IHRoaXMuYXdhaXRQb3MsIG9sZEF3YWl0SWRlbnRQb3MgPSB0aGlzLmF3YWl0SWRlbnRQb3M7XG4gICAgdGhpcy55aWVsZFBvcyA9IDA7XG4gICAgdGhpcy5hd2FpdFBvcyA9IDA7XG4gICAgdGhpcy5hd2FpdElkZW50UG9zID0gMDtcbiAgICB0aGlzLmVudGVyU2NvcGUoZnVuY3Rpb25GbGFncyhub2RlLmFzeW5jLCBub2RlLmdlbmVyYXRvcikpO1xuXG4gICAgaWYgKCEoc3RhdGVtZW50ICYgRlVOQ19TVEFURU1FTlQpKVxuICAgICAgeyBub2RlLmlkID0gdGhpcy50eXBlID09PSB0eXBlcy5uYW1lID8gdGhpcy5wYXJzZUlkZW50KCkgOiBudWxsOyB9XG5cbiAgICB0aGlzLnBhcnNlRnVuY3Rpb25QYXJhbXMobm9kZSk7XG4gICAgdGhpcy5wYXJzZUZ1bmN0aW9uQm9keShub2RlLCBhbGxvd0V4cHJlc3Npb25Cb2R5LCBmYWxzZSk7XG5cbiAgICB0aGlzLnlpZWxkUG9zID0gb2xkWWllbGRQb3M7XG4gICAgdGhpcy5hd2FpdFBvcyA9IG9sZEF3YWl0UG9zO1xuICAgIHRoaXMuYXdhaXRJZGVudFBvcyA9IG9sZEF3YWl0SWRlbnRQb3M7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCAoc3RhdGVtZW50ICYgRlVOQ19TVEFURU1FTlQpID8gXCJGdW5jdGlvbkRlY2xhcmF0aW9uXCIgOiBcIkZ1bmN0aW9uRXhwcmVzc2lvblwiKVxuICB9O1xuXG4gIHBwJDEucGFyc2VGdW5jdGlvblBhcmFtcyA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICB0aGlzLmV4cGVjdCh0eXBlcy5wYXJlbkwpO1xuICAgIG5vZGUucGFyYW1zID0gdGhpcy5wYXJzZUJpbmRpbmdMaXN0KHR5cGVzLnBhcmVuUiwgZmFsc2UsIHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA4KTtcbiAgICB0aGlzLmNoZWNrWWllbGRBd2FpdEluRGVmYXVsdFBhcmFtcygpO1xuICB9O1xuXG5cbiAgcHAkMS5wYXJzZUNsYXNzID0gZnVuY3Rpb24obm9kZSwgaXNTdGF0ZW1lbnQpIHtcbiAgICB0aGlzLm5leHQoKTtcblxuICAgIHZhciBvbGRTdHJpY3QgPSB0aGlzLnN0cmljdDtcbiAgICB0aGlzLnN0cmljdCA9IHRydWU7XG5cbiAgICB0aGlzLnBhcnNlQ2xhc3NJZChub2RlLCBpc1N0YXRlbWVudCk7XG4gICAgdGhpcy5wYXJzZUNsYXNzU3VwZXIobm9kZSk7XG4gICAgdmFyIGNsYXNzQm9keSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgdmFyIGhhZENvbnN0cnVjdG9yID0gZmFsc2U7XG4gICAgY2xhc3NCb2R5LmJvZHkgPSBbXTtcbiAgICB0aGlzLmV4cGVjdCh0eXBlcy5icmFjZUwpO1xuICAgIHdoaWxlICghdGhpcy5lYXQodHlwZXMuYnJhY2VSKSkge1xuICAgICAgdmFyIGVsZW1lbnQgPSB0aGlzLnBhcnNlQ2xhc3NFbGVtZW50KG5vZGUuc3VwZXJDbGFzcyAhPT0gbnVsbCk7XG4gICAgICBpZiAoZWxlbWVudCkge1xuICAgICAgICBjbGFzc0JvZHkuYm9keS5wdXNoKGVsZW1lbnQpO1xuICAgICAgICBpZiAoZWxlbWVudC50eXBlID09PSBcIk1ldGhvZERlZmluaXRpb25cIiAmJiBlbGVtZW50LmtpbmQgPT09IFwiY29uc3RydWN0b3JcIikge1xuICAgICAgICAgIGlmIChoYWRDb25zdHJ1Y3RvcikgeyB0aGlzLnJhaXNlKGVsZW1lbnQuc3RhcnQsIFwiRHVwbGljYXRlIGNvbnN0cnVjdG9yIGluIHRoZSBzYW1lIGNsYXNzXCIpOyB9XG4gICAgICAgICAgaGFkQ29uc3RydWN0b3IgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIG5vZGUuYm9keSA9IHRoaXMuZmluaXNoTm9kZShjbGFzc0JvZHksIFwiQ2xhc3NCb2R5XCIpO1xuICAgIHRoaXMuc3RyaWN0ID0gb2xkU3RyaWN0O1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgaXNTdGF0ZW1lbnQgPyBcIkNsYXNzRGVjbGFyYXRpb25cIiA6IFwiQ2xhc3NFeHByZXNzaW9uXCIpXG4gIH07XG5cbiAgcHAkMS5wYXJzZUNsYXNzRWxlbWVudCA9IGZ1bmN0aW9uKGNvbnN0cnVjdG9yQWxsb3dzU3VwZXIpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIGlmICh0aGlzLmVhdCh0eXBlcy5zZW1pKSkgeyByZXR1cm4gbnVsbCB9XG5cbiAgICB2YXIgbWV0aG9kID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICB2YXIgdHJ5Q29udGV4dHVhbCA9IGZ1bmN0aW9uIChrLCBub0xpbmVCcmVhaykge1xuICAgICAgaWYgKCBub0xpbmVCcmVhayA9PT0gdm9pZCAwICkgbm9MaW5lQnJlYWsgPSBmYWxzZTtcblxuICAgICAgdmFyIHN0YXJ0ID0gdGhpcyQxLnN0YXJ0LCBzdGFydExvYyA9IHRoaXMkMS5zdGFydExvYztcbiAgICAgIGlmICghdGhpcyQxLmVhdENvbnRleHR1YWwoaykpIHsgcmV0dXJuIGZhbHNlIH1cbiAgICAgIGlmICh0aGlzJDEudHlwZSAhPT0gdHlwZXMucGFyZW5MICYmICghbm9MaW5lQnJlYWsgfHwgIXRoaXMkMS5jYW5JbnNlcnRTZW1pY29sb24oKSkpIHsgcmV0dXJuIHRydWUgfVxuICAgICAgaWYgKG1ldGhvZC5rZXkpIHsgdGhpcyQxLnVuZXhwZWN0ZWQoKTsgfVxuICAgICAgbWV0aG9kLmNvbXB1dGVkID0gZmFsc2U7XG4gICAgICBtZXRob2Qua2V5ID0gdGhpcyQxLnN0YXJ0Tm9kZUF0KHN0YXJ0LCBzdGFydExvYyk7XG4gICAgICBtZXRob2Qua2V5Lm5hbWUgPSBrO1xuICAgICAgdGhpcyQxLmZpbmlzaE5vZGUobWV0aG9kLmtleSwgXCJJZGVudGlmaWVyXCIpO1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfTtcblxuICAgIG1ldGhvZC5raW5kID0gXCJtZXRob2RcIjtcbiAgICBtZXRob2Quc3RhdGljID0gdHJ5Q29udGV4dHVhbChcInN0YXRpY1wiKTtcbiAgICB2YXIgaXNHZW5lcmF0b3IgPSB0aGlzLmVhdCh0eXBlcy5zdGFyKTtcbiAgICB2YXIgaXNBc3luYyA9IGZhbHNlO1xuICAgIGlmICghaXNHZW5lcmF0b3IpIHtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOCAmJiB0cnlDb250ZXh0dWFsKFwiYXN5bmNcIiwgdHJ1ZSkpIHtcbiAgICAgICAgaXNBc3luYyA9IHRydWU7XG4gICAgICAgIGlzR2VuZXJhdG9yID0gdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDkgJiYgdGhpcy5lYXQodHlwZXMuc3Rhcik7XG4gICAgICB9IGVsc2UgaWYgKHRyeUNvbnRleHR1YWwoXCJnZXRcIikpIHtcbiAgICAgICAgbWV0aG9kLmtpbmQgPSBcImdldFwiO1xuICAgICAgfSBlbHNlIGlmICh0cnlDb250ZXh0dWFsKFwic2V0XCIpKSB7XG4gICAgICAgIG1ldGhvZC5raW5kID0gXCJzZXRcIjtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFtZXRob2Qua2V5KSB7IHRoaXMucGFyc2VQcm9wZXJ0eU5hbWUobWV0aG9kKTsgfVxuICAgIHZhciBrZXkgPSBtZXRob2Qua2V5O1xuICAgIHZhciBhbGxvd3NEaXJlY3RTdXBlciA9IGZhbHNlO1xuICAgIGlmICghbWV0aG9kLmNvbXB1dGVkICYmICFtZXRob2Quc3RhdGljICYmIChrZXkudHlwZSA9PT0gXCJJZGVudGlmaWVyXCIgJiYga2V5Lm5hbWUgPT09IFwiY29uc3RydWN0b3JcIiB8fFxuICAgICAgICBrZXkudHlwZSA9PT0gXCJMaXRlcmFsXCIgJiYga2V5LnZhbHVlID09PSBcImNvbnN0cnVjdG9yXCIpKSB7XG4gICAgICBpZiAobWV0aG9kLmtpbmQgIT09IFwibWV0aG9kXCIpIHsgdGhpcy5yYWlzZShrZXkuc3RhcnQsIFwiQ29uc3RydWN0b3IgY2FuJ3QgaGF2ZSBnZXQvc2V0IG1vZGlmaWVyXCIpOyB9XG4gICAgICBpZiAoaXNHZW5lcmF0b3IpIHsgdGhpcy5yYWlzZShrZXkuc3RhcnQsIFwiQ29uc3RydWN0b3IgY2FuJ3QgYmUgYSBnZW5lcmF0b3JcIik7IH1cbiAgICAgIGlmIChpc0FzeW5jKSB7IHRoaXMucmFpc2Uoa2V5LnN0YXJ0LCBcIkNvbnN0cnVjdG9yIGNhbid0IGJlIGFuIGFzeW5jIG1ldGhvZFwiKTsgfVxuICAgICAgbWV0aG9kLmtpbmQgPSBcImNvbnN0cnVjdG9yXCI7XG4gICAgICBhbGxvd3NEaXJlY3RTdXBlciA9IGNvbnN0cnVjdG9yQWxsb3dzU3VwZXI7XG4gICAgfSBlbHNlIGlmIChtZXRob2Quc3RhdGljICYmIGtleS50eXBlID09PSBcIklkZW50aWZpZXJcIiAmJiBrZXkubmFtZSA9PT0gXCJwcm90b3R5cGVcIikge1xuICAgICAgdGhpcy5yYWlzZShrZXkuc3RhcnQsIFwiQ2xhc3NlcyBtYXkgbm90IGhhdmUgYSBzdGF0aWMgcHJvcGVydHkgbmFtZWQgcHJvdG90eXBlXCIpO1xuICAgIH1cbiAgICB0aGlzLnBhcnNlQ2xhc3NNZXRob2QobWV0aG9kLCBpc0dlbmVyYXRvciwgaXNBc3luYywgYWxsb3dzRGlyZWN0U3VwZXIpO1xuICAgIGlmIChtZXRob2Qua2luZCA9PT0gXCJnZXRcIiAmJiBtZXRob2QudmFsdWUucGFyYW1zLmxlbmd0aCAhPT0gMClcbiAgICAgIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKG1ldGhvZC52YWx1ZS5zdGFydCwgXCJnZXR0ZXIgc2hvdWxkIGhhdmUgbm8gcGFyYW1zXCIpOyB9XG4gICAgaWYgKG1ldGhvZC5raW5kID09PSBcInNldFwiICYmIG1ldGhvZC52YWx1ZS5wYXJhbXMubGVuZ3RoICE9PSAxKVxuICAgICAgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUobWV0aG9kLnZhbHVlLnN0YXJ0LCBcInNldHRlciBzaG91bGQgaGF2ZSBleGFjdGx5IG9uZSBwYXJhbVwiKTsgfVxuICAgIGlmIChtZXRob2Qua2luZCA9PT0gXCJzZXRcIiAmJiBtZXRob2QudmFsdWUucGFyYW1zWzBdLnR5cGUgPT09IFwiUmVzdEVsZW1lbnRcIilcbiAgICAgIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKG1ldGhvZC52YWx1ZS5wYXJhbXNbMF0uc3RhcnQsIFwiU2V0dGVyIGNhbm5vdCB1c2UgcmVzdCBwYXJhbXNcIik7IH1cbiAgICByZXR1cm4gbWV0aG9kXG4gIH07XG5cbiAgcHAkMS5wYXJzZUNsYXNzTWV0aG9kID0gZnVuY3Rpb24obWV0aG9kLCBpc0dlbmVyYXRvciwgaXNBc3luYywgYWxsb3dzRGlyZWN0U3VwZXIpIHtcbiAgICBtZXRob2QudmFsdWUgPSB0aGlzLnBhcnNlTWV0aG9kKGlzR2VuZXJhdG9yLCBpc0FzeW5jLCBhbGxvd3NEaXJlY3RTdXBlcik7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShtZXRob2QsIFwiTWV0aG9kRGVmaW5pdGlvblwiKVxuICB9O1xuXG4gIHBwJDEucGFyc2VDbGFzc0lkID0gZnVuY3Rpb24obm9kZSwgaXNTdGF0ZW1lbnQpIHtcbiAgICBpZiAodGhpcy50eXBlID09PSB0eXBlcy5uYW1lKSB7XG4gICAgICBub2RlLmlkID0gdGhpcy5wYXJzZUlkZW50KCk7XG4gICAgICBpZiAoaXNTdGF0ZW1lbnQpXG4gICAgICAgIHsgdGhpcy5jaGVja0xWYWwobm9kZS5pZCwgQklORF9MRVhJQ0FMLCBmYWxzZSk7IH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGlzU3RhdGVtZW50ID09PSB0cnVlKVxuICAgICAgICB7IHRoaXMudW5leHBlY3RlZCgpOyB9XG4gICAgICBub2RlLmlkID0gbnVsbDtcbiAgICB9XG4gIH07XG5cbiAgcHAkMS5wYXJzZUNsYXNzU3VwZXIgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgbm9kZS5zdXBlckNsYXNzID0gdGhpcy5lYXQodHlwZXMuX2V4dGVuZHMpID8gdGhpcy5wYXJzZUV4cHJTdWJzY3JpcHRzKCkgOiBudWxsO1xuICB9O1xuXG5cbiAgcHAkMS5wYXJzZUV4cG9ydCA9IGZ1bmN0aW9uKG5vZGUsIGV4cG9ydHMpIHtcbiAgICB0aGlzLm5leHQoKTtcbiAgICBpZiAodGhpcy5lYXQodHlwZXMuc3RhcikpIHtcbiAgICAgIHRoaXMuZXhwZWN0Q29udGV4dHVhbChcImZyb21cIik7XG4gICAgICBpZiAodGhpcy50eXBlICE9PSB0eXBlcy5zdHJpbmcpIHsgdGhpcy51bmV4cGVjdGVkKCk7IH1cbiAgICAgIG5vZGUuc291cmNlID0gdGhpcy5wYXJzZUV4cHJBdG9tKCk7XG4gICAgICB0aGlzLnNlbWljb2xvbigpO1xuICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkV4cG9ydEFsbERlY2xhcmF0aW9uXCIpXG4gICAgfVxuICAgIGlmICh0aGlzLmVhdCh0eXBlcy5fZGVmYXVsdCkpIHsgXG4gICAgICB0aGlzLmNoZWNrRXhwb3J0KGV4cG9ydHMsIFwiZGVmYXVsdFwiLCB0aGlzLmxhc3RUb2tTdGFydCk7XG4gICAgICB2YXIgaXNBc3luYztcbiAgICAgIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzLl9mdW5jdGlvbiB8fCAoaXNBc3luYyA9IHRoaXMuaXNBc3luY0Z1bmN0aW9uKCkpKSB7XG4gICAgICAgIHZhciBmTm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICBpZiAoaXNBc3luYykgeyB0aGlzLm5leHQoKTsgfVxuICAgICAgICBub2RlLmRlY2xhcmF0aW9uID0gdGhpcy5wYXJzZUZ1bmN0aW9uKGZOb2RlLCBGVU5DX1NUQVRFTUVOVCB8IEZVTkNfTlVMTEFCTEVfSUQsIGZhbHNlLCBpc0FzeW5jKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy50eXBlID09PSB0eXBlcy5fY2xhc3MpIHtcbiAgICAgICAgdmFyIGNOb2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICAgICAgbm9kZS5kZWNsYXJhdGlvbiA9IHRoaXMucGFyc2VDbGFzcyhjTm9kZSwgXCJudWxsYWJsZUlEXCIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9kZS5kZWNsYXJhdGlvbiA9IHRoaXMucGFyc2VNYXliZUFzc2lnbigpO1xuICAgICAgICB0aGlzLnNlbWljb2xvbigpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkV4cG9ydERlZmF1bHREZWNsYXJhdGlvblwiKVxuICAgIH1cbiAgICBpZiAodGhpcy5zaG91bGRQYXJzZUV4cG9ydFN0YXRlbWVudCgpKSB7XG4gICAgICBub2RlLmRlY2xhcmF0aW9uID0gdGhpcy5wYXJzZVN0YXRlbWVudChudWxsKTtcbiAgICAgIGlmIChub2RlLmRlY2xhcmF0aW9uLnR5cGUgPT09IFwiVmFyaWFibGVEZWNsYXJhdGlvblwiKVxuICAgICAgICB7IHRoaXMuY2hlY2tWYXJpYWJsZUV4cG9ydChleHBvcnRzLCBub2RlLmRlY2xhcmF0aW9uLmRlY2xhcmF0aW9ucyk7IH1cbiAgICAgIGVsc2VcbiAgICAgICAgeyB0aGlzLmNoZWNrRXhwb3J0KGV4cG9ydHMsIG5vZGUuZGVjbGFyYXRpb24uaWQubmFtZSwgbm9kZS5kZWNsYXJhdGlvbi5pZC5zdGFydCk7IH1cbiAgICAgIG5vZGUuc3BlY2lmaWVycyA9IFtdO1xuICAgICAgbm9kZS5zb3VyY2UgPSBudWxsO1xuICAgIH0gZWxzZSB7IFxuICAgICAgbm9kZS5kZWNsYXJhdGlvbiA9IG51bGw7XG4gICAgICBub2RlLnNwZWNpZmllcnMgPSB0aGlzLnBhcnNlRXhwb3J0U3BlY2lmaWVycyhleHBvcnRzKTtcbiAgICAgIGlmICh0aGlzLmVhdENvbnRleHR1YWwoXCJmcm9tXCIpKSB7XG4gICAgICAgIGlmICh0aGlzLnR5cGUgIT09IHR5cGVzLnN0cmluZykgeyB0aGlzLnVuZXhwZWN0ZWQoKTsgfVxuICAgICAgICBub2RlLnNvdXJjZSA9IHRoaXMucGFyc2VFeHByQXRvbSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxpc3QgPSBub2RlLnNwZWNpZmllcnM7IGkgPCBsaXN0Lmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgdmFyIHNwZWMgPSBsaXN0W2ldO1xuXG4gICAgICAgICAgdGhpcy5jaGVja1VucmVzZXJ2ZWQoc3BlYy5sb2NhbCk7XG4gICAgICAgICAgdGhpcy5jaGVja0xvY2FsRXhwb3J0KHNwZWMubG9jYWwpO1xuICAgICAgICB9XG5cbiAgICAgICAgbm9kZS5zb3VyY2UgPSBudWxsO1xuICAgICAgfVxuICAgICAgdGhpcy5zZW1pY29sb24oKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkV4cG9ydE5hbWVkRGVjbGFyYXRpb25cIilcbiAgfTtcblxuICBwcCQxLmNoZWNrRXhwb3J0ID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgcG9zKSB7XG4gICAgaWYgKCFleHBvcnRzKSB7IHJldHVybiB9XG4gICAgaWYgKGhhcyhleHBvcnRzLCBuYW1lKSlcbiAgICAgIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKHBvcywgXCJEdXBsaWNhdGUgZXhwb3J0ICdcIiArIG5hbWUgKyBcIidcIik7IH1cbiAgICBleHBvcnRzW25hbWVdID0gdHJ1ZTtcbiAgfTtcblxuICBwcCQxLmNoZWNrUGF0dGVybkV4cG9ydCA9IGZ1bmN0aW9uKGV4cG9ydHMsIHBhdCkge1xuICAgIHZhciB0eXBlID0gcGF0LnR5cGU7XG4gICAgaWYgKHR5cGUgPT09IFwiSWRlbnRpZmllclwiKVxuICAgICAgeyB0aGlzLmNoZWNrRXhwb3J0KGV4cG9ydHMsIHBhdC5uYW1lLCBwYXQuc3RhcnQpOyB9XG4gICAgZWxzZSBpZiAodHlwZSA9PT0gXCJPYmplY3RQYXR0ZXJuXCIpXG4gICAgICB7IGZvciAodmFyIGkgPSAwLCBsaXN0ID0gcGF0LnByb3BlcnRpZXM7IGkgPCBsaXN0Lmxlbmd0aDsgaSArPSAxKVxuICAgICAgICB7XG4gICAgICAgICAgdmFyIHByb3AgPSBsaXN0W2ldO1xuXG4gICAgICAgICAgdGhpcy5jaGVja1BhdHRlcm5FeHBvcnQoZXhwb3J0cywgcHJvcCk7XG4gICAgICAgIH0gfVxuICAgIGVsc2UgaWYgKHR5cGUgPT09IFwiQXJyYXlQYXR0ZXJuXCIpXG4gICAgICB7IGZvciAodmFyIGkkMSA9IDAsIGxpc3QkMSA9IHBhdC5lbGVtZW50czsgaSQxIDwgbGlzdCQxLmxlbmd0aDsgaSQxICs9IDEpIHtcbiAgICAgICAgdmFyIGVsdCA9IGxpc3QkMVtpJDFdO1xuXG4gICAgICAgICAgaWYgKGVsdCkgeyB0aGlzLmNoZWNrUGF0dGVybkV4cG9ydChleHBvcnRzLCBlbHQpOyB9XG4gICAgICB9IH1cbiAgICBlbHNlIGlmICh0eXBlID09PSBcIlByb3BlcnR5XCIpXG4gICAgICB7IHRoaXMuY2hlY2tQYXR0ZXJuRXhwb3J0KGV4cG9ydHMsIHBhdC52YWx1ZSk7IH1cbiAgICBlbHNlIGlmICh0eXBlID09PSBcIkFzc2lnbm1lbnRQYXR0ZXJuXCIpXG4gICAgICB7IHRoaXMuY2hlY2tQYXR0ZXJuRXhwb3J0KGV4cG9ydHMsIHBhdC5sZWZ0KTsgfVxuICAgIGVsc2UgaWYgKHR5cGUgPT09IFwiUmVzdEVsZW1lbnRcIilcbiAgICAgIHsgdGhpcy5jaGVja1BhdHRlcm5FeHBvcnQoZXhwb3J0cywgcGF0LmFyZ3VtZW50KTsgfVxuICAgIGVsc2UgaWYgKHR5cGUgPT09IFwiUGFyZW50aGVzaXplZEV4cHJlc3Npb25cIilcbiAgICAgIHsgdGhpcy5jaGVja1BhdHRlcm5FeHBvcnQoZXhwb3J0cywgcGF0LmV4cHJlc3Npb24pOyB9XG4gIH07XG5cbiAgcHAkMS5jaGVja1ZhcmlhYmxlRXhwb3J0ID0gZnVuY3Rpb24oZXhwb3J0cywgZGVjbHMpIHtcbiAgICBpZiAoIWV4cG9ydHMpIHsgcmV0dXJuIH1cbiAgICBmb3IgKHZhciBpID0gMCwgbGlzdCA9IGRlY2xzOyBpIDwgbGlzdC5sZW5ndGg7IGkgKz0gMSlcbiAgICAgIHtcbiAgICAgIHZhciBkZWNsID0gbGlzdFtpXTtcblxuICAgICAgdGhpcy5jaGVja1BhdHRlcm5FeHBvcnQoZXhwb3J0cywgZGVjbC5pZCk7XG4gICAgfVxuICB9O1xuXG4gIHBwJDEuc2hvdWxkUGFyc2VFeHBvcnRTdGF0ZW1lbnQgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy50eXBlLmtleXdvcmQgPT09IFwidmFyXCIgfHxcbiAgICAgIHRoaXMudHlwZS5rZXl3b3JkID09PSBcImNvbnN0XCIgfHxcbiAgICAgIHRoaXMudHlwZS5rZXl3b3JkID09PSBcImNsYXNzXCIgfHxcbiAgICAgIHRoaXMudHlwZS5rZXl3b3JkID09PSBcImZ1bmN0aW9uXCIgfHxcbiAgICAgIHRoaXMuaXNMZXQoKSB8fFxuICAgICAgdGhpcy5pc0FzeW5jRnVuY3Rpb24oKVxuICB9O1xuXG5cbiAgcHAkMS5wYXJzZUV4cG9ydFNwZWNpZmllcnMgPSBmdW5jdGlvbihleHBvcnRzKSB7XG4gICAgdmFyIG5vZGVzID0gW10sIGZpcnN0ID0gdHJ1ZTtcbiAgICB0aGlzLmV4cGVjdCh0eXBlcy5icmFjZUwpO1xuICAgIHdoaWxlICghdGhpcy5lYXQodHlwZXMuYnJhY2VSKSkge1xuICAgICAgaWYgKCFmaXJzdCkge1xuICAgICAgICB0aGlzLmV4cGVjdCh0eXBlcy5jb21tYSk7XG4gICAgICAgIGlmICh0aGlzLmFmdGVyVHJhaWxpbmdDb21tYSh0eXBlcy5icmFjZVIpKSB7IGJyZWFrIH1cbiAgICAgIH0gZWxzZSB7IGZpcnN0ID0gZmFsc2U7IH1cblxuICAgICAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgICAgbm9kZS5sb2NhbCA9IHRoaXMucGFyc2VJZGVudCh0cnVlKTtcbiAgICAgIG5vZGUuZXhwb3J0ZWQgPSB0aGlzLmVhdENvbnRleHR1YWwoXCJhc1wiKSA/IHRoaXMucGFyc2VJZGVudCh0cnVlKSA6IG5vZGUubG9jYWw7XG4gICAgICB0aGlzLmNoZWNrRXhwb3J0KGV4cG9ydHMsIG5vZGUuZXhwb3J0ZWQubmFtZSwgbm9kZS5leHBvcnRlZC5zdGFydCk7XG4gICAgICBub2Rlcy5wdXNoKHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkV4cG9ydFNwZWNpZmllclwiKSk7XG4gICAgfVxuICAgIHJldHVybiBub2Rlc1xuICB9O1xuXG5cbiAgcHAkMS5wYXJzZUltcG9ydCA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICB0aGlzLm5leHQoKTtcbiAgICBpZiAodGhpcy50eXBlID09PSB0eXBlcy5zdHJpbmcpIHtcbiAgICAgIG5vZGUuc3BlY2lmaWVycyA9IGVtcHR5O1xuICAgICAgbm9kZS5zb3VyY2UgPSB0aGlzLnBhcnNlRXhwckF0b20oKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbm9kZS5zcGVjaWZpZXJzID0gdGhpcy5wYXJzZUltcG9ydFNwZWNpZmllcnMoKTtcbiAgICAgIHRoaXMuZXhwZWN0Q29udGV4dHVhbChcImZyb21cIik7XG4gICAgICBub2RlLnNvdXJjZSA9IHRoaXMudHlwZSA9PT0gdHlwZXMuc3RyaW5nID8gdGhpcy5wYXJzZUV4cHJBdG9tKCkgOiB0aGlzLnVuZXhwZWN0ZWQoKTtcbiAgICB9XG4gICAgdGhpcy5zZW1pY29sb24oKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiSW1wb3J0RGVjbGFyYXRpb25cIilcbiAgfTtcblxuXG4gIHBwJDEucGFyc2VJbXBvcnRTcGVjaWZpZXJzID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIG5vZGVzID0gW10sIGZpcnN0ID0gdHJ1ZTtcbiAgICBpZiAodGhpcy50eXBlID09PSB0eXBlcy5uYW1lKSB7XG4gICAgICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgICBub2RlLmxvY2FsID0gdGhpcy5wYXJzZUlkZW50KCk7XG4gICAgICB0aGlzLmNoZWNrTFZhbChub2RlLmxvY2FsLCBCSU5EX0xFWElDQUwpO1xuICAgICAgbm9kZXMucHVzaCh0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJJbXBvcnREZWZhdWx0U3BlY2lmaWVyXCIpKTtcbiAgICAgIGlmICghdGhpcy5lYXQodHlwZXMuY29tbWEpKSB7IHJldHVybiBub2RlcyB9XG4gICAgfVxuICAgIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzLnN0YXIpIHtcbiAgICAgIHZhciBub2RlJDEgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICB0aGlzLmV4cGVjdENvbnRleHR1YWwoXCJhc1wiKTtcbiAgICAgIG5vZGUkMS5sb2NhbCA9IHRoaXMucGFyc2VJZGVudCgpO1xuICAgICAgdGhpcy5jaGVja0xWYWwobm9kZSQxLmxvY2FsLCBCSU5EX0xFWElDQUwpO1xuICAgICAgbm9kZXMucHVzaCh0aGlzLmZpbmlzaE5vZGUobm9kZSQxLCBcIkltcG9ydE5hbWVzcGFjZVNwZWNpZmllclwiKSk7XG4gICAgICByZXR1cm4gbm9kZXNcbiAgICB9XG4gICAgdGhpcy5leHBlY3QodHlwZXMuYnJhY2VMKTtcbiAgICB3aGlsZSAoIXRoaXMuZWF0KHR5cGVzLmJyYWNlUikpIHtcbiAgICAgIGlmICghZmlyc3QpIHtcbiAgICAgICAgdGhpcy5leHBlY3QodHlwZXMuY29tbWEpO1xuICAgICAgICBpZiAodGhpcy5hZnRlclRyYWlsaW5nQ29tbWEodHlwZXMuYnJhY2VSKSkgeyBicmVhayB9XG4gICAgICB9IGVsc2UgeyBmaXJzdCA9IGZhbHNlOyB9XG5cbiAgICAgIHZhciBub2RlJDIgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgICAgbm9kZSQyLmltcG9ydGVkID0gdGhpcy5wYXJzZUlkZW50KHRydWUpO1xuICAgICAgaWYgKHRoaXMuZWF0Q29udGV4dHVhbChcImFzXCIpKSB7XG4gICAgICAgIG5vZGUkMi5sb2NhbCA9IHRoaXMucGFyc2VJZGVudCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5jaGVja1VucmVzZXJ2ZWQobm9kZSQyLmltcG9ydGVkKTtcbiAgICAgICAgbm9kZSQyLmxvY2FsID0gbm9kZSQyLmltcG9ydGVkO1xuICAgICAgfVxuICAgICAgdGhpcy5jaGVja0xWYWwobm9kZSQyLmxvY2FsLCBCSU5EX0xFWElDQUwpO1xuICAgICAgbm9kZXMucHVzaCh0aGlzLmZpbmlzaE5vZGUobm9kZSQyLCBcIkltcG9ydFNwZWNpZmllclwiKSk7XG4gICAgfVxuICAgIHJldHVybiBub2Rlc1xuICB9O1xuXG4gIHBwJDEuYWRhcHREaXJlY3RpdmVQcm9sb2d1ZSA9IGZ1bmN0aW9uKHN0YXRlbWVudHMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0YXRlbWVudHMubGVuZ3RoICYmIHRoaXMuaXNEaXJlY3RpdmVDYW5kaWRhdGUoc3RhdGVtZW50c1tpXSk7ICsraSkge1xuICAgICAgc3RhdGVtZW50c1tpXS5kaXJlY3RpdmUgPSBzdGF0ZW1lbnRzW2ldLmV4cHJlc3Npb24ucmF3LnNsaWNlKDEsIC0xKTtcbiAgICB9XG4gIH07XG4gIHBwJDEuaXNEaXJlY3RpdmVDYW5kaWRhdGUgPSBmdW5jdGlvbihzdGF0ZW1lbnQpIHtcbiAgICByZXR1cm4gKFxuICAgICAgc3RhdGVtZW50LnR5cGUgPT09IFwiRXhwcmVzc2lvblN0YXRlbWVudFwiICYmXG4gICAgICBzdGF0ZW1lbnQuZXhwcmVzc2lvbi50eXBlID09PSBcIkxpdGVyYWxcIiAmJlxuICAgICAgdHlwZW9mIHN0YXRlbWVudC5leHByZXNzaW9uLnZhbHVlID09PSBcInN0cmluZ1wiICYmXG4gICAgICAodGhpcy5pbnB1dFtzdGF0ZW1lbnQuc3RhcnRdID09PSBcIlxcXCJcIiB8fCB0aGlzLmlucHV0W3N0YXRlbWVudC5zdGFydF0gPT09IFwiJ1wiKVxuICAgIClcbiAgfTtcblxuICB2YXIgcHAkMiA9IFBhcnNlci5wcm90b3R5cGU7XG5cblxuICBwcCQyLnRvQXNzaWduYWJsZSA9IGZ1bmN0aW9uKG5vZGUsIGlzQmluZGluZywgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycykge1xuICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNiAmJiBub2RlKSB7XG4gICAgICBzd2l0Y2ggKG5vZGUudHlwZSkge1xuICAgICAgY2FzZSBcIklkZW50aWZpZXJcIjpcbiAgICAgICAgaWYgKHRoaXMuaW5Bc3luYyAmJiBub2RlLm5hbWUgPT09IFwiYXdhaXRcIilcbiAgICAgICAgICB7IHRoaXMucmFpc2Uobm9kZS5zdGFydCwgXCJDYW5ub3QgdXNlICdhd2FpdCcgYXMgaWRlbnRpZmllciBpbnNpZGUgYW4gYXN5bmMgZnVuY3Rpb25cIik7IH1cbiAgICAgICAgYnJlYWtcblxuICAgICAgY2FzZSBcIk9iamVjdFBhdHRlcm5cIjpcbiAgICAgIGNhc2UgXCJBcnJheVBhdHRlcm5cIjpcbiAgICAgIGNhc2UgXCJSZXN0RWxlbWVudFwiOlxuICAgICAgICBicmVha1xuXG4gICAgICBjYXNlIFwiT2JqZWN0RXhwcmVzc2lvblwiOlxuICAgICAgICBub2RlLnR5cGUgPSBcIk9iamVjdFBhdHRlcm5cIjtcbiAgICAgICAgaWYgKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpIHsgdGhpcy5jaGVja1BhdHRlcm5FcnJvcnMocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycywgdHJ1ZSk7IH1cbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxpc3QgPSBub2RlLnByb3BlcnRpZXM7IGkgPCBsaXN0Lmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgdmFyIHByb3AgPSBsaXN0W2ldO1xuXG4gICAgICAgIHRoaXMudG9Bc3NpZ25hYmxlKHByb3AsIGlzQmluZGluZyk7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgcHJvcC50eXBlID09PSBcIlJlc3RFbGVtZW50XCIgJiZcbiAgICAgICAgICAgIChwcm9wLmFyZ3VtZW50LnR5cGUgPT09IFwiQXJyYXlQYXR0ZXJuXCIgfHwgcHJvcC5hcmd1bWVudC50eXBlID09PSBcIk9iamVjdFBhdHRlcm5cIilcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIHRoaXMucmFpc2UocHJvcC5hcmd1bWVudC5zdGFydCwgXCJVbmV4cGVjdGVkIHRva2VuXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVha1xuXG4gICAgICBjYXNlIFwiUHJvcGVydHlcIjpcbiAgICAgICAgaWYgKG5vZGUua2luZCAhPT0gXCJpbml0XCIpIHsgdGhpcy5yYWlzZShub2RlLmtleS5zdGFydCwgXCJPYmplY3QgcGF0dGVybiBjYW4ndCBjb250YWluIGdldHRlciBvciBzZXR0ZXJcIik7IH1cbiAgICAgICAgdGhpcy50b0Fzc2lnbmFibGUobm9kZS52YWx1ZSwgaXNCaW5kaW5nKTtcbiAgICAgICAgYnJlYWtcblxuICAgICAgY2FzZSBcIkFycmF5RXhwcmVzc2lvblwiOlxuICAgICAgICBub2RlLnR5cGUgPSBcIkFycmF5UGF0dGVyblwiO1xuICAgICAgICBpZiAocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycykgeyB0aGlzLmNoZWNrUGF0dGVybkVycm9ycyhyZWZEZXN0cnVjdHVyaW5nRXJyb3JzLCB0cnVlKTsgfVxuICAgICAgICB0aGlzLnRvQXNzaWduYWJsZUxpc3Qobm9kZS5lbGVtZW50cywgaXNCaW5kaW5nKTtcbiAgICAgICAgYnJlYWtcblxuICAgICAgY2FzZSBcIlNwcmVhZEVsZW1lbnRcIjpcbiAgICAgICAgbm9kZS50eXBlID0gXCJSZXN0RWxlbWVudFwiO1xuICAgICAgICB0aGlzLnRvQXNzaWduYWJsZShub2RlLmFyZ3VtZW50LCBpc0JpbmRpbmcpO1xuICAgICAgICBpZiAobm9kZS5hcmd1bWVudC50eXBlID09PSBcIkFzc2lnbm1lbnRQYXR0ZXJuXCIpXG4gICAgICAgICAgeyB0aGlzLnJhaXNlKG5vZGUuYXJndW1lbnQuc3RhcnQsIFwiUmVzdCBlbGVtZW50cyBjYW5ub3QgaGF2ZSBhIGRlZmF1bHQgdmFsdWVcIik7IH1cbiAgICAgICAgYnJlYWtcblxuICAgICAgY2FzZSBcIkFzc2lnbm1lbnRFeHByZXNzaW9uXCI6XG4gICAgICAgIGlmIChub2RlLm9wZXJhdG9yICE9PSBcIj1cIikgeyB0aGlzLnJhaXNlKG5vZGUubGVmdC5lbmQsIFwiT25seSAnPScgb3BlcmF0b3IgY2FuIGJlIHVzZWQgZm9yIHNwZWNpZnlpbmcgZGVmYXVsdCB2YWx1ZS5cIik7IH1cbiAgICAgICAgbm9kZS50eXBlID0gXCJBc3NpZ25tZW50UGF0dGVyblwiO1xuICAgICAgICBkZWxldGUgbm9kZS5vcGVyYXRvcjtcbiAgICAgICAgdGhpcy50b0Fzc2lnbmFibGUobm9kZS5sZWZ0LCBpc0JpbmRpbmcpO1xuXG4gICAgICBjYXNlIFwiQXNzaWdubWVudFBhdHRlcm5cIjpcbiAgICAgICAgYnJlYWtcblxuICAgICAgY2FzZSBcIlBhcmVudGhlc2l6ZWRFeHByZXNzaW9uXCI6XG4gICAgICAgIHRoaXMudG9Bc3NpZ25hYmxlKG5vZGUuZXhwcmVzc2lvbiwgaXNCaW5kaW5nLCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKTtcbiAgICAgICAgYnJlYWtcblxuICAgICAgY2FzZSBcIk1lbWJlckV4cHJlc3Npb25cIjpcbiAgICAgICAgaWYgKCFpc0JpbmRpbmcpIHsgYnJlYWsgfVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aGlzLnJhaXNlKG5vZGUuc3RhcnQsIFwiQXNzaWduaW5nIHRvIHJ2YWx1ZVwiKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpIHsgdGhpcy5jaGVja1BhdHRlcm5FcnJvcnMocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycywgdHJ1ZSk7IH1cbiAgICByZXR1cm4gbm9kZVxuICB9O1xuXG5cbiAgcHAkMi50b0Fzc2lnbmFibGVMaXN0ID0gZnVuY3Rpb24oZXhwckxpc3QsIGlzQmluZGluZykge1xuICAgIHZhciBlbmQgPSBleHByTGlzdC5sZW5ndGg7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbmQ7IGkrKykge1xuICAgICAgdmFyIGVsdCA9IGV4cHJMaXN0W2ldO1xuICAgICAgaWYgKGVsdCkgeyB0aGlzLnRvQXNzaWduYWJsZShlbHQsIGlzQmluZGluZyk7IH1cbiAgICB9XG4gICAgaWYgKGVuZCkge1xuICAgICAgdmFyIGxhc3QgPSBleHByTGlzdFtlbmQgLSAxXTtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPT09IDYgJiYgaXNCaW5kaW5nICYmIGxhc3QgJiYgbGFzdC50eXBlID09PSBcIlJlc3RFbGVtZW50XCIgJiYgbGFzdC5hcmd1bWVudC50eXBlICE9PSBcIklkZW50aWZpZXJcIilcbiAgICAgICAgeyB0aGlzLnVuZXhwZWN0ZWQobGFzdC5hcmd1bWVudC5zdGFydCk7IH1cbiAgICB9XG4gICAgcmV0dXJuIGV4cHJMaXN0XG4gIH07XG5cblxuICBwcCQyLnBhcnNlU3ByZWFkID0gZnVuY3Rpb24ocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycykge1xuICAgIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICB0aGlzLm5leHQoKTtcbiAgICBub2RlLmFyZ3VtZW50ID0gdGhpcy5wYXJzZU1heWJlQXNzaWduKGZhbHNlLCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiU3ByZWFkRWxlbWVudFwiKVxuICB9O1xuXG4gIHBwJDIucGFyc2VSZXN0QmluZGluZyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICB0aGlzLm5leHQoKTtcblxuICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPT09IDYgJiYgdGhpcy50eXBlICE9PSB0eXBlcy5uYW1lKVxuICAgICAgeyB0aGlzLnVuZXhwZWN0ZWQoKTsgfVxuXG4gICAgbm9kZS5hcmd1bWVudCA9IHRoaXMucGFyc2VCaW5kaW5nQXRvbSgpO1xuXG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlJlc3RFbGVtZW50XCIpXG4gIH07XG5cblxuICBwcCQyLnBhcnNlQmluZGluZ0F0b20gPSBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDYpIHtcbiAgICAgIHN3aXRjaCAodGhpcy50eXBlKSB7XG4gICAgICBjYXNlIHR5cGVzLmJyYWNrZXRMOlxuICAgICAgICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICBub2RlLmVsZW1lbnRzID0gdGhpcy5wYXJzZUJpbmRpbmdMaXN0KHR5cGVzLmJyYWNrZXRSLCB0cnVlLCB0cnVlKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkFycmF5UGF0dGVyblwiKVxuXG4gICAgICBjYXNlIHR5cGVzLmJyYWNlTDpcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VPYmoodHJ1ZSlcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMucGFyc2VJZGVudCgpXG4gIH07XG5cbiAgcHAkMi5wYXJzZUJpbmRpbmdMaXN0ID0gZnVuY3Rpb24oY2xvc2UsIGFsbG93RW1wdHksIGFsbG93VHJhaWxpbmdDb21tYSkge1xuICAgIHZhciBlbHRzID0gW10sIGZpcnN0ID0gdHJ1ZTtcbiAgICB3aGlsZSAoIXRoaXMuZWF0KGNsb3NlKSkge1xuICAgICAgaWYgKGZpcnN0KSB7IGZpcnN0ID0gZmFsc2U7IH1cbiAgICAgIGVsc2UgeyB0aGlzLmV4cGVjdCh0eXBlcy5jb21tYSk7IH1cbiAgICAgIGlmIChhbGxvd0VtcHR5ICYmIHRoaXMudHlwZSA9PT0gdHlwZXMuY29tbWEpIHtcbiAgICAgICAgZWx0cy5wdXNoKG51bGwpO1xuICAgICAgfSBlbHNlIGlmIChhbGxvd1RyYWlsaW5nQ29tbWEgJiYgdGhpcy5hZnRlclRyYWlsaW5nQ29tbWEoY2xvc2UpKSB7XG4gICAgICAgIGJyZWFrXG4gICAgICB9IGVsc2UgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMuZWxsaXBzaXMpIHtcbiAgICAgICAgdmFyIHJlc3QgPSB0aGlzLnBhcnNlUmVzdEJpbmRpbmcoKTtcbiAgICAgICAgdGhpcy5wYXJzZUJpbmRpbmdMaXN0SXRlbShyZXN0KTtcbiAgICAgICAgZWx0cy5wdXNoKHJlc3QpO1xuICAgICAgICBpZiAodGhpcy50eXBlID09PSB0eXBlcy5jb21tYSkgeyB0aGlzLnJhaXNlKHRoaXMuc3RhcnQsIFwiQ29tbWEgaXMgbm90IHBlcm1pdHRlZCBhZnRlciB0aGUgcmVzdCBlbGVtZW50XCIpOyB9XG4gICAgICAgIHRoaXMuZXhwZWN0KGNsb3NlKTtcbiAgICAgICAgYnJlYWtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBlbGVtID0gdGhpcy5wYXJzZU1heWJlRGVmYXVsdCh0aGlzLnN0YXJ0LCB0aGlzLnN0YXJ0TG9jKTtcbiAgICAgICAgdGhpcy5wYXJzZUJpbmRpbmdMaXN0SXRlbShlbGVtKTtcbiAgICAgICAgZWx0cy5wdXNoKGVsZW0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZWx0c1xuICB9O1xuXG4gIHBwJDIucGFyc2VCaW5kaW5nTGlzdEl0ZW0gPSBmdW5jdGlvbihwYXJhbSkge1xuICAgIHJldHVybiBwYXJhbVxuICB9O1xuXG5cbiAgcHAkMi5wYXJzZU1heWJlRGVmYXVsdCA9IGZ1bmN0aW9uKHN0YXJ0UG9zLCBzdGFydExvYywgbGVmdCkge1xuICAgIGxlZnQgPSBsZWZ0IHx8IHRoaXMucGFyc2VCaW5kaW5nQXRvbSgpO1xuICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPCA2IHx8ICF0aGlzLmVhdCh0eXBlcy5lcSkpIHsgcmV0dXJuIGxlZnQgfVxuICAgIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGVBdChzdGFydFBvcywgc3RhcnRMb2MpO1xuICAgIG5vZGUubGVmdCA9IGxlZnQ7XG4gICAgbm9kZS5yaWdodCA9IHRoaXMucGFyc2VNYXliZUFzc2lnbigpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJBc3NpZ25tZW50UGF0dGVyblwiKVxuICB9O1xuXG5cbiAgcHAkMi5jaGVja0xWYWwgPSBmdW5jdGlvbihleHByLCBiaW5kaW5nVHlwZSwgY2hlY2tDbGFzaGVzKSB7XG4gICAgaWYgKCBiaW5kaW5nVHlwZSA9PT0gdm9pZCAwICkgYmluZGluZ1R5cGUgPSBCSU5EX05PTkU7XG5cbiAgICBzd2l0Y2ggKGV4cHIudHlwZSkge1xuICAgIGNhc2UgXCJJZGVudGlmaWVyXCI6XG4gICAgICBpZiAoYmluZGluZ1R5cGUgPT09IEJJTkRfTEVYSUNBTCAmJiBleHByLm5hbWUgPT09IFwibGV0XCIpXG4gICAgICAgIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKGV4cHIuc3RhcnQsIFwibGV0IGlzIGRpc2FsbG93ZWQgYXMgYSBsZXhpY2FsbHkgYm91bmQgbmFtZVwiKTsgfVxuICAgICAgaWYgKHRoaXMuc3RyaWN0ICYmIHRoaXMucmVzZXJ2ZWRXb3Jkc1N0cmljdEJpbmQudGVzdChleHByLm5hbWUpKVxuICAgICAgICB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZShleHByLnN0YXJ0LCAoYmluZGluZ1R5cGUgPyBcIkJpbmRpbmcgXCIgOiBcIkFzc2lnbmluZyB0byBcIikgKyBleHByLm5hbWUgKyBcIiBpbiBzdHJpY3QgbW9kZVwiKTsgfVxuICAgICAgaWYgKGNoZWNrQ2xhc2hlcykge1xuICAgICAgICBpZiAoaGFzKGNoZWNrQ2xhc2hlcywgZXhwci5uYW1lKSlcbiAgICAgICAgICB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZShleHByLnN0YXJ0LCBcIkFyZ3VtZW50IG5hbWUgY2xhc2hcIik7IH1cbiAgICAgICAgY2hlY2tDbGFzaGVzW2V4cHIubmFtZV0gPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKGJpbmRpbmdUeXBlICE9PSBCSU5EX05PTkUgJiYgYmluZGluZ1R5cGUgIT09IEJJTkRfT1VUU0lERSkgeyB0aGlzLmRlY2xhcmVOYW1lKGV4cHIubmFtZSwgYmluZGluZ1R5cGUsIGV4cHIuc3RhcnQpOyB9XG4gICAgICBicmVha1xuXG4gICAgY2FzZSBcIk1lbWJlckV4cHJlc3Npb25cIjpcbiAgICAgIGlmIChiaW5kaW5nVHlwZSkgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUoZXhwci5zdGFydCwgXCJCaW5kaW5nIG1lbWJlciBleHByZXNzaW9uXCIpOyB9XG4gICAgICBicmVha1xuXG4gICAgY2FzZSBcIk9iamVjdFBhdHRlcm5cIjpcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsaXN0ID0gZXhwci5wcm9wZXJ0aWVzOyBpIDwgbGlzdC5sZW5ndGg7IGkgKz0gMSlcbiAgICAgICAge1xuICAgICAgdmFyIHByb3AgPSBsaXN0W2ldO1xuXG4gICAgICB0aGlzLmNoZWNrTFZhbChwcm9wLCBiaW5kaW5nVHlwZSwgY2hlY2tDbGFzaGVzKTtcbiAgICB9XG4gICAgICBicmVha1xuXG4gICAgY2FzZSBcIlByb3BlcnR5XCI6XG4gICAgICB0aGlzLmNoZWNrTFZhbChleHByLnZhbHVlLCBiaW5kaW5nVHlwZSwgY2hlY2tDbGFzaGVzKTtcbiAgICAgIGJyZWFrXG5cbiAgICBjYXNlIFwiQXJyYXlQYXR0ZXJuXCI6XG4gICAgICBmb3IgKHZhciBpJDEgPSAwLCBsaXN0JDEgPSBleHByLmVsZW1lbnRzOyBpJDEgPCBsaXN0JDEubGVuZ3RoOyBpJDEgKz0gMSkge1xuICAgICAgICB2YXIgZWxlbSA9IGxpc3QkMVtpJDFdO1xuXG4gICAgICBpZiAoZWxlbSkgeyB0aGlzLmNoZWNrTFZhbChlbGVtLCBiaW5kaW5nVHlwZSwgY2hlY2tDbGFzaGVzKTsgfVxuICAgICAgfVxuICAgICAgYnJlYWtcblxuICAgIGNhc2UgXCJBc3NpZ25tZW50UGF0dGVyblwiOlxuICAgICAgdGhpcy5jaGVja0xWYWwoZXhwci5sZWZ0LCBiaW5kaW5nVHlwZSwgY2hlY2tDbGFzaGVzKTtcbiAgICAgIGJyZWFrXG5cbiAgICBjYXNlIFwiUmVzdEVsZW1lbnRcIjpcbiAgICAgIHRoaXMuY2hlY2tMVmFsKGV4cHIuYXJndW1lbnQsIGJpbmRpbmdUeXBlLCBjaGVja0NsYXNoZXMpO1xuICAgICAgYnJlYWtcblxuICAgIGNhc2UgXCJQYXJlbnRoZXNpemVkRXhwcmVzc2lvblwiOlxuICAgICAgdGhpcy5jaGVja0xWYWwoZXhwci5leHByZXNzaW9uLCBiaW5kaW5nVHlwZSwgY2hlY2tDbGFzaGVzKTtcbiAgICAgIGJyZWFrXG5cbiAgICBkZWZhdWx0OlxuICAgICAgdGhpcy5yYWlzZShleHByLnN0YXJ0LCAoYmluZGluZ1R5cGUgPyBcIkJpbmRpbmdcIiA6IFwiQXNzaWduaW5nIHRvXCIpICsgXCIgcnZhbHVlXCIpO1xuICAgIH1cbiAgfTtcblxuXG4gIHZhciBwcCQzID0gUGFyc2VyLnByb3RvdHlwZTtcblxuXG4gIHBwJDMuY2hlY2tQcm9wQ2xhc2ggPSBmdW5jdGlvbihwcm9wLCBwcm9wSGFzaCwgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycykge1xuICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOSAmJiBwcm9wLnR5cGUgPT09IFwiU3ByZWFkRWxlbWVudFwiKVxuICAgICAgeyByZXR1cm4gfVxuICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNiAmJiAocHJvcC5jb21wdXRlZCB8fCBwcm9wLm1ldGhvZCB8fCBwcm9wLnNob3J0aGFuZCkpXG4gICAgICB7IHJldHVybiB9XG4gICAgdmFyIGtleSA9IHByb3Aua2V5O1xuICAgIHZhciBuYW1lO1xuICAgIHN3aXRjaCAoa2V5LnR5cGUpIHtcbiAgICBjYXNlIFwiSWRlbnRpZmllclwiOiBuYW1lID0ga2V5Lm5hbWU7IGJyZWFrXG4gICAgY2FzZSBcIkxpdGVyYWxcIjogbmFtZSA9IFN0cmluZyhrZXkudmFsdWUpOyBicmVha1xuICAgIGRlZmF1bHQ6IHJldHVyblxuICAgIH1cbiAgICB2YXIga2luZCA9IHByb3Aua2luZDtcbiAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDYpIHtcbiAgICAgIGlmIChuYW1lID09PSBcIl9fcHJvdG9fX1wiICYmIGtpbmQgPT09IFwiaW5pdFwiKSB7XG4gICAgICAgIGlmIChwcm9wSGFzaC5wcm90bykge1xuICAgICAgICAgIGlmIChyZWZEZXN0cnVjdHVyaW5nRXJyb3JzKSB7XG4gICAgICAgICAgICBpZiAocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy5kb3VibGVQcm90byA8IDApXG4gICAgICAgICAgICAgIHsgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy5kb3VibGVQcm90byA9IGtleS5zdGFydDsgfVxuICAgICAgICAgIH0gZWxzZSB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZShrZXkuc3RhcnQsIFwiUmVkZWZpbml0aW9uIG9mIF9fcHJvdG9fXyBwcm9wZXJ0eVwiKTsgfVxuICAgICAgICB9XG4gICAgICAgIHByb3BIYXNoLnByb3RvID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBuYW1lID0gXCIkXCIgKyBuYW1lO1xuICAgIHZhciBvdGhlciA9IHByb3BIYXNoW25hbWVdO1xuICAgIGlmIChvdGhlcikge1xuICAgICAgdmFyIHJlZGVmaW5pdGlvbjtcbiAgICAgIGlmIChraW5kID09PSBcImluaXRcIikge1xuICAgICAgICByZWRlZmluaXRpb24gPSB0aGlzLnN0cmljdCAmJiBvdGhlci5pbml0IHx8IG90aGVyLmdldCB8fCBvdGhlci5zZXQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZWRlZmluaXRpb24gPSBvdGhlci5pbml0IHx8IG90aGVyW2tpbmRdO1xuICAgICAgfVxuICAgICAgaWYgKHJlZGVmaW5pdGlvbilcbiAgICAgICAgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUoa2V5LnN0YXJ0LCBcIlJlZGVmaW5pdGlvbiBvZiBwcm9wZXJ0eVwiKTsgfVxuICAgIH0gZWxzZSB7XG4gICAgICBvdGhlciA9IHByb3BIYXNoW25hbWVdID0ge1xuICAgICAgICBpbml0OiBmYWxzZSxcbiAgICAgICAgZ2V0OiBmYWxzZSxcbiAgICAgICAgc2V0OiBmYWxzZVxuICAgICAgfTtcbiAgICB9XG4gICAgb3RoZXJba2luZF0gPSB0cnVlO1xuICB9O1xuXG5cblxuXG4gIHBwJDMucGFyc2VFeHByZXNzaW9uID0gZnVuY3Rpb24obm9JbiwgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycykge1xuICAgIHZhciBzdGFydFBvcyA9IHRoaXMuc3RhcnQsIHN0YXJ0TG9jID0gdGhpcy5zdGFydExvYztcbiAgICB2YXIgZXhwciA9IHRoaXMucGFyc2VNYXliZUFzc2lnbihub0luLCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKTtcbiAgICBpZiAodGhpcy50eXBlID09PSB0eXBlcy5jb21tYSkge1xuICAgICAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0UG9zLCBzdGFydExvYyk7XG4gICAgICBub2RlLmV4cHJlc3Npb25zID0gW2V4cHJdO1xuICAgICAgd2hpbGUgKHRoaXMuZWF0KHR5cGVzLmNvbW1hKSkgeyBub2RlLmV4cHJlc3Npb25zLnB1c2godGhpcy5wYXJzZU1heWJlQXNzaWduKG5vSW4sIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpKTsgfVxuICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlNlcXVlbmNlRXhwcmVzc2lvblwiKVxuICAgIH1cbiAgICByZXR1cm4gZXhwclxuICB9O1xuXG5cbiAgcHAkMy5wYXJzZU1heWJlQXNzaWduID0gZnVuY3Rpb24obm9JbiwgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycywgYWZ0ZXJMZWZ0UGFyc2UpIHtcbiAgICBpZiAodGhpcy5pc0NvbnRleHR1YWwoXCJ5aWVsZFwiKSkge1xuICAgICAgaWYgKHRoaXMuaW5HZW5lcmF0b3IpIHsgcmV0dXJuIHRoaXMucGFyc2VZaWVsZChub0luKSB9XG4gICAgICBlbHNlIHsgdGhpcy5leHByQWxsb3dlZCA9IGZhbHNlOyB9XG4gICAgfVxuXG4gICAgdmFyIG93bkRlc3RydWN0dXJpbmdFcnJvcnMgPSBmYWxzZSwgb2xkUGFyZW5Bc3NpZ24gPSAtMSwgb2xkVHJhaWxpbmdDb21tYSA9IC0xO1xuICAgIGlmIChyZWZEZXN0cnVjdHVyaW5nRXJyb3JzKSB7XG4gICAgICBvbGRQYXJlbkFzc2lnbiA9IHJlZkRlc3RydWN0dXJpbmdFcnJvcnMucGFyZW50aGVzaXplZEFzc2lnbjtcbiAgICAgIG9sZFRyYWlsaW5nQ29tbWEgPSByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnRyYWlsaW5nQ29tbWE7XG4gICAgICByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnBhcmVudGhlc2l6ZWRBc3NpZ24gPSByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnRyYWlsaW5nQ29tbWEgPSAtMTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyA9IG5ldyBEZXN0cnVjdHVyaW5nRXJyb3JzO1xuICAgICAgb3duRGVzdHJ1Y3R1cmluZ0Vycm9ycyA9IHRydWU7XG4gICAgfVxuXG4gICAgdmFyIHN0YXJ0UG9zID0gdGhpcy5zdGFydCwgc3RhcnRMb2MgPSB0aGlzLnN0YXJ0TG9jO1xuICAgIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzLnBhcmVuTCB8fCB0aGlzLnR5cGUgPT09IHR5cGVzLm5hbWUpXG4gICAgICB7IHRoaXMucG90ZW50aWFsQXJyb3dBdCA9IHRoaXMuc3RhcnQ7IH1cbiAgICB2YXIgbGVmdCA9IHRoaXMucGFyc2VNYXliZUNvbmRpdGlvbmFsKG5vSW4sIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpO1xuICAgIGlmIChhZnRlckxlZnRQYXJzZSkgeyBsZWZ0ID0gYWZ0ZXJMZWZ0UGFyc2UuY2FsbCh0aGlzLCBsZWZ0LCBzdGFydFBvcywgc3RhcnRMb2MpOyB9XG4gICAgaWYgKHRoaXMudHlwZS5pc0Fzc2lnbikge1xuICAgICAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0UG9zLCBzdGFydExvYyk7XG4gICAgICBub2RlLm9wZXJhdG9yID0gdGhpcy52YWx1ZTtcbiAgICAgIG5vZGUubGVmdCA9IHRoaXMudHlwZSA9PT0gdHlwZXMuZXEgPyB0aGlzLnRvQXNzaWduYWJsZShsZWZ0LCBmYWxzZSwgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycykgOiBsZWZ0O1xuICAgICAgaWYgKCFvd25EZXN0cnVjdHVyaW5nRXJyb3JzKSB7XG4gICAgICAgIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMucGFyZW50aGVzaXplZEFzc2lnbiA9IHJlZkRlc3RydWN0dXJpbmdFcnJvcnMudHJhaWxpbmdDb21tYSA9IHJlZkRlc3RydWN0dXJpbmdFcnJvcnMuZG91YmxlUHJvdG8gPSAtMTtcbiAgICAgIH1cbiAgICAgIGlmIChyZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnNob3J0aGFuZEFzc2lnbiA+PSBub2RlLmxlZnQuc3RhcnQpXG4gICAgICAgIHsgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy5zaG9ydGhhbmRBc3NpZ24gPSAtMTsgfSBcbiAgICAgIHRoaXMuY2hlY2tMVmFsKGxlZnQpO1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICBub2RlLnJpZ2h0ID0gdGhpcy5wYXJzZU1heWJlQXNzaWduKG5vSW4pO1xuICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkFzc2lnbm1lbnRFeHByZXNzaW9uXCIpXG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChvd25EZXN0cnVjdHVyaW5nRXJyb3JzKSB7IHRoaXMuY2hlY2tFeHByZXNzaW9uRXJyb3JzKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMsIHRydWUpOyB9XG4gICAgfVxuICAgIGlmIChvbGRQYXJlbkFzc2lnbiA+IC0xKSB7IHJlZkRlc3RydWN0dXJpbmdFcnJvcnMucGFyZW50aGVzaXplZEFzc2lnbiA9IG9sZFBhcmVuQXNzaWduOyB9XG4gICAgaWYgKG9sZFRyYWlsaW5nQ29tbWEgPiAtMSkgeyByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnRyYWlsaW5nQ29tbWEgPSBvbGRUcmFpbGluZ0NvbW1hOyB9XG4gICAgcmV0dXJuIGxlZnRcbiAgfTtcblxuXG4gIHBwJDMucGFyc2VNYXliZUNvbmRpdGlvbmFsID0gZnVuY3Rpb24obm9JbiwgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycykge1xuICAgIHZhciBzdGFydFBvcyA9IHRoaXMuc3RhcnQsIHN0YXJ0TG9jID0gdGhpcy5zdGFydExvYztcbiAgICB2YXIgZXhwciA9IHRoaXMucGFyc2VFeHByT3BzKG5vSW4sIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpO1xuICAgIGlmICh0aGlzLmNoZWNrRXhwcmVzc2lvbkVycm9ycyhyZWZEZXN0cnVjdHVyaW5nRXJyb3JzKSkgeyByZXR1cm4gZXhwciB9XG4gICAgaWYgKHRoaXMuZWF0KHR5cGVzLnF1ZXN0aW9uKSkge1xuICAgICAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0UG9zLCBzdGFydExvYyk7XG4gICAgICBub2RlLnRlc3QgPSBleHByO1xuICAgICAgbm9kZS5jb25zZXF1ZW50ID0gdGhpcy5wYXJzZU1heWJlQXNzaWduKCk7XG4gICAgICB0aGlzLmV4cGVjdCh0eXBlcy5jb2xvbik7XG4gICAgICBub2RlLmFsdGVybmF0ZSA9IHRoaXMucGFyc2VNYXliZUFzc2lnbihub0luKTtcbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJDb25kaXRpb25hbEV4cHJlc3Npb25cIilcbiAgICB9XG4gICAgcmV0dXJuIGV4cHJcbiAgfTtcblxuXG4gIHBwJDMucGFyc2VFeHByT3BzID0gZnVuY3Rpb24obm9JbiwgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycykge1xuICAgIHZhciBzdGFydFBvcyA9IHRoaXMuc3RhcnQsIHN0YXJ0TG9jID0gdGhpcy5zdGFydExvYztcbiAgICB2YXIgZXhwciA9IHRoaXMucGFyc2VNYXliZVVuYXJ5KHJlZkRlc3RydWN0dXJpbmdFcnJvcnMsIGZhbHNlKTtcbiAgICBpZiAodGhpcy5jaGVja0V4cHJlc3Npb25FcnJvcnMocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycykpIHsgcmV0dXJuIGV4cHIgfVxuICAgIHJldHVybiBleHByLnN0YXJ0ID09PSBzdGFydFBvcyAmJiBleHByLnR5cGUgPT09IFwiQXJyb3dGdW5jdGlvbkV4cHJlc3Npb25cIiA/IGV4cHIgOiB0aGlzLnBhcnNlRXhwck9wKGV4cHIsIHN0YXJ0UG9zLCBzdGFydExvYywgLTEsIG5vSW4pXG4gIH07XG5cblxuICBwcCQzLnBhcnNlRXhwck9wID0gZnVuY3Rpb24obGVmdCwgbGVmdFN0YXJ0UG9zLCBsZWZ0U3RhcnRMb2MsIG1pblByZWMsIG5vSW4pIHtcbiAgICB2YXIgcHJlYyA9IHRoaXMudHlwZS5iaW5vcDtcbiAgICBpZiAocHJlYyAhPSBudWxsICYmICghbm9JbiB8fCB0aGlzLnR5cGUgIT09IHR5cGVzLl9pbikpIHtcbiAgICAgIGlmIChwcmVjID4gbWluUHJlYykge1xuICAgICAgICB2YXIgbG9naWNhbCA9IHRoaXMudHlwZSA9PT0gdHlwZXMubG9naWNhbE9SIHx8IHRoaXMudHlwZSA9PT0gdHlwZXMubG9naWNhbEFORDtcbiAgICAgICAgdmFyIG9wID0gdGhpcy52YWx1ZTtcbiAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgIHZhciBzdGFydFBvcyA9IHRoaXMuc3RhcnQsIHN0YXJ0TG9jID0gdGhpcy5zdGFydExvYztcbiAgICAgICAgdmFyIHJpZ2h0ID0gdGhpcy5wYXJzZUV4cHJPcCh0aGlzLnBhcnNlTWF5YmVVbmFyeShudWxsLCBmYWxzZSksIHN0YXJ0UG9zLCBzdGFydExvYywgcHJlYywgbm9Jbik7XG4gICAgICAgIHZhciBub2RlID0gdGhpcy5idWlsZEJpbmFyeShsZWZ0U3RhcnRQb3MsIGxlZnRTdGFydExvYywgbGVmdCwgcmlnaHQsIG9wLCBsb2dpY2FsKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VFeHByT3Aobm9kZSwgbGVmdFN0YXJ0UG9zLCBsZWZ0U3RhcnRMb2MsIG1pblByZWMsIG5vSW4pXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBsZWZ0XG4gIH07XG5cbiAgcHAkMy5idWlsZEJpbmFyeSA9IGZ1bmN0aW9uKHN0YXJ0UG9zLCBzdGFydExvYywgbGVmdCwgcmlnaHQsIG9wLCBsb2dpY2FsKSB7XG4gICAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0UG9zLCBzdGFydExvYyk7XG4gICAgbm9kZS5sZWZ0ID0gbGVmdDtcbiAgICBub2RlLm9wZXJhdG9yID0gb3A7XG4gICAgbm9kZS5yaWdodCA9IHJpZ2h0O1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgbG9naWNhbCA/IFwiTG9naWNhbEV4cHJlc3Npb25cIiA6IFwiQmluYXJ5RXhwcmVzc2lvblwiKVxuICB9O1xuXG5cbiAgcHAkMy5wYXJzZU1heWJlVW5hcnkgPSBmdW5jdGlvbihyZWZEZXN0cnVjdHVyaW5nRXJyb3JzLCBzYXdVbmFyeSkge1xuICAgIHZhciBzdGFydFBvcyA9IHRoaXMuc3RhcnQsIHN0YXJ0TG9jID0gdGhpcy5zdGFydExvYywgZXhwcjtcbiAgICBpZiAodGhpcy5pc0NvbnRleHR1YWwoXCJhd2FpdFwiKSAmJiAodGhpcy5pbkFzeW5jIHx8ICghdGhpcy5pbkZ1bmN0aW9uICYmIHRoaXMub3B0aW9ucy5hbGxvd0F3YWl0T3V0c2lkZUZ1bmN0aW9uKSkpIHtcbiAgICAgIGV4cHIgPSB0aGlzLnBhcnNlQXdhaXQoKTtcbiAgICAgIHNhd1VuYXJ5ID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKHRoaXMudHlwZS5wcmVmaXgpIHtcbiAgICAgIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGUoKSwgdXBkYXRlID0gdGhpcy50eXBlID09PSB0eXBlcy5pbmNEZWM7XG4gICAgICBub2RlLm9wZXJhdG9yID0gdGhpcy52YWx1ZTtcbiAgICAgIG5vZGUucHJlZml4ID0gdHJ1ZTtcbiAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgbm9kZS5hcmd1bWVudCA9IHRoaXMucGFyc2VNYXliZVVuYXJ5KG51bGwsIHRydWUpO1xuICAgICAgdGhpcy5jaGVja0V4cHJlc3Npb25FcnJvcnMocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycywgdHJ1ZSk7XG4gICAgICBpZiAodXBkYXRlKSB7IHRoaXMuY2hlY2tMVmFsKG5vZGUuYXJndW1lbnQpOyB9XG4gICAgICBlbHNlIGlmICh0aGlzLnN0cmljdCAmJiBub2RlLm9wZXJhdG9yID09PSBcImRlbGV0ZVwiICYmXG4gICAgICAgICAgICAgICBub2RlLmFyZ3VtZW50LnR5cGUgPT09IFwiSWRlbnRpZmllclwiKVxuICAgICAgICB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZShub2RlLnN0YXJ0LCBcIkRlbGV0aW5nIGxvY2FsIHZhcmlhYmxlIGluIHN0cmljdCBtb2RlXCIpOyB9XG4gICAgICBlbHNlIHsgc2F3VW5hcnkgPSB0cnVlOyB9XG4gICAgICBleHByID0gdGhpcy5maW5pc2hOb2RlKG5vZGUsIHVwZGF0ZSA/IFwiVXBkYXRlRXhwcmVzc2lvblwiIDogXCJVbmFyeUV4cHJlc3Npb25cIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGV4cHIgPSB0aGlzLnBhcnNlRXhwclN1YnNjcmlwdHMocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyk7XG4gICAgICBpZiAodGhpcy5jaGVja0V4cHJlc3Npb25FcnJvcnMocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycykpIHsgcmV0dXJuIGV4cHIgfVxuICAgICAgd2hpbGUgKHRoaXMudHlwZS5wb3N0Zml4ICYmICF0aGlzLmNhbkluc2VydFNlbWljb2xvbigpKSB7XG4gICAgICAgIHZhciBub2RlJDEgPSB0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0UG9zLCBzdGFydExvYyk7XG4gICAgICAgIG5vZGUkMS5vcGVyYXRvciA9IHRoaXMudmFsdWU7XG4gICAgICAgIG5vZGUkMS5wcmVmaXggPSBmYWxzZTtcbiAgICAgICAgbm9kZSQxLmFyZ3VtZW50ID0gZXhwcjtcbiAgICAgICAgdGhpcy5jaGVja0xWYWwoZXhwcik7XG4gICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICBleHByID0gdGhpcy5maW5pc2hOb2RlKG5vZGUkMSwgXCJVcGRhdGVFeHByZXNzaW9uXCIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghc2F3VW5hcnkgJiYgdGhpcy5lYXQodHlwZXMuc3RhcnN0YXIpKVxuICAgICAgeyByZXR1cm4gdGhpcy5idWlsZEJpbmFyeShzdGFydFBvcywgc3RhcnRMb2MsIGV4cHIsIHRoaXMucGFyc2VNYXliZVVuYXJ5KG51bGwsIGZhbHNlKSwgXCIqKlwiLCBmYWxzZSkgfVxuICAgIGVsc2VcbiAgICAgIHsgcmV0dXJuIGV4cHIgfVxuICB9O1xuXG5cbiAgcHAkMy5wYXJzZUV4cHJTdWJzY3JpcHRzID0gZnVuY3Rpb24ocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycykge1xuICAgIHZhciBzdGFydFBvcyA9IHRoaXMuc3RhcnQsIHN0YXJ0TG9jID0gdGhpcy5zdGFydExvYztcbiAgICB2YXIgZXhwciA9IHRoaXMucGFyc2VFeHByQXRvbShyZWZEZXN0cnVjdHVyaW5nRXJyb3JzKTtcbiAgICBpZiAoZXhwci50eXBlID09PSBcIkFycm93RnVuY3Rpb25FeHByZXNzaW9uXCIgJiYgdGhpcy5pbnB1dC5zbGljZSh0aGlzLmxhc3RUb2tTdGFydCwgdGhpcy5sYXN0VG9rRW5kKSAhPT0gXCIpXCIpXG4gICAgICB7IHJldHVybiBleHByIH1cbiAgICB2YXIgcmVzdWx0ID0gdGhpcy5wYXJzZVN1YnNjcmlwdHMoZXhwciwgc3RhcnRQb3MsIHN0YXJ0TG9jKTtcbiAgICBpZiAocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyAmJiByZXN1bHQudHlwZSA9PT0gXCJNZW1iZXJFeHByZXNzaW9uXCIpIHtcbiAgICAgIGlmIChyZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnBhcmVudGhlc2l6ZWRBc3NpZ24gPj0gcmVzdWx0LnN0YXJ0KSB7IHJlZkRlc3RydWN0dXJpbmdFcnJvcnMucGFyZW50aGVzaXplZEFzc2lnbiA9IC0xOyB9XG4gICAgICBpZiAocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy5wYXJlbnRoZXNpemVkQmluZCA+PSByZXN1bHQuc3RhcnQpIHsgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy5wYXJlbnRoZXNpemVkQmluZCA9IC0xOyB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHRcbiAgfTtcblxuICBwcCQzLnBhcnNlU3Vic2NyaXB0cyA9IGZ1bmN0aW9uKGJhc2UsIHN0YXJ0UG9zLCBzdGFydExvYywgbm9DYWxscykge1xuICAgIHZhciBtYXliZUFzeW5jQXJyb3cgPSB0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOCAmJiBiYXNlLnR5cGUgPT09IFwiSWRlbnRpZmllclwiICYmIGJhc2UubmFtZSA9PT0gXCJhc3luY1wiICYmXG4gICAgICAgIHRoaXMubGFzdFRva0VuZCA9PT0gYmFzZS5lbmQgJiYgIXRoaXMuY2FuSW5zZXJ0U2VtaWNvbG9uKCkgJiYgdGhpcy5pbnB1dC5zbGljZShiYXNlLnN0YXJ0LCBiYXNlLmVuZCkgPT09IFwiYXN5bmNcIjtcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgdmFyIGVsZW1lbnQgPSB0aGlzLnBhcnNlU3Vic2NyaXB0KGJhc2UsIHN0YXJ0UG9zLCBzdGFydExvYywgbm9DYWxscywgbWF5YmVBc3luY0Fycm93KTtcbiAgICAgIGlmIChlbGVtZW50ID09PSBiYXNlIHx8IGVsZW1lbnQudHlwZSA9PT0gXCJBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvblwiKSB7IHJldHVybiBlbGVtZW50IH1cbiAgICAgIGJhc2UgPSBlbGVtZW50O1xuICAgIH1cbiAgfTtcblxuICBwcCQzLnBhcnNlU3Vic2NyaXB0ID0gZnVuY3Rpb24oYmFzZSwgc3RhcnRQb3MsIHN0YXJ0TG9jLCBub0NhbGxzLCBtYXliZUFzeW5jQXJyb3cpIHtcbiAgICB2YXIgY29tcHV0ZWQgPSB0aGlzLmVhdCh0eXBlcy5icmFja2V0TCk7XG4gICAgaWYgKGNvbXB1dGVkIHx8IHRoaXMuZWF0KHR5cGVzLmRvdCkpIHtcbiAgICAgIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGVBdChzdGFydFBvcywgc3RhcnRMb2MpO1xuICAgICAgbm9kZS5vYmplY3QgPSBiYXNlO1xuICAgICAgbm9kZS5wcm9wZXJ0eSA9IGNvbXB1dGVkID8gdGhpcy5wYXJzZUV4cHJlc3Npb24oKSA6IHRoaXMucGFyc2VJZGVudCh0aGlzLm9wdGlvbnMuYWxsb3dSZXNlcnZlZCAhPT0gXCJuZXZlclwiKTtcbiAgICAgIG5vZGUuY29tcHV0ZWQgPSAhIWNvbXB1dGVkO1xuICAgICAgaWYgKGNvbXB1dGVkKSB7IHRoaXMuZXhwZWN0KHR5cGVzLmJyYWNrZXRSKTsgfVxuICAgICAgYmFzZSA9IHRoaXMuZmluaXNoTm9kZShub2RlLCBcIk1lbWJlckV4cHJlc3Npb25cIik7XG4gICAgfSBlbHNlIGlmICghbm9DYWxscyAmJiB0aGlzLmVhdCh0eXBlcy5wYXJlbkwpKSB7XG4gICAgICB2YXIgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyA9IG5ldyBEZXN0cnVjdHVyaW5nRXJyb3JzLCBvbGRZaWVsZFBvcyA9IHRoaXMueWllbGRQb3MsIG9sZEF3YWl0UG9zID0gdGhpcy5hd2FpdFBvcywgb2xkQXdhaXRJZGVudFBvcyA9IHRoaXMuYXdhaXRJZGVudFBvcztcbiAgICAgIHRoaXMueWllbGRQb3MgPSAwO1xuICAgICAgdGhpcy5hd2FpdFBvcyA9IDA7XG4gICAgICB0aGlzLmF3YWl0SWRlbnRQb3MgPSAwO1xuICAgICAgdmFyIGV4cHJMaXN0ID0gdGhpcy5wYXJzZUV4cHJMaXN0KHR5cGVzLnBhcmVuUiwgdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDgsIGZhbHNlLCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKTtcbiAgICAgIGlmIChtYXliZUFzeW5jQXJyb3cgJiYgIXRoaXMuY2FuSW5zZXJ0U2VtaWNvbG9uKCkgJiYgdGhpcy5lYXQodHlwZXMuYXJyb3cpKSB7XG4gICAgICAgIHRoaXMuY2hlY2tQYXR0ZXJuRXJyb3JzKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMsIGZhbHNlKTtcbiAgICAgICAgdGhpcy5jaGVja1lpZWxkQXdhaXRJbkRlZmF1bHRQYXJhbXMoKTtcbiAgICAgICAgaWYgKHRoaXMuYXdhaXRJZGVudFBvcyA+IDApXG4gICAgICAgICAgeyB0aGlzLnJhaXNlKHRoaXMuYXdhaXRJZGVudFBvcywgXCJDYW5ub3QgdXNlICdhd2FpdCcgYXMgaWRlbnRpZmllciBpbnNpZGUgYW4gYXN5bmMgZnVuY3Rpb25cIik7IH1cbiAgICAgICAgdGhpcy55aWVsZFBvcyA9IG9sZFlpZWxkUG9zO1xuICAgICAgICB0aGlzLmF3YWl0UG9zID0gb2xkQXdhaXRQb3M7XG4gICAgICAgIHRoaXMuYXdhaXRJZGVudFBvcyA9IG9sZEF3YWl0SWRlbnRQb3M7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlQXJyb3dFeHByZXNzaW9uKHRoaXMuc3RhcnROb2RlQXQoc3RhcnRQb3MsIHN0YXJ0TG9jKSwgZXhwckxpc3QsIHRydWUpXG4gICAgICB9XG4gICAgICB0aGlzLmNoZWNrRXhwcmVzc2lvbkVycm9ycyhyZWZEZXN0cnVjdHVyaW5nRXJyb3JzLCB0cnVlKTtcbiAgICAgIHRoaXMueWllbGRQb3MgPSBvbGRZaWVsZFBvcyB8fCB0aGlzLnlpZWxkUG9zO1xuICAgICAgdGhpcy5hd2FpdFBvcyA9IG9sZEF3YWl0UG9zIHx8IHRoaXMuYXdhaXRQb3M7XG4gICAgICB0aGlzLmF3YWl0SWRlbnRQb3MgPSBvbGRBd2FpdElkZW50UG9zIHx8IHRoaXMuYXdhaXRJZGVudFBvcztcbiAgICAgIHZhciBub2RlJDEgPSB0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0UG9zLCBzdGFydExvYyk7XG4gICAgICBub2RlJDEuY2FsbGVlID0gYmFzZTtcbiAgICAgIG5vZGUkMS5hcmd1bWVudHMgPSBleHByTGlzdDtcbiAgICAgIGJhc2UgPSB0aGlzLmZpbmlzaE5vZGUobm9kZSQxLCBcIkNhbGxFeHByZXNzaW9uXCIpO1xuICAgIH0gZWxzZSBpZiAodGhpcy50eXBlID09PSB0eXBlcy5iYWNrUXVvdGUpIHtcbiAgICAgIHZhciBub2RlJDIgPSB0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0UG9zLCBzdGFydExvYyk7XG4gICAgICBub2RlJDIudGFnID0gYmFzZTtcbiAgICAgIG5vZGUkMi5xdWFzaSA9IHRoaXMucGFyc2VUZW1wbGF0ZSh7aXNUYWdnZWQ6IHRydWV9KTtcbiAgICAgIGJhc2UgPSB0aGlzLmZpbmlzaE5vZGUobm9kZSQyLCBcIlRhZ2dlZFRlbXBsYXRlRXhwcmVzc2lvblwiKTtcbiAgICB9XG4gICAgcmV0dXJuIGJhc2VcbiAgfTtcblxuXG4gIHBwJDMucGFyc2VFeHByQXRvbSA9IGZ1bmN0aW9uKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpIHtcbiAgICBpZiAodGhpcy50eXBlID09PSB0eXBlcy5zbGFzaCkgeyB0aGlzLnJlYWRSZWdleHAoKTsgfVxuXG4gICAgdmFyIG5vZGUsIGNhbkJlQXJyb3cgPSB0aGlzLnBvdGVudGlhbEFycm93QXQgPT09IHRoaXMuc3RhcnQ7XG4gICAgc3dpdGNoICh0aGlzLnR5cGUpIHtcbiAgICBjYXNlIHR5cGVzLl9zdXBlcjpcbiAgICAgIGlmICghdGhpcy5hbGxvd1N1cGVyKVxuICAgICAgICB7IHRoaXMucmFpc2UodGhpcy5zdGFydCwgXCInc3VwZXInIGtleXdvcmQgb3V0c2lkZSBhIG1ldGhvZFwiKTsgfVxuICAgICAgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICAgIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzLnBhcmVuTCAmJiAhdGhpcy5hbGxvd0RpcmVjdFN1cGVyKVxuICAgICAgICB7IHRoaXMucmFpc2Uobm9kZS5zdGFydCwgXCJzdXBlcigpIGNhbGwgb3V0c2lkZSBjb25zdHJ1Y3RvciBvZiBhIHN1YmNsYXNzXCIpOyB9XG4gICAgICBpZiAodGhpcy50eXBlICE9PSB0eXBlcy5kb3QgJiYgdGhpcy50eXBlICE9PSB0eXBlcy5icmFja2V0TCAmJiB0aGlzLnR5cGUgIT09IHR5cGVzLnBhcmVuTClcbiAgICAgICAgeyB0aGlzLnVuZXhwZWN0ZWQoKTsgfVxuICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlN1cGVyXCIpXG5cbiAgICBjYXNlIHR5cGVzLl90aGlzOlxuICAgICAgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJUaGlzRXhwcmVzc2lvblwiKVxuXG4gICAgY2FzZSB0eXBlcy5uYW1lOlxuICAgICAgdmFyIHN0YXJ0UG9zID0gdGhpcy5zdGFydCwgc3RhcnRMb2MgPSB0aGlzLnN0YXJ0TG9jLCBjb250YWluc0VzYyA9IHRoaXMuY29udGFpbnNFc2M7XG4gICAgICB2YXIgaWQgPSB0aGlzLnBhcnNlSWRlbnQoZmFsc2UpO1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA4ICYmICFjb250YWluc0VzYyAmJiBpZC5uYW1lID09PSBcImFzeW5jXCIgJiYgIXRoaXMuY2FuSW5zZXJ0U2VtaWNvbG9uKCkgJiYgdGhpcy5lYXQodHlwZXMuX2Z1bmN0aW9uKSlcbiAgICAgICAgeyByZXR1cm4gdGhpcy5wYXJzZUZ1bmN0aW9uKHRoaXMuc3RhcnROb2RlQXQoc3RhcnRQb3MsIHN0YXJ0TG9jKSwgMCwgZmFsc2UsIHRydWUpIH1cbiAgICAgIGlmIChjYW5CZUFycm93ICYmICF0aGlzLmNhbkluc2VydFNlbWljb2xvbigpKSB7XG4gICAgICAgIGlmICh0aGlzLmVhdCh0eXBlcy5hcnJvdykpXG4gICAgICAgICAgeyByZXR1cm4gdGhpcy5wYXJzZUFycm93RXhwcmVzc2lvbih0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0UG9zLCBzdGFydExvYyksIFtpZF0sIGZhbHNlKSB9XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOCAmJiBpZC5uYW1lID09PSBcImFzeW5jXCIgJiYgdGhpcy50eXBlID09PSB0eXBlcy5uYW1lICYmICFjb250YWluc0VzYykge1xuICAgICAgICAgIGlkID0gdGhpcy5wYXJzZUlkZW50KGZhbHNlKTtcbiAgICAgICAgICBpZiAodGhpcy5jYW5JbnNlcnRTZW1pY29sb24oKSB8fCAhdGhpcy5lYXQodHlwZXMuYXJyb3cpKVxuICAgICAgICAgICAgeyB0aGlzLnVuZXhwZWN0ZWQoKTsgfVxuICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlQXJyb3dFeHByZXNzaW9uKHRoaXMuc3RhcnROb2RlQXQoc3RhcnRQb3MsIHN0YXJ0TG9jKSwgW2lkXSwgdHJ1ZSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGlkXG5cbiAgICBjYXNlIHR5cGVzLnJlZ2V4cDpcbiAgICAgIHZhciB2YWx1ZSA9IHRoaXMudmFsdWU7XG4gICAgICBub2RlID0gdGhpcy5wYXJzZUxpdGVyYWwodmFsdWUudmFsdWUpO1xuICAgICAgbm9kZS5yZWdleCA9IHtwYXR0ZXJuOiB2YWx1ZS5wYXR0ZXJuLCBmbGFnczogdmFsdWUuZmxhZ3N9O1xuICAgICAgcmV0dXJuIG5vZGVcblxuICAgIGNhc2UgdHlwZXMubnVtOiBjYXNlIHR5cGVzLnN0cmluZzpcbiAgICAgIHJldHVybiB0aGlzLnBhcnNlTGl0ZXJhbCh0aGlzLnZhbHVlKVxuXG4gICAgY2FzZSB0eXBlcy5fbnVsbDogY2FzZSB0eXBlcy5fdHJ1ZTogY2FzZSB0eXBlcy5fZmFsc2U6XG4gICAgICBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICAgIG5vZGUudmFsdWUgPSB0aGlzLnR5cGUgPT09IHR5cGVzLl9udWxsID8gbnVsbCA6IHRoaXMudHlwZSA9PT0gdHlwZXMuX3RydWU7XG4gICAgICBub2RlLnJhdyA9IHRoaXMudHlwZS5rZXl3b3JkO1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiTGl0ZXJhbFwiKVxuXG4gICAgY2FzZSB0eXBlcy5wYXJlbkw6XG4gICAgICB2YXIgc3RhcnQgPSB0aGlzLnN0YXJ0LCBleHByID0gdGhpcy5wYXJzZVBhcmVuQW5kRGlzdGluZ3Vpc2hFeHByZXNzaW9uKGNhbkJlQXJyb3cpO1xuICAgICAgaWYgKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpIHtcbiAgICAgICAgaWYgKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMucGFyZW50aGVzaXplZEFzc2lnbiA8IDAgJiYgIXRoaXMuaXNTaW1wbGVBc3NpZ25UYXJnZXQoZXhwcikpXG4gICAgICAgICAgeyByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnBhcmVudGhlc2l6ZWRBc3NpZ24gPSBzdGFydDsgfVxuICAgICAgICBpZiAocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy5wYXJlbnRoZXNpemVkQmluZCA8IDApXG4gICAgICAgICAgeyByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnBhcmVudGhlc2l6ZWRCaW5kID0gc3RhcnQ7IH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBleHByXG5cbiAgICBjYXNlIHR5cGVzLmJyYWNrZXRMOlxuICAgICAgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICAgIG5vZGUuZWxlbWVudHMgPSB0aGlzLnBhcnNlRXhwckxpc3QodHlwZXMuYnJhY2tldFIsIHRydWUsIHRydWUsIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpO1xuICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkFycmF5RXhwcmVzc2lvblwiKVxuXG4gICAgY2FzZSB0eXBlcy5icmFjZUw6XG4gICAgICByZXR1cm4gdGhpcy5wYXJzZU9iaihmYWxzZSwgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycylcblxuICAgIGNhc2UgdHlwZXMuX2Z1bmN0aW9uOlxuICAgICAgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICAgIHJldHVybiB0aGlzLnBhcnNlRnVuY3Rpb24obm9kZSwgMClcblxuICAgIGNhc2UgdHlwZXMuX2NsYXNzOlxuICAgICAgcmV0dXJuIHRoaXMucGFyc2VDbGFzcyh0aGlzLnN0YXJ0Tm9kZSgpLCBmYWxzZSlcblxuICAgIGNhc2UgdHlwZXMuX25ldzpcbiAgICAgIHJldHVybiB0aGlzLnBhcnNlTmV3KClcblxuICAgIGNhc2UgdHlwZXMuYmFja1F1b3RlOlxuICAgICAgcmV0dXJuIHRoaXMucGFyc2VUZW1wbGF0ZSgpXG5cbiAgICBjYXNlIHR5cGVzLl9pbXBvcnQ6XG4gICAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDExKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlRXhwckltcG9ydCgpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy51bmV4cGVjdGVkKClcbiAgICAgIH1cblxuICAgIGRlZmF1bHQ6XG4gICAgICB0aGlzLnVuZXhwZWN0ZWQoKTtcbiAgICB9XG4gIH07XG5cbiAgcHAkMy5wYXJzZUV4cHJJbXBvcnQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgdGhpcy5uZXh0KCk7IFxuICAgIHN3aXRjaCAodGhpcy50eXBlKSB7XG4gICAgY2FzZSB0eXBlcy5wYXJlbkw6XG4gICAgICByZXR1cm4gdGhpcy5wYXJzZUR5bmFtaWNJbXBvcnQobm9kZSlcbiAgICBkZWZhdWx0OlxuICAgICAgdGhpcy51bmV4cGVjdGVkKCk7XG4gICAgfVxuICB9O1xuXG4gIHBwJDMucGFyc2VEeW5hbWljSW1wb3J0ID0gZnVuY3Rpb24obm9kZSkge1xuICAgIHRoaXMubmV4dCgpOyBcblxuICAgIG5vZGUuc291cmNlID0gdGhpcy5wYXJzZU1heWJlQXNzaWduKCk7XG5cbiAgICBpZiAoIXRoaXMuZWF0KHR5cGVzLnBhcmVuUikpIHtcbiAgICAgIHZhciBlcnJvclBvcyA9IHRoaXMuc3RhcnQ7XG4gICAgICBpZiAodGhpcy5lYXQodHlwZXMuY29tbWEpICYmIHRoaXMuZWF0KHR5cGVzLnBhcmVuUikpIHtcbiAgICAgICAgdGhpcy5yYWlzZVJlY292ZXJhYmxlKGVycm9yUG9zLCBcIlRyYWlsaW5nIGNvbW1hIGlzIG5vdCBhbGxvd2VkIGluIGltcG9ydCgpXCIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy51bmV4cGVjdGVkKGVycm9yUG9zKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiSW1wb3J0RXhwcmVzc2lvblwiKVxuICB9O1xuXG4gIHBwJDMucGFyc2VMaXRlcmFsID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgbm9kZS52YWx1ZSA9IHZhbHVlO1xuICAgIG5vZGUucmF3ID0gdGhpcy5pbnB1dC5zbGljZSh0aGlzLnN0YXJ0LCB0aGlzLmVuZCk7XG4gICAgaWYgKG5vZGUucmF3LmNoYXJDb2RlQXQobm9kZS5yYXcubGVuZ3RoIC0gMSkgPT09IDExMCkgeyBub2RlLmJpZ2ludCA9IG5vZGUucmF3LnNsaWNlKDAsIC0xKTsgfVxuICAgIHRoaXMubmV4dCgpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJMaXRlcmFsXCIpXG4gIH07XG5cbiAgcHAkMy5wYXJzZVBhcmVuRXhwcmVzc2lvbiA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuZXhwZWN0KHR5cGVzLnBhcmVuTCk7XG4gICAgdmFyIHZhbCA9IHRoaXMucGFyc2VFeHByZXNzaW9uKCk7XG4gICAgdGhpcy5leHBlY3QodHlwZXMucGFyZW5SKTtcbiAgICByZXR1cm4gdmFsXG4gIH07XG5cbiAgcHAkMy5wYXJzZVBhcmVuQW5kRGlzdGluZ3Vpc2hFeHByZXNzaW9uID0gZnVuY3Rpb24oY2FuQmVBcnJvdykge1xuICAgIHZhciBzdGFydFBvcyA9IHRoaXMuc3RhcnQsIHN0YXJ0TG9jID0gdGhpcy5zdGFydExvYywgdmFsLCBhbGxvd1RyYWlsaW5nQ29tbWEgPSB0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gODtcbiAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDYpIHtcbiAgICAgIHRoaXMubmV4dCgpO1xuXG4gICAgICB2YXIgaW5uZXJTdGFydFBvcyA9IHRoaXMuc3RhcnQsIGlubmVyU3RhcnRMb2MgPSB0aGlzLnN0YXJ0TG9jO1xuICAgICAgdmFyIGV4cHJMaXN0ID0gW10sIGZpcnN0ID0gdHJ1ZSwgbGFzdElzQ29tbWEgPSBmYWxzZTtcbiAgICAgIHZhciByZWZEZXN0cnVjdHVyaW5nRXJyb3JzID0gbmV3IERlc3RydWN0dXJpbmdFcnJvcnMsIG9sZFlpZWxkUG9zID0gdGhpcy55aWVsZFBvcywgb2xkQXdhaXRQb3MgPSB0aGlzLmF3YWl0UG9zLCBzcHJlYWRTdGFydDtcbiAgICAgIHRoaXMueWllbGRQb3MgPSAwO1xuICAgICAgdGhpcy5hd2FpdFBvcyA9IDA7XG4gICAgICB3aGlsZSAodGhpcy50eXBlICE9PSB0eXBlcy5wYXJlblIpIHtcbiAgICAgICAgZmlyc3QgPyBmaXJzdCA9IGZhbHNlIDogdGhpcy5leHBlY3QodHlwZXMuY29tbWEpO1xuICAgICAgICBpZiAoYWxsb3dUcmFpbGluZ0NvbW1hICYmIHRoaXMuYWZ0ZXJUcmFpbGluZ0NvbW1hKHR5cGVzLnBhcmVuUiwgdHJ1ZSkpIHtcbiAgICAgICAgICBsYXN0SXNDb21tYSA9IHRydWU7XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzLmVsbGlwc2lzKSB7XG4gICAgICAgICAgc3ByZWFkU3RhcnQgPSB0aGlzLnN0YXJ0O1xuICAgICAgICAgIGV4cHJMaXN0LnB1c2godGhpcy5wYXJzZVBhcmVuSXRlbSh0aGlzLnBhcnNlUmVzdEJpbmRpbmcoKSkpO1xuICAgICAgICAgIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzLmNvbW1hKSB7IHRoaXMucmFpc2UodGhpcy5zdGFydCwgXCJDb21tYSBpcyBub3QgcGVybWl0dGVkIGFmdGVyIHRoZSByZXN0IGVsZW1lbnRcIik7IH1cbiAgICAgICAgICBicmVha1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGV4cHJMaXN0LnB1c2godGhpcy5wYXJzZU1heWJlQXNzaWduKGZhbHNlLCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLCB0aGlzLnBhcnNlUGFyZW5JdGVtKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciBpbm5lckVuZFBvcyA9IHRoaXMuc3RhcnQsIGlubmVyRW5kTG9jID0gdGhpcy5zdGFydExvYztcbiAgICAgIHRoaXMuZXhwZWN0KHR5cGVzLnBhcmVuUik7XG5cbiAgICAgIGlmIChjYW5CZUFycm93ICYmICF0aGlzLmNhbkluc2VydFNlbWljb2xvbigpICYmIHRoaXMuZWF0KHR5cGVzLmFycm93KSkge1xuICAgICAgICB0aGlzLmNoZWNrUGF0dGVybkVycm9ycyhyZWZEZXN0cnVjdHVyaW5nRXJyb3JzLCBmYWxzZSk7XG4gICAgICAgIHRoaXMuY2hlY2tZaWVsZEF3YWl0SW5EZWZhdWx0UGFyYW1zKCk7XG4gICAgICAgIHRoaXMueWllbGRQb3MgPSBvbGRZaWVsZFBvcztcbiAgICAgICAgdGhpcy5hd2FpdFBvcyA9IG9sZEF3YWl0UG9zO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVBhcmVuQXJyb3dMaXN0KHN0YXJ0UG9zLCBzdGFydExvYywgZXhwckxpc3QpXG4gICAgICB9XG5cbiAgICAgIGlmICghZXhwckxpc3QubGVuZ3RoIHx8IGxhc3RJc0NvbW1hKSB7IHRoaXMudW5leHBlY3RlZCh0aGlzLmxhc3RUb2tTdGFydCk7IH1cbiAgICAgIGlmIChzcHJlYWRTdGFydCkgeyB0aGlzLnVuZXhwZWN0ZWQoc3ByZWFkU3RhcnQpOyB9XG4gICAgICB0aGlzLmNoZWNrRXhwcmVzc2lvbkVycm9ycyhyZWZEZXN0cnVjdHVyaW5nRXJyb3JzLCB0cnVlKTtcbiAgICAgIHRoaXMueWllbGRQb3MgPSBvbGRZaWVsZFBvcyB8fCB0aGlzLnlpZWxkUG9zO1xuICAgICAgdGhpcy5hd2FpdFBvcyA9IG9sZEF3YWl0UG9zIHx8IHRoaXMuYXdhaXRQb3M7XG5cbiAgICAgIGlmIChleHByTGlzdC5sZW5ndGggPiAxKSB7XG4gICAgICAgIHZhbCA9IHRoaXMuc3RhcnROb2RlQXQoaW5uZXJTdGFydFBvcywgaW5uZXJTdGFydExvYyk7XG4gICAgICAgIHZhbC5leHByZXNzaW9ucyA9IGV4cHJMaXN0O1xuICAgICAgICB0aGlzLmZpbmlzaE5vZGVBdCh2YWwsIFwiU2VxdWVuY2VFeHByZXNzaW9uXCIsIGlubmVyRW5kUG9zLCBpbm5lckVuZExvYyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWwgPSBleHByTGlzdFswXTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFsID0gdGhpcy5wYXJzZVBhcmVuRXhwcmVzc2lvbigpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLm9wdGlvbnMucHJlc2VydmVQYXJlbnMpIHtcbiAgICAgIHZhciBwYXIgPSB0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0UG9zLCBzdGFydExvYyk7XG4gICAgICBwYXIuZXhwcmVzc2lvbiA9IHZhbDtcbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUocGFyLCBcIlBhcmVudGhlc2l6ZWRFeHByZXNzaW9uXCIpXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB2YWxcbiAgICB9XG4gIH07XG5cbiAgcHAkMy5wYXJzZVBhcmVuSXRlbSA9IGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICByZXR1cm4gaXRlbVxuICB9O1xuXG4gIHBwJDMucGFyc2VQYXJlbkFycm93TGlzdCA9IGZ1bmN0aW9uKHN0YXJ0UG9zLCBzdGFydExvYywgZXhwckxpc3QpIHtcbiAgICByZXR1cm4gdGhpcy5wYXJzZUFycm93RXhwcmVzc2lvbih0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0UG9zLCBzdGFydExvYyksIGV4cHJMaXN0KVxuICB9O1xuXG5cbiAgdmFyIGVtcHR5JDEgPSBbXTtcblxuICBwcCQzLnBhcnNlTmV3ID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuY29udGFpbnNFc2MpIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKHRoaXMuc3RhcnQsIFwiRXNjYXBlIHNlcXVlbmNlIGluIGtleXdvcmQgbmV3XCIpOyB9XG4gICAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIHZhciBtZXRhID0gdGhpcy5wYXJzZUlkZW50KHRydWUpO1xuICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNiAmJiB0aGlzLmVhdCh0eXBlcy5kb3QpKSB7XG4gICAgICBub2RlLm1ldGEgPSBtZXRhO1xuICAgICAgdmFyIGNvbnRhaW5zRXNjID0gdGhpcy5jb250YWluc0VzYztcbiAgICAgIG5vZGUucHJvcGVydHkgPSB0aGlzLnBhcnNlSWRlbnQodHJ1ZSk7XG4gICAgICBpZiAobm9kZS5wcm9wZXJ0eS5uYW1lICE9PSBcInRhcmdldFwiIHx8IGNvbnRhaW5zRXNjKVxuICAgICAgICB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZShub2RlLnByb3BlcnR5LnN0YXJ0LCBcIlRoZSBvbmx5IHZhbGlkIG1ldGEgcHJvcGVydHkgZm9yIG5ldyBpcyBuZXcudGFyZ2V0XCIpOyB9XG4gICAgICBpZiAoIXRoaXMuaW5Ob25BcnJvd0Z1bmN0aW9uKCkpXG4gICAgICAgIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKG5vZGUuc3RhcnQsIFwibmV3LnRhcmdldCBjYW4gb25seSBiZSB1c2VkIGluIGZ1bmN0aW9uc1wiKTsgfVxuICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIk1ldGFQcm9wZXJ0eVwiKVxuICAgIH1cbiAgICB2YXIgc3RhcnRQb3MgPSB0aGlzLnN0YXJ0LCBzdGFydExvYyA9IHRoaXMuc3RhcnRMb2MsIGlzSW1wb3J0ID0gdGhpcy50eXBlID09PSB0eXBlcy5faW1wb3J0O1xuICAgIG5vZGUuY2FsbGVlID0gdGhpcy5wYXJzZVN1YnNjcmlwdHModGhpcy5wYXJzZUV4cHJBdG9tKCksIHN0YXJ0UG9zLCBzdGFydExvYywgdHJ1ZSk7XG4gICAgaWYgKGlzSW1wb3J0ICYmIG5vZGUuY2FsbGVlLnR5cGUgPT09IFwiSW1wb3J0RXhwcmVzc2lvblwiKSB7XG4gICAgICB0aGlzLnJhaXNlKHN0YXJ0UG9zLCBcIkNhbm5vdCB1c2UgbmV3IHdpdGggaW1wb3J0KClcIik7XG4gICAgfVxuICAgIGlmICh0aGlzLmVhdCh0eXBlcy5wYXJlbkwpKSB7IG5vZGUuYXJndW1lbnRzID0gdGhpcy5wYXJzZUV4cHJMaXN0KHR5cGVzLnBhcmVuUiwgdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDgsIGZhbHNlKTsgfVxuICAgIGVsc2UgeyBub2RlLmFyZ3VtZW50cyA9IGVtcHR5JDE7IH1cbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiTmV3RXhwcmVzc2lvblwiKVxuICB9O1xuXG5cbiAgcHAkMy5wYXJzZVRlbXBsYXRlRWxlbWVudCA9IGZ1bmN0aW9uKHJlZikge1xuICAgIHZhciBpc1RhZ2dlZCA9IHJlZi5pc1RhZ2dlZDtcblxuICAgIHZhciBlbGVtID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICBpZiAodGhpcy50eXBlID09PSB0eXBlcy5pbnZhbGlkVGVtcGxhdGUpIHtcbiAgICAgIGlmICghaXNUYWdnZWQpIHtcbiAgICAgICAgdGhpcy5yYWlzZVJlY292ZXJhYmxlKHRoaXMuc3RhcnQsIFwiQmFkIGVzY2FwZSBzZXF1ZW5jZSBpbiB1bnRhZ2dlZCB0ZW1wbGF0ZSBsaXRlcmFsXCIpO1xuICAgICAgfVxuICAgICAgZWxlbS52YWx1ZSA9IHtcbiAgICAgICAgcmF3OiB0aGlzLnZhbHVlLFxuICAgICAgICBjb29rZWQ6IG51bGxcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsZW0udmFsdWUgPSB7XG4gICAgICAgIHJhdzogdGhpcy5pbnB1dC5zbGljZSh0aGlzLnN0YXJ0LCB0aGlzLmVuZCkucmVwbGFjZSgvXFxyXFxuPy9nLCBcIlxcblwiKSxcbiAgICAgICAgY29va2VkOiB0aGlzLnZhbHVlXG4gICAgICB9O1xuICAgIH1cbiAgICB0aGlzLm5leHQoKTtcbiAgICBlbGVtLnRhaWwgPSB0aGlzLnR5cGUgPT09IHR5cGVzLmJhY2tRdW90ZTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKGVsZW0sIFwiVGVtcGxhdGVFbGVtZW50XCIpXG4gIH07XG5cbiAgcHAkMy5wYXJzZVRlbXBsYXRlID0gZnVuY3Rpb24ocmVmKSB7XG4gICAgaWYgKCByZWYgPT09IHZvaWQgMCApIHJlZiA9IHt9O1xuICAgIHZhciBpc1RhZ2dlZCA9IHJlZi5pc1RhZ2dlZDsgaWYgKCBpc1RhZ2dlZCA9PT0gdm9pZCAwICkgaXNUYWdnZWQgPSBmYWxzZTtcblxuICAgIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICB0aGlzLm5leHQoKTtcbiAgICBub2RlLmV4cHJlc3Npb25zID0gW107XG4gICAgdmFyIGN1ckVsdCA9IHRoaXMucGFyc2VUZW1wbGF0ZUVsZW1lbnQoe2lzVGFnZ2VkOiBpc1RhZ2dlZH0pO1xuICAgIG5vZGUucXVhc2lzID0gW2N1ckVsdF07XG4gICAgd2hpbGUgKCFjdXJFbHQudGFpbCkge1xuICAgICAgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMuZW9mKSB7IHRoaXMucmFpc2UodGhpcy5wb3MsIFwiVW50ZXJtaW5hdGVkIHRlbXBsYXRlIGxpdGVyYWxcIik7IH1cbiAgICAgIHRoaXMuZXhwZWN0KHR5cGVzLmRvbGxhckJyYWNlTCk7XG4gICAgICBub2RlLmV4cHJlc3Npb25zLnB1c2godGhpcy5wYXJzZUV4cHJlc3Npb24oKSk7XG4gICAgICB0aGlzLmV4cGVjdCh0eXBlcy5icmFjZVIpO1xuICAgICAgbm9kZS5xdWFzaXMucHVzaChjdXJFbHQgPSB0aGlzLnBhcnNlVGVtcGxhdGVFbGVtZW50KHtpc1RhZ2dlZDogaXNUYWdnZWR9KSk7XG4gICAgfVxuICAgIHRoaXMubmV4dCgpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJUZW1wbGF0ZUxpdGVyYWxcIilcbiAgfTtcblxuICBwcCQzLmlzQXN5bmNQcm9wID0gZnVuY3Rpb24ocHJvcCkge1xuICAgIHJldHVybiAhcHJvcC5jb21wdXRlZCAmJiBwcm9wLmtleS50eXBlID09PSBcIklkZW50aWZpZXJcIiAmJiBwcm9wLmtleS5uYW1lID09PSBcImFzeW5jXCIgJiZcbiAgICAgICh0aGlzLnR5cGUgPT09IHR5cGVzLm5hbWUgfHwgdGhpcy50eXBlID09PSB0eXBlcy5udW0gfHwgdGhpcy50eXBlID09PSB0eXBlcy5zdHJpbmcgfHwgdGhpcy50eXBlID09PSB0eXBlcy5icmFja2V0TCB8fCB0aGlzLnR5cGUua2V5d29yZCB8fCAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDkgJiYgdGhpcy50eXBlID09PSB0eXBlcy5zdGFyKSkgJiZcbiAgICAgICFsaW5lQnJlYWsudGVzdCh0aGlzLmlucHV0LnNsaWNlKHRoaXMubGFzdFRva0VuZCwgdGhpcy5zdGFydCkpXG4gIH07XG5cblxuICBwcCQzLnBhcnNlT2JqID0gZnVuY3Rpb24oaXNQYXR0ZXJuLCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKSB7XG4gICAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpLCBmaXJzdCA9IHRydWUsIHByb3BIYXNoID0ge307XG4gICAgbm9kZS5wcm9wZXJ0aWVzID0gW107XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgd2hpbGUgKCF0aGlzLmVhdCh0eXBlcy5icmFjZVIpKSB7XG4gICAgICBpZiAoIWZpcnN0KSB7XG4gICAgICAgIHRoaXMuZXhwZWN0KHR5cGVzLmNvbW1hKTtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA1ICYmIHRoaXMuYWZ0ZXJUcmFpbGluZ0NvbW1hKHR5cGVzLmJyYWNlUikpIHsgYnJlYWsgfVxuICAgICAgfSBlbHNlIHsgZmlyc3QgPSBmYWxzZTsgfVxuXG4gICAgICB2YXIgcHJvcCA9IHRoaXMucGFyc2VQcm9wZXJ0eShpc1BhdHRlcm4sIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpO1xuICAgICAgaWYgKCFpc1BhdHRlcm4pIHsgdGhpcy5jaGVja1Byb3BDbGFzaChwcm9wLCBwcm9wSGFzaCwgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyk7IH1cbiAgICAgIG5vZGUucHJvcGVydGllcy5wdXNoKHByb3ApO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIGlzUGF0dGVybiA/IFwiT2JqZWN0UGF0dGVyblwiIDogXCJPYmplY3RFeHByZXNzaW9uXCIpXG4gIH07XG5cbiAgcHAkMy5wYXJzZVByb3BlcnR5ID0gZnVuY3Rpb24oaXNQYXR0ZXJuLCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKSB7XG4gICAgdmFyIHByb3AgPSB0aGlzLnN0YXJ0Tm9kZSgpLCBpc0dlbmVyYXRvciwgaXNBc3luYywgc3RhcnRQb3MsIHN0YXJ0TG9jO1xuICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOSAmJiB0aGlzLmVhdCh0eXBlcy5lbGxpcHNpcykpIHtcbiAgICAgIGlmIChpc1BhdHRlcm4pIHtcbiAgICAgICAgcHJvcC5hcmd1bWVudCA9IHRoaXMucGFyc2VJZGVudChmYWxzZSk7XG4gICAgICAgIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzLmNvbW1hKSB7XG4gICAgICAgICAgdGhpcy5yYWlzZSh0aGlzLnN0YXJ0LCBcIkNvbW1hIGlzIG5vdCBwZXJtaXR0ZWQgYWZ0ZXIgdGhlIHJlc3QgZWxlbWVudFwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKHByb3AsIFwiUmVzdEVsZW1lbnRcIilcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzLnBhcmVuTCAmJiByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKSB7XG4gICAgICAgIGlmIChyZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnBhcmVudGhlc2l6ZWRBc3NpZ24gPCAwKSB7XG4gICAgICAgICAgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy5wYXJlbnRoZXNpemVkQXNzaWduID0gdGhpcy5zdGFydDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy5wYXJlbnRoZXNpemVkQmluZCA8IDApIHtcbiAgICAgICAgICByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnBhcmVudGhlc2l6ZWRCaW5kID0gdGhpcy5zdGFydDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcHJvcC5hcmd1bWVudCA9IHRoaXMucGFyc2VNYXliZUFzc2lnbihmYWxzZSwgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyk7XG4gICAgICBpZiAodGhpcy50eXBlID09PSB0eXBlcy5jb21tYSAmJiByZWZEZXN0cnVjdHVyaW5nRXJyb3JzICYmIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMudHJhaWxpbmdDb21tYSA8IDApIHtcbiAgICAgICAgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy50cmFpbGluZ0NvbW1hID0gdGhpcy5zdGFydDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUocHJvcCwgXCJTcHJlYWRFbGVtZW50XCIpXG4gICAgfVxuICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNikge1xuICAgICAgcHJvcC5tZXRob2QgPSBmYWxzZTtcbiAgICAgIHByb3Auc2hvcnRoYW5kID0gZmFsc2U7XG4gICAgICBpZiAoaXNQYXR0ZXJuIHx8IHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpIHtcbiAgICAgICAgc3RhcnRQb3MgPSB0aGlzLnN0YXJ0O1xuICAgICAgICBzdGFydExvYyA9IHRoaXMuc3RhcnRMb2M7XG4gICAgICB9XG4gICAgICBpZiAoIWlzUGF0dGVybilcbiAgICAgICAgeyBpc0dlbmVyYXRvciA9IHRoaXMuZWF0KHR5cGVzLnN0YXIpOyB9XG4gICAgfVxuICAgIHZhciBjb250YWluc0VzYyA9IHRoaXMuY29udGFpbnNFc2M7XG4gICAgdGhpcy5wYXJzZVByb3BlcnR5TmFtZShwcm9wKTtcbiAgICBpZiAoIWlzUGF0dGVybiAmJiAhY29udGFpbnNFc2MgJiYgdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDggJiYgIWlzR2VuZXJhdG9yICYmIHRoaXMuaXNBc3luY1Byb3AocHJvcCkpIHtcbiAgICAgIGlzQXN5bmMgPSB0cnVlO1xuICAgICAgaXNHZW5lcmF0b3IgPSB0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOSAmJiB0aGlzLmVhdCh0eXBlcy5zdGFyKTtcbiAgICAgIHRoaXMucGFyc2VQcm9wZXJ0eU5hbWUocHJvcCwgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlzQXN5bmMgPSBmYWxzZTtcbiAgICB9XG4gICAgdGhpcy5wYXJzZVByb3BlcnR5VmFsdWUocHJvcCwgaXNQYXR0ZXJuLCBpc0dlbmVyYXRvciwgaXNBc3luYywgc3RhcnRQb3MsIHN0YXJ0TG9jLCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLCBjb250YWluc0VzYyk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShwcm9wLCBcIlByb3BlcnR5XCIpXG4gIH07XG5cbiAgcHAkMy5wYXJzZVByb3BlcnR5VmFsdWUgPSBmdW5jdGlvbihwcm9wLCBpc1BhdHRlcm4sIGlzR2VuZXJhdG9yLCBpc0FzeW5jLCBzdGFydFBvcywgc3RhcnRMb2MsIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMsIGNvbnRhaW5zRXNjKSB7XG4gICAgaWYgKChpc0dlbmVyYXRvciB8fCBpc0FzeW5jKSAmJiB0aGlzLnR5cGUgPT09IHR5cGVzLmNvbG9uKVxuICAgICAgeyB0aGlzLnVuZXhwZWN0ZWQoKTsgfVxuXG4gICAgaWYgKHRoaXMuZWF0KHR5cGVzLmNvbG9uKSkge1xuICAgICAgcHJvcC52YWx1ZSA9IGlzUGF0dGVybiA/IHRoaXMucGFyc2VNYXliZURlZmF1bHQodGhpcy5zdGFydCwgdGhpcy5zdGFydExvYykgOiB0aGlzLnBhcnNlTWF5YmVBc3NpZ24oZmFsc2UsIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpO1xuICAgICAgcHJvcC5raW5kID0gXCJpbml0XCI7XG4gICAgfSBlbHNlIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNiAmJiB0aGlzLnR5cGUgPT09IHR5cGVzLnBhcmVuTCkge1xuICAgICAgaWYgKGlzUGF0dGVybikgeyB0aGlzLnVuZXhwZWN0ZWQoKTsgfVxuICAgICAgcHJvcC5raW5kID0gXCJpbml0XCI7XG4gICAgICBwcm9wLm1ldGhvZCA9IHRydWU7XG4gICAgICBwcm9wLnZhbHVlID0gdGhpcy5wYXJzZU1ldGhvZChpc0dlbmVyYXRvciwgaXNBc3luYyk7XG4gICAgfSBlbHNlIGlmICghaXNQYXR0ZXJuICYmICFjb250YWluc0VzYyAmJlxuICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDUgJiYgIXByb3AuY29tcHV0ZWQgJiYgcHJvcC5rZXkudHlwZSA9PT0gXCJJZGVudGlmaWVyXCIgJiZcbiAgICAgICAgICAgICAgIChwcm9wLmtleS5uYW1lID09PSBcImdldFwiIHx8IHByb3Aua2V5Lm5hbWUgPT09IFwic2V0XCIpICYmXG4gICAgICAgICAgICAgICAodGhpcy50eXBlICE9PSB0eXBlcy5jb21tYSAmJiB0aGlzLnR5cGUgIT09IHR5cGVzLmJyYWNlUikpIHtcbiAgICAgIGlmIChpc0dlbmVyYXRvciB8fCBpc0FzeW5jKSB7IHRoaXMudW5leHBlY3RlZCgpOyB9XG4gICAgICBwcm9wLmtpbmQgPSBwcm9wLmtleS5uYW1lO1xuICAgICAgdGhpcy5wYXJzZVByb3BlcnR5TmFtZShwcm9wKTtcbiAgICAgIHByb3AudmFsdWUgPSB0aGlzLnBhcnNlTWV0aG9kKGZhbHNlKTtcbiAgICAgIHZhciBwYXJhbUNvdW50ID0gcHJvcC5raW5kID09PSBcImdldFwiID8gMCA6IDE7XG4gICAgICBpZiAocHJvcC52YWx1ZS5wYXJhbXMubGVuZ3RoICE9PSBwYXJhbUNvdW50KSB7XG4gICAgICAgIHZhciBzdGFydCA9IHByb3AudmFsdWUuc3RhcnQ7XG4gICAgICAgIGlmIChwcm9wLmtpbmQgPT09IFwiZ2V0XCIpXG4gICAgICAgICAgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUoc3RhcnQsIFwiZ2V0dGVyIHNob3VsZCBoYXZlIG5vIHBhcmFtc1wiKTsgfVxuICAgICAgICBlbHNlXG4gICAgICAgICAgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUoc3RhcnQsIFwic2V0dGVyIHNob3VsZCBoYXZlIGV4YWN0bHkgb25lIHBhcmFtXCIpOyB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAocHJvcC5raW5kID09PSBcInNldFwiICYmIHByb3AudmFsdWUucGFyYW1zWzBdLnR5cGUgPT09IFwiUmVzdEVsZW1lbnRcIilcbiAgICAgICAgICB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZShwcm9wLnZhbHVlLnBhcmFtc1swXS5zdGFydCwgXCJTZXR0ZXIgY2Fubm90IHVzZSByZXN0IHBhcmFtc1wiKTsgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDYgJiYgIXByb3AuY29tcHV0ZWQgJiYgcHJvcC5rZXkudHlwZSA9PT0gXCJJZGVudGlmaWVyXCIpIHtcbiAgICAgIGlmIChpc0dlbmVyYXRvciB8fCBpc0FzeW5jKSB7IHRoaXMudW5leHBlY3RlZCgpOyB9XG4gICAgICB0aGlzLmNoZWNrVW5yZXNlcnZlZChwcm9wLmtleSk7XG4gICAgICBpZiAocHJvcC5rZXkubmFtZSA9PT0gXCJhd2FpdFwiICYmICF0aGlzLmF3YWl0SWRlbnRQb3MpXG4gICAgICAgIHsgdGhpcy5hd2FpdElkZW50UG9zID0gc3RhcnRQb3M7IH1cbiAgICAgIHByb3Aua2luZCA9IFwiaW5pdFwiO1xuICAgICAgaWYgKGlzUGF0dGVybikge1xuICAgICAgICBwcm9wLnZhbHVlID0gdGhpcy5wYXJzZU1heWJlRGVmYXVsdChzdGFydFBvcywgc3RhcnRMb2MsIHByb3Aua2V5KTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy50eXBlID09PSB0eXBlcy5lcSAmJiByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKSB7XG4gICAgICAgIGlmIChyZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnNob3J0aGFuZEFzc2lnbiA8IDApXG4gICAgICAgICAgeyByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnNob3J0aGFuZEFzc2lnbiA9IHRoaXMuc3RhcnQ7IH1cbiAgICAgICAgcHJvcC52YWx1ZSA9IHRoaXMucGFyc2VNYXliZURlZmF1bHQoc3RhcnRQb3MsIHN0YXJ0TG9jLCBwcm9wLmtleSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcm9wLnZhbHVlID0gcHJvcC5rZXk7XG4gICAgICB9XG4gICAgICBwcm9wLnNob3J0aGFuZCA9IHRydWU7XG4gICAgfSBlbHNlIHsgdGhpcy51bmV4cGVjdGVkKCk7IH1cbiAgfTtcblxuICBwcCQzLnBhcnNlUHJvcGVydHlOYW1lID0gZnVuY3Rpb24ocHJvcCkge1xuICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNikge1xuICAgICAgaWYgKHRoaXMuZWF0KHR5cGVzLmJyYWNrZXRMKSkge1xuICAgICAgICBwcm9wLmNvbXB1dGVkID0gdHJ1ZTtcbiAgICAgICAgcHJvcC5rZXkgPSB0aGlzLnBhcnNlTWF5YmVBc3NpZ24oKTtcbiAgICAgICAgdGhpcy5leHBlY3QodHlwZXMuYnJhY2tldFIpO1xuICAgICAgICByZXR1cm4gcHJvcC5rZXlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByb3AuY29tcHV0ZWQgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHByb3Aua2V5ID0gdGhpcy50eXBlID09PSB0eXBlcy5udW0gfHwgdGhpcy50eXBlID09PSB0eXBlcy5zdHJpbmcgPyB0aGlzLnBhcnNlRXhwckF0b20oKSA6IHRoaXMucGFyc2VJZGVudCh0aGlzLm9wdGlvbnMuYWxsb3dSZXNlcnZlZCAhPT0gXCJuZXZlclwiKVxuICB9O1xuXG5cbiAgcHAkMy5pbml0RnVuY3Rpb24gPSBmdW5jdGlvbihub2RlKSB7XG4gICAgbm9kZS5pZCA9IG51bGw7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2KSB7IG5vZGUuZ2VuZXJhdG9yID0gbm9kZS5leHByZXNzaW9uID0gZmFsc2U7IH1cbiAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDgpIHsgbm9kZS5hc3luYyA9IGZhbHNlOyB9XG4gIH07XG5cblxuICBwcCQzLnBhcnNlTWV0aG9kID0gZnVuY3Rpb24oaXNHZW5lcmF0b3IsIGlzQXN5bmMsIGFsbG93RGlyZWN0U3VwZXIpIHtcbiAgICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCksIG9sZFlpZWxkUG9zID0gdGhpcy55aWVsZFBvcywgb2xkQXdhaXRQb3MgPSB0aGlzLmF3YWl0UG9zLCBvbGRBd2FpdElkZW50UG9zID0gdGhpcy5hd2FpdElkZW50UG9zO1xuXG4gICAgdGhpcy5pbml0RnVuY3Rpb24obm9kZSk7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2KVxuICAgICAgeyBub2RlLmdlbmVyYXRvciA9IGlzR2VuZXJhdG9yOyB9XG4gICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA4KVxuICAgICAgeyBub2RlLmFzeW5jID0gISFpc0FzeW5jOyB9XG5cbiAgICB0aGlzLnlpZWxkUG9zID0gMDtcbiAgICB0aGlzLmF3YWl0UG9zID0gMDtcbiAgICB0aGlzLmF3YWl0SWRlbnRQb3MgPSAwO1xuICAgIHRoaXMuZW50ZXJTY29wZShmdW5jdGlvbkZsYWdzKGlzQXN5bmMsIG5vZGUuZ2VuZXJhdG9yKSB8IFNDT1BFX1NVUEVSIHwgKGFsbG93RGlyZWN0U3VwZXIgPyBTQ09QRV9ESVJFQ1RfU1VQRVIgOiAwKSk7XG5cbiAgICB0aGlzLmV4cGVjdCh0eXBlcy5wYXJlbkwpO1xuICAgIG5vZGUucGFyYW1zID0gdGhpcy5wYXJzZUJpbmRpbmdMaXN0KHR5cGVzLnBhcmVuUiwgZmFsc2UsIHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA4KTtcbiAgICB0aGlzLmNoZWNrWWllbGRBd2FpdEluRGVmYXVsdFBhcmFtcygpO1xuICAgIHRoaXMucGFyc2VGdW5jdGlvbkJvZHkobm9kZSwgZmFsc2UsIHRydWUpO1xuXG4gICAgdGhpcy55aWVsZFBvcyA9IG9sZFlpZWxkUG9zO1xuICAgIHRoaXMuYXdhaXRQb3MgPSBvbGRBd2FpdFBvcztcbiAgICB0aGlzLmF3YWl0SWRlbnRQb3MgPSBvbGRBd2FpdElkZW50UG9zO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJGdW5jdGlvbkV4cHJlc3Npb25cIilcbiAgfTtcblxuXG4gIHBwJDMucGFyc2VBcnJvd0V4cHJlc3Npb24gPSBmdW5jdGlvbihub2RlLCBwYXJhbXMsIGlzQXN5bmMpIHtcbiAgICB2YXIgb2xkWWllbGRQb3MgPSB0aGlzLnlpZWxkUG9zLCBvbGRBd2FpdFBvcyA9IHRoaXMuYXdhaXRQb3MsIG9sZEF3YWl0SWRlbnRQb3MgPSB0aGlzLmF3YWl0SWRlbnRQb3M7XG5cbiAgICB0aGlzLmVudGVyU2NvcGUoZnVuY3Rpb25GbGFncyhpc0FzeW5jLCBmYWxzZSkgfCBTQ09QRV9BUlJPVyk7XG4gICAgdGhpcy5pbml0RnVuY3Rpb24obm9kZSk7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA4KSB7IG5vZGUuYXN5bmMgPSAhIWlzQXN5bmM7IH1cblxuICAgIHRoaXMueWllbGRQb3MgPSAwO1xuICAgIHRoaXMuYXdhaXRQb3MgPSAwO1xuICAgIHRoaXMuYXdhaXRJZGVudFBvcyA9IDA7XG5cbiAgICBub2RlLnBhcmFtcyA9IHRoaXMudG9Bc3NpZ25hYmxlTGlzdChwYXJhbXMsIHRydWUpO1xuICAgIHRoaXMucGFyc2VGdW5jdGlvbkJvZHkobm9kZSwgdHJ1ZSwgZmFsc2UpO1xuXG4gICAgdGhpcy55aWVsZFBvcyA9IG9sZFlpZWxkUG9zO1xuICAgIHRoaXMuYXdhaXRQb3MgPSBvbGRBd2FpdFBvcztcbiAgICB0aGlzLmF3YWl0SWRlbnRQb3MgPSBvbGRBd2FpdElkZW50UG9zO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvblwiKVxuICB9O1xuXG5cbiAgcHAkMy5wYXJzZUZ1bmN0aW9uQm9keSA9IGZ1bmN0aW9uKG5vZGUsIGlzQXJyb3dGdW5jdGlvbiwgaXNNZXRob2QpIHtcbiAgICB2YXIgaXNFeHByZXNzaW9uID0gaXNBcnJvd0Z1bmN0aW9uICYmIHRoaXMudHlwZSAhPT0gdHlwZXMuYnJhY2VMO1xuICAgIHZhciBvbGRTdHJpY3QgPSB0aGlzLnN0cmljdCwgdXNlU3RyaWN0ID0gZmFsc2U7XG5cbiAgICBpZiAoaXNFeHByZXNzaW9uKSB7XG4gICAgICBub2RlLmJvZHkgPSB0aGlzLnBhcnNlTWF5YmVBc3NpZ24oKTtcbiAgICAgIG5vZGUuZXhwcmVzc2lvbiA9IHRydWU7XG4gICAgICB0aGlzLmNoZWNrUGFyYW1zKG5vZGUsIGZhbHNlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIG5vblNpbXBsZSA9IHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA3ICYmICF0aGlzLmlzU2ltcGxlUGFyYW1MaXN0KG5vZGUucGFyYW1zKTtcbiAgICAgIGlmICghb2xkU3RyaWN0IHx8IG5vblNpbXBsZSkge1xuICAgICAgICB1c2VTdHJpY3QgPSB0aGlzLnN0cmljdERpcmVjdGl2ZSh0aGlzLmVuZCk7XG4gICAgICAgIGlmICh1c2VTdHJpY3QgJiYgbm9uU2ltcGxlKVxuICAgICAgICAgIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKG5vZGUuc3RhcnQsIFwiSWxsZWdhbCAndXNlIHN0cmljdCcgZGlyZWN0aXZlIGluIGZ1bmN0aW9uIHdpdGggbm9uLXNpbXBsZSBwYXJhbWV0ZXIgbGlzdFwiKTsgfVxuICAgICAgfVxuICAgICAgdmFyIG9sZExhYmVscyA9IHRoaXMubGFiZWxzO1xuICAgICAgdGhpcy5sYWJlbHMgPSBbXTtcbiAgICAgIGlmICh1c2VTdHJpY3QpIHsgdGhpcy5zdHJpY3QgPSB0cnVlOyB9XG5cbiAgICAgIHRoaXMuY2hlY2tQYXJhbXMobm9kZSwgIW9sZFN0cmljdCAmJiAhdXNlU3RyaWN0ICYmICFpc0Fycm93RnVuY3Rpb24gJiYgIWlzTWV0aG9kICYmIHRoaXMuaXNTaW1wbGVQYXJhbUxpc3Qobm9kZS5wYXJhbXMpKTtcbiAgICAgIG5vZGUuYm9keSA9IHRoaXMucGFyc2VCbG9jayhmYWxzZSk7XG4gICAgICBub2RlLmV4cHJlc3Npb24gPSBmYWxzZTtcbiAgICAgIHRoaXMuYWRhcHREaXJlY3RpdmVQcm9sb2d1ZShub2RlLmJvZHkuYm9keSk7XG4gICAgICB0aGlzLmxhYmVscyA9IG9sZExhYmVscztcbiAgICB9XG4gICAgdGhpcy5leGl0U2NvcGUoKTtcblxuICAgIGlmICh0aGlzLnN0cmljdCAmJiBub2RlLmlkKSB7IHRoaXMuY2hlY2tMVmFsKG5vZGUuaWQsIEJJTkRfT1VUU0lERSk7IH1cbiAgICB0aGlzLnN0cmljdCA9IG9sZFN0cmljdDtcbiAgfTtcblxuICBwcCQzLmlzU2ltcGxlUGFyYW1MaXN0ID0gZnVuY3Rpb24ocGFyYW1zKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxpc3QgPSBwYXJhbXM7IGkgPCBsaXN0Lmxlbmd0aDsgaSArPSAxKVxuICAgICAge1xuICAgICAgdmFyIHBhcmFtID0gbGlzdFtpXTtcblxuICAgICAgaWYgKHBhcmFtLnR5cGUgIT09IFwiSWRlbnRpZmllclwiKSB7IHJldHVybiBmYWxzZVxuICAgIH0gfVxuICAgIHJldHVybiB0cnVlXG4gIH07XG5cblxuICBwcCQzLmNoZWNrUGFyYW1zID0gZnVuY3Rpb24obm9kZSwgYWxsb3dEdXBsaWNhdGVzKSB7XG4gICAgdmFyIG5hbWVIYXNoID0ge307XG4gICAgZm9yICh2YXIgaSA9IDAsIGxpc3QgPSBub2RlLnBhcmFtczsgaSA8IGxpc3QubGVuZ3RoOyBpICs9IDEpXG4gICAgICB7XG4gICAgICB2YXIgcGFyYW0gPSBsaXN0W2ldO1xuXG4gICAgICB0aGlzLmNoZWNrTFZhbChwYXJhbSwgQklORF9WQVIsIGFsbG93RHVwbGljYXRlcyA/IG51bGwgOiBuYW1lSGFzaCk7XG4gICAgfVxuICB9O1xuXG5cbiAgcHAkMy5wYXJzZUV4cHJMaXN0ID0gZnVuY3Rpb24oY2xvc2UsIGFsbG93VHJhaWxpbmdDb21tYSwgYWxsb3dFbXB0eSwgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycykge1xuICAgIHZhciBlbHRzID0gW10sIGZpcnN0ID0gdHJ1ZTtcbiAgICB3aGlsZSAoIXRoaXMuZWF0KGNsb3NlKSkge1xuICAgICAgaWYgKCFmaXJzdCkge1xuICAgICAgICB0aGlzLmV4cGVjdCh0eXBlcy5jb21tYSk7XG4gICAgICAgIGlmIChhbGxvd1RyYWlsaW5nQ29tbWEgJiYgdGhpcy5hZnRlclRyYWlsaW5nQ29tbWEoY2xvc2UpKSB7IGJyZWFrIH1cbiAgICAgIH0gZWxzZSB7IGZpcnN0ID0gZmFsc2U7IH1cblxuICAgICAgdmFyIGVsdCA9ICh2b2lkIDApO1xuICAgICAgaWYgKGFsbG93RW1wdHkgJiYgdGhpcy50eXBlID09PSB0eXBlcy5jb21tYSlcbiAgICAgICAgeyBlbHQgPSBudWxsOyB9XG4gICAgICBlbHNlIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzLmVsbGlwc2lzKSB7XG4gICAgICAgIGVsdCA9IHRoaXMucGFyc2VTcHJlYWQocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyk7XG4gICAgICAgIGlmIChyZWZEZXN0cnVjdHVyaW5nRXJyb3JzICYmIHRoaXMudHlwZSA9PT0gdHlwZXMuY29tbWEgJiYgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy50cmFpbGluZ0NvbW1hIDwgMClcbiAgICAgICAgICB7IHJlZkRlc3RydWN0dXJpbmdFcnJvcnMudHJhaWxpbmdDb21tYSA9IHRoaXMuc3RhcnQ7IH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVsdCA9IHRoaXMucGFyc2VNYXliZUFzc2lnbihmYWxzZSwgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyk7XG4gICAgICB9XG4gICAgICBlbHRzLnB1c2goZWx0KTtcbiAgICB9XG4gICAgcmV0dXJuIGVsdHNcbiAgfTtcblxuICBwcCQzLmNoZWNrVW5yZXNlcnZlZCA9IGZ1bmN0aW9uKHJlZikge1xuICAgIHZhciBzdGFydCA9IHJlZi5zdGFydDtcbiAgICB2YXIgZW5kID0gcmVmLmVuZDtcbiAgICB2YXIgbmFtZSA9IHJlZi5uYW1lO1xuXG4gICAgaWYgKHRoaXMuaW5HZW5lcmF0b3IgJiYgbmFtZSA9PT0gXCJ5aWVsZFwiKVxuICAgICAgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUoc3RhcnQsIFwiQ2Fubm90IHVzZSAneWllbGQnIGFzIGlkZW50aWZpZXIgaW5zaWRlIGEgZ2VuZXJhdG9yXCIpOyB9XG4gICAgaWYgKHRoaXMuaW5Bc3luYyAmJiBuYW1lID09PSBcImF3YWl0XCIpXG4gICAgICB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZShzdGFydCwgXCJDYW5ub3QgdXNlICdhd2FpdCcgYXMgaWRlbnRpZmllciBpbnNpZGUgYW4gYXN5bmMgZnVuY3Rpb25cIik7IH1cbiAgICBpZiAodGhpcy5rZXl3b3Jkcy50ZXN0KG5hbWUpKVxuICAgICAgeyB0aGlzLnJhaXNlKHN0YXJ0LCAoXCJVbmV4cGVjdGVkIGtleXdvcmQgJ1wiICsgbmFtZSArIFwiJ1wiKSk7IH1cbiAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uIDwgNiAmJlxuICAgICAgdGhpcy5pbnB1dC5zbGljZShzdGFydCwgZW5kKS5pbmRleE9mKFwiXFxcXFwiKSAhPT0gLTEpIHsgcmV0dXJuIH1cbiAgICB2YXIgcmUgPSB0aGlzLnN0cmljdCA/IHRoaXMucmVzZXJ2ZWRXb3Jkc1N0cmljdCA6IHRoaXMucmVzZXJ2ZWRXb3JkcztcbiAgICBpZiAocmUudGVzdChuYW1lKSkge1xuICAgICAgaWYgKCF0aGlzLmluQXN5bmMgJiYgbmFtZSA9PT0gXCJhd2FpdFwiKVxuICAgICAgICB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZShzdGFydCwgXCJDYW5ub3QgdXNlIGtleXdvcmQgJ2F3YWl0JyBvdXRzaWRlIGFuIGFzeW5jIGZ1bmN0aW9uXCIpOyB9XG4gICAgICB0aGlzLnJhaXNlUmVjb3ZlcmFibGUoc3RhcnQsIChcIlRoZSBrZXl3b3JkICdcIiArIG5hbWUgKyBcIicgaXMgcmVzZXJ2ZWRcIikpO1xuICAgIH1cbiAgfTtcblxuXG4gIHBwJDMucGFyc2VJZGVudCA9IGZ1bmN0aW9uKGxpYmVyYWwsIGlzQmluZGluZykge1xuICAgIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICBpZiAodGhpcy50eXBlID09PSB0eXBlcy5uYW1lKSB7XG4gICAgICBub2RlLm5hbWUgPSB0aGlzLnZhbHVlO1xuICAgIH0gZWxzZSBpZiAodGhpcy50eXBlLmtleXdvcmQpIHtcbiAgICAgIG5vZGUubmFtZSA9IHRoaXMudHlwZS5rZXl3b3JkO1xuXG4gICAgICBpZiAoKG5vZGUubmFtZSA9PT0gXCJjbGFzc1wiIHx8IG5vZGUubmFtZSA9PT0gXCJmdW5jdGlvblwiKSAmJlxuICAgICAgICAgICh0aGlzLmxhc3RUb2tFbmQgIT09IHRoaXMubGFzdFRva1N0YXJ0ICsgMSB8fCB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5sYXN0VG9rU3RhcnQpICE9PSA0NikpIHtcbiAgICAgICAgdGhpcy5jb250ZXh0LnBvcCgpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnVuZXhwZWN0ZWQoKTtcbiAgICB9XG4gICAgdGhpcy5uZXh0KCEhbGliZXJhbCk7XG4gICAgdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiSWRlbnRpZmllclwiKTtcbiAgICBpZiAoIWxpYmVyYWwpIHtcbiAgICAgIHRoaXMuY2hlY2tVbnJlc2VydmVkKG5vZGUpO1xuICAgICAgaWYgKG5vZGUubmFtZSA9PT0gXCJhd2FpdFwiICYmICF0aGlzLmF3YWl0SWRlbnRQb3MpXG4gICAgICAgIHsgdGhpcy5hd2FpdElkZW50UG9zID0gbm9kZS5zdGFydDsgfVxuICAgIH1cbiAgICByZXR1cm4gbm9kZVxuICB9O1xuXG5cbiAgcHAkMy5wYXJzZVlpZWxkID0gZnVuY3Rpb24obm9Jbikge1xuICAgIGlmICghdGhpcy55aWVsZFBvcykgeyB0aGlzLnlpZWxkUG9zID0gdGhpcy5zdGFydDsgfVxuXG4gICAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIHRoaXMubmV4dCgpO1xuICAgIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzLnNlbWkgfHwgdGhpcy5jYW5JbnNlcnRTZW1pY29sb24oKSB8fCAodGhpcy50eXBlICE9PSB0eXBlcy5zdGFyICYmICF0aGlzLnR5cGUuc3RhcnRzRXhwcikpIHtcbiAgICAgIG5vZGUuZGVsZWdhdGUgPSBmYWxzZTtcbiAgICAgIG5vZGUuYXJndW1lbnQgPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICBub2RlLmRlbGVnYXRlID0gdGhpcy5lYXQodHlwZXMuc3Rhcik7XG4gICAgICBub2RlLmFyZ3VtZW50ID0gdGhpcy5wYXJzZU1heWJlQXNzaWduKG5vSW4pO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiWWllbGRFeHByZXNzaW9uXCIpXG4gIH07XG5cbiAgcHAkMy5wYXJzZUF3YWl0ID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKCF0aGlzLmF3YWl0UG9zKSB7IHRoaXMuYXdhaXRQb3MgPSB0aGlzLnN0YXJ0OyB9XG5cbiAgICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgbm9kZS5hcmd1bWVudCA9IHRoaXMucGFyc2VNYXliZVVuYXJ5KG51bGwsIGZhbHNlKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiQXdhaXRFeHByZXNzaW9uXCIpXG4gIH07XG5cbiAgdmFyIHBwJDQgPSBQYXJzZXIucHJvdG90eXBlO1xuXG5cbiAgcHAkNC5yYWlzZSA9IGZ1bmN0aW9uKHBvcywgbWVzc2FnZSkge1xuICAgIHZhciBsb2MgPSBnZXRMaW5lSW5mbyh0aGlzLmlucHV0LCBwb3MpO1xuICAgIG1lc3NhZ2UgKz0gXCIgKFwiICsgbG9jLmxpbmUgKyBcIjpcIiArIGxvYy5jb2x1bW4gKyBcIilcIjtcbiAgICB2YXIgZXJyID0gbmV3IFN5bnRheEVycm9yKG1lc3NhZ2UpO1xuICAgIGVyci5wb3MgPSBwb3M7IGVyci5sb2MgPSBsb2M7IGVyci5yYWlzZWRBdCA9IHRoaXMucG9zO1xuICAgIHRocm93IGVyclxuICB9O1xuXG4gIHBwJDQucmFpc2VSZWNvdmVyYWJsZSA9IHBwJDQucmFpc2U7XG5cbiAgcHAkNC5jdXJQb3NpdGlvbiA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLm9wdGlvbnMubG9jYXRpb25zKSB7XG4gICAgICByZXR1cm4gbmV3IFBvc2l0aW9uKHRoaXMuY3VyTGluZSwgdGhpcy5wb3MgLSB0aGlzLmxpbmVTdGFydClcbiAgICB9XG4gIH07XG5cbiAgdmFyIHBwJDUgPSBQYXJzZXIucHJvdG90eXBlO1xuXG4gIHZhciBTY29wZSA9IGZ1bmN0aW9uIFNjb3BlKGZsYWdzKSB7XG4gICAgdGhpcy5mbGFncyA9IGZsYWdzO1xuICAgIHRoaXMudmFyID0gW107XG4gICAgdGhpcy5sZXhpY2FsID0gW107XG4gICAgdGhpcy5mdW5jdGlvbnMgPSBbXTtcbiAgfTtcblxuXG4gIHBwJDUuZW50ZXJTY29wZSA9IGZ1bmN0aW9uKGZsYWdzKSB7XG4gICAgdGhpcy5zY29wZVN0YWNrLnB1c2gobmV3IFNjb3BlKGZsYWdzKSk7XG4gIH07XG5cbiAgcHAkNS5leGl0U2NvcGUgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnNjb3BlU3RhY2sucG9wKCk7XG4gIH07XG5cbiAgcHAkNS50cmVhdEZ1bmN0aW9uc0FzVmFySW5TY29wZSA9IGZ1bmN0aW9uKHNjb3BlKSB7XG4gICAgcmV0dXJuIChzY29wZS5mbGFncyAmIFNDT1BFX0ZVTkNUSU9OKSB8fCAhdGhpcy5pbk1vZHVsZSAmJiAoc2NvcGUuZmxhZ3MgJiBTQ09QRV9UT1ApXG4gIH07XG5cbiAgcHAkNS5kZWNsYXJlTmFtZSA9IGZ1bmN0aW9uKG5hbWUsIGJpbmRpbmdUeXBlLCBwb3MpIHtcbiAgICB2YXIgcmVkZWNsYXJlZCA9IGZhbHNlO1xuICAgIGlmIChiaW5kaW5nVHlwZSA9PT0gQklORF9MRVhJQ0FMKSB7XG4gICAgICB2YXIgc2NvcGUgPSB0aGlzLmN1cnJlbnRTY29wZSgpO1xuICAgICAgcmVkZWNsYXJlZCA9IHNjb3BlLmxleGljYWwuaW5kZXhPZihuYW1lKSA+IC0xIHx8IHNjb3BlLmZ1bmN0aW9ucy5pbmRleE9mKG5hbWUpID4gLTEgfHwgc2NvcGUudmFyLmluZGV4T2YobmFtZSkgPiAtMTtcbiAgICAgIHNjb3BlLmxleGljYWwucHVzaChuYW1lKTtcbiAgICAgIGlmICh0aGlzLmluTW9kdWxlICYmIChzY29wZS5mbGFncyAmIFNDT1BFX1RPUCkpXG4gICAgICAgIHsgZGVsZXRlIHRoaXMudW5kZWZpbmVkRXhwb3J0c1tuYW1lXTsgfVxuICAgIH0gZWxzZSBpZiAoYmluZGluZ1R5cGUgPT09IEJJTkRfU0lNUExFX0NBVENIKSB7XG4gICAgICB2YXIgc2NvcGUkMSA9IHRoaXMuY3VycmVudFNjb3BlKCk7XG4gICAgICBzY29wZSQxLmxleGljYWwucHVzaChuYW1lKTtcbiAgICB9IGVsc2UgaWYgKGJpbmRpbmdUeXBlID09PSBCSU5EX0ZVTkNUSU9OKSB7XG4gICAgICB2YXIgc2NvcGUkMiA9IHRoaXMuY3VycmVudFNjb3BlKCk7XG4gICAgICBpZiAodGhpcy50cmVhdEZ1bmN0aW9uc0FzVmFyKVxuICAgICAgICB7IHJlZGVjbGFyZWQgPSBzY29wZSQyLmxleGljYWwuaW5kZXhPZihuYW1lKSA+IC0xOyB9XG4gICAgICBlbHNlXG4gICAgICAgIHsgcmVkZWNsYXJlZCA9IHNjb3BlJDIubGV4aWNhbC5pbmRleE9mKG5hbWUpID4gLTEgfHwgc2NvcGUkMi52YXIuaW5kZXhPZihuYW1lKSA+IC0xOyB9XG4gICAgICBzY29wZSQyLmZ1bmN0aW9ucy5wdXNoKG5hbWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy5zY29wZVN0YWNrLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBzY29wZSQzID0gdGhpcy5zY29wZVN0YWNrW2ldO1xuICAgICAgICBpZiAoc2NvcGUkMy5sZXhpY2FsLmluZGV4T2YobmFtZSkgPiAtMSAmJiAhKChzY29wZSQzLmZsYWdzICYgU0NPUEVfU0lNUExFX0NBVENIKSAmJiBzY29wZSQzLmxleGljYWxbMF0gPT09IG5hbWUpIHx8XG4gICAgICAgICAgICAhdGhpcy50cmVhdEZ1bmN0aW9uc0FzVmFySW5TY29wZShzY29wZSQzKSAmJiBzY29wZSQzLmZ1bmN0aW9ucy5pbmRleE9mKG5hbWUpID4gLTEpIHtcbiAgICAgICAgICByZWRlY2xhcmVkID0gdHJ1ZTtcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICAgIHNjb3BlJDMudmFyLnB1c2gobmFtZSk7XG4gICAgICAgIGlmICh0aGlzLmluTW9kdWxlICYmIChzY29wZSQzLmZsYWdzICYgU0NPUEVfVE9QKSlcbiAgICAgICAgICB7IGRlbGV0ZSB0aGlzLnVuZGVmaW5lZEV4cG9ydHNbbmFtZV07IH1cbiAgICAgICAgaWYgKHNjb3BlJDMuZmxhZ3MgJiBTQ09QRV9WQVIpIHsgYnJlYWsgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAocmVkZWNsYXJlZCkgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUocG9zLCAoXCJJZGVudGlmaWVyICdcIiArIG5hbWUgKyBcIicgaGFzIGFscmVhZHkgYmVlbiBkZWNsYXJlZFwiKSk7IH1cbiAgfTtcblxuICBwcCQ1LmNoZWNrTG9jYWxFeHBvcnQgPSBmdW5jdGlvbihpZCkge1xuICAgIGlmICh0aGlzLnNjb3BlU3RhY2tbMF0ubGV4aWNhbC5pbmRleE9mKGlkLm5hbWUpID09PSAtMSAmJlxuICAgICAgICB0aGlzLnNjb3BlU3RhY2tbMF0udmFyLmluZGV4T2YoaWQubmFtZSkgPT09IC0xKSB7XG4gICAgICB0aGlzLnVuZGVmaW5lZEV4cG9ydHNbaWQubmFtZV0gPSBpZDtcbiAgICB9XG4gIH07XG5cbiAgcHAkNS5jdXJyZW50U2NvcGUgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5zY29wZVN0YWNrW3RoaXMuc2NvcGVTdGFjay5sZW5ndGggLSAxXVxuICB9O1xuXG4gIHBwJDUuY3VycmVudFZhclNjb3BlID0gZnVuY3Rpb24oKSB7XG4gICAgZm9yICh2YXIgaSA9IHRoaXMuc2NvcGVTdGFjay5sZW5ndGggLSAxOzsgaS0tKSB7XG4gICAgICB2YXIgc2NvcGUgPSB0aGlzLnNjb3BlU3RhY2tbaV07XG4gICAgICBpZiAoc2NvcGUuZmxhZ3MgJiBTQ09QRV9WQVIpIHsgcmV0dXJuIHNjb3BlIH1cbiAgICB9XG4gIH07XG5cbiAgcHAkNS5jdXJyZW50VGhpc1Njb3BlID0gZnVuY3Rpb24oKSB7XG4gICAgZm9yICh2YXIgaSA9IHRoaXMuc2NvcGVTdGFjay5sZW5ndGggLSAxOzsgaS0tKSB7XG4gICAgICB2YXIgc2NvcGUgPSB0aGlzLnNjb3BlU3RhY2tbaV07XG4gICAgICBpZiAoc2NvcGUuZmxhZ3MgJiBTQ09QRV9WQVIgJiYgIShzY29wZS5mbGFncyAmIFNDT1BFX0FSUk9XKSkgeyByZXR1cm4gc2NvcGUgfVxuICAgIH1cbiAgfTtcblxuICB2YXIgTm9kZSA9IGZ1bmN0aW9uIE5vZGUocGFyc2VyLCBwb3MsIGxvYykge1xuICAgIHRoaXMudHlwZSA9IFwiXCI7XG4gICAgdGhpcy5zdGFydCA9IHBvcztcbiAgICB0aGlzLmVuZCA9IDA7XG4gICAgaWYgKHBhcnNlci5vcHRpb25zLmxvY2F0aW9ucylcbiAgICAgIHsgdGhpcy5sb2MgPSBuZXcgU291cmNlTG9jYXRpb24ocGFyc2VyLCBsb2MpOyB9XG4gICAgaWYgKHBhcnNlci5vcHRpb25zLmRpcmVjdFNvdXJjZUZpbGUpXG4gICAgICB7IHRoaXMuc291cmNlRmlsZSA9IHBhcnNlci5vcHRpb25zLmRpcmVjdFNvdXJjZUZpbGU7IH1cbiAgICBpZiAocGFyc2VyLm9wdGlvbnMucmFuZ2VzKVxuICAgICAgeyB0aGlzLnJhbmdlID0gW3BvcywgMF07IH1cbiAgfTtcblxuXG4gIHZhciBwcCQ2ID0gUGFyc2VyLnByb3RvdHlwZTtcblxuICBwcCQ2LnN0YXJ0Tm9kZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBuZXcgTm9kZSh0aGlzLCB0aGlzLnN0YXJ0LCB0aGlzLnN0YXJ0TG9jKVxuICB9O1xuXG4gIHBwJDYuc3RhcnROb2RlQXQgPSBmdW5jdGlvbihwb3MsIGxvYykge1xuICAgIHJldHVybiBuZXcgTm9kZSh0aGlzLCBwb3MsIGxvYylcbiAgfTtcblxuXG4gIGZ1bmN0aW9uIGZpbmlzaE5vZGVBdChub2RlLCB0eXBlLCBwb3MsIGxvYykge1xuICAgIG5vZGUudHlwZSA9IHR5cGU7XG4gICAgbm9kZS5lbmQgPSBwb3M7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5sb2NhdGlvbnMpXG4gICAgICB7IG5vZGUubG9jLmVuZCA9IGxvYzsgfVxuICAgIGlmICh0aGlzLm9wdGlvbnMucmFuZ2VzKVxuICAgICAgeyBub2RlLnJhbmdlWzFdID0gcG9zOyB9XG4gICAgcmV0dXJuIG5vZGVcbiAgfVxuXG4gIHBwJDYuZmluaXNoTm9kZSA9IGZ1bmN0aW9uKG5vZGUsIHR5cGUpIHtcbiAgICByZXR1cm4gZmluaXNoTm9kZUF0LmNhbGwodGhpcywgbm9kZSwgdHlwZSwgdGhpcy5sYXN0VG9rRW5kLCB0aGlzLmxhc3RUb2tFbmRMb2MpXG4gIH07XG5cblxuICBwcCQ2LmZpbmlzaE5vZGVBdCA9IGZ1bmN0aW9uKG5vZGUsIHR5cGUsIHBvcywgbG9jKSB7XG4gICAgcmV0dXJuIGZpbmlzaE5vZGVBdC5jYWxsKHRoaXMsIG5vZGUsIHR5cGUsIHBvcywgbG9jKVxuICB9O1xuXG5cbiAgdmFyIFRva0NvbnRleHQgPSBmdW5jdGlvbiBUb2tDb250ZXh0KHRva2VuLCBpc0V4cHIsIHByZXNlcnZlU3BhY2UsIG92ZXJyaWRlLCBnZW5lcmF0b3IpIHtcbiAgICB0aGlzLnRva2VuID0gdG9rZW47XG4gICAgdGhpcy5pc0V4cHIgPSAhIWlzRXhwcjtcbiAgICB0aGlzLnByZXNlcnZlU3BhY2UgPSAhIXByZXNlcnZlU3BhY2U7XG4gICAgdGhpcy5vdmVycmlkZSA9IG92ZXJyaWRlO1xuICAgIHRoaXMuZ2VuZXJhdG9yID0gISFnZW5lcmF0b3I7XG4gIH07XG5cbiAgdmFyIHR5cGVzJDEgPSB7XG4gICAgYl9zdGF0OiBuZXcgVG9rQ29udGV4dChcIntcIiwgZmFsc2UpLFxuICAgIGJfZXhwcjogbmV3IFRva0NvbnRleHQoXCJ7XCIsIHRydWUpLFxuICAgIGJfdG1wbDogbmV3IFRva0NvbnRleHQoXCIke1wiLCBmYWxzZSksXG4gICAgcF9zdGF0OiBuZXcgVG9rQ29udGV4dChcIihcIiwgZmFsc2UpLFxuICAgIHBfZXhwcjogbmV3IFRva0NvbnRleHQoXCIoXCIsIHRydWUpLFxuICAgIHFfdG1wbDogbmV3IFRva0NvbnRleHQoXCJgXCIsIHRydWUsIHRydWUsIGZ1bmN0aW9uIChwKSB7IHJldHVybiBwLnRyeVJlYWRUZW1wbGF0ZVRva2VuKCk7IH0pLFxuICAgIGZfc3RhdDogbmV3IFRva0NvbnRleHQoXCJmdW5jdGlvblwiLCBmYWxzZSksXG4gICAgZl9leHByOiBuZXcgVG9rQ29udGV4dChcImZ1bmN0aW9uXCIsIHRydWUpLFxuICAgIGZfZXhwcl9nZW46IG5ldyBUb2tDb250ZXh0KFwiZnVuY3Rpb25cIiwgdHJ1ZSwgZmFsc2UsIG51bGwsIHRydWUpLFxuICAgIGZfZ2VuOiBuZXcgVG9rQ29udGV4dChcImZ1bmN0aW9uXCIsIGZhbHNlLCBmYWxzZSwgbnVsbCwgdHJ1ZSlcbiAgfTtcblxuICB2YXIgcHAkNyA9IFBhcnNlci5wcm90b3R5cGU7XG5cbiAgcHAkNy5pbml0aWFsQ29udGV4dCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBbdHlwZXMkMS5iX3N0YXRdXG4gIH07XG5cbiAgcHAkNy5icmFjZUlzQmxvY2sgPSBmdW5jdGlvbihwcmV2VHlwZSkge1xuICAgIHZhciBwYXJlbnQgPSB0aGlzLmN1ckNvbnRleHQoKTtcbiAgICBpZiAocGFyZW50ID09PSB0eXBlcyQxLmZfZXhwciB8fCBwYXJlbnQgPT09IHR5cGVzJDEuZl9zdGF0KVxuICAgICAgeyByZXR1cm4gdHJ1ZSB9XG4gICAgaWYgKHByZXZUeXBlID09PSB0eXBlcy5jb2xvbiAmJiAocGFyZW50ID09PSB0eXBlcyQxLmJfc3RhdCB8fCBwYXJlbnQgPT09IHR5cGVzJDEuYl9leHByKSlcbiAgICAgIHsgcmV0dXJuICFwYXJlbnQuaXNFeHByIH1cblxuICAgIGlmIChwcmV2VHlwZSA9PT0gdHlwZXMuX3JldHVybiB8fCBwcmV2VHlwZSA9PT0gdHlwZXMubmFtZSAmJiB0aGlzLmV4cHJBbGxvd2VkKVxuICAgICAgeyByZXR1cm4gbGluZUJyZWFrLnRlc3QodGhpcy5pbnB1dC5zbGljZSh0aGlzLmxhc3RUb2tFbmQsIHRoaXMuc3RhcnQpKSB9XG4gICAgaWYgKHByZXZUeXBlID09PSB0eXBlcy5fZWxzZSB8fCBwcmV2VHlwZSA9PT0gdHlwZXMuc2VtaSB8fCBwcmV2VHlwZSA9PT0gdHlwZXMuZW9mIHx8IHByZXZUeXBlID09PSB0eXBlcy5wYXJlblIgfHwgcHJldlR5cGUgPT09IHR5cGVzLmFycm93KVxuICAgICAgeyByZXR1cm4gdHJ1ZSB9XG4gICAgaWYgKHByZXZUeXBlID09PSB0eXBlcy5icmFjZUwpXG4gICAgICB7IHJldHVybiBwYXJlbnQgPT09IHR5cGVzJDEuYl9zdGF0IH1cbiAgICBpZiAocHJldlR5cGUgPT09IHR5cGVzLl92YXIgfHwgcHJldlR5cGUgPT09IHR5cGVzLl9jb25zdCB8fCBwcmV2VHlwZSA9PT0gdHlwZXMubmFtZSlcbiAgICAgIHsgcmV0dXJuIGZhbHNlIH1cbiAgICByZXR1cm4gIXRoaXMuZXhwckFsbG93ZWRcbiAgfTtcblxuICBwcCQ3LmluR2VuZXJhdG9yQ29udGV4dCA9IGZ1bmN0aW9uKCkge1xuICAgIGZvciAodmFyIGkgPSB0aGlzLmNvbnRleHQubGVuZ3RoIC0gMTsgaSA+PSAxOyBpLS0pIHtcbiAgICAgIHZhciBjb250ZXh0ID0gdGhpcy5jb250ZXh0W2ldO1xuICAgICAgaWYgKGNvbnRleHQudG9rZW4gPT09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgeyByZXR1cm4gY29udGV4dC5nZW5lcmF0b3IgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2VcbiAgfTtcblxuICBwcCQ3LnVwZGF0ZUNvbnRleHQgPSBmdW5jdGlvbihwcmV2VHlwZSkge1xuICAgIHZhciB1cGRhdGUsIHR5cGUgPSB0aGlzLnR5cGU7XG4gICAgaWYgKHR5cGUua2V5d29yZCAmJiBwcmV2VHlwZSA9PT0gdHlwZXMuZG90KVxuICAgICAgeyB0aGlzLmV4cHJBbGxvd2VkID0gZmFsc2U7IH1cbiAgICBlbHNlIGlmICh1cGRhdGUgPSB0eXBlLnVwZGF0ZUNvbnRleHQpXG4gICAgICB7IHVwZGF0ZS5jYWxsKHRoaXMsIHByZXZUeXBlKTsgfVxuICAgIGVsc2VcbiAgICAgIHsgdGhpcy5leHByQWxsb3dlZCA9IHR5cGUuYmVmb3JlRXhwcjsgfVxuICB9O1xuXG5cbiAgdHlwZXMucGFyZW5SLnVwZGF0ZUNvbnRleHQgPSB0eXBlcy5icmFjZVIudXBkYXRlQ29udGV4dCA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLmNvbnRleHQubGVuZ3RoID09PSAxKSB7XG4gICAgICB0aGlzLmV4cHJBbGxvd2VkID0gdHJ1ZTtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICB2YXIgb3V0ID0gdGhpcy5jb250ZXh0LnBvcCgpO1xuICAgIGlmIChvdXQgPT09IHR5cGVzJDEuYl9zdGF0ICYmIHRoaXMuY3VyQ29udGV4dCgpLnRva2VuID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIG91dCA9IHRoaXMuY29udGV4dC5wb3AoKTtcbiAgICB9XG4gICAgdGhpcy5leHByQWxsb3dlZCA9ICFvdXQuaXNFeHByO1xuICB9O1xuXG4gIHR5cGVzLmJyYWNlTC51cGRhdGVDb250ZXh0ID0gZnVuY3Rpb24ocHJldlR5cGUpIHtcbiAgICB0aGlzLmNvbnRleHQucHVzaCh0aGlzLmJyYWNlSXNCbG9jayhwcmV2VHlwZSkgPyB0eXBlcyQxLmJfc3RhdCA6IHR5cGVzJDEuYl9leHByKTtcbiAgICB0aGlzLmV4cHJBbGxvd2VkID0gdHJ1ZTtcbiAgfTtcblxuICB0eXBlcy5kb2xsYXJCcmFjZUwudXBkYXRlQ29udGV4dCA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuY29udGV4dC5wdXNoKHR5cGVzJDEuYl90bXBsKTtcbiAgICB0aGlzLmV4cHJBbGxvd2VkID0gdHJ1ZTtcbiAgfTtcblxuICB0eXBlcy5wYXJlbkwudXBkYXRlQ29udGV4dCA9IGZ1bmN0aW9uKHByZXZUeXBlKSB7XG4gICAgdmFyIHN0YXRlbWVudFBhcmVucyA9IHByZXZUeXBlID09PSB0eXBlcy5faWYgfHwgcHJldlR5cGUgPT09IHR5cGVzLl9mb3IgfHwgcHJldlR5cGUgPT09IHR5cGVzLl93aXRoIHx8IHByZXZUeXBlID09PSB0eXBlcy5fd2hpbGU7XG4gICAgdGhpcy5jb250ZXh0LnB1c2goc3RhdGVtZW50UGFyZW5zID8gdHlwZXMkMS5wX3N0YXQgOiB0eXBlcyQxLnBfZXhwcik7XG4gICAgdGhpcy5leHByQWxsb3dlZCA9IHRydWU7XG4gIH07XG5cbiAgdHlwZXMuaW5jRGVjLnVwZGF0ZUNvbnRleHQgPSBmdW5jdGlvbigpIHtcbiAgfTtcblxuICB0eXBlcy5fZnVuY3Rpb24udXBkYXRlQ29udGV4dCA9IHR5cGVzLl9jbGFzcy51cGRhdGVDb250ZXh0ID0gZnVuY3Rpb24ocHJldlR5cGUpIHtcbiAgICBpZiAocHJldlR5cGUuYmVmb3JlRXhwciAmJiBwcmV2VHlwZSAhPT0gdHlwZXMuc2VtaSAmJiBwcmV2VHlwZSAhPT0gdHlwZXMuX2Vsc2UgJiZcbiAgICAgICAgIShwcmV2VHlwZSA9PT0gdHlwZXMuX3JldHVybiAmJiBsaW5lQnJlYWsudGVzdCh0aGlzLmlucHV0LnNsaWNlKHRoaXMubGFzdFRva0VuZCwgdGhpcy5zdGFydCkpKSAmJlxuICAgICAgICAhKChwcmV2VHlwZSA9PT0gdHlwZXMuY29sb24gfHwgcHJldlR5cGUgPT09IHR5cGVzLmJyYWNlTCkgJiYgdGhpcy5jdXJDb250ZXh0KCkgPT09IHR5cGVzJDEuYl9zdGF0KSlcbiAgICAgIHsgdGhpcy5jb250ZXh0LnB1c2godHlwZXMkMS5mX2V4cHIpOyB9XG4gICAgZWxzZVxuICAgICAgeyB0aGlzLmNvbnRleHQucHVzaCh0eXBlcyQxLmZfc3RhdCk7IH1cbiAgICB0aGlzLmV4cHJBbGxvd2VkID0gZmFsc2U7XG4gIH07XG5cbiAgdHlwZXMuYmFja1F1b3RlLnVwZGF0ZUNvbnRleHQgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5jdXJDb250ZXh0KCkgPT09IHR5cGVzJDEucV90bXBsKVxuICAgICAgeyB0aGlzLmNvbnRleHQucG9wKCk7IH1cbiAgICBlbHNlXG4gICAgICB7IHRoaXMuY29udGV4dC5wdXNoKHR5cGVzJDEucV90bXBsKTsgfVxuICAgIHRoaXMuZXhwckFsbG93ZWQgPSBmYWxzZTtcbiAgfTtcblxuICB0eXBlcy5zdGFyLnVwZGF0ZUNvbnRleHQgPSBmdW5jdGlvbihwcmV2VHlwZSkge1xuICAgIGlmIChwcmV2VHlwZSA9PT0gdHlwZXMuX2Z1bmN0aW9uKSB7XG4gICAgICB2YXIgaW5kZXggPSB0aGlzLmNvbnRleHQubGVuZ3RoIC0gMTtcbiAgICAgIGlmICh0aGlzLmNvbnRleHRbaW5kZXhdID09PSB0eXBlcyQxLmZfZXhwcilcbiAgICAgICAgeyB0aGlzLmNvbnRleHRbaW5kZXhdID0gdHlwZXMkMS5mX2V4cHJfZ2VuOyB9XG4gICAgICBlbHNlXG4gICAgICAgIHsgdGhpcy5jb250ZXh0W2luZGV4XSA9IHR5cGVzJDEuZl9nZW47IH1cbiAgICB9XG4gICAgdGhpcy5leHByQWxsb3dlZCA9IHRydWU7XG4gIH07XG5cbiAgdHlwZXMubmFtZS51cGRhdGVDb250ZXh0ID0gZnVuY3Rpb24ocHJldlR5cGUpIHtcbiAgICB2YXIgYWxsb3dlZCA9IGZhbHNlO1xuICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNiAmJiBwcmV2VHlwZSAhPT0gdHlwZXMuZG90KSB7XG4gICAgICBpZiAodGhpcy52YWx1ZSA9PT0gXCJvZlwiICYmICF0aGlzLmV4cHJBbGxvd2VkIHx8XG4gICAgICAgICAgdGhpcy52YWx1ZSA9PT0gXCJ5aWVsZFwiICYmIHRoaXMuaW5HZW5lcmF0b3JDb250ZXh0KCkpXG4gICAgICAgIHsgYWxsb3dlZCA9IHRydWU7IH1cbiAgICB9XG4gICAgdGhpcy5leHByQWxsb3dlZCA9IGFsbG93ZWQ7XG4gIH07XG5cblxuICB2YXIgZWNtYTlCaW5hcnlQcm9wZXJ0aWVzID0gXCJBU0NJSSBBU0NJSV9IZXhfRGlnaXQgQUhleCBBbHBoYWJldGljIEFscGhhIEFueSBBc3NpZ25lZCBCaWRpX0NvbnRyb2wgQmlkaV9DIEJpZGlfTWlycm9yZWQgQmlkaV9NIENhc2VfSWdub3JhYmxlIENJIENhc2VkIENoYW5nZXNfV2hlbl9DYXNlZm9sZGVkIENXQ0YgQ2hhbmdlc19XaGVuX0Nhc2VtYXBwZWQgQ1dDTSBDaGFuZ2VzX1doZW5fTG93ZXJjYXNlZCBDV0wgQ2hhbmdlc19XaGVuX05GS0NfQ2FzZWZvbGRlZCBDV0tDRiBDaGFuZ2VzX1doZW5fVGl0bGVjYXNlZCBDV1QgQ2hhbmdlc19XaGVuX1VwcGVyY2FzZWQgQ1dVIERhc2ggRGVmYXVsdF9JZ25vcmFibGVfQ29kZV9Qb2ludCBESSBEZXByZWNhdGVkIERlcCBEaWFjcml0aWMgRGlhIEVtb2ppIEVtb2ppX0NvbXBvbmVudCBFbW9qaV9Nb2RpZmllciBFbW9qaV9Nb2RpZmllcl9CYXNlIEVtb2ppX1ByZXNlbnRhdGlvbiBFeHRlbmRlciBFeHQgR3JhcGhlbWVfQmFzZSBHcl9CYXNlIEdyYXBoZW1lX0V4dGVuZCBHcl9FeHQgSGV4X0RpZ2l0IEhleCBJRFNfQmluYXJ5X09wZXJhdG9yIElEU0IgSURTX1RyaW5hcnlfT3BlcmF0b3IgSURTVCBJRF9Db250aW51ZSBJREMgSURfU3RhcnQgSURTIElkZW9ncmFwaGljIElkZW8gSm9pbl9Db250cm9sIEpvaW5fQyBMb2dpY2FsX09yZGVyX0V4Y2VwdGlvbiBMT0UgTG93ZXJjYXNlIExvd2VyIE1hdGggTm9uY2hhcmFjdGVyX0NvZGVfUG9pbnQgTkNoYXIgUGF0dGVybl9TeW50YXggUGF0X1N5biBQYXR0ZXJuX1doaXRlX1NwYWNlIFBhdF9XUyBRdW90YXRpb25fTWFyayBRTWFyayBSYWRpY2FsIFJlZ2lvbmFsX0luZGljYXRvciBSSSBTZW50ZW5jZV9UZXJtaW5hbCBTVGVybSBTb2Z0X0RvdHRlZCBTRCBUZXJtaW5hbF9QdW5jdHVhdGlvbiBUZXJtIFVuaWZpZWRfSWRlb2dyYXBoIFVJZGVvIFVwcGVyY2FzZSBVcHBlciBWYXJpYXRpb25fU2VsZWN0b3IgVlMgV2hpdGVfU3BhY2Ugc3BhY2UgWElEX0NvbnRpbnVlIFhJREMgWElEX1N0YXJ0IFhJRFNcIjtcbiAgdmFyIGVjbWExMEJpbmFyeVByb3BlcnRpZXMgPSBlY21hOUJpbmFyeVByb3BlcnRpZXMgKyBcIiBFeHRlbmRlZF9QaWN0b2dyYXBoaWNcIjtcbiAgdmFyIGVjbWExMUJpbmFyeVByb3BlcnRpZXMgPSBlY21hMTBCaW5hcnlQcm9wZXJ0aWVzO1xuICB2YXIgdW5pY29kZUJpbmFyeVByb3BlcnRpZXMgPSB7XG4gICAgOTogZWNtYTlCaW5hcnlQcm9wZXJ0aWVzLFxuICAgIDEwOiBlY21hMTBCaW5hcnlQcm9wZXJ0aWVzLFxuICAgIDExOiBlY21hMTFCaW5hcnlQcm9wZXJ0aWVzXG4gIH07XG5cbiAgdmFyIHVuaWNvZGVHZW5lcmFsQ2F0ZWdvcnlWYWx1ZXMgPSBcIkNhc2VkX0xldHRlciBMQyBDbG9zZV9QdW5jdHVhdGlvbiBQZSBDb25uZWN0b3JfUHVuY3R1YXRpb24gUGMgQ29udHJvbCBDYyBjbnRybCBDdXJyZW5jeV9TeW1ib2wgU2MgRGFzaF9QdW5jdHVhdGlvbiBQZCBEZWNpbWFsX051bWJlciBOZCBkaWdpdCBFbmNsb3NpbmdfTWFyayBNZSBGaW5hbF9QdW5jdHVhdGlvbiBQZiBGb3JtYXQgQ2YgSW5pdGlhbF9QdW5jdHVhdGlvbiBQaSBMZXR0ZXIgTCBMZXR0ZXJfTnVtYmVyIE5sIExpbmVfU2VwYXJhdG9yIFpsIExvd2VyY2FzZV9MZXR0ZXIgTGwgTWFyayBNIENvbWJpbmluZ19NYXJrIE1hdGhfU3ltYm9sIFNtIE1vZGlmaWVyX0xldHRlciBMbSBNb2RpZmllcl9TeW1ib2wgU2sgTm9uc3BhY2luZ19NYXJrIE1uIE51bWJlciBOIE9wZW5fUHVuY3R1YXRpb24gUHMgT3RoZXIgQyBPdGhlcl9MZXR0ZXIgTG8gT3RoZXJfTnVtYmVyIE5vIE90aGVyX1B1bmN0dWF0aW9uIFBvIE90aGVyX1N5bWJvbCBTbyBQYXJhZ3JhcGhfU2VwYXJhdG9yIFpwIFByaXZhdGVfVXNlIENvIFB1bmN0dWF0aW9uIFAgcHVuY3QgU2VwYXJhdG9yIFogU3BhY2VfU2VwYXJhdG9yIFpzIFNwYWNpbmdfTWFyayBNYyBTdXJyb2dhdGUgQ3MgU3ltYm9sIFMgVGl0bGVjYXNlX0xldHRlciBMdCBVbmFzc2lnbmVkIENuIFVwcGVyY2FzZV9MZXR0ZXIgTHVcIjtcblxuICB2YXIgZWNtYTlTY3JpcHRWYWx1ZXMgPSBcIkFkbGFtIEFkbG0gQWhvbSBBaG9tIEFuYXRvbGlhbl9IaWVyb2dseXBocyBIbHV3IEFyYWJpYyBBcmFiIEFybWVuaWFuIEFybW4gQXZlc3RhbiBBdnN0IEJhbGluZXNlIEJhbGkgQmFtdW0gQmFtdSBCYXNzYV9WYWggQmFzcyBCYXRhayBCYXRrIEJlbmdhbGkgQmVuZyBCaGFpa3N1a2kgQmhrcyBCb3BvbW9mbyBCb3BvIEJyYWhtaSBCcmFoIEJyYWlsbGUgQnJhaSBCdWdpbmVzZSBCdWdpIEJ1aGlkIEJ1aGQgQ2FuYWRpYW5fQWJvcmlnaW5hbCBDYW5zIENhcmlhbiBDYXJpIENhdWNhc2lhbl9BbGJhbmlhbiBBZ2hiIENoYWttYSBDYWttIENoYW0gQ2hhbSBDaGVyb2tlZSBDaGVyIENvbW1vbiBaeXl5IENvcHRpYyBDb3B0IFFhYWMgQ3VuZWlmb3JtIFhzdXggQ3lwcmlvdCBDcHJ0IEN5cmlsbGljIEN5cmwgRGVzZXJldCBEc3J0IERldmFuYWdhcmkgRGV2YSBEdXBsb3lhbiBEdXBsIEVneXB0aWFuX0hpZXJvZ2x5cGhzIEVneXAgRWxiYXNhbiBFbGJhIEV0aGlvcGljIEV0aGkgR2VvcmdpYW4gR2VvciBHbGFnb2xpdGljIEdsYWcgR290aGljIEdvdGggR3JhbnRoYSBHcmFuIEdyZWVrIEdyZWsgR3VqYXJhdGkgR3VqciBHdXJtdWtoaSBHdXJ1IEhhbiBIYW5pIEhhbmd1bCBIYW5nIEhhbnVub28gSGFubyBIYXRyYW4gSGF0ciBIZWJyZXcgSGViciBIaXJhZ2FuYSBIaXJhIEltcGVyaWFsX0FyYW1haWMgQXJtaSBJbmhlcml0ZWQgWmluaCBRYWFpIEluc2NyaXB0aW9uYWxfUGFobGF2aSBQaGxpIEluc2NyaXB0aW9uYWxfUGFydGhpYW4gUHJ0aSBKYXZhbmVzZSBKYXZhIEthaXRoaSBLdGhpIEthbm5hZGEgS25kYSBLYXRha2FuYSBLYW5hIEtheWFoX0xpIEthbGkgS2hhcm9zaHRoaSBLaGFyIEtobWVyIEtobXIgS2hvamtpIEtob2ogS2h1ZGF3YWRpIFNpbmQgTGFvIExhb28gTGF0aW4gTGF0biBMZXBjaGEgTGVwYyBMaW1idSBMaW1iIExpbmVhcl9BIExpbmEgTGluZWFyX0IgTGluYiBMaXN1IExpc3UgTHljaWFuIEx5Y2kgTHlkaWFuIEx5ZGkgTWFoYWphbmkgTWFoaiBNYWxheWFsYW0gTWx5bSBNYW5kYWljIE1hbmQgTWFuaWNoYWVhbiBNYW5pIE1hcmNoZW4gTWFyYyBNYXNhcmFtX0dvbmRpIEdvbm0gTWVldGVpX01heWVrIE10ZWkgTWVuZGVfS2lrYWt1aSBNZW5kIE1lcm9pdGljX0N1cnNpdmUgTWVyYyBNZXJvaXRpY19IaWVyb2dseXBocyBNZXJvIE1pYW8gUGxyZCBNb2RpIE1vZGkgTW9uZ29saWFuIE1vbmcgTXJvIE1yb28gTXVsdGFuaSBNdWx0IE15YW5tYXIgTXltciBOYWJhdGFlYW4gTmJhdCBOZXdfVGFpX0x1ZSBUYWx1IE5ld2EgTmV3YSBOa28gTmtvbyBOdXNodSBOc2h1IE9naGFtIE9nYW0gT2xfQ2hpa2kgT2xjayBPbGRfSHVuZ2FyaWFuIEh1bmcgT2xkX0l0YWxpYyBJdGFsIE9sZF9Ob3J0aF9BcmFiaWFuIE5hcmIgT2xkX1Blcm1pYyBQZXJtIE9sZF9QZXJzaWFuIFhwZW8gT2xkX1NvdXRoX0FyYWJpYW4gU2FyYiBPbGRfVHVya2ljIE9ya2ggT3JpeWEgT3J5YSBPc2FnZSBPc2dlIE9zbWFueWEgT3NtYSBQYWhhd2hfSG1vbmcgSG1uZyBQYWxteXJlbmUgUGFsbSBQYXVfQ2luX0hhdSBQYXVjIFBoYWdzX1BhIFBoYWcgUGhvZW5pY2lhbiBQaG54IFBzYWx0ZXJfUGFobGF2aSBQaGxwIFJlamFuZyBSam5nIFJ1bmljIFJ1bnIgU2FtYXJpdGFuIFNhbXIgU2F1cmFzaHRyYSBTYXVyIFNoYXJhZGEgU2hyZCBTaGF2aWFuIFNoYXcgU2lkZGhhbSBTaWRkIFNpZ25Xcml0aW5nIFNnbncgU2luaGFsYSBTaW5oIFNvcmFfU29tcGVuZyBTb3JhIFNveW9tYm8gU295byBTdW5kYW5lc2UgU3VuZCBTeWxvdGlfTmFncmkgU3lsbyBTeXJpYWMgU3lyYyBUYWdhbG9nIFRnbGcgVGFnYmFud2EgVGFnYiBUYWlfTGUgVGFsZSBUYWlfVGhhbSBMYW5hIFRhaV9WaWV0IFRhdnQgVGFrcmkgVGFrciBUYW1pbCBUYW1sIFRhbmd1dCBUYW5nIFRlbHVndSBUZWx1IFRoYWFuYSBUaGFhIFRoYWkgVGhhaSBUaWJldGFuIFRpYnQgVGlmaW5hZ2ggVGZuZyBUaXJodXRhIFRpcmggVWdhcml0aWMgVWdhciBWYWkgVmFpaSBXYXJhbmdfQ2l0aSBXYXJhIFlpIFlpaWkgWmFuYWJhemFyX1NxdWFyZSBaYW5iXCI7XG4gIHZhciBlY21hMTBTY3JpcHRWYWx1ZXMgPSBlY21hOVNjcmlwdFZhbHVlcyArIFwiIERvZ3JhIERvZ3IgR3VuamFsYV9Hb25kaSBHb25nIEhhbmlmaV9Sb2hpbmd5YSBSb2hnIE1ha2FzYXIgTWFrYSBNZWRlZmFpZHJpbiBNZWRmIE9sZF9Tb2dkaWFuIFNvZ28gU29nZGlhbiBTb2dkXCI7XG4gIHZhciBlY21hMTFTY3JpcHRWYWx1ZXMgPSBlY21hMTBTY3JpcHRWYWx1ZXMgKyBcIiBFbHltYWljIEVseW0gTmFuZGluYWdhcmkgTmFuZCBOeWlha2VuZ19QdWFjaHVlX0htb25nIEhtbnAgV2FuY2hvIFdjaG9cIjtcbiAgdmFyIHVuaWNvZGVTY3JpcHRWYWx1ZXMgPSB7XG4gICAgOTogZWNtYTlTY3JpcHRWYWx1ZXMsXG4gICAgMTA6IGVjbWExMFNjcmlwdFZhbHVlcyxcbiAgICAxMTogZWNtYTExU2NyaXB0VmFsdWVzXG4gIH07XG5cbiAgdmFyIGRhdGEgPSB7fTtcbiAgZnVuY3Rpb24gYnVpbGRVbmljb2RlRGF0YShlY21hVmVyc2lvbikge1xuICAgIHZhciBkID0gZGF0YVtlY21hVmVyc2lvbl0gPSB7XG4gICAgICBiaW5hcnk6IHdvcmRzUmVnZXhwKHVuaWNvZGVCaW5hcnlQcm9wZXJ0aWVzW2VjbWFWZXJzaW9uXSArIFwiIFwiICsgdW5pY29kZUdlbmVyYWxDYXRlZ29yeVZhbHVlcyksXG4gICAgICBub25CaW5hcnk6IHtcbiAgICAgICAgR2VuZXJhbF9DYXRlZ29yeTogd29yZHNSZWdleHAodW5pY29kZUdlbmVyYWxDYXRlZ29yeVZhbHVlcyksXG4gICAgICAgIFNjcmlwdDogd29yZHNSZWdleHAodW5pY29kZVNjcmlwdFZhbHVlc1tlY21hVmVyc2lvbl0pXG4gICAgICB9XG4gICAgfTtcbiAgICBkLm5vbkJpbmFyeS5TY3JpcHRfRXh0ZW5zaW9ucyA9IGQubm9uQmluYXJ5LlNjcmlwdDtcblxuICAgIGQubm9uQmluYXJ5LmdjID0gZC5ub25CaW5hcnkuR2VuZXJhbF9DYXRlZ29yeTtcbiAgICBkLm5vbkJpbmFyeS5zYyA9IGQubm9uQmluYXJ5LlNjcmlwdDtcbiAgICBkLm5vbkJpbmFyeS5zY3ggPSBkLm5vbkJpbmFyeS5TY3JpcHRfRXh0ZW5zaW9ucztcbiAgfVxuICBidWlsZFVuaWNvZGVEYXRhKDkpO1xuICBidWlsZFVuaWNvZGVEYXRhKDEwKTtcbiAgYnVpbGRVbmljb2RlRGF0YSgxMSk7XG5cbiAgdmFyIHBwJDggPSBQYXJzZXIucHJvdG90eXBlO1xuXG4gIHZhciBSZWdFeHBWYWxpZGF0aW9uU3RhdGUgPSBmdW5jdGlvbiBSZWdFeHBWYWxpZGF0aW9uU3RhdGUocGFyc2VyKSB7XG4gICAgdGhpcy5wYXJzZXIgPSBwYXJzZXI7XG4gICAgdGhpcy52YWxpZEZsYWdzID0gXCJnaW1cIiArIChwYXJzZXIub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2ID8gXCJ1eVwiIDogXCJcIikgKyAocGFyc2VyLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOSA/IFwic1wiIDogXCJcIik7XG4gICAgdGhpcy51bmljb2RlUHJvcGVydGllcyA9IGRhdGFbcGFyc2VyLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gMTEgPyAxMSA6IHBhcnNlci5vcHRpb25zLmVjbWFWZXJzaW9uXTtcbiAgICB0aGlzLnNvdXJjZSA9IFwiXCI7XG4gICAgdGhpcy5mbGFncyA9IFwiXCI7XG4gICAgdGhpcy5zdGFydCA9IDA7XG4gICAgdGhpcy5zd2l0Y2hVID0gZmFsc2U7XG4gICAgdGhpcy5zd2l0Y2hOID0gZmFsc2U7XG4gICAgdGhpcy5wb3MgPSAwO1xuICAgIHRoaXMubGFzdEludFZhbHVlID0gMDtcbiAgICB0aGlzLmxhc3RTdHJpbmdWYWx1ZSA9IFwiXCI7XG4gICAgdGhpcy5sYXN0QXNzZXJ0aW9uSXNRdWFudGlmaWFibGUgPSBmYWxzZTtcbiAgICB0aGlzLm51bUNhcHR1cmluZ1BhcmVucyA9IDA7XG4gICAgdGhpcy5tYXhCYWNrUmVmZXJlbmNlID0gMDtcbiAgICB0aGlzLmdyb3VwTmFtZXMgPSBbXTtcbiAgICB0aGlzLmJhY2tSZWZlcmVuY2VOYW1lcyA9IFtdO1xuICB9O1xuXG4gIFJlZ0V4cFZhbGlkYXRpb25TdGF0ZS5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiByZXNldCAoc3RhcnQsIHBhdHRlcm4sIGZsYWdzKSB7XG4gICAgdmFyIHVuaWNvZGUgPSBmbGFncy5pbmRleE9mKFwidVwiKSAhPT0gLTE7XG4gICAgdGhpcy5zdGFydCA9IHN0YXJ0IHwgMDtcbiAgICB0aGlzLnNvdXJjZSA9IHBhdHRlcm4gKyBcIlwiO1xuICAgIHRoaXMuZmxhZ3MgPSBmbGFncztcbiAgICB0aGlzLnN3aXRjaFUgPSB1bmljb2RlICYmIHRoaXMucGFyc2VyLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNjtcbiAgICB0aGlzLnN3aXRjaE4gPSB1bmljb2RlICYmIHRoaXMucGFyc2VyLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOTtcbiAgfTtcblxuICBSZWdFeHBWYWxpZGF0aW9uU3RhdGUucHJvdG90eXBlLnJhaXNlID0gZnVuY3Rpb24gcmFpc2UgKG1lc3NhZ2UpIHtcbiAgICB0aGlzLnBhcnNlci5yYWlzZVJlY292ZXJhYmxlKHRoaXMuc3RhcnQsIChcIkludmFsaWQgcmVndWxhciBleHByZXNzaW9uOiAvXCIgKyAodGhpcy5zb3VyY2UpICsgXCIvOiBcIiArIG1lc3NhZ2UpKTtcbiAgfTtcblxuICBSZWdFeHBWYWxpZGF0aW9uU3RhdGUucHJvdG90eXBlLmF0ID0gZnVuY3Rpb24gYXQgKGkpIHtcbiAgICB2YXIgcyA9IHRoaXMuc291cmNlO1xuICAgIHZhciBsID0gcy5sZW5ndGg7XG4gICAgaWYgKGkgPj0gbCkge1xuICAgICAgcmV0dXJuIC0xXG4gICAgfVxuICAgIHZhciBjID0gcy5jaGFyQ29kZUF0KGkpO1xuICAgIGlmICghdGhpcy5zd2l0Y2hVIHx8IGMgPD0gMHhEN0ZGIHx8IGMgPj0gMHhFMDAwIHx8IGkgKyAxID49IGwpIHtcbiAgICAgIHJldHVybiBjXG4gICAgfVxuICAgIHZhciBuZXh0ID0gcy5jaGFyQ29kZUF0KGkgKyAxKTtcbiAgICByZXR1cm4gbmV4dCA+PSAweERDMDAgJiYgbmV4dCA8PSAweERGRkYgPyAoYyA8PCAxMCkgKyBuZXh0IC0gMHgzNUZEQzAwIDogY1xuICB9O1xuXG4gIFJlZ0V4cFZhbGlkYXRpb25TdGF0ZS5wcm90b3R5cGUubmV4dEluZGV4ID0gZnVuY3Rpb24gbmV4dEluZGV4IChpKSB7XG4gICAgdmFyIHMgPSB0aGlzLnNvdXJjZTtcbiAgICB2YXIgbCA9IHMubGVuZ3RoO1xuICAgIGlmIChpID49IGwpIHtcbiAgICAgIHJldHVybiBsXG4gICAgfVxuICAgIHZhciBjID0gcy5jaGFyQ29kZUF0KGkpLCBuZXh0O1xuICAgIGlmICghdGhpcy5zd2l0Y2hVIHx8IGMgPD0gMHhEN0ZGIHx8IGMgPj0gMHhFMDAwIHx8IGkgKyAxID49IGwgfHxcbiAgICAgICAgKG5leHQgPSBzLmNoYXJDb2RlQXQoaSArIDEpKSA8IDB4REMwMCB8fCBuZXh0ID4gMHhERkZGKSB7XG4gICAgICByZXR1cm4gaSArIDFcbiAgICB9XG4gICAgcmV0dXJuIGkgKyAyXG4gIH07XG5cbiAgUmVnRXhwVmFsaWRhdGlvblN0YXRlLnByb3RvdHlwZS5jdXJyZW50ID0gZnVuY3Rpb24gY3VycmVudCAoKSB7XG4gICAgcmV0dXJuIHRoaXMuYXQodGhpcy5wb3MpXG4gIH07XG5cbiAgUmVnRXhwVmFsaWRhdGlvblN0YXRlLnByb3RvdHlwZS5sb29rYWhlYWQgPSBmdW5jdGlvbiBsb29rYWhlYWQgKCkge1xuICAgIHJldHVybiB0aGlzLmF0KHRoaXMubmV4dEluZGV4KHRoaXMucG9zKSlcbiAgfTtcblxuICBSZWdFeHBWYWxpZGF0aW9uU3RhdGUucHJvdG90eXBlLmFkdmFuY2UgPSBmdW5jdGlvbiBhZHZhbmNlICgpIHtcbiAgICB0aGlzLnBvcyA9IHRoaXMubmV4dEluZGV4KHRoaXMucG9zKTtcbiAgfTtcblxuICBSZWdFeHBWYWxpZGF0aW9uU3RhdGUucHJvdG90eXBlLmVhdCA9IGZ1bmN0aW9uIGVhdCAoY2gpIHtcbiAgICBpZiAodGhpcy5jdXJyZW50KCkgPT09IGNoKSB7XG4gICAgICB0aGlzLmFkdmFuY2UoKTtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9O1xuXG4gIGZ1bmN0aW9uIGNvZGVQb2ludFRvU3RyaW5nKGNoKSB7XG4gICAgaWYgKGNoIDw9IDB4RkZGRikgeyByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShjaCkgfVxuICAgIGNoIC09IDB4MTAwMDA7XG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoKGNoID4+IDEwKSArIDB4RDgwMCwgKGNoICYgMHgwM0ZGKSArIDB4REMwMClcbiAgfVxuXG4gIHBwJDgudmFsaWRhdGVSZWdFeHBGbGFncyA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgdmFyIHZhbGlkRmxhZ3MgPSBzdGF0ZS52YWxpZEZsYWdzO1xuICAgIHZhciBmbGFncyA9IHN0YXRlLmZsYWdzO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmbGFncy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGZsYWcgPSBmbGFncy5jaGFyQXQoaSk7XG4gICAgICBpZiAodmFsaWRGbGFncy5pbmRleE9mKGZsYWcpID09PSAtMSkge1xuICAgICAgICB0aGlzLnJhaXNlKHN0YXRlLnN0YXJ0LCBcIkludmFsaWQgcmVndWxhciBleHByZXNzaW9uIGZsYWdcIik7XG4gICAgICB9XG4gICAgICBpZiAoZmxhZ3MuaW5kZXhPZihmbGFnLCBpICsgMSkgPiAtMSkge1xuICAgICAgICB0aGlzLnJhaXNlKHN0YXRlLnN0YXJ0LCBcIkR1cGxpY2F0ZSByZWd1bGFyIGV4cHJlc3Npb24gZmxhZ1wiKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgcHAkOC52YWxpZGF0ZVJlZ0V4cFBhdHRlcm4gPSBmdW5jdGlvbihzdGF0ZSkge1xuICAgIHRoaXMucmVnZXhwX3BhdHRlcm4oc3RhdGUpO1xuXG4gICAgaWYgKCFzdGF0ZS5zd2l0Y2hOICYmIHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA5ICYmIHN0YXRlLmdyb3VwTmFtZXMubGVuZ3RoID4gMCkge1xuICAgICAgc3RhdGUuc3dpdGNoTiA9IHRydWU7XG4gICAgICB0aGlzLnJlZ2V4cF9wYXR0ZXJuKHN0YXRlKTtcbiAgICB9XG4gIH07XG5cbiAgcHAkOC5yZWdleHBfcGF0dGVybiA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgc3RhdGUucG9zID0gMDtcbiAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSAwO1xuICAgIHN0YXRlLmxhc3RTdHJpbmdWYWx1ZSA9IFwiXCI7XG4gICAgc3RhdGUubGFzdEFzc2VydGlvbklzUXVhbnRpZmlhYmxlID0gZmFsc2U7XG4gICAgc3RhdGUubnVtQ2FwdHVyaW5nUGFyZW5zID0gMDtcbiAgICBzdGF0ZS5tYXhCYWNrUmVmZXJlbmNlID0gMDtcbiAgICBzdGF0ZS5ncm91cE5hbWVzLmxlbmd0aCA9IDA7XG4gICAgc3RhdGUuYmFja1JlZmVyZW5jZU5hbWVzLmxlbmd0aCA9IDA7XG5cbiAgICB0aGlzLnJlZ2V4cF9kaXNqdW5jdGlvbihzdGF0ZSk7XG5cbiAgICBpZiAoc3RhdGUucG9zICE9PSBzdGF0ZS5zb3VyY2UubGVuZ3RoKSB7XG4gICAgICBpZiAoc3RhdGUuZWF0KDB4MjkgKSkge1xuICAgICAgICBzdGF0ZS5yYWlzZShcIlVubWF0Y2hlZCAnKSdcIik7XG4gICAgICB9XG4gICAgICBpZiAoc3RhdGUuZWF0KDB4NUQgKSB8fCBzdGF0ZS5lYXQoMHg3RCApKSB7XG4gICAgICAgIHN0YXRlLnJhaXNlKFwiTG9uZSBxdWFudGlmaWVyIGJyYWNrZXRzXCIpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoc3RhdGUubWF4QmFja1JlZmVyZW5jZSA+IHN0YXRlLm51bUNhcHR1cmluZ1BhcmVucykge1xuICAgICAgc3RhdGUucmFpc2UoXCJJbnZhbGlkIGVzY2FwZVwiKTtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDAsIGxpc3QgPSBzdGF0ZS5iYWNrUmVmZXJlbmNlTmFtZXM7IGkgPCBsaXN0Lmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICB2YXIgbmFtZSA9IGxpc3RbaV07XG5cbiAgICAgIGlmIChzdGF0ZS5ncm91cE5hbWVzLmluZGV4T2YobmFtZSkgPT09IC0xKSB7XG4gICAgICAgIHN0YXRlLnJhaXNlKFwiSW52YWxpZCBuYW1lZCBjYXB0dXJlIHJlZmVyZW5jZWRcIik7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHBwJDgucmVnZXhwX2Rpc2p1bmN0aW9uID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgICB0aGlzLnJlZ2V4cF9hbHRlcm5hdGl2ZShzdGF0ZSk7XG4gICAgd2hpbGUgKHN0YXRlLmVhdCgweDdDICkpIHtcbiAgICAgIHRoaXMucmVnZXhwX2FsdGVybmF0aXZlKHN0YXRlKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5yZWdleHBfZWF0UXVhbnRpZmllcihzdGF0ZSwgdHJ1ZSkpIHtcbiAgICAgIHN0YXRlLnJhaXNlKFwiTm90aGluZyB0byByZXBlYXRcIik7XG4gICAgfVxuICAgIGlmIChzdGF0ZS5lYXQoMHg3QiApKSB7XG4gICAgICBzdGF0ZS5yYWlzZShcIkxvbmUgcXVhbnRpZmllciBicmFja2V0c1wiKTtcbiAgICB9XG4gIH07XG5cbiAgcHAkOC5yZWdleHBfYWx0ZXJuYXRpdmUgPSBmdW5jdGlvbihzdGF0ZSkge1xuICAgIHdoaWxlIChzdGF0ZS5wb3MgPCBzdGF0ZS5zb3VyY2UubGVuZ3RoICYmIHRoaXMucmVnZXhwX2VhdFRlcm0oc3RhdGUpKVxuICAgICAgeyB9XG4gIH07XG5cbiAgcHAkOC5yZWdleHBfZWF0VGVybSA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgaWYgKHRoaXMucmVnZXhwX2VhdEFzc2VydGlvbihzdGF0ZSkpIHtcbiAgICAgIGlmIChzdGF0ZS5sYXN0QXNzZXJ0aW9uSXNRdWFudGlmaWFibGUgJiYgdGhpcy5yZWdleHBfZWF0UXVhbnRpZmllcihzdGF0ZSkpIHtcbiAgICAgICAgaWYgKHN0YXRlLnN3aXRjaFUpIHtcbiAgICAgICAgICBzdGF0ZS5yYWlzZShcIkludmFsaWQgcXVhbnRpZmllclwiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG5cbiAgICBpZiAoc3RhdGUuc3dpdGNoVSA/IHRoaXMucmVnZXhwX2VhdEF0b20oc3RhdGUpIDogdGhpcy5yZWdleHBfZWF0RXh0ZW5kZWRBdG9tKHN0YXRlKSkge1xuICAgICAgdGhpcy5yZWdleHBfZWF0UXVhbnRpZmllcihzdGF0ZSk7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZVxuICB9O1xuXG4gIHBwJDgucmVnZXhwX2VhdEFzc2VydGlvbiA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgdmFyIHN0YXJ0ID0gc3RhdGUucG9zO1xuICAgIHN0YXRlLmxhc3RBc3NlcnRpb25Jc1F1YW50aWZpYWJsZSA9IGZhbHNlO1xuXG4gICAgaWYgKHN0YXRlLmVhdCgweDVFICkgfHwgc3RhdGUuZWF0KDB4MjQgKSkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG5cbiAgICBpZiAoc3RhdGUuZWF0KDB4NUMgKSkge1xuICAgICAgaWYgKHN0YXRlLmVhdCgweDQyICkgfHwgc3RhdGUuZWF0KDB4NjIgKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgICAgc3RhdGUucG9zID0gc3RhcnQ7XG4gICAgfVxuXG4gICAgaWYgKHN0YXRlLmVhdCgweDI4ICkgJiYgc3RhdGUuZWF0KDB4M0YgKSkge1xuICAgICAgdmFyIGxvb2tiZWhpbmQgPSBmYWxzZTtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOSkge1xuICAgICAgICBsb29rYmVoaW5kID0gc3RhdGUuZWF0KDB4M0MgKTtcbiAgICAgIH1cbiAgICAgIGlmIChzdGF0ZS5lYXQoMHgzRCApIHx8IHN0YXRlLmVhdCgweDIxICkpIHtcbiAgICAgICAgdGhpcy5yZWdleHBfZGlzanVuY3Rpb24oc3RhdGUpO1xuICAgICAgICBpZiAoIXN0YXRlLmVhdCgweDI5ICkpIHtcbiAgICAgICAgICBzdGF0ZS5yYWlzZShcIlVudGVybWluYXRlZCBncm91cFwiKTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5sYXN0QXNzZXJ0aW9uSXNRdWFudGlmaWFibGUgPSAhbG9va2JlaGluZDtcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzdGF0ZS5wb3MgPSBzdGFydDtcbiAgICByZXR1cm4gZmFsc2VcbiAgfTtcblxuICBwcCQ4LnJlZ2V4cF9lYXRRdWFudGlmaWVyID0gZnVuY3Rpb24oc3RhdGUsIG5vRXJyb3IpIHtcbiAgICBpZiAoIG5vRXJyb3IgPT09IHZvaWQgMCApIG5vRXJyb3IgPSBmYWxzZTtcblxuICAgIGlmICh0aGlzLnJlZ2V4cF9lYXRRdWFudGlmaWVyUHJlZml4KHN0YXRlLCBub0Vycm9yKSkge1xuICAgICAgc3RhdGUuZWF0KDB4M0YgKTtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9O1xuXG4gIHBwJDgucmVnZXhwX2VhdFF1YW50aWZpZXJQcmVmaXggPSBmdW5jdGlvbihzdGF0ZSwgbm9FcnJvcikge1xuICAgIHJldHVybiAoXG4gICAgICBzdGF0ZS5lYXQoMHgyQSApIHx8XG4gICAgICBzdGF0ZS5lYXQoMHgyQiApIHx8XG4gICAgICBzdGF0ZS5lYXQoMHgzRiApIHx8XG4gICAgICB0aGlzLnJlZ2V4cF9lYXRCcmFjZWRRdWFudGlmaWVyKHN0YXRlLCBub0Vycm9yKVxuICAgIClcbiAgfTtcbiAgcHAkOC5yZWdleHBfZWF0QnJhY2VkUXVhbnRpZmllciA9IGZ1bmN0aW9uKHN0YXRlLCBub0Vycm9yKSB7XG4gICAgdmFyIHN0YXJ0ID0gc3RhdGUucG9zO1xuICAgIGlmIChzdGF0ZS5lYXQoMHg3QiApKSB7XG4gICAgICB2YXIgbWluID0gMCwgbWF4ID0gLTE7XG4gICAgICBpZiAodGhpcy5yZWdleHBfZWF0RGVjaW1hbERpZ2l0cyhzdGF0ZSkpIHtcbiAgICAgICAgbWluID0gc3RhdGUubGFzdEludFZhbHVlO1xuICAgICAgICBpZiAoc3RhdGUuZWF0KDB4MkMgKSAmJiB0aGlzLnJlZ2V4cF9lYXREZWNpbWFsRGlnaXRzKHN0YXRlKSkge1xuICAgICAgICAgIG1heCA9IHN0YXRlLmxhc3RJbnRWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhdGUuZWF0KDB4N0QgKSkge1xuICAgICAgICAgIGlmIChtYXggIT09IC0xICYmIG1heCA8IG1pbiAmJiAhbm9FcnJvcikge1xuICAgICAgICAgICAgc3RhdGUucmFpc2UoXCJudW1iZXJzIG91dCBvZiBvcmRlciBpbiB7fSBxdWFudGlmaWVyXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoc3RhdGUuc3dpdGNoVSAmJiAhbm9FcnJvcikge1xuICAgICAgICBzdGF0ZS5yYWlzZShcIkluY29tcGxldGUgcXVhbnRpZmllclwiKTtcbiAgICAgIH1cbiAgICAgIHN0YXRlLnBvcyA9IHN0YXJ0O1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2VcbiAgfTtcblxuICBwcCQ4LnJlZ2V4cF9lYXRBdG9tID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgICByZXR1cm4gKFxuICAgICAgdGhpcy5yZWdleHBfZWF0UGF0dGVybkNoYXJhY3RlcnMoc3RhdGUpIHx8XG4gICAgICBzdGF0ZS5lYXQoMHgyRSApIHx8XG4gICAgICB0aGlzLnJlZ2V4cF9lYXRSZXZlcnNlU29saWR1c0F0b21Fc2NhcGUoc3RhdGUpIHx8XG4gICAgICB0aGlzLnJlZ2V4cF9lYXRDaGFyYWN0ZXJDbGFzcyhzdGF0ZSkgfHxcbiAgICAgIHRoaXMucmVnZXhwX2VhdFVuY2FwdHVyaW5nR3JvdXAoc3RhdGUpIHx8XG4gICAgICB0aGlzLnJlZ2V4cF9lYXRDYXB0dXJpbmdHcm91cChzdGF0ZSlcbiAgICApXG4gIH07XG4gIHBwJDgucmVnZXhwX2VhdFJldmVyc2VTb2xpZHVzQXRvbUVzY2FwZSA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgdmFyIHN0YXJ0ID0gc3RhdGUucG9zO1xuICAgIGlmIChzdGF0ZS5lYXQoMHg1QyApKSB7XG4gICAgICBpZiAodGhpcy5yZWdleHBfZWF0QXRvbUVzY2FwZShzdGF0ZSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICAgIHN0YXRlLnBvcyA9IHN0YXJ0O1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2VcbiAgfTtcbiAgcHAkOC5yZWdleHBfZWF0VW5jYXB0dXJpbmdHcm91cCA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgdmFyIHN0YXJ0ID0gc3RhdGUucG9zO1xuICAgIGlmIChzdGF0ZS5lYXQoMHgyOCApKSB7XG4gICAgICBpZiAoc3RhdGUuZWF0KDB4M0YgKSAmJiBzdGF0ZS5lYXQoMHgzQSApKSB7XG4gICAgICAgIHRoaXMucmVnZXhwX2Rpc2p1bmN0aW9uKHN0YXRlKTtcbiAgICAgICAgaWYgKHN0YXRlLmVhdCgweDI5ICkpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICB9XG4gICAgICAgIHN0YXRlLnJhaXNlKFwiVW50ZXJtaW5hdGVkIGdyb3VwXCIpO1xuICAgICAgfVxuICAgICAgc3RhdGUucG9zID0gc3RhcnQ7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9O1xuICBwcCQ4LnJlZ2V4cF9lYXRDYXB0dXJpbmdHcm91cCA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgaWYgKHN0YXRlLmVhdCgweDI4ICkpIHtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOSkge1xuICAgICAgICB0aGlzLnJlZ2V4cF9ncm91cFNwZWNpZmllcihzdGF0ZSk7XG4gICAgICB9IGVsc2UgaWYgKHN0YXRlLmN1cnJlbnQoKSA9PT0gMHgzRiApIHtcbiAgICAgICAgc3RhdGUucmFpc2UoXCJJbnZhbGlkIGdyb3VwXCIpO1xuICAgICAgfVxuICAgICAgdGhpcy5yZWdleHBfZGlzanVuY3Rpb24oc3RhdGUpO1xuICAgICAgaWYgKHN0YXRlLmVhdCgweDI5ICkpIHtcbiAgICAgICAgc3RhdGUubnVtQ2FwdHVyaW5nUGFyZW5zICs9IDE7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgICBzdGF0ZS5yYWlzZShcIlVudGVybWluYXRlZCBncm91cFwiKTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlXG4gIH07XG5cbiAgcHAkOC5yZWdleHBfZWF0RXh0ZW5kZWRBdG9tID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgICByZXR1cm4gKFxuICAgICAgc3RhdGUuZWF0KDB4MkUgKSB8fFxuICAgICAgdGhpcy5yZWdleHBfZWF0UmV2ZXJzZVNvbGlkdXNBdG9tRXNjYXBlKHN0YXRlKSB8fFxuICAgICAgdGhpcy5yZWdleHBfZWF0Q2hhcmFjdGVyQ2xhc3Moc3RhdGUpIHx8XG4gICAgICB0aGlzLnJlZ2V4cF9lYXRVbmNhcHR1cmluZ0dyb3VwKHN0YXRlKSB8fFxuICAgICAgdGhpcy5yZWdleHBfZWF0Q2FwdHVyaW5nR3JvdXAoc3RhdGUpIHx8XG4gICAgICB0aGlzLnJlZ2V4cF9lYXRJbnZhbGlkQnJhY2VkUXVhbnRpZmllcihzdGF0ZSkgfHxcbiAgICAgIHRoaXMucmVnZXhwX2VhdEV4dGVuZGVkUGF0dGVybkNoYXJhY3RlcihzdGF0ZSlcbiAgICApXG4gIH07XG5cbiAgcHAkOC5yZWdleHBfZWF0SW52YWxpZEJyYWNlZFF1YW50aWZpZXIgPSBmdW5jdGlvbihzdGF0ZSkge1xuICAgIGlmICh0aGlzLnJlZ2V4cF9lYXRCcmFjZWRRdWFudGlmaWVyKHN0YXRlLCB0cnVlKSkge1xuICAgICAgc3RhdGUucmFpc2UoXCJOb3RoaW5nIHRvIHJlcGVhdFwiKTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlXG4gIH07XG5cbiAgcHAkOC5yZWdleHBfZWF0U3ludGF4Q2hhcmFjdGVyID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgICB2YXIgY2ggPSBzdGF0ZS5jdXJyZW50KCk7XG4gICAgaWYgKGlzU3ludGF4Q2hhcmFjdGVyKGNoKSkge1xuICAgICAgc3RhdGUubGFzdEludFZhbHVlID0gY2g7XG4gICAgICBzdGF0ZS5hZHZhbmNlKCk7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2VcbiAgfTtcbiAgZnVuY3Rpb24gaXNTeW50YXhDaGFyYWN0ZXIoY2gpIHtcbiAgICByZXR1cm4gKFxuICAgICAgY2ggPT09IDB4MjQgIHx8XG4gICAgICBjaCA+PSAweDI4ICAmJiBjaCA8PSAweDJCICB8fFxuICAgICAgY2ggPT09IDB4MkUgIHx8XG4gICAgICBjaCA9PT0gMHgzRiAgfHxcbiAgICAgIGNoID49IDB4NUIgICYmIGNoIDw9IDB4NUUgIHx8XG4gICAgICBjaCA+PSAweDdCICAmJiBjaCA8PSAweDdEIFxuICAgIClcbiAgfVxuXG4gIHBwJDgucmVnZXhwX2VhdFBhdHRlcm5DaGFyYWN0ZXJzID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgICB2YXIgc3RhcnQgPSBzdGF0ZS5wb3M7XG4gICAgdmFyIGNoID0gMDtcbiAgICB3aGlsZSAoKGNoID0gc3RhdGUuY3VycmVudCgpKSAhPT0gLTEgJiYgIWlzU3ludGF4Q2hhcmFjdGVyKGNoKSkge1xuICAgICAgc3RhdGUuYWR2YW5jZSgpO1xuICAgIH1cbiAgICByZXR1cm4gc3RhdGUucG9zICE9PSBzdGFydFxuICB9O1xuXG4gIHBwJDgucmVnZXhwX2VhdEV4dGVuZGVkUGF0dGVybkNoYXJhY3RlciA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgdmFyIGNoID0gc3RhdGUuY3VycmVudCgpO1xuICAgIGlmIChcbiAgICAgIGNoICE9PSAtMSAmJlxuICAgICAgY2ggIT09IDB4MjQgICYmXG4gICAgICAhKGNoID49IDB4MjggICYmIGNoIDw9IDB4MkIgKSAmJlxuICAgICAgY2ggIT09IDB4MkUgICYmXG4gICAgICBjaCAhPT0gMHgzRiAgJiZcbiAgICAgIGNoICE9PSAweDVCICAmJlxuICAgICAgY2ggIT09IDB4NUUgICYmXG4gICAgICBjaCAhPT0gMHg3QyBcbiAgICApIHtcbiAgICAgIHN0YXRlLmFkdmFuY2UoKTtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9O1xuXG4gIHBwJDgucmVnZXhwX2dyb3VwU3BlY2lmaWVyID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgICBpZiAoc3RhdGUuZWF0KDB4M0YgKSkge1xuICAgICAgaWYgKHRoaXMucmVnZXhwX2VhdEdyb3VwTmFtZShzdGF0ZSkpIHtcbiAgICAgICAgaWYgKHN0YXRlLmdyb3VwTmFtZXMuaW5kZXhPZihzdGF0ZS5sYXN0U3RyaW5nVmFsdWUpICE9PSAtMSkge1xuICAgICAgICAgIHN0YXRlLnJhaXNlKFwiRHVwbGljYXRlIGNhcHR1cmUgZ3JvdXAgbmFtZVwiKTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5ncm91cE5hbWVzLnB1c2goc3RhdGUubGFzdFN0cmluZ1ZhbHVlKTtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICBzdGF0ZS5yYWlzZShcIkludmFsaWQgZ3JvdXBcIik7XG4gICAgfVxuICB9O1xuXG4gIHBwJDgucmVnZXhwX2VhdEdyb3VwTmFtZSA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgc3RhdGUubGFzdFN0cmluZ1ZhbHVlID0gXCJcIjtcbiAgICBpZiAoc3RhdGUuZWF0KDB4M0MgKSkge1xuICAgICAgaWYgKHRoaXMucmVnZXhwX2VhdFJlZ0V4cElkZW50aWZpZXJOYW1lKHN0YXRlKSAmJiBzdGF0ZS5lYXQoMHgzRSApKSB7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgICBzdGF0ZS5yYWlzZShcIkludmFsaWQgY2FwdHVyZSBncm91cCBuYW1lXCIpO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2VcbiAgfTtcblxuICBwcCQ4LnJlZ2V4cF9lYXRSZWdFeHBJZGVudGlmaWVyTmFtZSA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgc3RhdGUubGFzdFN0cmluZ1ZhbHVlID0gXCJcIjtcbiAgICBpZiAodGhpcy5yZWdleHBfZWF0UmVnRXhwSWRlbnRpZmllclN0YXJ0KHN0YXRlKSkge1xuICAgICAgc3RhdGUubGFzdFN0cmluZ1ZhbHVlICs9IGNvZGVQb2ludFRvU3RyaW5nKHN0YXRlLmxhc3RJbnRWYWx1ZSk7XG4gICAgICB3aGlsZSAodGhpcy5yZWdleHBfZWF0UmVnRXhwSWRlbnRpZmllclBhcnQoc3RhdGUpKSB7XG4gICAgICAgIHN0YXRlLmxhc3RTdHJpbmdWYWx1ZSArPSBjb2RlUG9pbnRUb1N0cmluZyhzdGF0ZS5sYXN0SW50VmFsdWUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlXG4gIH07XG5cbiAgcHAkOC5yZWdleHBfZWF0UmVnRXhwSWRlbnRpZmllclN0YXJ0ID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgICB2YXIgc3RhcnQgPSBzdGF0ZS5wb3M7XG4gICAgdmFyIGNoID0gc3RhdGUuY3VycmVudCgpO1xuICAgIHN0YXRlLmFkdmFuY2UoKTtcblxuICAgIGlmIChjaCA9PT0gMHg1QyAgJiYgdGhpcy5yZWdleHBfZWF0UmVnRXhwVW5pY29kZUVzY2FwZVNlcXVlbmNlKHN0YXRlKSkge1xuICAgICAgY2ggPSBzdGF0ZS5sYXN0SW50VmFsdWU7XG4gICAgfVxuICAgIGlmIChpc1JlZ0V4cElkZW50aWZpZXJTdGFydChjaCkpIHtcbiAgICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IGNoO1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG5cbiAgICBzdGF0ZS5wb3MgPSBzdGFydDtcbiAgICByZXR1cm4gZmFsc2VcbiAgfTtcbiAgZnVuY3Rpb24gaXNSZWdFeHBJZGVudGlmaWVyU3RhcnQoY2gpIHtcbiAgICByZXR1cm4gaXNJZGVudGlmaWVyU3RhcnQoY2gsIHRydWUpIHx8IGNoID09PSAweDI0ICB8fCBjaCA9PT0gMHg1RiBcbiAgfVxuXG4gIHBwJDgucmVnZXhwX2VhdFJlZ0V4cElkZW50aWZpZXJQYXJ0ID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgICB2YXIgc3RhcnQgPSBzdGF0ZS5wb3M7XG4gICAgdmFyIGNoID0gc3RhdGUuY3VycmVudCgpO1xuICAgIHN0YXRlLmFkdmFuY2UoKTtcblxuICAgIGlmIChjaCA9PT0gMHg1QyAgJiYgdGhpcy5yZWdleHBfZWF0UmVnRXhwVW5pY29kZUVzY2FwZVNlcXVlbmNlKHN0YXRlKSkge1xuICAgICAgY2ggPSBzdGF0ZS5sYXN0SW50VmFsdWU7XG4gICAgfVxuICAgIGlmIChpc1JlZ0V4cElkZW50aWZpZXJQYXJ0KGNoKSkge1xuICAgICAgc3RhdGUubGFzdEludFZhbHVlID0gY2g7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cblxuICAgIHN0YXRlLnBvcyA9IHN0YXJ0O1xuICAgIHJldHVybiBmYWxzZVxuICB9O1xuICBmdW5jdGlvbiBpc1JlZ0V4cElkZW50aWZpZXJQYXJ0KGNoKSB7XG4gICAgcmV0dXJuIGlzSWRlbnRpZmllckNoYXIoY2gsIHRydWUpIHx8IGNoID09PSAweDI0ICB8fCBjaCA9PT0gMHg1RiAgfHwgY2ggPT09IDB4MjAwQyAgfHwgY2ggPT09IDB4MjAwRCBcbiAgfVxuXG4gIHBwJDgucmVnZXhwX2VhdEF0b21Fc2NhcGUgPSBmdW5jdGlvbihzdGF0ZSkge1xuICAgIGlmIChcbiAgICAgIHRoaXMucmVnZXhwX2VhdEJhY2tSZWZlcmVuY2Uoc3RhdGUpIHx8XG4gICAgICB0aGlzLnJlZ2V4cF9lYXRDaGFyYWN0ZXJDbGFzc0VzY2FwZShzdGF0ZSkgfHxcbiAgICAgIHRoaXMucmVnZXhwX2VhdENoYXJhY3RlckVzY2FwZShzdGF0ZSkgfHxcbiAgICAgIChzdGF0ZS5zd2l0Y2hOICYmIHRoaXMucmVnZXhwX2VhdEtHcm91cE5hbWUoc3RhdGUpKVxuICAgICkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgaWYgKHN0YXRlLnN3aXRjaFUpIHtcbiAgICAgIGlmIChzdGF0ZS5jdXJyZW50KCkgPT09IDB4NjMgKSB7XG4gICAgICAgIHN0YXRlLnJhaXNlKFwiSW52YWxpZCB1bmljb2RlIGVzY2FwZVwiKTtcbiAgICAgIH1cbiAgICAgIHN0YXRlLnJhaXNlKFwiSW52YWxpZCBlc2NhcGVcIik7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9O1xuICBwcCQ4LnJlZ2V4cF9lYXRCYWNrUmVmZXJlbmNlID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgICB2YXIgc3RhcnQgPSBzdGF0ZS5wb3M7XG4gICAgaWYgKHRoaXMucmVnZXhwX2VhdERlY2ltYWxFc2NhcGUoc3RhdGUpKSB7XG4gICAgICB2YXIgbiA9IHN0YXRlLmxhc3RJbnRWYWx1ZTtcbiAgICAgIGlmIChzdGF0ZS5zd2l0Y2hVKSB7XG4gICAgICAgIGlmIChuID4gc3RhdGUubWF4QmFja1JlZmVyZW5jZSkge1xuICAgICAgICAgIHN0YXRlLm1heEJhY2tSZWZlcmVuY2UgPSBuO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgICBpZiAobiA8PSBzdGF0ZS5udW1DYXB0dXJpbmdQYXJlbnMpIHtcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICAgIHN0YXRlLnBvcyA9IHN0YXJ0O1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2VcbiAgfTtcbiAgcHAkOC5yZWdleHBfZWF0S0dyb3VwTmFtZSA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgaWYgKHN0YXRlLmVhdCgweDZCICkpIHtcbiAgICAgIGlmICh0aGlzLnJlZ2V4cF9lYXRHcm91cE5hbWUoc3RhdGUpKSB7XG4gICAgICAgIHN0YXRlLmJhY2tSZWZlcmVuY2VOYW1lcy5wdXNoKHN0YXRlLmxhc3RTdHJpbmdWYWx1ZSk7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgICBzdGF0ZS5yYWlzZShcIkludmFsaWQgbmFtZWQgcmVmZXJlbmNlXCIpO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2VcbiAgfTtcblxuICBwcCQ4LnJlZ2V4cF9lYXRDaGFyYWN0ZXJFc2NhcGUgPSBmdW5jdGlvbihzdGF0ZSkge1xuICAgIHJldHVybiAoXG4gICAgICB0aGlzLnJlZ2V4cF9lYXRDb250cm9sRXNjYXBlKHN0YXRlKSB8fFxuICAgICAgdGhpcy5yZWdleHBfZWF0Q0NvbnRyb2xMZXR0ZXIoc3RhdGUpIHx8XG4gICAgICB0aGlzLnJlZ2V4cF9lYXRaZXJvKHN0YXRlKSB8fFxuICAgICAgdGhpcy5yZWdleHBfZWF0SGV4RXNjYXBlU2VxdWVuY2Uoc3RhdGUpIHx8XG4gICAgICB0aGlzLnJlZ2V4cF9lYXRSZWdFeHBVbmljb2RlRXNjYXBlU2VxdWVuY2Uoc3RhdGUpIHx8XG4gICAgICAoIXN0YXRlLnN3aXRjaFUgJiYgdGhpcy5yZWdleHBfZWF0TGVnYWN5T2N0YWxFc2NhcGVTZXF1ZW5jZShzdGF0ZSkpIHx8XG4gICAgICB0aGlzLnJlZ2V4cF9lYXRJZGVudGl0eUVzY2FwZShzdGF0ZSlcbiAgICApXG4gIH07XG4gIHBwJDgucmVnZXhwX2VhdENDb250cm9sTGV0dGVyID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgICB2YXIgc3RhcnQgPSBzdGF0ZS5wb3M7XG4gICAgaWYgKHN0YXRlLmVhdCgweDYzICkpIHtcbiAgICAgIGlmICh0aGlzLnJlZ2V4cF9lYXRDb250cm9sTGV0dGVyKHN0YXRlKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgICAgc3RhdGUucG9zID0gc3RhcnQ7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9O1xuICBwcCQ4LnJlZ2V4cF9lYXRaZXJvID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgICBpZiAoc3RhdGUuY3VycmVudCgpID09PSAweDMwICAmJiAhaXNEZWNpbWFsRGlnaXQoc3RhdGUubG9va2FoZWFkKCkpKSB7XG4gICAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSAwO1xuICAgICAgc3RhdGUuYWR2YW5jZSgpO1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlXG4gIH07XG5cbiAgcHAkOC5yZWdleHBfZWF0Q29udHJvbEVzY2FwZSA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgdmFyIGNoID0gc3RhdGUuY3VycmVudCgpO1xuICAgIGlmIChjaCA9PT0gMHg3NCApIHtcbiAgICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IDB4MDk7IFxuICAgICAgc3RhdGUuYWR2YW5jZSgpO1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgaWYgKGNoID09PSAweDZFICkge1xuICAgICAgc3RhdGUubGFzdEludFZhbHVlID0gMHgwQTsgXG4gICAgICBzdGF0ZS5hZHZhbmNlKCk7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICBpZiAoY2ggPT09IDB4NzYgKSB7XG4gICAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSAweDBCOyBcbiAgICAgIHN0YXRlLmFkdmFuY2UoKTtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIGlmIChjaCA9PT0gMHg2NiApIHtcbiAgICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IDB4MEM7IFxuICAgICAgc3RhdGUuYWR2YW5jZSgpO1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgaWYgKGNoID09PSAweDcyICkge1xuICAgICAgc3RhdGUubGFzdEludFZhbHVlID0gMHgwRDsgXG4gICAgICBzdGF0ZS5hZHZhbmNlKCk7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2VcbiAgfTtcblxuICBwcCQ4LnJlZ2V4cF9lYXRDb250cm9sTGV0dGVyID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgICB2YXIgY2ggPSBzdGF0ZS5jdXJyZW50KCk7XG4gICAgaWYgKGlzQ29udHJvbExldHRlcihjaCkpIHtcbiAgICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IGNoICUgMHgyMDtcbiAgICAgIHN0YXRlLmFkdmFuY2UoKTtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9O1xuICBmdW5jdGlvbiBpc0NvbnRyb2xMZXR0ZXIoY2gpIHtcbiAgICByZXR1cm4gKFxuICAgICAgKGNoID49IDB4NDEgICYmIGNoIDw9IDB4NUEgKSB8fFxuICAgICAgKGNoID49IDB4NjEgICYmIGNoIDw9IDB4N0EgKVxuICAgIClcbiAgfVxuXG4gIHBwJDgucmVnZXhwX2VhdFJlZ0V4cFVuaWNvZGVFc2NhcGVTZXF1ZW5jZSA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgdmFyIHN0YXJ0ID0gc3RhdGUucG9zO1xuXG4gICAgaWYgKHN0YXRlLmVhdCgweDc1ICkpIHtcbiAgICAgIGlmICh0aGlzLnJlZ2V4cF9lYXRGaXhlZEhleERpZ2l0cyhzdGF0ZSwgNCkpIHtcbiAgICAgICAgdmFyIGxlYWQgPSBzdGF0ZS5sYXN0SW50VmFsdWU7XG4gICAgICAgIGlmIChzdGF0ZS5zd2l0Y2hVICYmIGxlYWQgPj0gMHhEODAwICYmIGxlYWQgPD0gMHhEQkZGKSB7XG4gICAgICAgICAgdmFyIGxlYWRTdXJyb2dhdGVFbmQgPSBzdGF0ZS5wb3M7XG4gICAgICAgICAgaWYgKHN0YXRlLmVhdCgweDVDICkgJiYgc3RhdGUuZWF0KDB4NzUgKSAmJiB0aGlzLnJlZ2V4cF9lYXRGaXhlZEhleERpZ2l0cyhzdGF0ZSwgNCkpIHtcbiAgICAgICAgICAgIHZhciB0cmFpbCA9IHN0YXRlLmxhc3RJbnRWYWx1ZTtcbiAgICAgICAgICAgIGlmICh0cmFpbCA+PSAweERDMDAgJiYgdHJhaWwgPD0gMHhERkZGKSB7XG4gICAgICAgICAgICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IChsZWFkIC0gMHhEODAwKSAqIDB4NDAwICsgKHRyYWlsIC0gMHhEQzAwKSArIDB4MTAwMDA7XG4gICAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHN0YXRlLnBvcyA9IGxlYWRTdXJyb2dhdGVFbmQ7XG4gICAgICAgICAgc3RhdGUubGFzdEludFZhbHVlID0gbGVhZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgICAgaWYgKFxuICAgICAgICBzdGF0ZS5zd2l0Y2hVICYmXG4gICAgICAgIHN0YXRlLmVhdCgweDdCICkgJiZcbiAgICAgICAgdGhpcy5yZWdleHBfZWF0SGV4RGlnaXRzKHN0YXRlKSAmJlxuICAgICAgICBzdGF0ZS5lYXQoMHg3RCApICYmXG4gICAgICAgIGlzVmFsaWRVbmljb2RlKHN0YXRlLmxhc3RJbnRWYWx1ZSlcbiAgICAgICkge1xuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgICAgaWYgKHN0YXRlLnN3aXRjaFUpIHtcbiAgICAgICAgc3RhdGUucmFpc2UoXCJJbnZhbGlkIHVuaWNvZGUgZXNjYXBlXCIpO1xuICAgICAgfVxuICAgICAgc3RhdGUucG9zID0gc3RhcnQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlXG4gIH07XG4gIGZ1bmN0aW9uIGlzVmFsaWRVbmljb2RlKGNoKSB7XG4gICAgcmV0dXJuIGNoID49IDAgJiYgY2ggPD0gMHgxMEZGRkZcbiAgfVxuXG4gIHBwJDgucmVnZXhwX2VhdElkZW50aXR5RXNjYXBlID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgICBpZiAoc3RhdGUuc3dpdGNoVSkge1xuICAgICAgaWYgKHRoaXMucmVnZXhwX2VhdFN5bnRheENoYXJhY3RlcihzdGF0ZSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICAgIGlmIChzdGF0ZS5lYXQoMHgyRiApKSB7XG4gICAgICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IDB4MkY7IFxuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgdmFyIGNoID0gc3RhdGUuY3VycmVudCgpO1xuICAgIGlmIChjaCAhPT0gMHg2MyAgJiYgKCFzdGF0ZS5zd2l0Y2hOIHx8IGNoICE9PSAweDZCICkpIHtcbiAgICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IGNoO1xuICAgICAgc3RhdGUuYWR2YW5jZSgpO1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2VcbiAgfTtcblxuICBwcCQ4LnJlZ2V4cF9lYXREZWNpbWFsRXNjYXBlID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSAwO1xuICAgIHZhciBjaCA9IHN0YXRlLmN1cnJlbnQoKTtcbiAgICBpZiAoY2ggPj0gMHgzMSAgJiYgY2ggPD0gMHgzOSApIHtcbiAgICAgIGRvIHtcbiAgICAgICAgc3RhdGUubGFzdEludFZhbHVlID0gMTAgKiBzdGF0ZS5sYXN0SW50VmFsdWUgKyAoY2ggLSAweDMwICk7XG4gICAgICAgIHN0YXRlLmFkdmFuY2UoKTtcbiAgICAgIH0gd2hpbGUgKChjaCA9IHN0YXRlLmN1cnJlbnQoKSkgPj0gMHgzMCAgJiYgY2ggPD0gMHgzOSApXG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2VcbiAgfTtcblxuICBwcCQ4LnJlZ2V4cF9lYXRDaGFyYWN0ZXJDbGFzc0VzY2FwZSA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgdmFyIGNoID0gc3RhdGUuY3VycmVudCgpO1xuXG4gICAgaWYgKGlzQ2hhcmFjdGVyQ2xhc3NFc2NhcGUoY2gpKSB7XG4gICAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSAtMTtcbiAgICAgIHN0YXRlLmFkdmFuY2UoKTtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuXG4gICAgaWYgKFxuICAgICAgc3RhdGUuc3dpdGNoVSAmJlxuICAgICAgdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDkgJiZcbiAgICAgIChjaCA9PT0gMHg1MCAgfHwgY2ggPT09IDB4NzAgKVxuICAgICkge1xuICAgICAgc3RhdGUubGFzdEludFZhbHVlID0gLTE7XG4gICAgICBzdGF0ZS5hZHZhbmNlKCk7XG4gICAgICBpZiAoXG4gICAgICAgIHN0YXRlLmVhdCgweDdCICkgJiZcbiAgICAgICAgdGhpcy5yZWdleHBfZWF0VW5pY29kZVByb3BlcnR5VmFsdWVFeHByZXNzaW9uKHN0YXRlKSAmJlxuICAgICAgICBzdGF0ZS5lYXQoMHg3RCApXG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICAgIHN0YXRlLnJhaXNlKFwiSW52YWxpZCBwcm9wZXJ0eSBuYW1lXCIpO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZVxuICB9O1xuICBmdW5jdGlvbiBpc0NoYXJhY3RlckNsYXNzRXNjYXBlKGNoKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIGNoID09PSAweDY0ICB8fFxuICAgICAgY2ggPT09IDB4NDQgIHx8XG4gICAgICBjaCA9PT0gMHg3MyAgfHxcbiAgICAgIGNoID09PSAweDUzICB8fFxuICAgICAgY2ggPT09IDB4NzcgIHx8XG4gICAgICBjaCA9PT0gMHg1NyBcbiAgICApXG4gIH1cblxuICBwcCQ4LnJlZ2V4cF9lYXRVbmljb2RlUHJvcGVydHlWYWx1ZUV4cHJlc3Npb24gPSBmdW5jdGlvbihzdGF0ZSkge1xuICAgIHZhciBzdGFydCA9IHN0YXRlLnBvcztcblxuICAgIGlmICh0aGlzLnJlZ2V4cF9lYXRVbmljb2RlUHJvcGVydHlOYW1lKHN0YXRlKSAmJiBzdGF0ZS5lYXQoMHgzRCApKSB7XG4gICAgICB2YXIgbmFtZSA9IHN0YXRlLmxhc3RTdHJpbmdWYWx1ZTtcbiAgICAgIGlmICh0aGlzLnJlZ2V4cF9lYXRVbmljb2RlUHJvcGVydHlWYWx1ZShzdGF0ZSkpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gc3RhdGUubGFzdFN0cmluZ1ZhbHVlO1xuICAgICAgICB0aGlzLnJlZ2V4cF92YWxpZGF0ZVVuaWNvZGVQcm9wZXJ0eU5hbWVBbmRWYWx1ZShzdGF0ZSwgbmFtZSwgdmFsdWUpO1xuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgIH1cbiAgICBzdGF0ZS5wb3MgPSBzdGFydDtcblxuICAgIGlmICh0aGlzLnJlZ2V4cF9lYXRMb25lVW5pY29kZVByb3BlcnR5TmFtZU9yVmFsdWUoc3RhdGUpKSB7XG4gICAgICB2YXIgbmFtZU9yVmFsdWUgPSBzdGF0ZS5sYXN0U3RyaW5nVmFsdWU7XG4gICAgICB0aGlzLnJlZ2V4cF92YWxpZGF0ZVVuaWNvZGVQcm9wZXJ0eU5hbWVPclZhbHVlKHN0YXRlLCBuYW1lT3JWYWx1ZSk7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2VcbiAgfTtcbiAgcHAkOC5yZWdleHBfdmFsaWRhdGVVbmljb2RlUHJvcGVydHlOYW1lQW5kVmFsdWUgPSBmdW5jdGlvbihzdGF0ZSwgbmFtZSwgdmFsdWUpIHtcbiAgICBpZiAoIWhhcyhzdGF0ZS51bmljb2RlUHJvcGVydGllcy5ub25CaW5hcnksIG5hbWUpKVxuICAgICAgeyBzdGF0ZS5yYWlzZShcIkludmFsaWQgcHJvcGVydHkgbmFtZVwiKTsgfVxuICAgIGlmICghc3RhdGUudW5pY29kZVByb3BlcnRpZXMubm9uQmluYXJ5W25hbWVdLnRlc3QodmFsdWUpKVxuICAgICAgeyBzdGF0ZS5yYWlzZShcIkludmFsaWQgcHJvcGVydHkgdmFsdWVcIik7IH1cbiAgfTtcbiAgcHAkOC5yZWdleHBfdmFsaWRhdGVVbmljb2RlUHJvcGVydHlOYW1lT3JWYWx1ZSA9IGZ1bmN0aW9uKHN0YXRlLCBuYW1lT3JWYWx1ZSkge1xuICAgIGlmICghc3RhdGUudW5pY29kZVByb3BlcnRpZXMuYmluYXJ5LnRlc3QobmFtZU9yVmFsdWUpKVxuICAgICAgeyBzdGF0ZS5yYWlzZShcIkludmFsaWQgcHJvcGVydHkgbmFtZVwiKTsgfVxuICB9O1xuXG4gIHBwJDgucmVnZXhwX2VhdFVuaWNvZGVQcm9wZXJ0eU5hbWUgPSBmdW5jdGlvbihzdGF0ZSkge1xuICAgIHZhciBjaCA9IDA7XG4gICAgc3RhdGUubGFzdFN0cmluZ1ZhbHVlID0gXCJcIjtcbiAgICB3aGlsZSAoaXNVbmljb2RlUHJvcGVydHlOYW1lQ2hhcmFjdGVyKGNoID0gc3RhdGUuY3VycmVudCgpKSkge1xuICAgICAgc3RhdGUubGFzdFN0cmluZ1ZhbHVlICs9IGNvZGVQb2ludFRvU3RyaW5nKGNoKTtcbiAgICAgIHN0YXRlLmFkdmFuY2UoKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0YXRlLmxhc3RTdHJpbmdWYWx1ZSAhPT0gXCJcIlxuICB9O1xuICBmdW5jdGlvbiBpc1VuaWNvZGVQcm9wZXJ0eU5hbWVDaGFyYWN0ZXIoY2gpIHtcbiAgICByZXR1cm4gaXNDb250cm9sTGV0dGVyKGNoKSB8fCBjaCA9PT0gMHg1RiBcbiAgfVxuXG4gIHBwJDgucmVnZXhwX2VhdFVuaWNvZGVQcm9wZXJ0eVZhbHVlID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgICB2YXIgY2ggPSAwO1xuICAgIHN0YXRlLmxhc3RTdHJpbmdWYWx1ZSA9IFwiXCI7XG4gICAgd2hpbGUgKGlzVW5pY29kZVByb3BlcnR5VmFsdWVDaGFyYWN0ZXIoY2ggPSBzdGF0ZS5jdXJyZW50KCkpKSB7XG4gICAgICBzdGF0ZS5sYXN0U3RyaW5nVmFsdWUgKz0gY29kZVBvaW50VG9TdHJpbmcoY2gpO1xuICAgICAgc3RhdGUuYWR2YW5jZSgpO1xuICAgIH1cbiAgICByZXR1cm4gc3RhdGUubGFzdFN0cmluZ1ZhbHVlICE9PSBcIlwiXG4gIH07XG4gIGZ1bmN0aW9uIGlzVW5pY29kZVByb3BlcnR5VmFsdWVDaGFyYWN0ZXIoY2gpIHtcbiAgICByZXR1cm4gaXNVbmljb2RlUHJvcGVydHlOYW1lQ2hhcmFjdGVyKGNoKSB8fCBpc0RlY2ltYWxEaWdpdChjaClcbiAgfVxuXG4gIHBwJDgucmVnZXhwX2VhdExvbmVVbmljb2RlUHJvcGVydHlOYW1lT3JWYWx1ZSA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgcmV0dXJuIHRoaXMucmVnZXhwX2VhdFVuaWNvZGVQcm9wZXJ0eVZhbHVlKHN0YXRlKVxuICB9O1xuXG4gIHBwJDgucmVnZXhwX2VhdENoYXJhY3RlckNsYXNzID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgICBpZiAoc3RhdGUuZWF0KDB4NUIgKSkge1xuICAgICAgc3RhdGUuZWF0KDB4NUUgKTtcbiAgICAgIHRoaXMucmVnZXhwX2NsYXNzUmFuZ2VzKHN0YXRlKTtcbiAgICAgIGlmIChzdGF0ZS5lYXQoMHg1RCApKSB7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgICBzdGF0ZS5yYWlzZShcIlVudGVybWluYXRlZCBjaGFyYWN0ZXIgY2xhc3NcIik7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9O1xuXG4gIHBwJDgucmVnZXhwX2NsYXNzUmFuZ2VzID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgICB3aGlsZSAodGhpcy5yZWdleHBfZWF0Q2xhc3NBdG9tKHN0YXRlKSkge1xuICAgICAgdmFyIGxlZnQgPSBzdGF0ZS5sYXN0SW50VmFsdWU7XG4gICAgICBpZiAoc3RhdGUuZWF0KDB4MkQgKSAmJiB0aGlzLnJlZ2V4cF9lYXRDbGFzc0F0b20oc3RhdGUpKSB7XG4gICAgICAgIHZhciByaWdodCA9IHN0YXRlLmxhc3RJbnRWYWx1ZTtcbiAgICAgICAgaWYgKHN0YXRlLnN3aXRjaFUgJiYgKGxlZnQgPT09IC0xIHx8IHJpZ2h0ID09PSAtMSkpIHtcbiAgICAgICAgICBzdGF0ZS5yYWlzZShcIkludmFsaWQgY2hhcmFjdGVyIGNsYXNzXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsZWZ0ICE9PSAtMSAmJiByaWdodCAhPT0gLTEgJiYgbGVmdCA+IHJpZ2h0KSB7XG4gICAgICAgICAgc3RhdGUucmFpc2UoXCJSYW5nZSBvdXQgb2Ygb3JkZXIgaW4gY2hhcmFjdGVyIGNsYXNzXCIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHBwJDgucmVnZXhwX2VhdENsYXNzQXRvbSA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgdmFyIHN0YXJ0ID0gc3RhdGUucG9zO1xuXG4gICAgaWYgKHN0YXRlLmVhdCgweDVDICkpIHtcbiAgICAgIGlmICh0aGlzLnJlZ2V4cF9lYXRDbGFzc0VzY2FwZShzdGF0ZSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICAgIGlmIChzdGF0ZS5zd2l0Y2hVKSB7XG4gICAgICAgIHZhciBjaCQxID0gc3RhdGUuY3VycmVudCgpO1xuICAgICAgICBpZiAoY2gkMSA9PT0gMHg2MyAgfHwgaXNPY3RhbERpZ2l0KGNoJDEpKSB7XG4gICAgICAgICAgc3RhdGUucmFpc2UoXCJJbnZhbGlkIGNsYXNzIGVzY2FwZVwiKTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5yYWlzZShcIkludmFsaWQgZXNjYXBlXCIpO1xuICAgICAgfVxuICAgICAgc3RhdGUucG9zID0gc3RhcnQ7XG4gICAgfVxuXG4gICAgdmFyIGNoID0gc3RhdGUuY3VycmVudCgpO1xuICAgIGlmIChjaCAhPT0gMHg1RCApIHtcbiAgICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IGNoO1xuICAgICAgc3RhdGUuYWR2YW5jZSgpO1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2VcbiAgfTtcblxuICBwcCQ4LnJlZ2V4cF9lYXRDbGFzc0VzY2FwZSA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgdmFyIHN0YXJ0ID0gc3RhdGUucG9zO1xuXG4gICAgaWYgKHN0YXRlLmVhdCgweDYyICkpIHtcbiAgICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IDB4MDg7IFxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG5cbiAgICBpZiAoc3RhdGUuc3dpdGNoVSAmJiBzdGF0ZS5lYXQoMHgyRCApKSB7XG4gICAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSAweDJEOyBcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuXG4gICAgaWYgKCFzdGF0ZS5zd2l0Y2hVICYmIHN0YXRlLmVhdCgweDYzICkpIHtcbiAgICAgIGlmICh0aGlzLnJlZ2V4cF9lYXRDbGFzc0NvbnRyb2xMZXR0ZXIoc3RhdGUpKSB7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgICBzdGF0ZS5wb3MgPSBzdGFydDtcbiAgICB9XG5cbiAgICByZXR1cm4gKFxuICAgICAgdGhpcy5yZWdleHBfZWF0Q2hhcmFjdGVyQ2xhc3NFc2NhcGUoc3RhdGUpIHx8XG4gICAgICB0aGlzLnJlZ2V4cF9lYXRDaGFyYWN0ZXJFc2NhcGUoc3RhdGUpXG4gICAgKVxuICB9O1xuXG4gIHBwJDgucmVnZXhwX2VhdENsYXNzQ29udHJvbExldHRlciA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgdmFyIGNoID0gc3RhdGUuY3VycmVudCgpO1xuICAgIGlmIChpc0RlY2ltYWxEaWdpdChjaCkgfHwgY2ggPT09IDB4NUYgKSB7XG4gICAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSBjaCAlIDB4MjA7XG4gICAgICBzdGF0ZS5hZHZhbmNlKCk7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2VcbiAgfTtcblxuICBwcCQ4LnJlZ2V4cF9lYXRIZXhFc2NhcGVTZXF1ZW5jZSA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgdmFyIHN0YXJ0ID0gc3RhdGUucG9zO1xuICAgIGlmIChzdGF0ZS5lYXQoMHg3OCApKSB7XG4gICAgICBpZiAodGhpcy5yZWdleHBfZWF0Rml4ZWRIZXhEaWdpdHMoc3RhdGUsIDIpKSB7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgICBpZiAoc3RhdGUuc3dpdGNoVSkge1xuICAgICAgICBzdGF0ZS5yYWlzZShcIkludmFsaWQgZXNjYXBlXCIpO1xuICAgICAgfVxuICAgICAgc3RhdGUucG9zID0gc3RhcnQ7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9O1xuXG4gIHBwJDgucmVnZXhwX2VhdERlY2ltYWxEaWdpdHMgPSBmdW5jdGlvbihzdGF0ZSkge1xuICAgIHZhciBzdGFydCA9IHN0YXRlLnBvcztcbiAgICB2YXIgY2ggPSAwO1xuICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IDA7XG4gICAgd2hpbGUgKGlzRGVjaW1hbERpZ2l0KGNoID0gc3RhdGUuY3VycmVudCgpKSkge1xuICAgICAgc3RhdGUubGFzdEludFZhbHVlID0gMTAgKiBzdGF0ZS5sYXN0SW50VmFsdWUgKyAoY2ggLSAweDMwICk7XG4gICAgICBzdGF0ZS5hZHZhbmNlKCk7XG4gICAgfVxuICAgIHJldHVybiBzdGF0ZS5wb3MgIT09IHN0YXJ0XG4gIH07XG4gIGZ1bmN0aW9uIGlzRGVjaW1hbERpZ2l0KGNoKSB7XG4gICAgcmV0dXJuIGNoID49IDB4MzAgICYmIGNoIDw9IDB4MzkgXG4gIH1cblxuICBwcCQ4LnJlZ2V4cF9lYXRIZXhEaWdpdHMgPSBmdW5jdGlvbihzdGF0ZSkge1xuICAgIHZhciBzdGFydCA9IHN0YXRlLnBvcztcbiAgICB2YXIgY2ggPSAwO1xuICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IDA7XG4gICAgd2hpbGUgKGlzSGV4RGlnaXQoY2ggPSBzdGF0ZS5jdXJyZW50KCkpKSB7XG4gICAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSAxNiAqIHN0YXRlLmxhc3RJbnRWYWx1ZSArIGhleFRvSW50KGNoKTtcbiAgICAgIHN0YXRlLmFkdmFuY2UoKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0YXRlLnBvcyAhPT0gc3RhcnRcbiAgfTtcbiAgZnVuY3Rpb24gaXNIZXhEaWdpdChjaCkge1xuICAgIHJldHVybiAoXG4gICAgICAoY2ggPj0gMHgzMCAgJiYgY2ggPD0gMHgzOSApIHx8XG4gICAgICAoY2ggPj0gMHg0MSAgJiYgY2ggPD0gMHg0NiApIHx8XG4gICAgICAoY2ggPj0gMHg2MSAgJiYgY2ggPD0gMHg2NiApXG4gICAgKVxuICB9XG4gIGZ1bmN0aW9uIGhleFRvSW50KGNoKSB7XG4gICAgaWYgKGNoID49IDB4NDEgICYmIGNoIDw9IDB4NDYgKSB7XG4gICAgICByZXR1cm4gMTAgKyAoY2ggLSAweDQxIClcbiAgICB9XG4gICAgaWYgKGNoID49IDB4NjEgICYmIGNoIDw9IDB4NjYgKSB7XG4gICAgICByZXR1cm4gMTAgKyAoY2ggLSAweDYxIClcbiAgICB9XG4gICAgcmV0dXJuIGNoIC0gMHgzMCBcbiAgfVxuXG4gIHBwJDgucmVnZXhwX2VhdExlZ2FjeU9jdGFsRXNjYXBlU2VxdWVuY2UgPSBmdW5jdGlvbihzdGF0ZSkge1xuICAgIGlmICh0aGlzLnJlZ2V4cF9lYXRPY3RhbERpZ2l0KHN0YXRlKSkge1xuICAgICAgdmFyIG4xID0gc3RhdGUubGFzdEludFZhbHVlO1xuICAgICAgaWYgKHRoaXMucmVnZXhwX2VhdE9jdGFsRGlnaXQoc3RhdGUpKSB7XG4gICAgICAgIHZhciBuMiA9IHN0YXRlLmxhc3RJbnRWYWx1ZTtcbiAgICAgICAgaWYgKG4xIDw9IDMgJiYgdGhpcy5yZWdleHBfZWF0T2N0YWxEaWdpdChzdGF0ZSkpIHtcbiAgICAgICAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSBuMSAqIDY0ICsgbjIgKiA4ICsgc3RhdGUubGFzdEludFZhbHVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IG4xICogOCArIG4yO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSBuMTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9O1xuXG4gIHBwJDgucmVnZXhwX2VhdE9jdGFsRGlnaXQgPSBmdW5jdGlvbihzdGF0ZSkge1xuICAgIHZhciBjaCA9IHN0YXRlLmN1cnJlbnQoKTtcbiAgICBpZiAoaXNPY3RhbERpZ2l0KGNoKSkge1xuICAgICAgc3RhdGUubGFzdEludFZhbHVlID0gY2ggLSAweDMwOyBcbiAgICAgIHN0YXRlLmFkdmFuY2UoKTtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IDA7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH07XG4gIGZ1bmN0aW9uIGlzT2N0YWxEaWdpdChjaCkge1xuICAgIHJldHVybiBjaCA+PSAweDMwICAmJiBjaCA8PSAweDM3IFxuICB9XG5cbiAgcHAkOC5yZWdleHBfZWF0Rml4ZWRIZXhEaWdpdHMgPSBmdW5jdGlvbihzdGF0ZSwgbGVuZ3RoKSB7XG4gICAgdmFyIHN0YXJ0ID0gc3RhdGUucG9zO1xuICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgICAgdmFyIGNoID0gc3RhdGUuY3VycmVudCgpO1xuICAgICAgaWYgKCFpc0hleERpZ2l0KGNoKSkge1xuICAgICAgICBzdGF0ZS5wb3MgPSBzdGFydDtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSAxNiAqIHN0YXRlLmxhc3RJbnRWYWx1ZSArIGhleFRvSW50KGNoKTtcbiAgICAgIHN0YXRlLmFkdmFuY2UoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWVcbiAgfTtcblxuXG4gIHZhciBUb2tlbiA9IGZ1bmN0aW9uIFRva2VuKHApIHtcbiAgICB0aGlzLnR5cGUgPSBwLnR5cGU7XG4gICAgdGhpcy52YWx1ZSA9IHAudmFsdWU7XG4gICAgdGhpcy5zdGFydCA9IHAuc3RhcnQ7XG4gICAgdGhpcy5lbmQgPSBwLmVuZDtcbiAgICBpZiAocC5vcHRpb25zLmxvY2F0aW9ucylcbiAgICAgIHsgdGhpcy5sb2MgPSBuZXcgU291cmNlTG9jYXRpb24ocCwgcC5zdGFydExvYywgcC5lbmRMb2MpOyB9XG4gICAgaWYgKHAub3B0aW9ucy5yYW5nZXMpXG4gICAgICB7IHRoaXMucmFuZ2UgPSBbcC5zdGFydCwgcC5lbmRdOyB9XG4gIH07XG5cblxuICB2YXIgcHAkOSA9IFBhcnNlci5wcm90b3R5cGU7XG5cblxuICBwcCQ5Lm5leHQgPSBmdW5jdGlvbihpZ25vcmVFc2NhcGVTZXF1ZW5jZUluS2V5d29yZCkge1xuICAgIGlmICghaWdub3JlRXNjYXBlU2VxdWVuY2VJbktleXdvcmQgJiYgdGhpcy50eXBlLmtleXdvcmQgJiYgdGhpcy5jb250YWluc0VzYylcbiAgICAgIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKHRoaXMuc3RhcnQsIFwiRXNjYXBlIHNlcXVlbmNlIGluIGtleXdvcmQgXCIgKyB0aGlzLnR5cGUua2V5d29yZCk7IH1cbiAgICBpZiAodGhpcy5vcHRpb25zLm9uVG9rZW4pXG4gICAgICB7IHRoaXMub3B0aW9ucy5vblRva2VuKG5ldyBUb2tlbih0aGlzKSk7IH1cblxuICAgIHRoaXMubGFzdFRva0VuZCA9IHRoaXMuZW5kO1xuICAgIHRoaXMubGFzdFRva1N0YXJ0ID0gdGhpcy5zdGFydDtcbiAgICB0aGlzLmxhc3RUb2tFbmRMb2MgPSB0aGlzLmVuZExvYztcbiAgICB0aGlzLmxhc3RUb2tTdGFydExvYyA9IHRoaXMuc3RhcnRMb2M7XG4gICAgdGhpcy5uZXh0VG9rZW4oKTtcbiAgfTtcblxuICBwcCQ5LmdldFRva2VuID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgcmV0dXJuIG5ldyBUb2tlbih0aGlzKVxuICB9O1xuXG4gIGlmICh0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiKVxuICAgIHsgcHAkOVtTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbmV4dDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciB0b2tlbiA9IHRoaXMkMS5nZXRUb2tlbigpO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkb25lOiB0b2tlbi50eXBlID09PSB0eXBlcy5lb2YsXG4gICAgICAgICAgICB2YWx1ZTogdG9rZW5cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9OyB9XG5cblxuICBwcCQ5LmN1ckNvbnRleHQgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5jb250ZXh0W3RoaXMuY29udGV4dC5sZW5ndGggLSAxXVxuICB9O1xuXG5cbiAgcHAkOS5uZXh0VG9rZW4gPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgY3VyQ29udGV4dCA9IHRoaXMuY3VyQ29udGV4dCgpO1xuICAgIGlmICghY3VyQ29udGV4dCB8fCAhY3VyQ29udGV4dC5wcmVzZXJ2ZVNwYWNlKSB7IHRoaXMuc2tpcFNwYWNlKCk7IH1cblxuICAgIHRoaXMuc3RhcnQgPSB0aGlzLnBvcztcbiAgICBpZiAodGhpcy5vcHRpb25zLmxvY2F0aW9ucykgeyB0aGlzLnN0YXJ0TG9jID0gdGhpcy5jdXJQb3NpdGlvbigpOyB9XG4gICAgaWYgKHRoaXMucG9zID49IHRoaXMuaW5wdXQubGVuZ3RoKSB7IHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGVzLmVvZikgfVxuXG4gICAgaWYgKGN1ckNvbnRleHQub3ZlcnJpZGUpIHsgcmV0dXJuIGN1ckNvbnRleHQub3ZlcnJpZGUodGhpcykgfVxuICAgIGVsc2UgeyB0aGlzLnJlYWRUb2tlbih0aGlzLmZ1bGxDaGFyQ29kZUF0UG9zKCkpOyB9XG4gIH07XG5cbiAgcHAkOS5yZWFkVG9rZW4gPSBmdW5jdGlvbihjb2RlKSB7XG4gICAgaWYgKGlzSWRlbnRpZmllclN0YXJ0KGNvZGUsIHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2KSB8fCBjb2RlID09PSA5MiApXG4gICAgICB7IHJldHVybiB0aGlzLnJlYWRXb3JkKCkgfVxuXG4gICAgcmV0dXJuIHRoaXMuZ2V0VG9rZW5Gcm9tQ29kZShjb2RlKVxuICB9O1xuXG4gIHBwJDkuZnVsbENoYXJDb2RlQXRQb3MgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgY29kZSA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyk7XG4gICAgaWYgKGNvZGUgPD0gMHhkN2ZmIHx8IGNvZGUgPj0gMHhlMDAwKSB7IHJldHVybiBjb2RlIH1cbiAgICB2YXIgbmV4dCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyArIDEpO1xuICAgIHJldHVybiAoY29kZSA8PCAxMCkgKyBuZXh0IC0gMHgzNWZkYzAwXG4gIH07XG5cbiAgcHAkOS5za2lwQmxvY2tDb21tZW50ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHN0YXJ0TG9jID0gdGhpcy5vcHRpb25zLm9uQ29tbWVudCAmJiB0aGlzLmN1clBvc2l0aW9uKCk7XG4gICAgdmFyIHN0YXJ0ID0gdGhpcy5wb3MsIGVuZCA9IHRoaXMuaW5wdXQuaW5kZXhPZihcIiovXCIsIHRoaXMucG9zICs9IDIpO1xuICAgIGlmIChlbmQgPT09IC0xKSB7IHRoaXMucmFpc2UodGhpcy5wb3MgLSAyLCBcIlVudGVybWluYXRlZCBjb21tZW50XCIpOyB9XG4gICAgdGhpcy5wb3MgPSBlbmQgKyAyO1xuICAgIGlmICh0aGlzLm9wdGlvbnMubG9jYXRpb25zKSB7XG4gICAgICBsaW5lQnJlYWtHLmxhc3RJbmRleCA9IHN0YXJ0O1xuICAgICAgdmFyIG1hdGNoO1xuICAgICAgd2hpbGUgKChtYXRjaCA9IGxpbmVCcmVha0cuZXhlYyh0aGlzLmlucHV0KSkgJiYgbWF0Y2guaW5kZXggPCB0aGlzLnBvcykge1xuICAgICAgICArK3RoaXMuY3VyTGluZTtcbiAgICAgICAgdGhpcy5saW5lU3RhcnQgPSBtYXRjaC5pbmRleCArIG1hdGNoWzBdLmxlbmd0aDtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRoaXMub3B0aW9ucy5vbkNvbW1lbnQpXG4gICAgICB7IHRoaXMub3B0aW9ucy5vbkNvbW1lbnQodHJ1ZSwgdGhpcy5pbnB1dC5zbGljZShzdGFydCArIDIsIGVuZCksIHN0YXJ0LCB0aGlzLnBvcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRMb2MsIHRoaXMuY3VyUG9zaXRpb24oKSk7IH1cbiAgfTtcblxuICBwcCQ5LnNraXBMaW5lQ29tbWVudCA9IGZ1bmN0aW9uKHN0YXJ0U2tpcCkge1xuICAgIHZhciBzdGFydCA9IHRoaXMucG9zO1xuICAgIHZhciBzdGFydExvYyA9IHRoaXMub3B0aW9ucy5vbkNvbW1lbnQgJiYgdGhpcy5jdXJQb3NpdGlvbigpO1xuICAgIHZhciBjaCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyArPSBzdGFydFNraXApO1xuICAgIHdoaWxlICh0aGlzLnBvcyA8IHRoaXMuaW5wdXQubGVuZ3RoICYmICFpc05ld0xpbmUoY2gpKSB7XG4gICAgICBjaCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCgrK3RoaXMucG9zKTtcbiAgICB9XG4gICAgaWYgKHRoaXMub3B0aW9ucy5vbkNvbW1lbnQpXG4gICAgICB7IHRoaXMub3B0aW9ucy5vbkNvbW1lbnQoZmFsc2UsIHRoaXMuaW5wdXQuc2xpY2Uoc3RhcnQgKyBzdGFydFNraXAsIHRoaXMucG9zKSwgc3RhcnQsIHRoaXMucG9zLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydExvYywgdGhpcy5jdXJQb3NpdGlvbigpKTsgfVxuICB9O1xuXG5cbiAgcHAkOS5za2lwU3BhY2UgPSBmdW5jdGlvbigpIHtcbiAgICBsb29wOiB3aGlsZSAodGhpcy5wb3MgPCB0aGlzLmlucHV0Lmxlbmd0aCkge1xuICAgICAgdmFyIGNoID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zKTtcbiAgICAgIHN3aXRjaCAoY2gpIHtcbiAgICAgIGNhc2UgMzI6IGNhc2UgMTYwOiBcbiAgICAgICAgKyt0aGlzLnBvcztcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgMTM6XG4gICAgICAgIGlmICh0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MgKyAxKSA9PT0gMTApIHtcbiAgICAgICAgICArK3RoaXMucG9zO1xuICAgICAgICB9XG4gICAgICBjYXNlIDEwOiBjYXNlIDgyMzI6IGNhc2UgODIzMzpcbiAgICAgICAgKyt0aGlzLnBvcztcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5sb2NhdGlvbnMpIHtcbiAgICAgICAgICArK3RoaXMuY3VyTGluZTtcbiAgICAgICAgICB0aGlzLmxpbmVTdGFydCA9IHRoaXMucG9zO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlIDQ3OiBcbiAgICAgICAgc3dpdGNoICh0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MgKyAxKSkge1xuICAgICAgICBjYXNlIDQyOiBcbiAgICAgICAgICB0aGlzLnNraXBCbG9ja0NvbW1lbnQoKTtcbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDQ3OlxuICAgICAgICAgIHRoaXMuc2tpcExpbmVDb21tZW50KDIpO1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgYnJlYWsgbG9vcFxuICAgICAgICB9XG4gICAgICAgIGJyZWFrXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAoY2ggPiA4ICYmIGNoIDwgMTQgfHwgY2ggPj0gNTc2MCAmJiBub25BU0NJSXdoaXRlc3BhY2UudGVzdChTdHJpbmcuZnJvbUNoYXJDb2RlKGNoKSkpIHtcbiAgICAgICAgICArK3RoaXMucG9zO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGJyZWFrIGxvb3BcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuXG4gIHBwJDkuZmluaXNoVG9rZW4gPSBmdW5jdGlvbih0eXBlLCB2YWwpIHtcbiAgICB0aGlzLmVuZCA9IHRoaXMucG9zO1xuICAgIGlmICh0aGlzLm9wdGlvbnMubG9jYXRpb25zKSB7IHRoaXMuZW5kTG9jID0gdGhpcy5jdXJQb3NpdGlvbigpOyB9XG4gICAgdmFyIHByZXZUeXBlID0gdGhpcy50eXBlO1xuICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgdGhpcy52YWx1ZSA9IHZhbDtcblxuICAgIHRoaXMudXBkYXRlQ29udGV4dChwcmV2VHlwZSk7XG4gIH07XG5cblxuICBwcCQ5LnJlYWRUb2tlbl9kb3QgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgbmV4dCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyArIDEpO1xuICAgIGlmIChuZXh0ID49IDQ4ICYmIG5leHQgPD0gNTcpIHsgcmV0dXJuIHRoaXMucmVhZE51bWJlcih0cnVlKSB9XG4gICAgdmFyIG5leHQyID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zICsgMik7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2ICYmIG5leHQgPT09IDQ2ICYmIG5leHQyID09PSA0NikgeyBcbiAgICAgIHRoaXMucG9zICs9IDM7XG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0eXBlcy5lbGxpcHNpcylcbiAgICB9IGVsc2Uge1xuICAgICAgKyt0aGlzLnBvcztcbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGVzLmRvdClcbiAgICB9XG4gIH07XG5cbiAgcHAkOS5yZWFkVG9rZW5fc2xhc2ggPSBmdW5jdGlvbigpIHsgXG4gICAgdmFyIG5leHQgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MgKyAxKTtcbiAgICBpZiAodGhpcy5leHByQWxsb3dlZCkgeyArK3RoaXMucG9zOyByZXR1cm4gdGhpcy5yZWFkUmVnZXhwKCkgfVxuICAgIGlmIChuZXh0ID09PSA2MSkgeyByZXR1cm4gdGhpcy5maW5pc2hPcCh0eXBlcy5hc3NpZ24sIDIpIH1cbiAgICByZXR1cm4gdGhpcy5maW5pc2hPcCh0eXBlcy5zbGFzaCwgMSlcbiAgfTtcblxuICBwcCQ5LnJlYWRUb2tlbl9tdWx0X21vZHVsb19leHAgPSBmdW5jdGlvbihjb2RlKSB7IFxuICAgIHZhciBuZXh0ID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zICsgMSk7XG4gICAgdmFyIHNpemUgPSAxO1xuICAgIHZhciB0b2tlbnR5cGUgPSBjb2RlID09PSA0MiA/IHR5cGVzLnN0YXIgOiB0eXBlcy5tb2R1bG87XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDcgJiYgY29kZSA9PT0gNDIgJiYgbmV4dCA9PT0gNDIpIHtcbiAgICAgICsrc2l6ZTtcbiAgICAgIHRva2VudHlwZSA9IHR5cGVzLnN0YXJzdGFyO1xuICAgICAgbmV4dCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyArIDIpO1xuICAgIH1cblxuICAgIGlmIChuZXh0ID09PSA2MSkgeyByZXR1cm4gdGhpcy5maW5pc2hPcCh0eXBlcy5hc3NpZ24sIHNpemUgKyAxKSB9XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoT3AodG9rZW50eXBlLCBzaXplKVxuICB9O1xuXG4gIHBwJDkucmVhZFRva2VuX3BpcGVfYW1wID0gZnVuY3Rpb24oY29kZSkgeyBcbiAgICB2YXIgbmV4dCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyArIDEpO1xuICAgIGlmIChuZXh0ID09PSBjb2RlKSB7IHJldHVybiB0aGlzLmZpbmlzaE9wKGNvZGUgPT09IDEyNCA/IHR5cGVzLmxvZ2ljYWxPUiA6IHR5cGVzLmxvZ2ljYWxBTkQsIDIpIH1cbiAgICBpZiAobmV4dCA9PT0gNjEpIHsgcmV0dXJuIHRoaXMuZmluaXNoT3AodHlwZXMuYXNzaWduLCAyKSB9XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoT3AoY29kZSA9PT0gMTI0ID8gdHlwZXMuYml0d2lzZU9SIDogdHlwZXMuYml0d2lzZUFORCwgMSlcbiAgfTtcblxuICBwcCQ5LnJlYWRUb2tlbl9jYXJldCA9IGZ1bmN0aW9uKCkgeyBcbiAgICB2YXIgbmV4dCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyArIDEpO1xuICAgIGlmIChuZXh0ID09PSA2MSkgeyByZXR1cm4gdGhpcy5maW5pc2hPcCh0eXBlcy5hc3NpZ24sIDIpIH1cbiAgICByZXR1cm4gdGhpcy5maW5pc2hPcCh0eXBlcy5iaXR3aXNlWE9SLCAxKVxuICB9O1xuXG4gIHBwJDkucmVhZFRva2VuX3BsdXNfbWluID0gZnVuY3Rpb24oY29kZSkgeyBcbiAgICB2YXIgbmV4dCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyArIDEpO1xuICAgIGlmIChuZXh0ID09PSBjb2RlKSB7XG4gICAgICBpZiAobmV4dCA9PT0gNDUgJiYgIXRoaXMuaW5Nb2R1bGUgJiYgdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zICsgMikgPT09IDYyICYmXG4gICAgICAgICAgKHRoaXMubGFzdFRva0VuZCA9PT0gMCB8fCBsaW5lQnJlYWsudGVzdCh0aGlzLmlucHV0LnNsaWNlKHRoaXMubGFzdFRva0VuZCwgdGhpcy5wb3MpKSkpIHtcbiAgICAgICAgdGhpcy5za2lwTGluZUNvbW1lbnQoMyk7XG4gICAgICAgIHRoaXMuc2tpcFNwYWNlKCk7XG4gICAgICAgIHJldHVybiB0aGlzLm5leHRUb2tlbigpXG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hPcCh0eXBlcy5pbmNEZWMsIDIpXG4gICAgfVxuICAgIGlmIChuZXh0ID09PSA2MSkgeyByZXR1cm4gdGhpcy5maW5pc2hPcCh0eXBlcy5hc3NpZ24sIDIpIH1cbiAgICByZXR1cm4gdGhpcy5maW5pc2hPcCh0eXBlcy5wbHVzTWluLCAxKVxuICB9O1xuXG4gIHBwJDkucmVhZFRva2VuX2x0X2d0ID0gZnVuY3Rpb24oY29kZSkgeyBcbiAgICB2YXIgbmV4dCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyArIDEpO1xuICAgIHZhciBzaXplID0gMTtcbiAgICBpZiAobmV4dCA9PT0gY29kZSkge1xuICAgICAgc2l6ZSA9IGNvZGUgPT09IDYyICYmIHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyArIDIpID09PSA2MiA/IDMgOiAyO1xuICAgICAgaWYgKHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyArIHNpemUpID09PSA2MSkgeyByZXR1cm4gdGhpcy5maW5pc2hPcCh0eXBlcy5hc3NpZ24sIHNpemUgKyAxKSB9XG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hPcCh0eXBlcy5iaXRTaGlmdCwgc2l6ZSlcbiAgICB9XG4gICAgaWYgKG5leHQgPT09IDMzICYmIGNvZGUgPT09IDYwICYmICF0aGlzLmluTW9kdWxlICYmIHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyArIDIpID09PSA0NSAmJlxuICAgICAgICB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MgKyAzKSA9PT0gNDUpIHtcbiAgICAgIHRoaXMuc2tpcExpbmVDb21tZW50KDQpO1xuICAgICAgdGhpcy5za2lwU3BhY2UoKTtcbiAgICAgIHJldHVybiB0aGlzLm5leHRUb2tlbigpXG4gICAgfVxuICAgIGlmIChuZXh0ID09PSA2MSkgeyBzaXplID0gMjsgfVxuICAgIHJldHVybiB0aGlzLmZpbmlzaE9wKHR5cGVzLnJlbGF0aW9uYWwsIHNpemUpXG4gIH07XG5cbiAgcHAkOS5yZWFkVG9rZW5fZXFfZXhjbCA9IGZ1bmN0aW9uKGNvZGUpIHsgXG4gICAgdmFyIG5leHQgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MgKyAxKTtcbiAgICBpZiAobmV4dCA9PT0gNjEpIHsgcmV0dXJuIHRoaXMuZmluaXNoT3AodHlwZXMuZXF1YWxpdHksIHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyArIDIpID09PSA2MSA/IDMgOiAyKSB9XG4gICAgaWYgKGNvZGUgPT09IDYxICYmIG5leHQgPT09IDYyICYmIHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2KSB7IFxuICAgICAgdGhpcy5wb3MgKz0gMjtcbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGVzLmFycm93KVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5maW5pc2hPcChjb2RlID09PSA2MSA/IHR5cGVzLmVxIDogdHlwZXMucHJlZml4LCAxKVxuICB9O1xuXG4gIHBwJDkuZ2V0VG9rZW5Gcm9tQ29kZSA9IGZ1bmN0aW9uKGNvZGUpIHtcbiAgICBzd2l0Y2ggKGNvZGUpIHtcbiAgICBjYXNlIDQ2OiBcbiAgICAgIHJldHVybiB0aGlzLnJlYWRUb2tlbl9kb3QoKVxuXG4gICAgY2FzZSA0MDogKyt0aGlzLnBvczsgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZXMucGFyZW5MKVxuICAgIGNhc2UgNDE6ICsrdGhpcy5wb3M7IHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGVzLnBhcmVuUilcbiAgICBjYXNlIDU5OiArK3RoaXMucG9zOyByZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0eXBlcy5zZW1pKVxuICAgIGNhc2UgNDQ6ICsrdGhpcy5wb3M7IHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGVzLmNvbW1hKVxuICAgIGNhc2UgOTE6ICsrdGhpcy5wb3M7IHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGVzLmJyYWNrZXRMKVxuICAgIGNhc2UgOTM6ICsrdGhpcy5wb3M7IHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGVzLmJyYWNrZXRSKVxuICAgIGNhc2UgMTIzOiArK3RoaXMucG9zOyByZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0eXBlcy5icmFjZUwpXG4gICAgY2FzZSAxMjU6ICsrdGhpcy5wb3M7IHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGVzLmJyYWNlUilcbiAgICBjYXNlIDU4OiArK3RoaXMucG9zOyByZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0eXBlcy5jb2xvbilcbiAgICBjYXNlIDYzOiArK3RoaXMucG9zOyByZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0eXBlcy5xdWVzdGlvbilcblxuICAgIGNhc2UgOTY6IFxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA8IDYpIHsgYnJlYWsgfVxuICAgICAgKyt0aGlzLnBvcztcbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGVzLmJhY2tRdW90ZSlcblxuICAgIGNhc2UgNDg6IFxuICAgICAgdmFyIG5leHQgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MgKyAxKTtcbiAgICAgIGlmIChuZXh0ID09PSAxMjAgfHwgbmV4dCA9PT0gODgpIHsgcmV0dXJuIHRoaXMucmVhZFJhZGl4TnVtYmVyKDE2KSB9IFxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2KSB7XG4gICAgICAgIGlmIChuZXh0ID09PSAxMTEgfHwgbmV4dCA9PT0gNzkpIHsgcmV0dXJuIHRoaXMucmVhZFJhZGl4TnVtYmVyKDgpIH0gXG4gICAgICAgIGlmIChuZXh0ID09PSA5OCB8fCBuZXh0ID09PSA2NikgeyByZXR1cm4gdGhpcy5yZWFkUmFkaXhOdW1iZXIoMikgfSBcbiAgICAgIH1cblxuICAgIGNhc2UgNDk6IGNhc2UgNTA6IGNhc2UgNTE6IGNhc2UgNTI6IGNhc2UgNTM6IGNhc2UgNTQ6IGNhc2UgNTU6IGNhc2UgNTY6IGNhc2UgNTc6IFxuICAgICAgcmV0dXJuIHRoaXMucmVhZE51bWJlcihmYWxzZSlcblxuICAgIGNhc2UgMzQ6IGNhc2UgMzk6IFxuICAgICAgcmV0dXJuIHRoaXMucmVhZFN0cmluZyhjb2RlKVxuXG5cbiAgICBjYXNlIDQ3OiBcbiAgICAgIHJldHVybiB0aGlzLnJlYWRUb2tlbl9zbGFzaCgpXG5cbiAgICBjYXNlIDM3OiBjYXNlIDQyOiBcbiAgICAgIHJldHVybiB0aGlzLnJlYWRUb2tlbl9tdWx0X21vZHVsb19leHAoY29kZSlcblxuICAgIGNhc2UgMTI0OiBjYXNlIDM4OiBcbiAgICAgIHJldHVybiB0aGlzLnJlYWRUb2tlbl9waXBlX2FtcChjb2RlKVxuXG4gICAgY2FzZSA5NDogXG4gICAgICByZXR1cm4gdGhpcy5yZWFkVG9rZW5fY2FyZXQoKVxuXG4gICAgY2FzZSA0MzogY2FzZSA0NTogXG4gICAgICByZXR1cm4gdGhpcy5yZWFkVG9rZW5fcGx1c19taW4oY29kZSlcblxuICAgIGNhc2UgNjA6IGNhc2UgNjI6IFxuICAgICAgcmV0dXJuIHRoaXMucmVhZFRva2VuX2x0X2d0KGNvZGUpXG5cbiAgICBjYXNlIDYxOiBjYXNlIDMzOiBcbiAgICAgIHJldHVybiB0aGlzLnJlYWRUb2tlbl9lcV9leGNsKGNvZGUpXG5cbiAgICBjYXNlIDEyNjogXG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hPcCh0eXBlcy5wcmVmaXgsIDEpXG4gICAgfVxuXG4gICAgdGhpcy5yYWlzZSh0aGlzLnBvcywgXCJVbmV4cGVjdGVkIGNoYXJhY3RlciAnXCIgKyBjb2RlUG9pbnRUb1N0cmluZyQxKGNvZGUpICsgXCInXCIpO1xuICB9O1xuXG4gIHBwJDkuZmluaXNoT3AgPSBmdW5jdGlvbih0eXBlLCBzaXplKSB7XG4gICAgdmFyIHN0ciA9IHRoaXMuaW5wdXQuc2xpY2UodGhpcy5wb3MsIHRoaXMucG9zICsgc2l6ZSk7XG4gICAgdGhpcy5wb3MgKz0gc2l6ZTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0eXBlLCBzdHIpXG4gIH07XG5cbiAgcHAkOS5yZWFkUmVnZXhwID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGVzY2FwZWQsIGluQ2xhc3MsIHN0YXJ0ID0gdGhpcy5wb3M7XG4gICAgZm9yICg7Oykge1xuICAgICAgaWYgKHRoaXMucG9zID49IHRoaXMuaW5wdXQubGVuZ3RoKSB7IHRoaXMucmFpc2Uoc3RhcnQsIFwiVW50ZXJtaW5hdGVkIHJlZ3VsYXIgZXhwcmVzc2lvblwiKTsgfVxuICAgICAgdmFyIGNoID0gdGhpcy5pbnB1dC5jaGFyQXQodGhpcy5wb3MpO1xuICAgICAgaWYgKGxpbmVCcmVhay50ZXN0KGNoKSkgeyB0aGlzLnJhaXNlKHN0YXJ0LCBcIlVudGVybWluYXRlZCByZWd1bGFyIGV4cHJlc3Npb25cIik7IH1cbiAgICAgIGlmICghZXNjYXBlZCkge1xuICAgICAgICBpZiAoY2ggPT09IFwiW1wiKSB7IGluQ2xhc3MgPSB0cnVlOyB9XG4gICAgICAgIGVsc2UgaWYgKGNoID09PSBcIl1cIiAmJiBpbkNsYXNzKSB7IGluQ2xhc3MgPSBmYWxzZTsgfVxuICAgICAgICBlbHNlIGlmIChjaCA9PT0gXCIvXCIgJiYgIWluQ2xhc3MpIHsgYnJlYWsgfVxuICAgICAgICBlc2NhcGVkID0gY2ggPT09IFwiXFxcXFwiO1xuICAgICAgfSBlbHNlIHsgZXNjYXBlZCA9IGZhbHNlOyB9XG4gICAgICArK3RoaXMucG9zO1xuICAgIH1cbiAgICB2YXIgcGF0dGVybiA9IHRoaXMuaW5wdXQuc2xpY2Uoc3RhcnQsIHRoaXMucG9zKTtcbiAgICArK3RoaXMucG9zO1xuICAgIHZhciBmbGFnc1N0YXJ0ID0gdGhpcy5wb3M7XG4gICAgdmFyIGZsYWdzID0gdGhpcy5yZWFkV29yZDEoKTtcbiAgICBpZiAodGhpcy5jb250YWluc0VzYykgeyB0aGlzLnVuZXhwZWN0ZWQoZmxhZ3NTdGFydCk7IH1cblxuICAgIHZhciBzdGF0ZSA9IHRoaXMucmVnZXhwU3RhdGUgfHwgKHRoaXMucmVnZXhwU3RhdGUgPSBuZXcgUmVnRXhwVmFsaWRhdGlvblN0YXRlKHRoaXMpKTtcbiAgICBzdGF0ZS5yZXNldChzdGFydCwgcGF0dGVybiwgZmxhZ3MpO1xuICAgIHRoaXMudmFsaWRhdGVSZWdFeHBGbGFncyhzdGF0ZSk7XG4gICAgdGhpcy52YWxpZGF0ZVJlZ0V4cFBhdHRlcm4oc3RhdGUpO1xuXG4gICAgdmFyIHZhbHVlID0gbnVsbDtcbiAgICB0cnkge1xuICAgICAgdmFsdWUgPSBuZXcgUmVnRXhwKHBhdHRlcm4sIGZsYWdzKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZXMucmVnZXhwLCB7cGF0dGVybjogcGF0dGVybiwgZmxhZ3M6IGZsYWdzLCB2YWx1ZTogdmFsdWV9KVxuICB9O1xuXG5cbiAgcHAkOS5yZWFkSW50ID0gZnVuY3Rpb24ocmFkaXgsIGxlbikge1xuICAgIHZhciBzdGFydCA9IHRoaXMucG9zLCB0b3RhbCA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDAsIGUgPSBsZW4gPT0gbnVsbCA/IEluZmluaXR5IDogbGVuOyBpIDwgZTsgKytpKSB7XG4gICAgICB2YXIgY29kZSA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyksIHZhbCA9ICh2b2lkIDApO1xuICAgICAgaWYgKGNvZGUgPj0gOTcpIHsgdmFsID0gY29kZSAtIDk3ICsgMTA7IH0gXG4gICAgICBlbHNlIGlmIChjb2RlID49IDY1KSB7IHZhbCA9IGNvZGUgLSA2NSArIDEwOyB9IFxuICAgICAgZWxzZSBpZiAoY29kZSA+PSA0OCAmJiBjb2RlIDw9IDU3KSB7IHZhbCA9IGNvZGUgLSA0ODsgfSBcbiAgICAgIGVsc2UgeyB2YWwgPSBJbmZpbml0eTsgfVxuICAgICAgaWYgKHZhbCA+PSByYWRpeCkgeyBicmVhayB9XG4gICAgICArK3RoaXMucG9zO1xuICAgICAgdG90YWwgPSB0b3RhbCAqIHJhZGl4ICsgdmFsO1xuICAgIH1cbiAgICBpZiAodGhpcy5wb3MgPT09IHN0YXJ0IHx8IGxlbiAhPSBudWxsICYmIHRoaXMucG9zIC0gc3RhcnQgIT09IGxlbikgeyByZXR1cm4gbnVsbCB9XG5cbiAgICByZXR1cm4gdG90YWxcbiAgfTtcblxuICBwcCQ5LnJlYWRSYWRpeE51bWJlciA9IGZ1bmN0aW9uKHJhZGl4KSB7XG4gICAgdmFyIHN0YXJ0ID0gdGhpcy5wb3M7XG4gICAgdGhpcy5wb3MgKz0gMjsgXG4gICAgdmFyIHZhbCA9IHRoaXMucmVhZEludChyYWRpeCk7XG4gICAgaWYgKHZhbCA9PSBudWxsKSB7IHRoaXMucmFpc2UodGhpcy5zdGFydCArIDIsIFwiRXhwZWN0ZWQgbnVtYmVyIGluIHJhZGl4IFwiICsgcmFkaXgpOyB9XG4gICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSAxMSAmJiB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MpID09PSAxMTApIHtcbiAgICAgIHZhbCA9IHR5cGVvZiBCaWdJbnQgIT09IFwidW5kZWZpbmVkXCIgPyBCaWdJbnQodGhpcy5pbnB1dC5zbGljZShzdGFydCwgdGhpcy5wb3MpKSA6IG51bGw7XG4gICAgICArK3RoaXMucG9zO1xuICAgIH0gZWxzZSBpZiAoaXNJZGVudGlmaWVyU3RhcnQodGhpcy5mdWxsQ2hhckNvZGVBdFBvcygpKSkgeyB0aGlzLnJhaXNlKHRoaXMucG9zLCBcIklkZW50aWZpZXIgZGlyZWN0bHkgYWZ0ZXIgbnVtYmVyXCIpOyB9XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZXMubnVtLCB2YWwpXG4gIH07XG5cblxuICBwcCQ5LnJlYWROdW1iZXIgPSBmdW5jdGlvbihzdGFydHNXaXRoRG90KSB7XG4gICAgdmFyIHN0YXJ0ID0gdGhpcy5wb3M7XG4gICAgaWYgKCFzdGFydHNXaXRoRG90ICYmIHRoaXMucmVhZEludCgxMCkgPT09IG51bGwpIHsgdGhpcy5yYWlzZShzdGFydCwgXCJJbnZhbGlkIG51bWJlclwiKTsgfVxuICAgIHZhciBvY3RhbCA9IHRoaXMucG9zIC0gc3RhcnQgPj0gMiAmJiB0aGlzLmlucHV0LmNoYXJDb2RlQXQoc3RhcnQpID09PSA0ODtcbiAgICBpZiAob2N0YWwgJiYgdGhpcy5zdHJpY3QpIHsgdGhpcy5yYWlzZShzdGFydCwgXCJJbnZhbGlkIG51bWJlclwiKTsgfVxuICAgIHZhciBuZXh0ID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zKTtcbiAgICBpZiAoIW9jdGFsICYmICFzdGFydHNXaXRoRG90ICYmIHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSAxMSAmJiBuZXh0ID09PSAxMTApIHtcbiAgICAgIHZhciBzdHIkMSA9IHRoaXMuaW5wdXQuc2xpY2Uoc3RhcnQsIHRoaXMucG9zKTtcbiAgICAgIHZhciB2YWwkMSA9IHR5cGVvZiBCaWdJbnQgIT09IFwidW5kZWZpbmVkXCIgPyBCaWdJbnQoc3RyJDEpIDogbnVsbDtcbiAgICAgICsrdGhpcy5wb3M7XG4gICAgICBpZiAoaXNJZGVudGlmaWVyU3RhcnQodGhpcy5mdWxsQ2hhckNvZGVBdFBvcygpKSkgeyB0aGlzLnJhaXNlKHRoaXMucG9zLCBcIklkZW50aWZpZXIgZGlyZWN0bHkgYWZ0ZXIgbnVtYmVyXCIpOyB9XG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0eXBlcy5udW0sIHZhbCQxKVxuICAgIH1cbiAgICBpZiAob2N0YWwgJiYgL1s4OV0vLnRlc3QodGhpcy5pbnB1dC5zbGljZShzdGFydCwgdGhpcy5wb3MpKSkgeyBvY3RhbCA9IGZhbHNlOyB9XG4gICAgaWYgKG5leHQgPT09IDQ2ICYmICFvY3RhbCkgeyBcbiAgICAgICsrdGhpcy5wb3M7XG4gICAgICB0aGlzLnJlYWRJbnQoMTApO1xuICAgICAgbmV4dCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyk7XG4gICAgfVxuICAgIGlmICgobmV4dCA9PT0gNjkgfHwgbmV4dCA9PT0gMTAxKSAmJiAhb2N0YWwpIHsgXG4gICAgICBuZXh0ID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KCsrdGhpcy5wb3MpO1xuICAgICAgaWYgKG5leHQgPT09IDQzIHx8IG5leHQgPT09IDQ1KSB7ICsrdGhpcy5wb3M7IH0gXG4gICAgICBpZiAodGhpcy5yZWFkSW50KDEwKSA9PT0gbnVsbCkgeyB0aGlzLnJhaXNlKHN0YXJ0LCBcIkludmFsaWQgbnVtYmVyXCIpOyB9XG4gICAgfVxuICAgIGlmIChpc0lkZW50aWZpZXJTdGFydCh0aGlzLmZ1bGxDaGFyQ29kZUF0UG9zKCkpKSB7IHRoaXMucmFpc2UodGhpcy5wb3MsIFwiSWRlbnRpZmllciBkaXJlY3RseSBhZnRlciBudW1iZXJcIik7IH1cblxuICAgIHZhciBzdHIgPSB0aGlzLmlucHV0LnNsaWNlKHN0YXJ0LCB0aGlzLnBvcyk7XG4gICAgdmFyIHZhbCA9IG9jdGFsID8gcGFyc2VJbnQoc3RyLCA4KSA6IHBhcnNlRmxvYXQoc3RyKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0eXBlcy5udW0sIHZhbClcbiAgfTtcblxuXG4gIHBwJDkucmVhZENvZGVQb2ludCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBjaCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyksIGNvZGU7XG5cbiAgICBpZiAoY2ggPT09IDEyMykgeyBcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPCA2KSB7IHRoaXMudW5leHBlY3RlZCgpOyB9XG4gICAgICB2YXIgY29kZVBvcyA9ICsrdGhpcy5wb3M7XG4gICAgICBjb2RlID0gdGhpcy5yZWFkSGV4Q2hhcih0aGlzLmlucHV0LmluZGV4T2YoXCJ9XCIsIHRoaXMucG9zKSAtIHRoaXMucG9zKTtcbiAgICAgICsrdGhpcy5wb3M7XG4gICAgICBpZiAoY29kZSA+IDB4MTBGRkZGKSB7IHRoaXMuaW52YWxpZFN0cmluZ1Rva2VuKGNvZGVQb3MsIFwiQ29kZSBwb2ludCBvdXQgb2YgYm91bmRzXCIpOyB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvZGUgPSB0aGlzLnJlYWRIZXhDaGFyKDQpO1xuICAgIH1cbiAgICByZXR1cm4gY29kZVxuICB9O1xuXG4gIGZ1bmN0aW9uIGNvZGVQb2ludFRvU3RyaW5nJDEoY29kZSkge1xuICAgIGlmIChjb2RlIDw9IDB4RkZGRikgeyByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKSB9XG4gICAgY29kZSAtPSAweDEwMDAwO1xuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKChjb2RlID4+IDEwKSArIDB4RDgwMCwgKGNvZGUgJiAxMDIzKSArIDB4REMwMClcbiAgfVxuXG4gIHBwJDkucmVhZFN0cmluZyA9IGZ1bmN0aW9uKHF1b3RlKSB7XG4gICAgdmFyIG91dCA9IFwiXCIsIGNodW5rU3RhcnQgPSArK3RoaXMucG9zO1xuICAgIGZvciAoOzspIHtcbiAgICAgIGlmICh0aGlzLnBvcyA+PSB0aGlzLmlucHV0Lmxlbmd0aCkgeyB0aGlzLnJhaXNlKHRoaXMuc3RhcnQsIFwiVW50ZXJtaW5hdGVkIHN0cmluZyBjb25zdGFudFwiKTsgfVxuICAgICAgdmFyIGNoID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zKTtcbiAgICAgIGlmIChjaCA9PT0gcXVvdGUpIHsgYnJlYWsgfVxuICAgICAgaWYgKGNoID09PSA5MikgeyBcbiAgICAgICAgb3V0ICs9IHRoaXMuaW5wdXQuc2xpY2UoY2h1bmtTdGFydCwgdGhpcy5wb3MpO1xuICAgICAgICBvdXQgKz0gdGhpcy5yZWFkRXNjYXBlZENoYXIoZmFsc2UpO1xuICAgICAgICBjaHVua1N0YXJ0ID0gdGhpcy5wb3M7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoaXNOZXdMaW5lKGNoLCB0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gMTApKSB7IHRoaXMucmFpc2UodGhpcy5zdGFydCwgXCJVbnRlcm1pbmF0ZWQgc3RyaW5nIGNvbnN0YW50XCIpOyB9XG4gICAgICAgICsrdGhpcy5wb3M7XG4gICAgICB9XG4gICAgfVxuICAgIG91dCArPSB0aGlzLmlucHV0LnNsaWNlKGNodW5rU3RhcnQsIHRoaXMucG9zKyspO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGVzLnN0cmluZywgb3V0KVxuICB9O1xuXG5cbiAgdmFyIElOVkFMSURfVEVNUExBVEVfRVNDQVBFX0VSUk9SID0ge307XG5cbiAgcHAkOS50cnlSZWFkVGVtcGxhdGVUb2tlbiA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuaW5UZW1wbGF0ZUVsZW1lbnQgPSB0cnVlO1xuICAgIHRyeSB7XG4gICAgICB0aGlzLnJlYWRUbXBsVG9rZW4oKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGlmIChlcnIgPT09IElOVkFMSURfVEVNUExBVEVfRVNDQVBFX0VSUk9SKSB7XG4gICAgICAgIHRoaXMucmVhZEludmFsaWRUZW1wbGF0ZVRva2VuKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBlcnJcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmluVGVtcGxhdGVFbGVtZW50ID0gZmFsc2U7XG4gIH07XG5cbiAgcHAkOS5pbnZhbGlkU3RyaW5nVG9rZW4gPSBmdW5jdGlvbihwb3NpdGlvbiwgbWVzc2FnZSkge1xuICAgIGlmICh0aGlzLmluVGVtcGxhdGVFbGVtZW50ICYmIHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA5KSB7XG4gICAgICB0aHJvdyBJTlZBTElEX1RFTVBMQVRFX0VTQ0FQRV9FUlJPUlxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnJhaXNlKHBvc2l0aW9uLCBtZXNzYWdlKTtcbiAgICB9XG4gIH07XG5cbiAgcHAkOS5yZWFkVG1wbFRva2VuID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIG91dCA9IFwiXCIsIGNodW5rU3RhcnQgPSB0aGlzLnBvcztcbiAgICBmb3IgKDs7KSB7XG4gICAgICBpZiAodGhpcy5wb3MgPj0gdGhpcy5pbnB1dC5sZW5ndGgpIHsgdGhpcy5yYWlzZSh0aGlzLnN0YXJ0LCBcIlVudGVybWluYXRlZCB0ZW1wbGF0ZVwiKTsgfVxuICAgICAgdmFyIGNoID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zKTtcbiAgICAgIGlmIChjaCA9PT0gOTYgfHwgY2ggPT09IDM2ICYmIHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyArIDEpID09PSAxMjMpIHsgXG4gICAgICAgIGlmICh0aGlzLnBvcyA9PT0gdGhpcy5zdGFydCAmJiAodGhpcy50eXBlID09PSB0eXBlcy50ZW1wbGF0ZSB8fCB0aGlzLnR5cGUgPT09IHR5cGVzLmludmFsaWRUZW1wbGF0ZSkpIHtcbiAgICAgICAgICBpZiAoY2ggPT09IDM2KSB7XG4gICAgICAgICAgICB0aGlzLnBvcyArPSAyO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZXMuZG9sbGFyQnJhY2VMKVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICArK3RoaXMucG9zO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZXMuYmFja1F1b3RlKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBvdXQgKz0gdGhpcy5pbnB1dC5zbGljZShjaHVua1N0YXJ0LCB0aGlzLnBvcyk7XG4gICAgICAgIHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGVzLnRlbXBsYXRlLCBvdXQpXG4gICAgICB9XG4gICAgICBpZiAoY2ggPT09IDkyKSB7IFxuICAgICAgICBvdXQgKz0gdGhpcy5pbnB1dC5zbGljZShjaHVua1N0YXJ0LCB0aGlzLnBvcyk7XG4gICAgICAgIG91dCArPSB0aGlzLnJlYWRFc2NhcGVkQ2hhcih0cnVlKTtcbiAgICAgICAgY2h1bmtTdGFydCA9IHRoaXMucG9zO1xuICAgICAgfSBlbHNlIGlmIChpc05ld0xpbmUoY2gpKSB7XG4gICAgICAgIG91dCArPSB0aGlzLmlucHV0LnNsaWNlKGNodW5rU3RhcnQsIHRoaXMucG9zKTtcbiAgICAgICAgKyt0aGlzLnBvcztcbiAgICAgICAgc3dpdGNoIChjaCkge1xuICAgICAgICBjYXNlIDEzOlxuICAgICAgICAgIGlmICh0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MpID09PSAxMCkgeyArK3RoaXMucG9zOyB9XG4gICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgb3V0ICs9IFwiXFxuXCI7XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBvdXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShjaCk7XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmxvY2F0aW9ucykge1xuICAgICAgICAgICsrdGhpcy5jdXJMaW5lO1xuICAgICAgICAgIHRoaXMubGluZVN0YXJ0ID0gdGhpcy5wb3M7XG4gICAgICAgIH1cbiAgICAgICAgY2h1bmtTdGFydCA9IHRoaXMucG9zO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgKyt0aGlzLnBvcztcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgcHAkOS5yZWFkSW52YWxpZFRlbXBsYXRlVG9rZW4gPSBmdW5jdGlvbigpIHtcbiAgICBmb3IgKDsgdGhpcy5wb3MgPCB0aGlzLmlucHV0Lmxlbmd0aDsgdGhpcy5wb3MrKykge1xuICAgICAgc3dpdGNoICh0aGlzLmlucHV0W3RoaXMucG9zXSkge1xuICAgICAgY2FzZSBcIlxcXFxcIjpcbiAgICAgICAgKyt0aGlzLnBvcztcbiAgICAgICAgYnJlYWtcblxuICAgICAgY2FzZSBcIiRcIjpcbiAgICAgICAgaWYgKHRoaXMuaW5wdXRbdGhpcy5wb3MgKyAxXSAhPT0gXCJ7XCIpIHtcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgXCJgXCI6XG4gICAgICAgIHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGVzLmludmFsaWRUZW1wbGF0ZSwgdGhpcy5pbnB1dC5zbGljZSh0aGlzLnN0YXJ0LCB0aGlzLnBvcykpXG5cbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5yYWlzZSh0aGlzLnN0YXJ0LCBcIlVudGVybWluYXRlZCB0ZW1wbGF0ZVwiKTtcbiAgfTtcblxuXG4gIHBwJDkucmVhZEVzY2FwZWRDaGFyID0gZnVuY3Rpb24oaW5UZW1wbGF0ZSkge1xuICAgIHZhciBjaCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCgrK3RoaXMucG9zKTtcbiAgICArK3RoaXMucG9zO1xuICAgIHN3aXRjaCAoY2gpIHtcbiAgICBjYXNlIDExMDogcmV0dXJuIFwiXFxuXCIgXG4gICAgY2FzZSAxMTQ6IHJldHVybiBcIlxcclwiIFxuICAgIGNhc2UgMTIwOiByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZSh0aGlzLnJlYWRIZXhDaGFyKDIpKSBcbiAgICBjYXNlIDExNzogcmV0dXJuIGNvZGVQb2ludFRvU3RyaW5nJDEodGhpcy5yZWFkQ29kZVBvaW50KCkpIFxuICAgIGNhc2UgMTE2OiByZXR1cm4gXCJcXHRcIiBcbiAgICBjYXNlIDk4OiByZXR1cm4gXCJcXGJcIiBcbiAgICBjYXNlIDExODogcmV0dXJuIFwiXFx1MDAwYlwiIFxuICAgIGNhc2UgMTAyOiByZXR1cm4gXCJcXGZcIiBcbiAgICBjYXNlIDEzOiBpZiAodGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zKSA9PT0gMTApIHsgKyt0aGlzLnBvczsgfSBcbiAgICBjYXNlIDEwOiBcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMubG9jYXRpb25zKSB7IHRoaXMubGluZVN0YXJ0ID0gdGhpcy5wb3M7ICsrdGhpcy5jdXJMaW5lOyB9XG4gICAgICByZXR1cm4gXCJcIlxuICAgIGNhc2UgNTY6XG4gICAgY2FzZSA1NzpcbiAgICAgIGlmIChpblRlbXBsYXRlKSB7XG4gICAgICAgIHZhciBjb2RlUG9zID0gdGhpcy5wb3MgLSAxO1xuXG4gICAgICAgIHRoaXMuaW52YWxpZFN0cmluZ1Rva2VuKFxuICAgICAgICAgIGNvZGVQb3MsXG4gICAgICAgICAgXCJJbnZhbGlkIGVzY2FwZSBzZXF1ZW5jZSBpbiB0ZW1wbGF0ZSBzdHJpbmdcIlxuICAgICAgICApO1xuXG4gICAgICAgIHJldHVybiBudWxsXG4gICAgICB9XG4gICAgZGVmYXVsdDpcbiAgICAgIGlmIChjaCA+PSA0OCAmJiBjaCA8PSA1NSkge1xuICAgICAgICB2YXIgb2N0YWxTdHIgPSB0aGlzLmlucHV0LnN1YnN0cih0aGlzLnBvcyAtIDEsIDMpLm1hdGNoKC9eWzAtN10rLylbMF07XG4gICAgICAgIHZhciBvY3RhbCA9IHBhcnNlSW50KG9jdGFsU3RyLCA4KTtcbiAgICAgICAgaWYgKG9jdGFsID4gMjU1KSB7XG4gICAgICAgICAgb2N0YWxTdHIgPSBvY3RhbFN0ci5zbGljZSgwLCAtMSk7XG4gICAgICAgICAgb2N0YWwgPSBwYXJzZUludChvY3RhbFN0ciwgOCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wb3MgKz0gb2N0YWxTdHIubGVuZ3RoIC0gMTtcbiAgICAgICAgY2ggPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MpO1xuICAgICAgICBpZiAoKG9jdGFsU3RyICE9PSBcIjBcIiB8fCBjaCA9PT0gNTYgfHwgY2ggPT09IDU3KSAmJiAodGhpcy5zdHJpY3QgfHwgaW5UZW1wbGF0ZSkpIHtcbiAgICAgICAgICB0aGlzLmludmFsaWRTdHJpbmdUb2tlbihcbiAgICAgICAgICAgIHRoaXMucG9zIC0gMSAtIG9jdGFsU3RyLmxlbmd0aCxcbiAgICAgICAgICAgIGluVGVtcGxhdGVcbiAgICAgICAgICAgICAgPyBcIk9jdGFsIGxpdGVyYWwgaW4gdGVtcGxhdGUgc3RyaW5nXCJcbiAgICAgICAgICAgICAgOiBcIk9jdGFsIGxpdGVyYWwgaW4gc3RyaWN0IG1vZGVcIlxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUob2N0YWwpXG4gICAgICB9XG4gICAgICBpZiAoaXNOZXdMaW5lKGNoKSkge1xuICAgICAgICByZXR1cm4gXCJcIlxuICAgICAgfVxuICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoY2gpXG4gICAgfVxuICB9O1xuXG5cbiAgcHAkOS5yZWFkSGV4Q2hhciA9IGZ1bmN0aW9uKGxlbikge1xuICAgIHZhciBjb2RlUG9zID0gdGhpcy5wb3M7XG4gICAgdmFyIG4gPSB0aGlzLnJlYWRJbnQoMTYsIGxlbik7XG4gICAgaWYgKG4gPT09IG51bGwpIHsgdGhpcy5pbnZhbGlkU3RyaW5nVG9rZW4oY29kZVBvcywgXCJCYWQgY2hhcmFjdGVyIGVzY2FwZSBzZXF1ZW5jZVwiKTsgfVxuICAgIHJldHVybiBuXG4gIH07XG5cblxuICBwcCQ5LnJlYWRXb3JkMSA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuY29udGFpbnNFc2MgPSBmYWxzZTtcbiAgICB2YXIgd29yZCA9IFwiXCIsIGZpcnN0ID0gdHJ1ZSwgY2h1bmtTdGFydCA9IHRoaXMucG9zO1xuICAgIHZhciBhc3RyYWwgPSB0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNjtcbiAgICB3aGlsZSAodGhpcy5wb3MgPCB0aGlzLmlucHV0Lmxlbmd0aCkge1xuICAgICAgdmFyIGNoID0gdGhpcy5mdWxsQ2hhckNvZGVBdFBvcygpO1xuICAgICAgaWYgKGlzSWRlbnRpZmllckNoYXIoY2gsIGFzdHJhbCkpIHtcbiAgICAgICAgdGhpcy5wb3MgKz0gY2ggPD0gMHhmZmZmID8gMSA6IDI7XG4gICAgICB9IGVsc2UgaWYgKGNoID09PSA5MikgeyBcbiAgICAgICAgdGhpcy5jb250YWluc0VzYyA9IHRydWU7XG4gICAgICAgIHdvcmQgKz0gdGhpcy5pbnB1dC5zbGljZShjaHVua1N0YXJ0LCB0aGlzLnBvcyk7XG4gICAgICAgIHZhciBlc2NTdGFydCA9IHRoaXMucG9zO1xuICAgICAgICBpZiAodGhpcy5pbnB1dC5jaGFyQ29kZUF0KCsrdGhpcy5wb3MpICE9PSAxMTcpIFxuICAgICAgICAgIHsgdGhpcy5pbnZhbGlkU3RyaW5nVG9rZW4odGhpcy5wb3MsIFwiRXhwZWN0aW5nIFVuaWNvZGUgZXNjYXBlIHNlcXVlbmNlIFxcXFx1WFhYWFwiKTsgfVxuICAgICAgICArK3RoaXMucG9zO1xuICAgICAgICB2YXIgZXNjID0gdGhpcy5yZWFkQ29kZVBvaW50KCk7XG4gICAgICAgIGlmICghKGZpcnN0ID8gaXNJZGVudGlmaWVyU3RhcnQgOiBpc0lkZW50aWZpZXJDaGFyKShlc2MsIGFzdHJhbCkpXG4gICAgICAgICAgeyB0aGlzLmludmFsaWRTdHJpbmdUb2tlbihlc2NTdGFydCwgXCJJbnZhbGlkIFVuaWNvZGUgZXNjYXBlXCIpOyB9XG4gICAgICAgIHdvcmQgKz0gY29kZVBvaW50VG9TdHJpbmckMShlc2MpO1xuICAgICAgICBjaHVua1N0YXJ0ID0gdGhpcy5wb3M7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBicmVha1xuICAgICAgfVxuICAgICAgZmlyc3QgPSBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHdvcmQgKyB0aGlzLmlucHV0LnNsaWNlKGNodW5rU3RhcnQsIHRoaXMucG9zKVxuICB9O1xuXG5cbiAgcHAkOS5yZWFkV29yZCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB3b3JkID0gdGhpcy5yZWFkV29yZDEoKTtcbiAgICB2YXIgdHlwZSA9IHR5cGVzLm5hbWU7XG4gICAgaWYgKHRoaXMua2V5d29yZHMudGVzdCh3b3JkKSkge1xuICAgICAgdHlwZSA9IGtleXdvcmRzJDFbd29yZF07XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGUsIHdvcmQpXG4gIH07XG5cblxuICB2YXIgdmVyc2lvbiA9IFwiNy4xLjBcIjtcblxuICBQYXJzZXIuYWNvcm4gPSB7XG4gICAgUGFyc2VyOiBQYXJzZXIsXG4gICAgdmVyc2lvbjogdmVyc2lvbixcbiAgICBkZWZhdWx0T3B0aW9uczogZGVmYXVsdE9wdGlvbnMsXG4gICAgUG9zaXRpb246IFBvc2l0aW9uLFxuICAgIFNvdXJjZUxvY2F0aW9uOiBTb3VyY2VMb2NhdGlvbixcbiAgICBnZXRMaW5lSW5mbzogZ2V0TGluZUluZm8sXG4gICAgTm9kZTogTm9kZSxcbiAgICBUb2tlblR5cGU6IFRva2VuVHlwZSxcbiAgICB0b2tUeXBlczogdHlwZXMsXG4gICAga2V5d29yZFR5cGVzOiBrZXl3b3JkcyQxLFxuICAgIFRva0NvbnRleHQ6IFRva0NvbnRleHQsXG4gICAgdG9rQ29udGV4dHM6IHR5cGVzJDEsXG4gICAgaXNJZGVudGlmaWVyQ2hhcjogaXNJZGVudGlmaWVyQ2hhcixcbiAgICBpc0lkZW50aWZpZXJTdGFydDogaXNJZGVudGlmaWVyU3RhcnQsXG4gICAgVG9rZW46IFRva2VuLFxuICAgIGlzTmV3TGluZTogaXNOZXdMaW5lLFxuICAgIGxpbmVCcmVhazogbGluZUJyZWFrLFxuICAgIGxpbmVCcmVha0c6IGxpbmVCcmVha0csXG4gICAgbm9uQVNDSUl3aGl0ZXNwYWNlOiBub25BU0NJSXdoaXRlc3BhY2VcbiAgfTtcblxuXG4gIGZ1bmN0aW9uIHBhcnNlKGlucHV0LCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIFBhcnNlci5wYXJzZShpbnB1dCwgb3B0aW9ucylcbiAgfVxuXG5cbiAgZnVuY3Rpb24gcGFyc2VFeHByZXNzaW9uQXQoaW5wdXQsIHBvcywgb3B0aW9ucykge1xuICAgIHJldHVybiBQYXJzZXIucGFyc2VFeHByZXNzaW9uQXQoaW5wdXQsIHBvcywgb3B0aW9ucylcbiAgfVxuXG5cbiAgZnVuY3Rpb24gdG9rZW5pemVyKGlucHV0LCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIFBhcnNlci50b2tlbml6ZXIoaW5wdXQsIG9wdGlvbnMpXG4gIH1cblxuICBleHBvcnRzLk5vZGUgPSBOb2RlO1xuICBleHBvcnRzLlBhcnNlciA9IFBhcnNlcjtcbiAgZXhwb3J0cy5Qb3NpdGlvbiA9IFBvc2l0aW9uO1xuICBleHBvcnRzLlNvdXJjZUxvY2F0aW9uID0gU291cmNlTG9jYXRpb247XG4gIGV4cG9ydHMuVG9rQ29udGV4dCA9IFRva0NvbnRleHQ7XG4gIGV4cG9ydHMuVG9rZW4gPSBUb2tlbjtcbiAgZXhwb3J0cy5Ub2tlblR5cGUgPSBUb2tlblR5cGU7XG4gIGV4cG9ydHMuZGVmYXVsdE9wdGlvbnMgPSBkZWZhdWx0T3B0aW9ucztcbiAgZXhwb3J0cy5nZXRMaW5lSW5mbyA9IGdldExpbmVJbmZvO1xuICBleHBvcnRzLmlzSWRlbnRpZmllckNoYXIgPSBpc0lkZW50aWZpZXJDaGFyO1xuICBleHBvcnRzLmlzSWRlbnRpZmllclN0YXJ0ID0gaXNJZGVudGlmaWVyU3RhcnQ7XG4gIGV4cG9ydHMuaXNOZXdMaW5lID0gaXNOZXdMaW5lO1xuICBleHBvcnRzLmtleXdvcmRUeXBlcyA9IGtleXdvcmRzJDE7XG4gIGV4cG9ydHMubGluZUJyZWFrID0gbGluZUJyZWFrO1xuICBleHBvcnRzLmxpbmVCcmVha0cgPSBsaW5lQnJlYWtHO1xuICBleHBvcnRzLm5vbkFTQ0lJd2hpdGVzcGFjZSA9IG5vbkFTQ0lJd2hpdGVzcGFjZTtcbiAgZXhwb3J0cy5wYXJzZSA9IHBhcnNlO1xuICBleHBvcnRzLnBhcnNlRXhwcmVzc2lvbkF0ID0gcGFyc2VFeHByZXNzaW9uQXQ7XG4gIGV4cG9ydHMudG9rQ29udGV4dHMgPSB0eXBlcyQxO1xuICBleHBvcnRzLnRva1R5cGVzID0gdHlwZXM7XG4gIGV4cG9ydHMudG9rZW5pemVyID0gdG9rZW5pemVyO1xuICBleHBvcnRzLnZlcnNpb24gPSB2ZXJzaW9uO1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbn0pKTtcblxufSx7fV0sMjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5cbn0se31dLDM6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuZnVuY3Rpb24gZ2xXaXJldGFwKGdsLCBvcHRpb25zID0ge30pIHtcbiAgY29uc3Qge1xuICAgIGNvbnRleHROYW1lID0gJ2dsJyxcbiAgICB0aHJvd0dldEVycm9yLFxuICAgIHVzZVRyYWNrYWJsZVByaW1pdGl2ZXMsXG4gICAgcmVhZFBpeGVsc0ZpbGUsXG4gICAgcmVjb3JkaW5nID0gW10sXG4gICAgdmFyaWFibGVzID0ge30sXG4gICAgb25SZWFkUGl4ZWxzLFxuICAgIG9uVW5yZWNvZ25pemVkQXJndW1lbnRMb29rdXAsXG4gIH0gPSBvcHRpb25zO1xuICBjb25zdCBwcm94eSA9IG5ldyBQcm94eShnbCwgeyBnZXQ6IGxpc3RlbiB9KTtcbiAgY29uc3QgY29udGV4dFZhcmlhYmxlcyA9IFtdO1xuICBjb25zdCBlbnRpdHlOYW1lcyA9IHt9O1xuICBsZXQgaW1hZ2VDb3VudCA9IDA7XG4gIGxldCBpbmRlbnQgPSAnJztcbiAgbGV0IHJlYWRQaXhlbHNWYXJpYWJsZU5hbWU7XG4gIHJldHVybiBwcm94eTtcbiAgZnVuY3Rpb24gbGlzdGVuKG9iaiwgcHJvcGVydHkpIHtcbiAgICBzd2l0Y2ggKHByb3BlcnR5KSB7XG4gICAgICBjYXNlICdhZGRDb21tZW50JzogcmV0dXJuIGFkZENvbW1lbnQ7XG4gICAgICBjYXNlICdjaGVja1Rocm93RXJyb3InOiByZXR1cm4gY2hlY2tUaHJvd0Vycm9yO1xuICAgICAgY2FzZSAnZ2V0UmVhZFBpeGVsc1ZhcmlhYmxlTmFtZSc6IHJldHVybiByZWFkUGl4ZWxzVmFyaWFibGVOYW1lO1xuICAgICAgY2FzZSAnaW5zZXJ0VmFyaWFibGUnOiByZXR1cm4gaW5zZXJ0VmFyaWFibGU7XG4gICAgICBjYXNlICdyZXNldCc6IHJldHVybiByZXNldDtcbiAgICAgIGNhc2UgJ3NldEluZGVudCc6IHJldHVybiBzZXRJbmRlbnQ7XG4gICAgICBjYXNlICd0b1N0cmluZyc6IHJldHVybiB0b1N0cmluZztcbiAgICAgIGNhc2UgJ2dldENvbnRleHRWYXJpYWJsZU5hbWUnOiByZXR1cm4gZ2V0Q29udGV4dFZhcmlhYmxlTmFtZTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBnbFtwcm9wZXJ0eV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbigpIHsgXG4gICAgICAgIHN3aXRjaCAocHJvcGVydHkpIHtcbiAgICAgICAgICBjYXNlICdnZXRFcnJvcic6XG4gICAgICAgICAgICBpZiAodGhyb3dHZXRFcnJvcikge1xuICAgICAgICAgICAgICByZWNvcmRpbmcucHVzaChgJHtpbmRlbnR9aWYgKCR7Y29udGV4dE5hbWV9LmdldEVycm9yKCkgIT09ICR7Y29udGV4dE5hbWV9Lk5PTkUpIHRocm93IG5ldyBFcnJvcignZXJyb3InKTtgKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJlY29yZGluZy5wdXNoKGAke2luZGVudH0ke2NvbnRleHROYW1lfS5nZXRFcnJvcigpO2ApOyBcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBnbC5nZXRFcnJvcigpO1xuICAgICAgICAgIGNhc2UgJ2dldEV4dGVuc2lvbic6IHtcbiAgICAgICAgICAgIGNvbnN0IHZhcmlhYmxlTmFtZSA9IGAke2NvbnRleHROYW1lfVZhcmlhYmxlcyR7Y29udGV4dFZhcmlhYmxlcy5sZW5ndGh9YDtcbiAgICAgICAgICAgIHJlY29yZGluZy5wdXNoKGAke2luZGVudH1jb25zdCAke3ZhcmlhYmxlTmFtZX0gPSAke2NvbnRleHROYW1lfS5nZXRFeHRlbnNpb24oJyR7YXJndW1lbnRzWzBdfScpO2ApO1xuICAgICAgICAgICAgY29uc3QgZXh0ZW5zaW9uID0gZ2wuZ2V0RXh0ZW5zaW9uKGFyZ3VtZW50c1swXSk7XG4gICAgICAgICAgICBpZiAoZXh0ZW5zaW9uICYmIHR5cGVvZiBleHRlbnNpb24gPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHRhcHBlZEV4dGVuc2lvbiA9IGdsRXh0ZW5zaW9uV2lyZXRhcChleHRlbnNpb24sIHtcbiAgICAgICAgICAgICAgICBnZXRFbnRpdHksXG4gICAgICAgICAgICAgICAgdXNlVHJhY2thYmxlUHJpbWl0aXZlcyxcbiAgICAgICAgICAgICAgICByZWNvcmRpbmcsXG4gICAgICAgICAgICAgICAgY29udGV4dE5hbWU6IHZhcmlhYmxlTmFtZSxcbiAgICAgICAgICAgICAgICBjb250ZXh0VmFyaWFibGVzLFxuICAgICAgICAgICAgICAgIHZhcmlhYmxlcyxcbiAgICAgICAgICAgICAgICBpbmRlbnQsXG4gICAgICAgICAgICAgICAgb25VbnJlY29nbml6ZWRBcmd1bWVudExvb2t1cCxcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGNvbnRleHRWYXJpYWJsZXMucHVzaCh0YXBwZWRFeHRlbnNpb24pO1xuICAgICAgICAgICAgICByZXR1cm4gdGFwcGVkRXh0ZW5zaW9uO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgY29udGV4dFZhcmlhYmxlcy5wdXNoKG51bGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGV4dGVuc2lvbjtcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSAncmVhZFBpeGVscyc6XG4gICAgICAgICAgICBjb25zdCBpID0gY29udGV4dFZhcmlhYmxlcy5pbmRleE9mKGFyZ3VtZW50c1s2XSk7XG4gICAgICAgICAgICBsZXQgdGFyZ2V0VmFyaWFibGVOYW1lO1xuICAgICAgICAgICAgaWYgKGkgPT09IC0xKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHZhcmlhYmxlTmFtZSA9IGdldFZhcmlhYmxlTmFtZShhcmd1bWVudHNbNl0pO1xuICAgICAgICAgICAgICBpZiAodmFyaWFibGVOYW1lKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0VmFyaWFibGVOYW1lID0gdmFyaWFibGVOYW1lO1xuICAgICAgICAgICAgICAgIHJlY29yZGluZy5wdXNoKGAke2luZGVudH0ke3ZhcmlhYmxlTmFtZX1gKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0YXJnZXRWYXJpYWJsZU5hbWUgPSBgJHtjb250ZXh0TmFtZX1WYXJpYWJsZSR7Y29udGV4dFZhcmlhYmxlcy5sZW5ndGh9YDtcbiAgICAgICAgICAgICAgICBjb250ZXh0VmFyaWFibGVzLnB1c2goYXJndW1lbnRzWzZdKTtcbiAgICAgICAgICAgICAgICByZWNvcmRpbmcucHVzaChgJHtpbmRlbnR9Y29uc3QgJHt0YXJnZXRWYXJpYWJsZU5hbWV9ID0gbmV3ICR7YXJndW1lbnRzWzZdLmNvbnN0cnVjdG9yLm5hbWV9KCR7YXJndW1lbnRzWzZdLmxlbmd0aH0pO2ApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0YXJnZXRWYXJpYWJsZU5hbWUgPSBgJHtjb250ZXh0TmFtZX1WYXJpYWJsZSR7aX1gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVhZFBpeGVsc1ZhcmlhYmxlTmFtZSA9IHRhcmdldFZhcmlhYmxlTmFtZTtcbiAgICAgICAgICAgIGNvbnN0IGFyZ3VtZW50QXNTdHJpbmdzID0gW1xuICAgICAgICAgICAgICBhcmd1bWVudHNbMF0sXG4gICAgICAgICAgICAgIGFyZ3VtZW50c1sxXSxcbiAgICAgICAgICAgICAgYXJndW1lbnRzWzJdLFxuICAgICAgICAgICAgICBhcmd1bWVudHNbM10sXG4gICAgICAgICAgICAgIGdldEVudGl0eShhcmd1bWVudHNbNF0pLFxuICAgICAgICAgICAgICBnZXRFbnRpdHkoYXJndW1lbnRzWzVdKSxcbiAgICAgICAgICAgICAgdGFyZ2V0VmFyaWFibGVOYW1lXG4gICAgICAgICAgICBdO1xuICAgICAgICAgICAgcmVjb3JkaW5nLnB1c2goYCR7aW5kZW50fSR7Y29udGV4dE5hbWV9LnJlYWRQaXhlbHMoJHthcmd1bWVudEFzU3RyaW5ncy5qb2luKCcsICcpfSk7YCk7XG4gICAgICAgICAgICBpZiAocmVhZFBpeGVsc0ZpbGUpIHtcbiAgICAgICAgICAgICAgd3JpdGVQUE0oYXJndW1lbnRzWzJdLCBhcmd1bWVudHNbM10pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9uUmVhZFBpeGVscykge1xuICAgICAgICAgICAgICBvblJlYWRQaXhlbHModGFyZ2V0VmFyaWFibGVOYW1lLCBhcmd1bWVudEFzU3RyaW5ncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZ2wucmVhZFBpeGVscy5hcHBseShnbCwgYXJndW1lbnRzKTtcbiAgICAgICAgICBjYXNlICdkcmF3QnVmZmVycyc6XG4gICAgICAgICAgICByZWNvcmRpbmcucHVzaChgJHtpbmRlbnR9JHtjb250ZXh0TmFtZX0uZHJhd0J1ZmZlcnMoWyR7YXJndW1lbnRzVG9TdHJpbmcoYXJndW1lbnRzWzBdLCB7IGNvbnRleHROYW1lLCBjb250ZXh0VmFyaWFibGVzLCBnZXRFbnRpdHksIGFkZFZhcmlhYmxlLCB2YXJpYWJsZXMsIG9uVW5yZWNvZ25pemVkQXJndW1lbnRMb29rdXAgfSApfV0pO2ApO1xuICAgICAgICAgICAgcmV0dXJuIGdsLmRyYXdCdWZmZXJzKGFyZ3VtZW50c1swXSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJlc3VsdCA9IGdsW3Byb3BlcnR5XS5hcHBseShnbCwgYXJndW1lbnRzKTtcbiAgICAgICAgc3dpdGNoICh0eXBlb2YgcmVzdWx0KSB7XG4gICAgICAgICAgY2FzZSAndW5kZWZpbmVkJzpcbiAgICAgICAgICAgIHJlY29yZGluZy5wdXNoKGAke2luZGVudH0ke21ldGhvZENhbGxUb1N0cmluZyhwcm9wZXJ0eSwgYXJndW1lbnRzKX07YCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgICAgIGlmICh1c2VUcmFja2FibGVQcmltaXRpdmVzICYmIGNvbnRleHRWYXJpYWJsZXMuaW5kZXhPZih0cmFja2FibGVQcmltaXRpdmUocmVzdWx0KSkgPT09IC0xKSB7XG4gICAgICAgICAgICAgIHJlY29yZGluZy5wdXNoKGAke2luZGVudH1jb25zdCAke2NvbnRleHROYW1lfVZhcmlhYmxlJHtjb250ZXh0VmFyaWFibGVzLmxlbmd0aH0gPSAke21ldGhvZENhbGxUb1N0cmluZyhwcm9wZXJ0eSwgYXJndW1lbnRzKX07YCk7XG4gICAgICAgICAgICAgIGNvbnRleHRWYXJpYWJsZXMucHVzaChyZXN1bHQgPSB0cmFja2FibGVQcmltaXRpdmUocmVzdWx0KSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBpZiAocmVzdWx0ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgIHJlY29yZGluZy5wdXNoKGAke21ldGhvZENhbGxUb1N0cmluZyhwcm9wZXJ0eSwgYXJndW1lbnRzKX07YCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZWNvcmRpbmcucHVzaChgJHtpbmRlbnR9Y29uc3QgJHtjb250ZXh0TmFtZX1WYXJpYWJsZSR7Y29udGV4dFZhcmlhYmxlcy5sZW5ndGh9ID0gJHttZXRob2RDYWxsVG9TdHJpbmcocHJvcGVydHksIGFyZ3VtZW50cyl9O2ApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb250ZXh0VmFyaWFibGVzLnB1c2gocmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgIH1cbiAgICBlbnRpdHlOYW1lc1tnbFtwcm9wZXJ0eV1dID0gcHJvcGVydHk7XG4gICAgcmV0dXJuIGdsW3Byb3BlcnR5XTtcbiAgfVxuICBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gcmVjb3JkaW5nLmpvaW4oJ1xcbicpO1xuICB9XG4gIGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgIHdoaWxlIChyZWNvcmRpbmcubGVuZ3RoID4gMCkge1xuICAgICAgcmVjb3JkaW5nLnBvcCgpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBpbnNlcnRWYXJpYWJsZShuYW1lLCB2YWx1ZSkge1xuICAgIHZhcmlhYmxlc1tuYW1lXSA9IHZhbHVlO1xuICB9XG4gIGZ1bmN0aW9uIGdldEVudGl0eSh2YWx1ZSkge1xuICAgIGNvbnN0IG5hbWUgPSBlbnRpdHlOYW1lc1t2YWx1ZV07XG4gICAgaWYgKG5hbWUpIHtcbiAgICAgIHJldHVybiBjb250ZXh0TmFtZSArICcuJyArIG5hbWU7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBmdW5jdGlvbiBzZXRJbmRlbnQoc3BhY2VzKSB7XG4gICAgaW5kZW50ID0gJyAnLnJlcGVhdChzcGFjZXMpO1xuICB9XG4gIGZ1bmN0aW9uIGFkZFZhcmlhYmxlKHZhbHVlLCBzb3VyY2UpIHtcbiAgICBjb25zdCB2YXJpYWJsZU5hbWUgPSBgJHtjb250ZXh0TmFtZX1WYXJpYWJsZSR7Y29udGV4dFZhcmlhYmxlcy5sZW5ndGh9YDtcbiAgICByZWNvcmRpbmcucHVzaChgJHtpbmRlbnR9Y29uc3QgJHt2YXJpYWJsZU5hbWV9ID0gJHtzb3VyY2V9O2ApO1xuICAgIGNvbnRleHRWYXJpYWJsZXMucHVzaCh2YWx1ZSk7XG4gICAgcmV0dXJuIHZhcmlhYmxlTmFtZTtcbiAgfVxuICBmdW5jdGlvbiB3cml0ZVBQTSh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgY29uc3Qgc291cmNlVmFyaWFibGUgPSBgJHtjb250ZXh0TmFtZX1WYXJpYWJsZSR7Y29udGV4dFZhcmlhYmxlcy5sZW5ndGh9YDtcbiAgICBjb25zdCBpbWFnZVZhcmlhYmxlID0gYGltYWdlRGF0dW0ke2ltYWdlQ291bnR9YDtcbiAgICByZWNvcmRpbmcucHVzaChgJHtpbmRlbnR9bGV0ICR7aW1hZ2VWYXJpYWJsZX0gPSBbXCJQM1xcXFxuIyAke3JlYWRQaXhlbHNGaWxlfS5wcG1cXFxcblwiLCAke3dpZHRofSwgJyAnLCAke2hlaWdodH0sIFwiXFxcXG4yNTVcXFxcblwiXS5qb2luKFwiXCIpO2ApO1xuICAgIHJlY29yZGluZy5wdXNoKGAke2luZGVudH1mb3IgKGxldCBpID0gMDsgaSA8ICR7aW1hZ2VWYXJpYWJsZX0ubGVuZ3RoOyBpICs9IDQpIHtgKTtcbiAgICByZWNvcmRpbmcucHVzaChgJHtpbmRlbnR9ICAke2ltYWdlVmFyaWFibGV9ICs9ICR7c291cmNlVmFyaWFibGV9W2ldICsgJyAnICsgJHtzb3VyY2VWYXJpYWJsZX1baSArIDFdICsgJyAnICsgJHtzb3VyY2VWYXJpYWJsZX1baSArIDJdICsgJyAnO2ApO1xuICAgIHJlY29yZGluZy5wdXNoKGAke2luZGVudH19YCk7XG4gICAgcmVjb3JkaW5nLnB1c2goYCR7aW5kZW50fWlmICh0eXBlb2YgcmVxdWlyZSAhPT0gXCJ1bmRlZmluZWRcIikge2ApO1xuICAgIHJlY29yZGluZy5wdXNoKGAke2luZGVudH0gIHJlcXVpcmUoJ2ZzJykud3JpdGVGaWxlU3luYygnLi8ke3JlYWRQaXhlbHNGaWxlfS5wcG0nLCAke2ltYWdlVmFyaWFibGV9KTtgKTtcbiAgICByZWNvcmRpbmcucHVzaChgJHtpbmRlbnR9fWApO1xuICAgIGltYWdlQ291bnQrKztcbiAgfVxuICBmdW5jdGlvbiBhZGRDb21tZW50KHZhbHVlKSB7XG4gICAgcmVjb3JkaW5nLnB1c2goYCR7aW5kZW50fS8vICR7dmFsdWV9YCk7XG4gIH1cbiAgZnVuY3Rpb24gY2hlY2tUaHJvd0Vycm9yKCkge1xuICAgIHJlY29yZGluZy5wdXNoKGAke2luZGVudH0oKCkgPT4ge1xuJHtpbmRlbnR9Y29uc3QgZXJyb3IgPSAke2NvbnRleHROYW1lfS5nZXRFcnJvcigpO1xuJHtpbmRlbnR9aWYgKGVycm9yICE9PSAke2NvbnRleHROYW1lfS5OT05FKSB7XG4ke2luZGVudH0gIGNvbnN0IG5hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoZ2wpO1xuJHtpbmRlbnR9ICBmb3IgKGxldCBpID0gMDsgaSA8IG5hbWVzLmxlbmd0aDsgaSsrKSB7XG4ke2luZGVudH0gICAgY29uc3QgbmFtZSA9IG5hbWVzW2ldO1xuJHtpbmRlbnR9ICAgIGlmICgke2NvbnRleHROYW1lfVtuYW1lXSA9PT0gZXJyb3IpIHtcbiR7aW5kZW50fSAgICAgIHRocm93IG5ldyBFcnJvcignJHtjb250ZXh0TmFtZX0gdGhyZXcgJyArIG5hbWUpO1xuJHtpbmRlbnR9ICAgIH1cbiR7aW5kZW50fSAgfVxuJHtpbmRlbnR9fVxuJHtpbmRlbnR9fSkoKTtgKTtcbiAgfVxuICBmdW5jdGlvbiBtZXRob2RDYWxsVG9TdHJpbmcobWV0aG9kLCBhcmdzKSB7XG4gICAgcmV0dXJuIGAke2NvbnRleHROYW1lfS4ke21ldGhvZH0oJHthcmd1bWVudHNUb1N0cmluZyhhcmdzLCB7IGNvbnRleHROYW1lLCBjb250ZXh0VmFyaWFibGVzLCBnZXRFbnRpdHksIGFkZFZhcmlhYmxlLCB2YXJpYWJsZXMsIG9uVW5yZWNvZ25pemVkQXJndW1lbnRMb29rdXAgfSl9KWA7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRWYXJpYWJsZU5hbWUodmFsdWUpIHtcbiAgICBpZiAodmFyaWFibGVzKSB7XG4gICAgICBmb3IgKGNvbnN0IG5hbWUgaW4gdmFyaWFibGVzKSB7XG4gICAgICAgIGlmICh2YXJpYWJsZXNbbmFtZV0gPT09IHZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIG5hbWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRDb250ZXh0VmFyaWFibGVOYW1lKHZhbHVlKSB7XG4gICAgY29uc3QgaSA9IGNvbnRleHRWYXJpYWJsZXMuaW5kZXhPZih2YWx1ZSk7XG4gICAgaWYgKGkgIT09IC0xKSB7XG4gICAgICByZXR1cm4gYCR7Y29udGV4dE5hbWV9VmFyaWFibGUke2l9YDtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2xFeHRlbnNpb25XaXJldGFwKGV4dGVuc2lvbiwgb3B0aW9ucykge1xuICBjb25zdCBwcm94eSA9IG5ldyBQcm94eShleHRlbnNpb24sIHsgZ2V0OiBsaXN0ZW4gfSk7XG4gIGNvbnN0IGV4dGVuc2lvbkVudGl0eU5hbWVzID0ge307XG4gIGNvbnN0IHtcbiAgICBjb250ZXh0TmFtZSxcbiAgICBjb250ZXh0VmFyaWFibGVzLFxuICAgIGdldEVudGl0eSxcbiAgICB1c2VUcmFja2FibGVQcmltaXRpdmVzLFxuICAgIHJlY29yZGluZyxcbiAgICB2YXJpYWJsZXMsXG4gICAgaW5kZW50LFxuICAgIG9uVW5yZWNvZ25pemVkQXJndW1lbnRMb29rdXAsXG4gIH0gPSBvcHRpb25zO1xuICByZXR1cm4gcHJveHk7XG4gIGZ1bmN0aW9uIGxpc3RlbihvYmosIHByb3BlcnR5KSB7XG4gICAgaWYgKHR5cGVvZiBvYmpbcHJvcGVydHldID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIHN3aXRjaCAocHJvcGVydHkpIHtcbiAgICAgICAgICBjYXNlICdkcmF3QnVmZmVyc1dFQkdMJzpcbiAgICAgICAgICAgIHJlY29yZGluZy5wdXNoKGAke2luZGVudH0ke2NvbnRleHROYW1lfS5kcmF3QnVmZmVyc1dFQkdMKFske2FyZ3VtZW50c1RvU3RyaW5nKGFyZ3VtZW50c1swXSwgeyBjb250ZXh0TmFtZSwgY29udGV4dFZhcmlhYmxlcywgZ2V0RW50aXR5OiBnZXRFeHRlbnNpb25FbnRpdHksIGFkZFZhcmlhYmxlLCB2YXJpYWJsZXMsIG9uVW5yZWNvZ25pemVkQXJndW1lbnRMb29rdXAgfSl9XSk7YCk7XG4gICAgICAgICAgICByZXR1cm4gZXh0ZW5zaW9uLmRyYXdCdWZmZXJzV0VCR0woYXJndW1lbnRzWzBdKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcmVzdWx0ID0gZXh0ZW5zaW9uW3Byb3BlcnR5XS5hcHBseShleHRlbnNpb24sIGFyZ3VtZW50cyk7XG4gICAgICAgIHN3aXRjaCAodHlwZW9mIHJlc3VsdCkge1xuICAgICAgICAgIGNhc2UgJ3VuZGVmaW5lZCc6XG4gICAgICAgICAgICByZWNvcmRpbmcucHVzaChgJHtpbmRlbnR9JHttZXRob2RDYWxsVG9TdHJpbmcocHJvcGVydHksIGFyZ3VtZW50cyl9O2ApO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgICAgICBpZiAodXNlVHJhY2thYmxlUHJpbWl0aXZlcyAmJiBjb250ZXh0VmFyaWFibGVzLmluZGV4T2YodHJhY2thYmxlUHJpbWl0aXZlKHJlc3VsdCkpID09PSAtMSkge1xuICAgICAgICAgICAgICByZWNvcmRpbmcucHVzaChgJHtpbmRlbnR9Y29uc3QgJHtjb250ZXh0TmFtZX1WYXJpYWJsZSR7Y29udGV4dFZhcmlhYmxlcy5sZW5ndGh9ID0gJHttZXRob2RDYWxsVG9TdHJpbmcocHJvcGVydHksIGFyZ3VtZW50cyl9O2ApO1xuICAgICAgICAgICAgICBjb250ZXh0VmFyaWFibGVzLnB1c2gocmVzdWx0ID0gdHJhY2thYmxlUHJpbWl0aXZlKHJlc3VsdCkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmVjb3JkaW5nLnB1c2goYCR7aW5kZW50fWNvbnN0ICR7Y29udGV4dE5hbWV9VmFyaWFibGUke2NvbnRleHRWYXJpYWJsZXMubGVuZ3RofSA9ICR7bWV0aG9kQ2FsbFRvU3RyaW5nKHByb3BlcnR5LCBhcmd1bWVudHMpfTtgKTtcbiAgICAgICAgICAgICAgY29udGV4dFZhcmlhYmxlcy5wdXNoKHJlc3VsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgaWYgKHJlc3VsdCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICByZWNvcmRpbmcucHVzaChgJHttZXRob2RDYWxsVG9TdHJpbmcocHJvcGVydHksIGFyZ3VtZW50cyl9O2ApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmVjb3JkaW5nLnB1c2goYCR7aW5kZW50fWNvbnN0ICR7Y29udGV4dE5hbWV9VmFyaWFibGUke2NvbnRleHRWYXJpYWJsZXMubGVuZ3RofSA9ICR7bWV0aG9kQ2FsbFRvU3RyaW5nKHByb3BlcnR5LCBhcmd1bWVudHMpfTtgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnRleHRWYXJpYWJsZXMucHVzaChyZXN1bHQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9O1xuICAgIH1cbiAgICBleHRlbnNpb25FbnRpdHlOYW1lc1tleHRlbnNpb25bcHJvcGVydHldXSA9IHByb3BlcnR5O1xuICAgIHJldHVybiBleHRlbnNpb25bcHJvcGVydHldO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0RXh0ZW5zaW9uRW50aXR5KHZhbHVlKSB7XG4gICAgaWYgKGV4dGVuc2lvbkVudGl0eU5hbWVzLmhhc093blByb3BlcnR5KHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGAke2NvbnRleHROYW1lfS4ke2V4dGVuc2lvbkVudGl0eU5hbWVzW3ZhbHVlXX1gO1xuICAgIH1cbiAgICByZXR1cm4gZ2V0RW50aXR5KHZhbHVlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1ldGhvZENhbGxUb1N0cmluZyhtZXRob2QsIGFyZ3MpIHtcbiAgICByZXR1cm4gYCR7Y29udGV4dE5hbWV9LiR7bWV0aG9kfSgke2FyZ3VtZW50c1RvU3RyaW5nKGFyZ3MsIHsgY29udGV4dE5hbWUsIGNvbnRleHRWYXJpYWJsZXMsIGdldEVudGl0eTogZ2V0RXh0ZW5zaW9uRW50aXR5LCBhZGRWYXJpYWJsZSwgdmFyaWFibGVzLCBvblVucmVjb2duaXplZEFyZ3VtZW50TG9va3VwIH0pfSlgO1xuICB9XG5cbiAgZnVuY3Rpb24gYWRkVmFyaWFibGUodmFsdWUsIHNvdXJjZSkge1xuICAgIGNvbnN0IHZhcmlhYmxlTmFtZSA9IGAke2NvbnRleHROYW1lfVZhcmlhYmxlJHtjb250ZXh0VmFyaWFibGVzLmxlbmd0aH1gO1xuICAgIGNvbnRleHRWYXJpYWJsZXMucHVzaCh2YWx1ZSk7XG4gICAgcmVjb3JkaW5nLnB1c2goYCR7aW5kZW50fWNvbnN0ICR7dmFyaWFibGVOYW1lfSA9ICR7c291cmNlfTtgKTtcbiAgICByZXR1cm4gdmFyaWFibGVOYW1lO1xuICB9XG59XG5cbmZ1bmN0aW9uIGFyZ3VtZW50c1RvU3RyaW5nKGFyZ3MsIG9wdGlvbnMpIHtcbiAgY29uc3QgeyB2YXJpYWJsZXMsIG9uVW5yZWNvZ25pemVkQXJndW1lbnRMb29rdXAgfSA9IG9wdGlvbnM7XG4gIHJldHVybiAoQXJyYXkuZnJvbShhcmdzKS5tYXAoKGFyZykgPT4ge1xuICAgIGNvbnN0IHZhcmlhYmxlTmFtZSA9IGdldFZhcmlhYmxlTmFtZShhcmcpO1xuICAgIGlmICh2YXJpYWJsZU5hbWUpIHtcbiAgICAgIHJldHVybiB2YXJpYWJsZU5hbWU7XG4gICAgfVxuICAgIHJldHVybiBhcmd1bWVudFRvU3RyaW5nKGFyZywgb3B0aW9ucyk7XG4gIH0pLmpvaW4oJywgJykpO1xuXG4gIGZ1bmN0aW9uIGdldFZhcmlhYmxlTmFtZSh2YWx1ZSkge1xuICAgIGlmICh2YXJpYWJsZXMpIHtcbiAgICAgIGZvciAoY29uc3QgbmFtZSBpbiB2YXJpYWJsZXMpIHtcbiAgICAgICAgaWYgKCF2YXJpYWJsZXMuaGFzT3duUHJvcGVydHkobmFtZSkpIGNvbnRpbnVlO1xuICAgICAgICBpZiAodmFyaWFibGVzW25hbWVdID09PSB2YWx1ZSkge1xuICAgICAgICAgIHJldHVybiBuYW1lO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChvblVucmVjb2duaXplZEFyZ3VtZW50TG9va3VwKSB7XG4gICAgICByZXR1cm4gb25VbnJlY29nbml6ZWRBcmd1bWVudExvb2t1cCh2YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbmZ1bmN0aW9uIGFyZ3VtZW50VG9TdHJpbmcoYXJnLCBvcHRpb25zKSB7XG4gIGNvbnN0IHsgY29udGV4dE5hbWUsIGNvbnRleHRWYXJpYWJsZXMsIGdldEVudGl0eSwgYWRkVmFyaWFibGUsIG9uVW5yZWNvZ25pemVkQXJndW1lbnRMb29rdXAgfSA9IG9wdGlvbnM7XG4gIGlmICh0eXBlb2YgYXJnID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiAndW5kZWZpbmVkJztcbiAgfVxuICBpZiAoYXJnID09PSBudWxsKSB7XG4gICAgcmV0dXJuICdudWxsJztcbiAgfVxuICBjb25zdCBpID0gY29udGV4dFZhcmlhYmxlcy5pbmRleE9mKGFyZyk7XG4gIGlmIChpID4gLTEpIHtcbiAgICByZXR1cm4gYCR7Y29udGV4dE5hbWV9VmFyaWFibGUke2l9YDtcbiAgfVxuICBzd2l0Y2ggKGFyZy5jb25zdHJ1Y3Rvci5uYW1lKSB7XG4gICAgY2FzZSAnU3RyaW5nJzpcbiAgICAgIGNvbnN0IGhhc0xpbmVzID0gL1xcbi8udGVzdChhcmcpO1xuICAgICAgY29uc3QgaGFzU2luZ2xlUXVvdGVzID0gLycvLnRlc3QoYXJnKTtcbiAgICAgIGNvbnN0IGhhc0RvdWJsZVF1b3RlcyA9IC9cIi8udGVzdChhcmcpO1xuICAgICAgaWYgKGhhc0xpbmVzKSB7XG4gICAgICAgIHJldHVybiAnYCcgKyBhcmcgKyAnYCc7XG4gICAgICB9IGVsc2UgaWYgKGhhc1NpbmdsZVF1b3RlcyAmJiAhaGFzRG91YmxlUXVvdGVzKSB7XG4gICAgICAgIHJldHVybiAnXCInICsgYXJnICsgJ1wiJztcbiAgICAgIH0gZWxzZSBpZiAoIWhhc1NpbmdsZVF1b3RlcyAmJiBoYXNEb3VibGVRdW90ZXMpIHtcbiAgICAgICAgcmV0dXJuIFwiJ1wiICsgYXJnICsgXCInXCI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gJ1xcJycgKyBhcmcgKyAnXFwnJztcbiAgICAgIH1cbiAgICBjYXNlICdOdW1iZXInOiByZXR1cm4gZ2V0RW50aXR5KGFyZyk7XG4gICAgY2FzZSAnQm9vbGVhbic6IHJldHVybiBnZXRFbnRpdHkoYXJnKTtcbiAgICBjYXNlICdBcnJheSc6XG4gICAgICByZXR1cm4gYWRkVmFyaWFibGUoYXJnLCBgbmV3ICR7YXJnLmNvbnN0cnVjdG9yLm5hbWV9KFske0FycmF5LmZyb20oYXJnKS5qb2luKCcsJyl9XSlgKTtcbiAgICBjYXNlICdGbG9hdDMyQXJyYXknOlxuICAgIGNhc2UgJ1VpbnQ4QXJyYXknOlxuICAgIGNhc2UgJ1VpbnQxNkFycmF5JzpcbiAgICBjYXNlICdJbnQzMkFycmF5JzpcbiAgICAgIHJldHVybiBhZGRWYXJpYWJsZShhcmcsIGBuZXcgJHthcmcuY29uc3RydWN0b3IubmFtZX0oJHtKU09OLnN0cmluZ2lmeShBcnJheS5mcm9tKGFyZykpfSlgKTtcbiAgICBkZWZhdWx0OlxuICAgICAgaWYgKG9uVW5yZWNvZ25pemVkQXJndW1lbnRMb29rdXApIHtcbiAgICAgICAgY29uc3QgaW5zdGFudGlhdGlvblN0cmluZyA9IG9uVW5yZWNvZ25pemVkQXJndW1lbnRMb29rdXAoYXJnKTtcbiAgICAgICAgaWYgKGluc3RhbnRpYXRpb25TdHJpbmcpIHtcbiAgICAgICAgICByZXR1cm4gaW5zdGFudGlhdGlvblN0cmluZztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IEVycm9yKGB1bnJlY29nbml6ZWQgYXJndW1lbnQgdHlwZSAke2FyZy5jb25zdHJ1Y3Rvci5uYW1lfWApO1xuICB9XG59XG5cbmZ1bmN0aW9uIHRyYWNrYWJsZVByaW1pdGl2ZSh2YWx1ZSkge1xuICByZXR1cm4gbmV3IHZhbHVlLmNvbnN0cnVjdG9yKHZhbHVlKTtcbn1cblxuaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnKSB7XG4gIG1vZHVsZS5leHBvcnRzID0geyBnbFdpcmV0YXAsIGdsRXh0ZW5zaW9uV2lyZXRhcCB9O1xufVxuXG5pZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgZ2xXaXJldGFwLmdsRXh0ZW5zaW9uV2lyZXRhcCA9IGdsRXh0ZW5zaW9uV2lyZXRhcDtcbiAgd2luZG93LmdsV2lyZXRhcCA9IGdsV2lyZXRhcDtcbn1cblxufSx7fV0sNDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5mdW5jdGlvbiBzZXR1cEFyZ3VtZW50cyhhcmdzKSB7XG4gIGNvbnN0IG5ld0FyZ3VtZW50cyA9IG5ldyBBcnJheShhcmdzLmxlbmd0aCk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGFyZyA9IGFyZ3NbaV07XG4gICAgaWYgKGFyZy50b0FycmF5KSB7XG4gICAgICBuZXdBcmd1bWVudHNbaV0gPSBhcmcudG9BcnJheSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBuZXdBcmd1bWVudHNbaV0gPSBhcmc7XG4gICAgfVxuICB9XG4gIHJldHVybiBuZXdBcmd1bWVudHM7XG59XG5cbmZ1bmN0aW9uIG1vY2sxRCgpIHtcbiAgY29uc3QgYXJncyA9IHNldHVwQXJndW1lbnRzKGFyZ3VtZW50cyk7XG4gIGNvbnN0IHJvdyA9IG5ldyBGbG9hdDMyQXJyYXkodGhpcy5vdXRwdXQueCk7XG4gIGZvciAobGV0IHggPSAwOyB4IDwgdGhpcy5vdXRwdXQueDsgeCsrKSB7XG4gICAgdGhpcy50aHJlYWQueCA9IHg7XG4gICAgdGhpcy50aHJlYWQueSA9IDA7XG4gICAgdGhpcy50aHJlYWQueiA9IDA7XG4gICAgcm93W3hdID0gdGhpcy5fZm4uYXBwbHkodGhpcywgYXJncyk7XG4gIH1cbiAgcmV0dXJuIHJvdztcbn1cblxuZnVuY3Rpb24gbW9jazJEKCkge1xuICBjb25zdCBhcmdzID0gc2V0dXBBcmd1bWVudHMoYXJndW1lbnRzKTtcbiAgY29uc3QgbWF0cml4ID0gbmV3IEFycmF5KHRoaXMub3V0cHV0LnkpO1xuICBmb3IgKGxldCB5ID0gMDsgeSA8IHRoaXMub3V0cHV0Lnk7IHkrKykge1xuICAgIGNvbnN0IHJvdyA9IG5ldyBGbG9hdDMyQXJyYXkodGhpcy5vdXRwdXQueCk7XG4gICAgZm9yIChsZXQgeCA9IDA7IHggPCB0aGlzLm91dHB1dC54OyB4KyspIHtcbiAgICAgIHRoaXMudGhyZWFkLnggPSB4O1xuICAgICAgdGhpcy50aHJlYWQueSA9IHk7XG4gICAgICB0aGlzLnRocmVhZC56ID0gMDtcbiAgICAgIHJvd1t4XSA9IHRoaXMuX2ZuLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH1cbiAgICBtYXRyaXhbeV0gPSByb3c7XG4gIH1cbiAgcmV0dXJuIG1hdHJpeDtcbn1cblxuZnVuY3Rpb24gbW9jazJER3JhcGhpY2FsKCkge1xuICBjb25zdCBhcmdzID0gc2V0dXBBcmd1bWVudHMoYXJndW1lbnRzKTtcbiAgZm9yIChsZXQgeSA9IDA7IHkgPCB0aGlzLm91dHB1dC55OyB5KyspIHtcbiAgICBmb3IgKGxldCB4ID0gMDsgeCA8IHRoaXMub3V0cHV0Lng7IHgrKykge1xuICAgICAgdGhpcy50aHJlYWQueCA9IHg7XG4gICAgICB0aGlzLnRocmVhZC55ID0geTtcbiAgICAgIHRoaXMudGhyZWFkLnogPSAwO1xuICAgICAgdGhpcy5fZm4uYXBwbHkodGhpcywgYXJncyk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIG1vY2szRCgpIHtcbiAgY29uc3QgYXJncyA9IHNldHVwQXJndW1lbnRzKGFyZ3VtZW50cyk7XG4gIGNvbnN0IGN1YmUgPSBuZXcgQXJyYXkodGhpcy5vdXRwdXQueik7XG4gIGZvciAobGV0IHogPSAwOyB6IDwgdGhpcy5vdXRwdXQuejsgeisrKSB7XG4gICAgY29uc3QgbWF0cml4ID0gbmV3IEFycmF5KHRoaXMub3V0cHV0LnkpO1xuICAgIGZvciAobGV0IHkgPSAwOyB5IDwgdGhpcy5vdXRwdXQueTsgeSsrKSB7XG4gICAgICBjb25zdCByb3cgPSBuZXcgRmxvYXQzMkFycmF5KHRoaXMub3V0cHV0LngpO1xuICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCB0aGlzLm91dHB1dC54OyB4KyspIHtcbiAgICAgICAgdGhpcy50aHJlYWQueCA9IHg7XG4gICAgICAgIHRoaXMudGhyZWFkLnkgPSB5O1xuICAgICAgICB0aGlzLnRocmVhZC56ID0gejtcbiAgICAgICAgcm93W3hdID0gdGhpcy5fZm4uYXBwbHkodGhpcywgYXJncyk7XG4gICAgICB9XG4gICAgICBtYXRyaXhbeV0gPSByb3c7XG4gICAgfVxuICAgIGN1YmVbel0gPSBtYXRyaXg7XG4gIH1cbiAgcmV0dXJuIGN1YmU7XG59XG5cbmZ1bmN0aW9uIGFwaURlY29yYXRlKGtlcm5lbCkge1xuICBrZXJuZWwuc2V0T3V0cHV0ID0gKG91dHB1dCkgPT4ge1xuICAgIGtlcm5lbC5vdXRwdXQgPSBzZXR1cE91dHB1dChvdXRwdXQpO1xuICAgIGlmIChrZXJuZWwuZ3JhcGhpY2FsKSB7XG4gICAgICBzZXR1cEdyYXBoaWNhbChrZXJuZWwpO1xuICAgIH1cbiAgfTtcbiAga2VybmVsLnRvSlNPTiA9ICgpID0+IHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vdCB1c2FibGUgd2l0aCBncHVNb2NrJyk7XG4gIH07XG4gIGtlcm5lbC5zZXRDb25zdGFudHMgPSAoZmxhZykgPT4ge1xuICAgIGtlcm5lbC5jb25zdGFudHMgPSBmbGFnO1xuICAgIHJldHVybiBrZXJuZWw7XG4gIH07XG4gIGtlcm5lbC5zZXRHcmFwaGljYWwgPSAoZmxhZykgPT4ge1xuICAgIGtlcm5lbC5ncmFwaGljYWwgPSBmbGFnO1xuICAgIHJldHVybiBrZXJuZWw7XG4gIH07XG4gIGtlcm5lbC5zZXRDYW52YXMgPSAoZmxhZykgPT4ge1xuICAgIGtlcm5lbC5jYW52YXMgPSBmbGFnO1xuICAgIHJldHVybiBrZXJuZWw7XG4gIH07XG4gIGtlcm5lbC5zZXRDb250ZXh0ID0gKGZsYWcpID0+IHtcbiAgICBrZXJuZWwuY29udGV4dCA9IGZsYWc7XG4gICAgcmV0dXJuIGtlcm5lbDtcbiAgfTtcbiAga2VybmVsLmRlc3Ryb3kgPSAoKSA9PiB7fTtcbiAga2VybmVsLnZhbGlkYXRlU2V0dGluZ3MgPSAoKSA9PiB7fTtcbiAgaWYgKGtlcm5lbC5ncmFwaGljYWwgJiYga2VybmVsLm91dHB1dCkge1xuICAgIHNldHVwR3JhcGhpY2FsKGtlcm5lbCk7XG4gIH1cbiAga2VybmVsLmV4ZWMgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmVzb2x2ZShrZXJuZWwuYXBwbHkoa2VybmVsLCBhcmd1bWVudHMpKTtcbiAgICAgIH0gY2F0Y2goZSkge1xuICAgICAgICByZWplY3QoZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG4gIGtlcm5lbC5nZXRQaXhlbHMgPSAoZmxpcCkgPT4ge1xuICAgIGNvbnN0IHt4LCB5fSA9IGtlcm5lbC5vdXRwdXQ7XG4gICAgcmV0dXJuIGZsaXAgPyBmbGlwUGl4ZWxzKGtlcm5lbC5faW1hZ2VEYXRhLmRhdGEsIHgsIHkpIDoga2VybmVsLl9pbWFnZURhdGEuZGF0YS5zbGljZSgwKTtcbiAgfTtcbiAga2VybmVsLmNvbG9yID0gZnVuY3Rpb24ociwgZywgYiwgYSkge1xuICAgIGlmICh0eXBlb2YgYSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGEgPSAxO1xuICAgIH1cblxuICAgIHIgPSBNYXRoLmZsb29yKHIgKiAyNTUpO1xuICAgIGcgPSBNYXRoLmZsb29yKGcgKiAyNTUpO1xuICAgIGIgPSBNYXRoLmZsb29yKGIgKiAyNTUpO1xuICAgIGEgPSBNYXRoLmZsb29yKGEgKiAyNTUpO1xuXG4gICAgY29uc3Qgd2lkdGggPSBrZXJuZWwub3V0cHV0Lng7XG4gICAgY29uc3QgaGVpZ2h0ID0ga2VybmVsLm91dHB1dC55O1xuXG4gICAgY29uc3QgeCA9IGtlcm5lbC50aHJlYWQueDtcbiAgICBjb25zdCB5ID0gaGVpZ2h0IC0ga2VybmVsLnRocmVhZC55IC0gMTtcblxuICAgIGNvbnN0IGluZGV4ID0geCArIHkgKiB3aWR0aDtcblxuICAgIGtlcm5lbC5fY29sb3JEYXRhW2luZGV4ICogNCArIDBdID0gcjtcbiAgICBrZXJuZWwuX2NvbG9yRGF0YVtpbmRleCAqIDQgKyAxXSA9IGc7XG4gICAga2VybmVsLl9jb2xvckRhdGFbaW5kZXggKiA0ICsgMl0gPSBiO1xuICAgIGtlcm5lbC5fY29sb3JEYXRhW2luZGV4ICogNCArIDNdID0gYTtcbiAgfTtcblxuICBjb25zdCBtb2NrTWV0aG9kID0gKCkgPT4ga2VybmVsO1xuICBjb25zdCBtZXRob2RzID0gW1xuICAgICdzZXRXYXJuVmFyVXNhZ2UnLFxuICAgICdzZXRBcmd1bWVudFR5cGVzJyxcbiAgICAnc2V0VGFjdGljJyxcbiAgICAnc2V0T3B0aW1pemVGbG9hdE1lbW9yeScsXG4gICAgJ3NldERlYnVnJyxcbiAgICAnc2V0TG9vcE1heEl0ZXJhdGlvbnMnLFxuICAgICdzZXRDb25zdGFudFR5cGVzJyxcbiAgICAnc2V0RnVuY3Rpb25zJyxcbiAgICAnc2V0TmF0aXZlRnVuY3Rpb25zJyxcbiAgICAnc2V0SW5qZWN0ZWROYXRpdmUnLFxuICAgICdzZXRQaXBlbGluZScsXG4gICAgJ3NldFByZWNpc2lvbicsXG4gICAgJ3NldE91dHB1dFRvVGV4dHVyZScsXG4gICAgJ3NldEltbXV0YWJsZScsXG4gICAgJ3NldFN0cmljdEludGVnZXJzJyxcbiAgICAnc2V0RHluYW1pY091dHB1dCcsXG4gICAgJ3NldEhhcmRjb2RlQ29uc3RhbnRzJyxcbiAgICAnc2V0RHluYW1pY0FyZ3VtZW50cycsXG4gICAgJ3NldFVzZUxlZ2FjeUVuY29kZXInLFxuICAgICdzZXRXYXJuVmFyVXNhZ2UnLFxuICAgICdhZGRTdWJLZXJuZWwnLFxuICBdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IG1ldGhvZHMubGVuZ3RoOyBpKyspIHtcbiAgICBrZXJuZWxbbWV0aG9kc1tpXV0gPSBtb2NrTWV0aG9kO1xuICB9XG4gIHJldHVybiBrZXJuZWw7XG59XG5cbmZ1bmN0aW9uIHNldHVwR3JhcGhpY2FsKGtlcm5lbCkge1xuICBjb25zdCB7eCwgeX0gPSBrZXJuZWwub3V0cHV0O1xuICBpZiAoa2VybmVsLmNvbnRleHQgJiYga2VybmVsLmNvbnRleHQuY3JlYXRlSW1hZ2VEYXRhKSB7XG4gICAgY29uc3QgZGF0YSA9IG5ldyBVaW50OENsYW1wZWRBcnJheSh4ICogeSAqIDQpO1xuICAgIGtlcm5lbC5faW1hZ2VEYXRhID0ga2VybmVsLmNvbnRleHQuY3JlYXRlSW1hZ2VEYXRhKHgsIHkpO1xuICAgIGtlcm5lbC5fY29sb3JEYXRhID0gZGF0YTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBkYXRhID0gbmV3IFVpbnQ4Q2xhbXBlZEFycmF5KHggKiB5ICogNCk7XG4gICAga2VybmVsLl9pbWFnZURhdGEgPSB7IGRhdGEgfTtcbiAgICBrZXJuZWwuX2NvbG9yRGF0YSA9IGRhdGE7XG4gIH1cbn1cblxuZnVuY3Rpb24gc2V0dXBPdXRwdXQob3V0cHV0KSB7XG4gIGxldCByZXN1bHQgPSBudWxsO1xuICBpZiAob3V0cHV0Lmxlbmd0aCkge1xuICAgIGlmIChvdXRwdXQubGVuZ3RoID09PSAzKSB7XG4gICAgICBjb25zdCBbeCx5LHpdID0gb3V0cHV0O1xuICAgICAgcmVzdWx0ID0geyB4LCB5LCB6IH07XG4gICAgfSBlbHNlIGlmIChvdXRwdXQubGVuZ3RoID09PSAyKSB7XG4gICAgICBjb25zdCBbeCx5XSA9IG91dHB1dDtcbiAgICAgIHJlc3VsdCA9IHsgeCwgeSB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBbeF0gPSBvdXRwdXQ7XG4gICAgICByZXN1bHQgPSB7IHggfTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcmVzdWx0ID0gb3V0cHV0O1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIGdwdU1vY2soZm4sIHNldHRpbmdzID0ge30pIHtcbiAgY29uc3Qgb3V0cHV0ID0gc2V0dGluZ3Mub3V0cHV0ID8gc2V0dXBPdXRwdXQoc2V0dGluZ3Mub3V0cHV0KSA6IG51bGw7XG4gIGZ1bmN0aW9uIGtlcm5lbCgpIHtcbiAgICBpZiAoa2VybmVsLm91dHB1dC56KSB7XG4gICAgICByZXR1cm4gbW9jazNELmFwcGx5KGtlcm5lbCwgYXJndW1lbnRzKTtcbiAgICB9IGVsc2UgaWYgKGtlcm5lbC5vdXRwdXQueSkge1xuICAgICAgaWYgKGtlcm5lbC5ncmFwaGljYWwpIHtcbiAgICAgICAgcmV0dXJuIG1vY2syREdyYXBoaWNhbC5hcHBseShrZXJuZWwsIGFyZ3VtZW50cyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbW9jazJELmFwcGx5KGtlcm5lbCwgYXJndW1lbnRzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG1vY2sxRC5hcHBseShrZXJuZWwsIGFyZ3VtZW50cyk7XG4gICAgfVxuICB9XG4gIGtlcm5lbC5fZm4gPSBmbjtcbiAga2VybmVsLmNvbnN0YW50cyA9IHNldHRpbmdzLmNvbnN0YW50cyB8fCBudWxsO1xuICBrZXJuZWwuY29udGV4dCA9IHNldHRpbmdzLmNvbnRleHQgfHwgbnVsbDtcbiAga2VybmVsLmNhbnZhcyA9IHNldHRpbmdzLmNhbnZhcyB8fCBudWxsO1xuICBrZXJuZWwuZ3JhcGhpY2FsID0gc2V0dGluZ3MuZ3JhcGhpY2FsIHx8IGZhbHNlO1xuICBrZXJuZWwuX2ltYWdlRGF0YSA9IG51bGw7XG4gIGtlcm5lbC5fY29sb3JEYXRhID0gbnVsbDtcbiAga2VybmVsLm91dHB1dCA9IG91dHB1dDtcbiAga2VybmVsLnRocmVhZCA9IHtcbiAgICB4OiAwLFxuICAgIHk6IDAsXG4gICAgejogMFxuICB9O1xuICByZXR1cm4gYXBpRGVjb3JhdGUoa2VybmVsKTtcbn1cblxuZnVuY3Rpb24gZmxpcFBpeGVscyhwaXhlbHMsIHdpZHRoLCBoZWlnaHQpIHtcbiAgY29uc3QgaGFsZkhlaWdodCA9IGhlaWdodCAvIDIgfCAwOyBcbiAgY29uc3QgYnl0ZXNQZXJSb3cgPSB3aWR0aCAqIDQ7XG4gIGNvbnN0IHRlbXAgPSBuZXcgVWludDhDbGFtcGVkQXJyYXkod2lkdGggKiA0KTtcbiAgY29uc3QgcmVzdWx0ID0gcGl4ZWxzLnNsaWNlKDApO1xuICBmb3IgKGxldCB5ID0gMDsgeSA8IGhhbGZIZWlnaHQ7ICsreSkge1xuICAgIGNvbnN0IHRvcE9mZnNldCA9IHkgKiBieXRlc1BlclJvdztcbiAgICBjb25zdCBib3R0b21PZmZzZXQgPSAoaGVpZ2h0IC0geSAtIDEpICogYnl0ZXNQZXJSb3c7XG5cbiAgICB0ZW1wLnNldChyZXN1bHQuc3ViYXJyYXkodG9wT2Zmc2V0LCB0b3BPZmZzZXQgKyBieXRlc1BlclJvdykpO1xuXG4gICAgcmVzdWx0LmNvcHlXaXRoaW4odG9wT2Zmc2V0LCBib3R0b21PZmZzZXQsIGJvdHRvbU9mZnNldCArIGJ5dGVzUGVyUm93KTtcblxuICAgIHJlc3VsdC5zZXQodGVtcCwgYm90dG9tT2Zmc2V0KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZ3B1TW9ja1xufTtcblxufSx7fV0sNTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5jb25zdCB7IHV0aWxzIH0gPSByZXF1aXJlKCcuL3V0aWxzJyk7XG5cbmZ1bmN0aW9uIGFsaWFzKG5hbWUsIHNvdXJjZSkge1xuICBjb25zdCBmblN0cmluZyA9IHNvdXJjZS50b1N0cmluZygpO1xuICByZXR1cm4gbmV3IEZ1bmN0aW9uKGByZXR1cm4gZnVuY3Rpb24gJHsgbmFtZSB9ICgkeyB1dGlscy5nZXRBcmd1bWVudE5hbWVzRnJvbVN0cmluZyhmblN0cmluZykuam9pbignLCAnKSB9KSB7XG4gICR7IHV0aWxzLmdldEZ1bmN0aW9uQm9keUZyb21TdHJpbmcoZm5TdHJpbmcpIH1cbn1gKSgpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgYWxpYXNcbn07XG59LHtcIi4vdXRpbHNcIjoxMTR9XSw2OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbmNvbnN0IHsgRnVuY3Rpb25Ob2RlIH0gPSByZXF1aXJlKCcuLi9mdW5jdGlvbi1ub2RlJyk7XG5cbmNsYXNzIENQVUZ1bmN0aW9uTm9kZSBleHRlbmRzIEZ1bmN0aW9uTm9kZSB7XG4gIGFzdEZ1bmN0aW9uKGFzdCwgcmV0QXJyKSB7XG5cbiAgICBpZiAoIXRoaXMuaXNSb290S2VybmVsKSB7XG4gICAgICByZXRBcnIucHVzaCgnZnVuY3Rpb24nKTtcbiAgICAgIHJldEFyci5wdXNoKCcgJyk7XG4gICAgICByZXRBcnIucHVzaCh0aGlzLm5hbWUpO1xuICAgICAgcmV0QXJyLnB1c2goJygnKTtcblxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmFyZ3VtZW50TmFtZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY29uc3QgYXJndW1lbnROYW1lID0gdGhpcy5hcmd1bWVudE5hbWVzW2ldO1xuXG4gICAgICAgIGlmIChpID4gMCkge1xuICAgICAgICAgIHJldEFyci5wdXNoKCcsICcpO1xuICAgICAgICB9XG4gICAgICAgIHJldEFyci5wdXNoKCd1c2VyXycpO1xuICAgICAgICByZXRBcnIucHVzaChhcmd1bWVudE5hbWUpO1xuICAgICAgfVxuXG4gICAgICByZXRBcnIucHVzaCgnKSB7XFxuJyk7XG4gICAgfVxuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhc3QuYm9keS5ib2R5Lmxlbmd0aDsgKytpKSB7XG4gICAgICB0aGlzLmFzdEdlbmVyaWMoYXN0LmJvZHkuYm9keVtpXSwgcmV0QXJyKTtcbiAgICAgIHJldEFyci5wdXNoKCdcXG4nKTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuaXNSb290S2VybmVsKSB7XG4gICAgICByZXRBcnIucHVzaCgnfVxcbicpO1xuICAgIH1cbiAgICByZXR1cm4gcmV0QXJyO1xuICB9XG5cbiAgYXN0UmV0dXJuU3RhdGVtZW50KGFzdCwgcmV0QXJyKSB7XG4gICAgY29uc3QgdHlwZSA9IHRoaXMucmV0dXJuVHlwZSB8fCB0aGlzLmdldFR5cGUoYXN0LmFyZ3VtZW50KTtcblxuICAgIGlmICghdGhpcy5yZXR1cm5UeXBlKSB7XG4gICAgICB0aGlzLnJldHVyblR5cGUgPSB0eXBlO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmlzUm9vdEtlcm5lbCkge1xuICAgICAgcmV0QXJyLnB1c2godGhpcy5sZWFkaW5nUmV0dXJuU3RhdGVtZW50KTtcbiAgICAgIHRoaXMuYXN0R2VuZXJpYyhhc3QuYXJndW1lbnQsIHJldEFycik7XG4gICAgICByZXRBcnIucHVzaCgnO1xcbicpO1xuICAgICAgcmV0QXJyLnB1c2godGhpcy5mb2xsb3dpbmdSZXR1cm5TdGF0ZW1lbnQpO1xuICAgICAgcmV0QXJyLnB1c2goJ2NvbnRpbnVlO1xcbicpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5pc1N1Yktlcm5lbCkge1xuICAgICAgcmV0QXJyLnB1c2goYHN1Yktlcm5lbFJlc3VsdF8keyB0aGlzLm5hbWUgfSA9IGApO1xuICAgICAgdGhpcy5hc3RHZW5lcmljKGFzdC5hcmd1bWVudCwgcmV0QXJyKTtcbiAgICAgIHJldEFyci5wdXNoKCc7Jyk7XG4gICAgICByZXRBcnIucHVzaChgcmV0dXJuIHN1Yktlcm5lbFJlc3VsdF8keyB0aGlzLm5hbWUgfTtgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0QXJyLnB1c2goJ3JldHVybiAnKTtcbiAgICAgIHRoaXMuYXN0R2VuZXJpYyhhc3QuYXJndW1lbnQsIHJldEFycik7XG4gICAgICByZXRBcnIucHVzaCgnOycpO1xuICAgIH1cbiAgICByZXR1cm4gcmV0QXJyO1xuICB9XG5cbiAgYXN0TGl0ZXJhbChhc3QsIHJldEFycikge1xuXG4gICAgaWYgKGlzTmFOKGFzdC52YWx1ZSkpIHtcbiAgICAgIHRocm93IHRoaXMuYXN0RXJyb3JPdXRwdXQoXG4gICAgICAgICdOb24tbnVtZXJpYyBsaXRlcmFsIG5vdCBzdXBwb3J0ZWQgOiAnICsgYXN0LnZhbHVlLFxuICAgICAgICBhc3RcbiAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0QXJyLnB1c2goYXN0LnZhbHVlKTtcblxuICAgIHJldHVybiByZXRBcnI7XG4gIH1cblxuICBhc3RCaW5hcnlFeHByZXNzaW9uKGFzdCwgcmV0QXJyKSB7XG4gICAgcmV0QXJyLnB1c2goJygnKTtcbiAgICB0aGlzLmFzdEdlbmVyaWMoYXN0LmxlZnQsIHJldEFycik7XG4gICAgcmV0QXJyLnB1c2goYXN0Lm9wZXJhdG9yKTtcbiAgICB0aGlzLmFzdEdlbmVyaWMoYXN0LnJpZ2h0LCByZXRBcnIpO1xuICAgIHJldEFyci5wdXNoKCcpJyk7XG4gICAgcmV0dXJuIHJldEFycjtcbiAgfVxuXG4gIGFzdElkZW50aWZpZXJFeHByZXNzaW9uKGlkdE5vZGUsIHJldEFycikge1xuICAgIGlmIChpZHROb2RlLnR5cGUgIT09ICdJZGVudGlmaWVyJykge1xuICAgICAgdGhyb3cgdGhpcy5hc3RFcnJvck91dHB1dChcbiAgICAgICAgJ0lkZW50aWZpZXJFeHByZXNzaW9uIC0gbm90IGFuIElkZW50aWZpZXInLFxuICAgICAgICBpZHROb2RlXG4gICAgICApO1xuICAgIH1cblxuICAgIHN3aXRjaCAoaWR0Tm9kZS5uYW1lKSB7XG4gICAgICBjYXNlICdJbmZpbml0eSc6XG4gICAgICAgIHJldEFyci5wdXNoKCdJbmZpbml0eScpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmICh0aGlzLmNvbnN0YW50cyAmJiB0aGlzLmNvbnN0YW50cy5oYXNPd25Qcm9wZXJ0eShpZHROb2RlLm5hbWUpKSB7XG4gICAgICAgICAgcmV0QXJyLnB1c2goJ2NvbnN0YW50c18nICsgaWR0Tm9kZS5uYW1lKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXRBcnIucHVzaCgndXNlcl8nICsgaWR0Tm9kZS5uYW1lKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXRBcnI7XG4gIH1cblxuICBhc3RGb3JTdGF0ZW1lbnQoZm9yTm9kZSwgcmV0QXJyKSB7XG4gICAgaWYgKGZvck5vZGUudHlwZSAhPT0gJ0ZvclN0YXRlbWVudCcpIHtcbiAgICAgIHRocm93IHRoaXMuYXN0RXJyb3JPdXRwdXQoJ0ludmFsaWQgZm9yIHN0YXRlbWVudCcsIGZvck5vZGUpO1xuICAgIH1cblxuICAgIGNvbnN0IGluaXRBcnIgPSBbXTtcbiAgICBjb25zdCB0ZXN0QXJyID0gW107XG4gICAgY29uc3QgdXBkYXRlQXJyID0gW107XG4gICAgY29uc3QgYm9keUFyciA9IFtdO1xuICAgIGxldCBpc1NhZmUgPSBudWxsO1xuXG4gICAgaWYgKGZvck5vZGUuaW5pdCkge1xuICAgICAgdGhpcy5wdXNoU3RhdGUoJ2luLWZvci1sb29wLWluaXQnKTtcbiAgICAgIHRoaXMuYXN0R2VuZXJpYyhmb3JOb2RlLmluaXQsIGluaXRBcnIpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbml0QXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChpbml0QXJyW2ldLmluY2x1ZGVzICYmIGluaXRBcnJbaV0uaW5jbHVkZXMoJywnKSkge1xuICAgICAgICAgIGlzU2FmZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLnBvcFN0YXRlKCdpbi1mb3ItbG9vcC1pbml0Jyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlzU2FmZSA9IGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChmb3JOb2RlLnRlc3QpIHtcbiAgICAgIHRoaXMuYXN0R2VuZXJpYyhmb3JOb2RlLnRlc3QsIHRlc3RBcnIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpc1NhZmUgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoZm9yTm9kZS51cGRhdGUpIHtcbiAgICAgIHRoaXMuYXN0R2VuZXJpYyhmb3JOb2RlLnVwZGF0ZSwgdXBkYXRlQXJyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaXNTYWZlID0gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKGZvck5vZGUuYm9keSkge1xuICAgICAgdGhpcy5wdXNoU3RhdGUoJ2xvb3AtYm9keScpO1xuICAgICAgdGhpcy5hc3RHZW5lcmljKGZvck5vZGUuYm9keSwgYm9keUFycik7XG4gICAgICB0aGlzLnBvcFN0YXRlKCdsb29wLWJvZHknKTtcbiAgICB9XG5cbiAgICBpZiAoaXNTYWZlID09PSBudWxsKSB7XG4gICAgICBpc1NhZmUgPSB0aGlzLmlzU2FmZShmb3JOb2RlLmluaXQpICYmIHRoaXMuaXNTYWZlKGZvck5vZGUudGVzdCk7XG4gICAgfVxuXG4gICAgaWYgKGlzU2FmZSkge1xuICAgICAgcmV0QXJyLnB1c2goYGZvciAoJHtpbml0QXJyLmpvaW4oJycpfTske3Rlc3RBcnIuam9pbignJyl9OyR7dXBkYXRlQXJyLmpvaW4oJycpfSl7XFxuYCk7XG4gICAgICByZXRBcnIucHVzaChib2R5QXJyLmpvaW4oJycpKTtcbiAgICAgIHJldEFyci5wdXNoKCd9XFxuJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGlWYXJpYWJsZU5hbWUgPSB0aGlzLmdldEludGVybmFsVmFyaWFibGVOYW1lKCdzYWZlSScpO1xuICAgICAgaWYgKGluaXRBcnIubGVuZ3RoID4gMCkge1xuICAgICAgICByZXRBcnIucHVzaChpbml0QXJyLmpvaW4oJycpLCAnO1xcbicpO1xuICAgICAgfVxuICAgICAgcmV0QXJyLnB1c2goYGZvciAobGV0ICR7aVZhcmlhYmxlTmFtZX09MDske2lWYXJpYWJsZU5hbWV9PExPT1BfTUFYOyR7aVZhcmlhYmxlTmFtZX0rKyl7XFxuYCk7XG4gICAgICBpZiAodGVzdEFyci5sZW5ndGggPiAwKSB7XG4gICAgICAgIHJldEFyci5wdXNoKGBpZiAoISR7dGVzdEFyci5qb2luKCcnKX0pIGJyZWFrO1xcbmApO1xuICAgICAgfVxuICAgICAgcmV0QXJyLnB1c2goYm9keUFyci5qb2luKCcnKSk7XG4gICAgICByZXRBcnIucHVzaChgXFxuJHt1cGRhdGVBcnIuam9pbignJyl9O2ApO1xuICAgICAgcmV0QXJyLnB1c2goJ31cXG4nKTtcbiAgICB9XG4gICAgcmV0dXJuIHJldEFycjtcbiAgfVxuXG4gIGFzdFdoaWxlU3RhdGVtZW50KHdoaWxlTm9kZSwgcmV0QXJyKSB7XG4gICAgaWYgKHdoaWxlTm9kZS50eXBlICE9PSAnV2hpbGVTdGF0ZW1lbnQnKSB7XG4gICAgICB0aHJvdyB0aGlzLmFzdEVycm9yT3V0cHV0KFxuICAgICAgICAnSW52YWxpZCB3aGlsZSBzdGF0ZW1lbnQnLFxuICAgICAgICB3aGlsZU5vZGVcbiAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0QXJyLnB1c2goJ2ZvciAobGV0IGkgPSAwOyBpIDwgTE9PUF9NQVg7IGkrKykgeycpO1xuICAgIHJldEFyci5wdXNoKCdpZiAoJyk7XG4gICAgdGhpcy5hc3RHZW5lcmljKHdoaWxlTm9kZS50ZXN0LCByZXRBcnIpO1xuICAgIHJldEFyci5wdXNoKCcpIHtcXG4nKTtcbiAgICB0aGlzLmFzdEdlbmVyaWMod2hpbGVOb2RlLmJvZHksIHJldEFycik7XG4gICAgcmV0QXJyLnB1c2goJ30gZWxzZSB7XFxuJyk7XG4gICAgcmV0QXJyLnB1c2goJ2JyZWFrO1xcbicpO1xuICAgIHJldEFyci5wdXNoKCd9XFxuJyk7XG4gICAgcmV0QXJyLnB1c2goJ31cXG4nKTtcblxuICAgIHJldHVybiByZXRBcnI7XG4gIH1cblxuICBhc3REb1doaWxlU3RhdGVtZW50KGRvV2hpbGVOb2RlLCByZXRBcnIpIHtcbiAgICBpZiAoZG9XaGlsZU5vZGUudHlwZSAhPT0gJ0RvV2hpbGVTdGF0ZW1lbnQnKSB7XG4gICAgICB0aHJvdyB0aGlzLmFzdEVycm9yT3V0cHV0KFxuICAgICAgICAnSW52YWxpZCB3aGlsZSBzdGF0ZW1lbnQnLFxuICAgICAgICBkb1doaWxlTm9kZVxuICAgICAgKTtcbiAgICB9XG5cbiAgICByZXRBcnIucHVzaCgnZm9yIChsZXQgaSA9IDA7IGkgPCBMT09QX01BWDsgaSsrKSB7Jyk7XG4gICAgdGhpcy5hc3RHZW5lcmljKGRvV2hpbGVOb2RlLmJvZHksIHJldEFycik7XG4gICAgcmV0QXJyLnB1c2goJ2lmICghJyk7XG4gICAgdGhpcy5hc3RHZW5lcmljKGRvV2hpbGVOb2RlLnRlc3QsIHJldEFycik7XG4gICAgcmV0QXJyLnB1c2goJykge1xcbicpO1xuICAgIHJldEFyci5wdXNoKCdicmVhaztcXG4nKTtcbiAgICByZXRBcnIucHVzaCgnfVxcbicpO1xuICAgIHJldEFyci5wdXNoKCd9XFxuJyk7XG5cbiAgICByZXR1cm4gcmV0QXJyO1xuXG4gIH1cblxuICBhc3RBc3NpZ25tZW50RXhwcmVzc2lvbihhc3NOb2RlLCByZXRBcnIpIHtcbiAgICBjb25zdCBkZWNsYXJhdGlvbiA9IHRoaXMuZ2V0RGVjbGFyYXRpb24oYXNzTm9kZS5sZWZ0KTtcbiAgICBpZiAoZGVjbGFyYXRpb24gJiYgIWRlY2xhcmF0aW9uLmFzc2lnbmFibGUpIHtcbiAgICAgIHRocm93IHRoaXMuYXN0RXJyb3JPdXRwdXQoYFZhcmlhYmxlICR7YXNzTm9kZS5sZWZ0Lm5hbWV9IGlzIG5vdCBhc3NpZ25hYmxlIGhlcmVgLCBhc3NOb2RlKTtcbiAgICB9XG4gICAgdGhpcy5hc3RHZW5lcmljKGFzc05vZGUubGVmdCwgcmV0QXJyKTtcbiAgICByZXRBcnIucHVzaChhc3NOb2RlLm9wZXJhdG9yKTtcbiAgICB0aGlzLmFzdEdlbmVyaWMoYXNzTm9kZS5yaWdodCwgcmV0QXJyKTtcbiAgICByZXR1cm4gcmV0QXJyO1xuICB9XG5cbiAgYXN0QmxvY2tTdGF0ZW1lbnQoYk5vZGUsIHJldEFycikge1xuICAgIGlmICh0aGlzLmlzU3RhdGUoJ2xvb3AtYm9keScpKSB7XG4gICAgICB0aGlzLnB1c2hTdGF0ZSgnYmxvY2stYm9keScpOyBcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYk5vZGUuYm9keS5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLmFzdEdlbmVyaWMoYk5vZGUuYm9keVtpXSwgcmV0QXJyKTtcbiAgICAgIH1cbiAgICAgIHRoaXMucG9wU3RhdGUoJ2Jsb2NrLWJvZHknKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0QXJyLnB1c2goJ3tcXG4nKTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYk5vZGUuYm9keS5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLmFzdEdlbmVyaWMoYk5vZGUuYm9keVtpXSwgcmV0QXJyKTtcbiAgICAgIH1cbiAgICAgIHJldEFyci5wdXNoKCd9XFxuJyk7XG4gICAgfVxuICAgIHJldHVybiByZXRBcnI7XG4gIH1cblxuICBhc3RWYXJpYWJsZURlY2xhcmF0aW9uKHZhckRlY05vZGUsIHJldEFycikge1xuICAgIHJldEFyci5wdXNoKGAke3ZhckRlY05vZGUua2luZH0gYCk7XG4gICAgY29uc3QgeyBkZWNsYXJhdGlvbnMgfSA9IHZhckRlY05vZGU7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkZWNsYXJhdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChpID4gMCkge1xuICAgICAgICByZXRBcnIucHVzaCgnLCcpO1xuICAgICAgfVxuICAgICAgY29uc3QgZGVjbGFyYXRpb24gPSBkZWNsYXJhdGlvbnNbaV07XG4gICAgICBjb25zdCBpbmZvID0gdGhpcy5nZXREZWNsYXJhdGlvbihkZWNsYXJhdGlvbi5pZCk7XG4gICAgICBpZiAoIWluZm8udmFsdWVUeXBlKSB7XG4gICAgICAgIGluZm8udmFsdWVUeXBlID0gdGhpcy5nZXRUeXBlKGRlY2xhcmF0aW9uLmluaXQpO1xuICAgICAgfVxuICAgICAgdGhpcy5hc3RHZW5lcmljKGRlY2xhcmF0aW9uLCByZXRBcnIpO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuaXNTdGF0ZSgnaW4tZm9yLWxvb3AtaW5pdCcpKSB7XG4gICAgICByZXRBcnIucHVzaCgnOycpO1xuICAgIH1cbiAgICByZXR1cm4gcmV0QXJyO1xuICB9XG5cbiAgYXN0SWZTdGF0ZW1lbnQoaWZOb2RlLCByZXRBcnIpIHtcbiAgICByZXRBcnIucHVzaCgnaWYgKCcpO1xuICAgIHRoaXMuYXN0R2VuZXJpYyhpZk5vZGUudGVzdCwgcmV0QXJyKTtcbiAgICByZXRBcnIucHVzaCgnKScpO1xuICAgIGlmIChpZk5vZGUuY29uc2VxdWVudC50eXBlID09PSAnQmxvY2tTdGF0ZW1lbnQnKSB7XG4gICAgICB0aGlzLmFzdEdlbmVyaWMoaWZOb2RlLmNvbnNlcXVlbnQsIHJldEFycik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldEFyci5wdXNoKCcge1xcbicpO1xuICAgICAgdGhpcy5hc3RHZW5lcmljKGlmTm9kZS5jb25zZXF1ZW50LCByZXRBcnIpO1xuICAgICAgcmV0QXJyLnB1c2goJ1xcbn1cXG4nKTtcbiAgICB9XG5cbiAgICBpZiAoaWZOb2RlLmFsdGVybmF0ZSkge1xuICAgICAgcmV0QXJyLnB1c2goJ2Vsc2UgJyk7XG4gICAgICBpZiAoaWZOb2RlLmFsdGVybmF0ZS50eXBlID09PSAnQmxvY2tTdGF0ZW1lbnQnIHx8IGlmTm9kZS5hbHRlcm5hdGUudHlwZSA9PT0gJ0lmU3RhdGVtZW50Jykge1xuICAgICAgICB0aGlzLmFzdEdlbmVyaWMoaWZOb2RlLmFsdGVybmF0ZSwgcmV0QXJyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldEFyci5wdXNoKCcge1xcbicpO1xuICAgICAgICB0aGlzLmFzdEdlbmVyaWMoaWZOb2RlLmFsdGVybmF0ZSwgcmV0QXJyKTtcbiAgICAgICAgcmV0QXJyLnB1c2goJ1xcbn1cXG4nKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJldEFycjtcblxuICB9XG5cbiAgYXN0U3dpdGNoU3RhdGVtZW50KGFzdCwgcmV0QXJyKSB7XG4gICAgY29uc3QgeyBkaXNjcmltaW5hbnQsIGNhc2VzIH0gPSBhc3Q7XG4gICAgcmV0QXJyLnB1c2goJ3N3aXRjaCAoJyk7XG4gICAgdGhpcy5hc3RHZW5lcmljKGRpc2NyaW1pbmFudCwgcmV0QXJyKTtcbiAgICByZXRBcnIucHVzaCgnKSB7XFxuJyk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjYXNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGNhc2VzW2ldLnRlc3QgPT09IG51bGwpIHtcbiAgICAgICAgcmV0QXJyLnB1c2goJ2RlZmF1bHQ6XFxuJyk7XG4gICAgICAgIHRoaXMuYXN0R2VuZXJpYyhjYXNlc1tpXS5jb25zZXF1ZW50LCByZXRBcnIpO1xuICAgICAgICBpZiAoY2FzZXNbaV0uY29uc2VxdWVudCAmJiBjYXNlc1tpXS5jb25zZXF1ZW50Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICByZXRBcnIucHVzaCgnYnJlYWs7XFxuJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICByZXRBcnIucHVzaCgnY2FzZSAnKTtcbiAgICAgIHRoaXMuYXN0R2VuZXJpYyhjYXNlc1tpXS50ZXN0LCByZXRBcnIpO1xuICAgICAgcmV0QXJyLnB1c2goJzpcXG4nKTtcbiAgICAgIGlmIChjYXNlc1tpXS5jb25zZXF1ZW50ICYmIGNhc2VzW2ldLmNvbnNlcXVlbnQubGVuZ3RoID4gMCkge1xuICAgICAgICB0aGlzLmFzdEdlbmVyaWMoY2FzZXNbaV0uY29uc2VxdWVudCwgcmV0QXJyKTtcbiAgICAgICAgcmV0QXJyLnB1c2goJ2JyZWFrO1xcbicpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXRBcnIucHVzaCgnXFxufScpO1xuICB9XG5cbiAgYXN0VGhpc0V4cHJlc3Npb24odE5vZGUsIHJldEFycikge1xuICAgIHJldEFyci5wdXNoKCdfdGhpcycpO1xuICAgIHJldHVybiByZXRBcnI7XG4gIH1cblxuICBhc3RNZW1iZXJFeHByZXNzaW9uKG1Ob2RlLCByZXRBcnIpIHtcbiAgICBjb25zdCB7XG4gICAgICBzaWduYXR1cmUsXG4gICAgICB0eXBlLFxuICAgICAgcHJvcGVydHksXG4gICAgICB4UHJvcGVydHksXG4gICAgICB5UHJvcGVydHksXG4gICAgICB6UHJvcGVydHksXG4gICAgICBuYW1lLFxuICAgICAgb3JpZ2luXG4gICAgfSA9IHRoaXMuZ2V0TWVtYmVyRXhwcmVzc2lvbkRldGFpbHMobU5vZGUpO1xuICAgIHN3aXRjaCAoc2lnbmF0dXJlKSB7XG4gICAgICBjYXNlICd0aGlzLnRocmVhZC52YWx1ZSc6XG4gICAgICAgIHJldEFyci5wdXNoKGBfdGhpcy50aHJlYWQuJHsgbmFtZSB9YCk7XG4gICAgICAgIHJldHVybiByZXRBcnI7XG4gICAgICBjYXNlICd0aGlzLm91dHB1dC52YWx1ZSc6XG4gICAgICAgIHN3aXRjaCAobmFtZSkge1xuICAgICAgICAgIGNhc2UgJ3gnOlxuICAgICAgICAgICAgcmV0QXJyLnB1c2goJ291dHB1dFgnKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ3knOlxuICAgICAgICAgICAgcmV0QXJyLnB1c2goJ291dHB1dFknKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ3onOlxuICAgICAgICAgICAgcmV0QXJyLnB1c2goJ291dHB1dFonKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyB0aGlzLmFzdEVycm9yT3V0cHV0KCdVbmV4cGVjdGVkIGV4cHJlc3Npb24nLCBtTm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJldEFycjtcbiAgICAgIGNhc2UgJ3ZhbHVlJzpcbiAgICAgICAgdGhyb3cgdGhpcy5hc3RFcnJvck91dHB1dCgnVW5leHBlY3RlZCBleHByZXNzaW9uJywgbU5vZGUpO1xuICAgICAgY2FzZSAndmFsdWVbXSc6XG4gICAgICBjYXNlICd2YWx1ZVtdW10nOlxuICAgICAgY2FzZSAndmFsdWVbXVtdW10nOlxuICAgICAgY2FzZSAndmFsdWUudmFsdWUnOlxuICAgICAgICBpZiAob3JpZ2luID09PSAnTWF0aCcpIHtcbiAgICAgICAgICByZXRBcnIucHVzaChNYXRoW25hbWVdKTtcbiAgICAgICAgICByZXR1cm4gcmV0QXJyO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAocHJvcGVydHkpIHtcbiAgICAgICAgICBjYXNlICdyJzpcbiAgICAgICAgICAgIHJldEFyci5wdXNoKGB1c2VyXyR7IG5hbWUgfVswXWApO1xuICAgICAgICAgICAgcmV0dXJuIHJldEFycjtcbiAgICAgICAgICBjYXNlICdnJzpcbiAgICAgICAgICAgIHJldEFyci5wdXNoKGB1c2VyXyR7IG5hbWUgfVsxXWApO1xuICAgICAgICAgICAgcmV0dXJuIHJldEFycjtcbiAgICAgICAgICBjYXNlICdiJzpcbiAgICAgICAgICAgIHJldEFyci5wdXNoKGB1c2VyXyR7IG5hbWUgfVsyXWApO1xuICAgICAgICAgICAgcmV0dXJuIHJldEFycjtcbiAgICAgICAgICBjYXNlICdhJzpcbiAgICAgICAgICAgIHJldEFyci5wdXNoKGB1c2VyXyR7IG5hbWUgfVszXWApO1xuICAgICAgICAgICAgcmV0dXJuIHJldEFycjtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3RoaXMuY29uc3RhbnRzLnZhbHVlJzpcbiAgICAgIGNhc2UgJ3RoaXMuY29uc3RhbnRzLnZhbHVlW10nOlxuICAgICAgY2FzZSAndGhpcy5jb25zdGFudHMudmFsdWVbXVtdJzpcbiAgICAgIGNhc2UgJ3RoaXMuY29uc3RhbnRzLnZhbHVlW11bXVtdJzpcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdmbigpW10nOlxuICAgICAgICB0aGlzLmFzdEdlbmVyaWMobU5vZGUub2JqZWN0LCByZXRBcnIpO1xuICAgICAgICByZXRBcnIucHVzaCgnWycpO1xuICAgICAgICB0aGlzLmFzdEdlbmVyaWMobU5vZGUucHJvcGVydHksIHJldEFycik7XG4gICAgICAgIHJldEFyci5wdXNoKCddJyk7XG4gICAgICAgIHJldHVybiByZXRBcnI7XG4gICAgICBjYXNlICdmbigpW11bXSc6XG4gICAgICAgIHRoaXMuYXN0R2VuZXJpYyhtTm9kZS5vYmplY3Qub2JqZWN0LCByZXRBcnIpO1xuICAgICAgICByZXRBcnIucHVzaCgnWycpO1xuICAgICAgICB0aGlzLmFzdEdlbmVyaWMobU5vZGUub2JqZWN0LnByb3BlcnR5LCByZXRBcnIpO1xuICAgICAgICByZXRBcnIucHVzaCgnXScpO1xuICAgICAgICByZXRBcnIucHVzaCgnWycpO1xuICAgICAgICB0aGlzLmFzdEdlbmVyaWMobU5vZGUucHJvcGVydHksIHJldEFycik7XG4gICAgICAgIHJldEFyci5wdXNoKCddJyk7XG4gICAgICAgIHJldHVybiByZXRBcnI7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyB0aGlzLmFzdEVycm9yT3V0cHV0KCdVbmV4cGVjdGVkIGV4cHJlc3Npb24nLCBtTm9kZSk7XG4gICAgfVxuXG4gICAgaWYgKCFtTm9kZS5jb21wdXRlZCkge1xuICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgJ051bWJlcic6XG4gICAgICAgIGNhc2UgJ0ludGVnZXInOlxuICAgICAgICBjYXNlICdGbG9hdCc6XG4gICAgICAgIGNhc2UgJ0Jvb2xlYW4nOlxuICAgICAgICAgIHJldEFyci5wdXNoKGAke29yaWdpbn1fJHtuYW1lfWApO1xuICAgICAgICAgIHJldHVybiByZXRBcnI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgbWFya3VwTmFtZSA9IGAke29yaWdpbn1fJHtuYW1lfWA7XG5cbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgJ0FycmF5KDIpJzpcbiAgICAgIGNhc2UgJ0FycmF5KDMpJzpcbiAgICAgIGNhc2UgJ0FycmF5KDQpJzpcbiAgICAgIGNhc2UgJ01hdHJpeCgyKSc6XG4gICAgICBjYXNlICdNYXRyaXgoMyknOlxuICAgICAgY2FzZSAnTWF0cml4KDQpJzpcbiAgICAgIGNhc2UgJ0hUTUxJbWFnZUFycmF5JzpcbiAgICAgIGNhc2UgJ0FycmF5VGV4dHVyZSgxKSc6XG4gICAgICBjYXNlICdBcnJheVRleHR1cmUoMiknOlxuICAgICAgY2FzZSAnQXJyYXlUZXh0dXJlKDMpJzpcbiAgICAgIGNhc2UgJ0FycmF5VGV4dHVyZSg0KSc6XG4gICAgICBjYXNlICdIVE1MSW1hZ2UnOlxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgbGV0IHNpemU7XG4gICAgICAgIGxldCBpc0lucHV0O1xuICAgICAgICBpZiAob3JpZ2luID09PSAnY29uc3RhbnRzJykge1xuICAgICAgICAgIGNvbnN0IGNvbnN0YW50ID0gdGhpcy5jb25zdGFudHNbbmFtZV07XG4gICAgICAgICAgaXNJbnB1dCA9IHRoaXMuY29uc3RhbnRUeXBlc1tuYW1lXSA9PT0gJ0lucHV0JztcbiAgICAgICAgICBzaXplID0gaXNJbnB1dCA/IGNvbnN0YW50LnNpemUgOiBudWxsO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlzSW5wdXQgPSB0aGlzLmlzSW5wdXQobmFtZSk7XG4gICAgICAgICAgc2l6ZSA9IGlzSW5wdXQgPyB0aGlzLmFyZ3VtZW50U2l6ZXNbdGhpcy5hcmd1bWVudE5hbWVzLmluZGV4T2YobmFtZSldIDogbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXRBcnIucHVzaChgJHsgbWFya3VwTmFtZSB9YCk7XG4gICAgICAgIGlmICh6UHJvcGVydHkgJiYgeVByb3BlcnR5KSB7XG4gICAgICAgICAgaWYgKGlzSW5wdXQpIHtcbiAgICAgICAgICAgIHJldEFyci5wdXNoKCdbKCcpO1xuICAgICAgICAgICAgdGhpcy5hc3RHZW5lcmljKHpQcm9wZXJ0eSwgcmV0QXJyKTtcbiAgICAgICAgICAgIHJldEFyci5wdXNoKGAqJHsgdGhpcy5keW5hbWljQXJndW1lbnRzID8gJyhvdXRwdXRZICogb3V0cHV0WCknIDogc2l6ZVsxXSAqIHNpemVbMF0gfSkrKGApO1xuICAgICAgICAgICAgdGhpcy5hc3RHZW5lcmljKHlQcm9wZXJ0eSwgcmV0QXJyKTtcbiAgICAgICAgICAgIHJldEFyci5wdXNoKGAqJHsgdGhpcy5keW5hbWljQXJndW1lbnRzID8gJ291dHB1dFgnIDogc2l6ZVswXSB9KStgKTtcbiAgICAgICAgICAgIHRoaXMuYXN0R2VuZXJpYyh4UHJvcGVydHksIHJldEFycik7XG4gICAgICAgICAgICByZXRBcnIucHVzaCgnXScpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXRBcnIucHVzaCgnWycpO1xuICAgICAgICAgICAgdGhpcy5hc3RHZW5lcmljKHpQcm9wZXJ0eSwgcmV0QXJyKTtcbiAgICAgICAgICAgIHJldEFyci5wdXNoKCddJyk7XG4gICAgICAgICAgICByZXRBcnIucHVzaCgnWycpO1xuICAgICAgICAgICAgdGhpcy5hc3RHZW5lcmljKHlQcm9wZXJ0eSwgcmV0QXJyKTtcbiAgICAgICAgICAgIHJldEFyci5wdXNoKCddJyk7XG4gICAgICAgICAgICByZXRBcnIucHVzaCgnWycpO1xuICAgICAgICAgICAgdGhpcy5hc3RHZW5lcmljKHhQcm9wZXJ0eSwgcmV0QXJyKTtcbiAgICAgICAgICAgIHJldEFyci5wdXNoKCddJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHlQcm9wZXJ0eSkge1xuICAgICAgICAgIGlmIChpc0lucHV0KSB7XG4gICAgICAgICAgICByZXRBcnIucHVzaCgnWygnKTtcbiAgICAgICAgICAgIHRoaXMuYXN0R2VuZXJpYyh5UHJvcGVydHksIHJldEFycik7XG4gICAgICAgICAgICByZXRBcnIucHVzaChgKiR7IHRoaXMuZHluYW1pY0FyZ3VtZW50cyA/ICdvdXRwdXRYJyA6IHNpemVbMF0gfSkrYCk7XG4gICAgICAgICAgICB0aGlzLmFzdEdlbmVyaWMoeFByb3BlcnR5LCByZXRBcnIpO1xuICAgICAgICAgICAgcmV0QXJyLnB1c2goJ10nKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0QXJyLnB1c2goJ1snKTtcbiAgICAgICAgICAgIHRoaXMuYXN0R2VuZXJpYyh5UHJvcGVydHksIHJldEFycik7XG4gICAgICAgICAgICByZXRBcnIucHVzaCgnXScpO1xuICAgICAgICAgICAgcmV0QXJyLnB1c2goJ1snKTtcbiAgICAgICAgICAgIHRoaXMuYXN0R2VuZXJpYyh4UHJvcGVydHksIHJldEFycik7XG4gICAgICAgICAgICByZXRBcnIucHVzaCgnXScpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgeFByb3BlcnR5ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIHJldEFyci5wdXNoKCdbJyk7XG4gICAgICAgICAgdGhpcy5hc3RHZW5lcmljKHhQcm9wZXJ0eSwgcmV0QXJyKTtcbiAgICAgICAgICByZXRBcnIucHVzaCgnXScpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXRBcnI7XG4gIH1cblxuICBhc3RDYWxsRXhwcmVzc2lvbihhc3QsIHJldEFycikge1xuICAgIGlmIChhc3QudHlwZSAhPT0gJ0NhbGxFeHByZXNzaW9uJykge1xuICAgICAgdGhyb3cgdGhpcy5hc3RFcnJvck91dHB1dCgnVW5rbm93biBDYWxsRXhwcmVzc2lvbicsIGFzdCk7XG4gICAgfVxuICAgIGxldCBmdW5jdGlvbk5hbWUgPSB0aGlzLmFzdE1lbWJlckV4cHJlc3Npb25VbnJvbGwoYXN0LmNhbGxlZSk7XG5cbiAgICBpZiAodGhpcy5jYWxsZWRGdW5jdGlvbnMuaW5kZXhPZihmdW5jdGlvbk5hbWUpIDwgMCkge1xuICAgICAgdGhpcy5jYWxsZWRGdW5jdGlvbnMucHVzaChmdW5jdGlvbk5hbWUpO1xuICAgIH1cblxuICAgIGNvbnN0IGlzTWF0aEZ1bmN0aW9uID0gdGhpcy5pc0FzdE1hdGhGdW5jdGlvbihhc3QpO1xuXG4gICAgaWYgKHRoaXMub25GdW5jdGlvbkNhbGwpIHtcbiAgICAgIHRoaXMub25GdW5jdGlvbkNhbGwodGhpcy5uYW1lLCBmdW5jdGlvbk5hbWUsIGFzdC5hcmd1bWVudHMpO1xuICAgIH1cblxuICAgIHJldEFyci5wdXNoKGZ1bmN0aW9uTmFtZSk7XG5cbiAgICByZXRBcnIucHVzaCgnKCcpO1xuICAgIGNvbnN0IHRhcmdldFR5cGVzID0gdGhpcy5sb29rdXBGdW5jdGlvbkFyZ3VtZW50VHlwZXMoZnVuY3Rpb25OYW1lKSB8fCBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFzdC5hcmd1bWVudHMubGVuZ3RoOyArK2kpIHtcbiAgICAgIGNvbnN0IGFyZ3VtZW50ID0gYXN0LmFyZ3VtZW50c1tpXTtcblxuICAgICAgbGV0IGFyZ3VtZW50VHlwZSA9IHRoaXMuZ2V0VHlwZShhcmd1bWVudCk7XG4gICAgICBpZiAoIXRhcmdldFR5cGVzW2ldKSB7XG4gICAgICAgIHRoaXMudHJpZ2dlckltcGx5QXJndW1lbnRUeXBlKGZ1bmN0aW9uTmFtZSwgaSwgYXJndW1lbnRUeXBlLCB0aGlzKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgIHJldEFyci5wdXNoKCcsICcpO1xuICAgICAgfVxuICAgICAgdGhpcy5hc3RHZW5lcmljKGFyZ3VtZW50LCByZXRBcnIpO1xuICAgIH1cbiAgICByZXRBcnIucHVzaCgnKScpO1xuXG4gICAgcmV0dXJuIHJldEFycjtcbiAgfVxuXG4gIGFzdEFycmF5RXhwcmVzc2lvbihhcnJOb2RlLCByZXRBcnIpIHtcbiAgICBjb25zdCByZXR1cm5UeXBlID0gdGhpcy5nZXRUeXBlKGFyck5vZGUpO1xuICAgIGNvbnN0IGFyckxlbiA9IGFyck5vZGUuZWxlbWVudHMubGVuZ3RoO1xuICAgIGNvbnN0IGVsZW1lbnRzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnJMZW47ICsraSkge1xuICAgICAgY29uc3QgZWxlbWVudCA9IFtdO1xuICAgICAgdGhpcy5hc3RHZW5lcmljKGFyck5vZGUuZWxlbWVudHNbaV0sIGVsZW1lbnQpO1xuICAgICAgZWxlbWVudHMucHVzaChlbGVtZW50LmpvaW4oJycpKTtcbiAgICB9XG4gICAgc3dpdGNoIChyZXR1cm5UeXBlKSB7XG4gICAgICBjYXNlICdNYXRyaXgoMiknOlxuICAgICAgY2FzZSAnTWF0cml4KDMpJzpcbiAgICAgIGNhc2UgJ01hdHJpeCg0KSc6XG4gICAgICAgIHJldEFyci5wdXNoKGBbJHtlbGVtZW50cy5qb2luKCcsICcpfV1gKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXRBcnIucHVzaChgbmV3IEZsb2F0MzJBcnJheShbJHtlbGVtZW50cy5qb2luKCcsICcpfV0pYCk7XG4gICAgfVxuICAgIHJldHVybiByZXRBcnI7XG4gIH1cblxuICBhc3REZWJ1Z2dlclN0YXRlbWVudChhcnJOb2RlLCByZXRBcnIpIHtcbiAgICByZXRBcnIucHVzaCgnZGVidWdnZXI7Jyk7XG4gICAgcmV0dXJuIHJldEFycjtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgQ1BVRnVuY3Rpb25Ob2RlXG59O1xufSx7XCIuLi9mdW5jdGlvbi1ub2RlXCI6MTB9XSw3OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbmNvbnN0IHsgdXRpbHMgfSA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzJyk7XG5cbmZ1bmN0aW9uIGNvbnN0YW50c1RvU3RyaW5nKGNvbnN0YW50cywgdHlwZXMpIHtcbiAgY29uc3QgcmVzdWx0cyA9IFtdO1xuICBmb3IgKGNvbnN0IG5hbWUgaW4gdHlwZXMpIHtcbiAgICBpZiAoIXR5cGVzLmhhc093blByb3BlcnR5KG5hbWUpKSBjb250aW51ZTtcbiAgICBjb25zdCB0eXBlID0gdHlwZXNbbmFtZV07XG4gICAgY29uc3QgY29uc3RhbnQgPSBjb25zdGFudHNbbmFtZV07XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlICdOdW1iZXInOlxuICAgICAgY2FzZSAnSW50ZWdlcic6XG4gICAgICBjYXNlICdGbG9hdCc6XG4gICAgICBjYXNlICdCb29sZWFuJzpcbiAgICAgICAgcmVzdWx0cy5wdXNoKGAke25hbWV9OiR7Y29uc3RhbnR9YCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnQXJyYXkoMiknOlxuICAgICAgY2FzZSAnQXJyYXkoMyknOlxuICAgICAgY2FzZSAnQXJyYXkoNCknOlxuICAgICAgY2FzZSAnTWF0cml4KDIpJzpcbiAgICAgIGNhc2UgJ01hdHJpeCgzKSc6XG4gICAgICBjYXNlICdNYXRyaXgoNCknOlxuICAgICAgICByZXN1bHRzLnB1c2goYCR7bmFtZX06bmV3ICR7Y29uc3RhbnQuY29uc3RydWN0b3IubmFtZX0oJHtKU09OLnN0cmluZ2lmeShBcnJheS5mcm9tKGNvbnN0YW50KSl9KWApO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGB7ICR7IHJlc3VsdHMuam9pbigpIH0gfWA7XG59XG5cbmZ1bmN0aW9uIGNwdUtlcm5lbFN0cmluZyhjcHVLZXJuZWwsIG5hbWUpIHtcbiAgY29uc3QgaGVhZGVyID0gW107XG4gIGNvbnN0IHRoaXNQcm9wZXJ0aWVzID0gW107XG4gIGNvbnN0IGJlZm9yZVJldHVybiA9IFtdO1xuXG4gIGNvbnN0IHVzZUZ1bmN0aW9uS2V5d29yZCA9ICEvXmZ1bmN0aW9uLy50ZXN0KGNwdUtlcm5lbC5jb2xvci50b1N0cmluZygpKTtcblxuICBoZWFkZXIucHVzaChcbiAgICAnICBjb25zdCB7IGNvbnRleHQsIGNhbnZhcywgY29uc3RhbnRzOiBpbmNvbWluZ0NvbnN0YW50cyB9ID0gc2V0dGluZ3M7JyxcbiAgICBgICBjb25zdCBvdXRwdXQgPSBuZXcgSW50MzJBcnJheSgke0pTT04uc3RyaW5naWZ5KEFycmF5LmZyb20oY3B1S2VybmVsLm91dHB1dCkpfSk7YCxcbiAgICBgICBjb25zdCBfY29uc3RhbnRUeXBlcyA9ICR7SlNPTi5zdHJpbmdpZnkoY3B1S2VybmVsLmNvbnN0YW50VHlwZXMpfTtgLFxuICAgIGAgIGNvbnN0IF9jb25zdGFudHMgPSAke2NvbnN0YW50c1RvU3RyaW5nKGNwdUtlcm5lbC5jb25zdGFudHMsIGNwdUtlcm5lbC5jb25zdGFudFR5cGVzKX07YFxuICApO1xuXG4gIHRoaXNQcm9wZXJ0aWVzLnB1c2goXG4gICAgJyAgICBjb25zdGFudHM6IF9jb25zdGFudHMsJyxcbiAgICAnICAgIGNvbnRleHQsJyxcbiAgICAnICAgIG91dHB1dCwnLFxuICAgICcgICAgdGhyZWFkOiB7eDogMCwgeTogMCwgejogMH0sJ1xuICApO1xuXG4gIGlmIChjcHVLZXJuZWwuZ3JhcGhpY2FsKSB7XG4gICAgaGVhZGVyLnB1c2goYCAgY29uc3QgX2ltYWdlRGF0YSA9IGNvbnRleHQuY3JlYXRlSW1hZ2VEYXRhKCR7Y3B1S2VybmVsLm91dHB1dFswXX0sICR7Y3B1S2VybmVsLm91dHB1dFsxXX0pO2ApO1xuICAgIGhlYWRlci5wdXNoKGAgIGNvbnN0IF9jb2xvckRhdGEgPSBuZXcgVWludDhDbGFtcGVkQXJyYXkoJHtjcHVLZXJuZWwub3V0cHV0WzBdfSAqICR7Y3B1S2VybmVsLm91dHB1dFsxXX0gKiA0KTtgKTtcblxuICAgIGNvbnN0IGNvbG9yRm4gPSB1dGlscy5mbGF0dGVuRnVuY3Rpb25Ub1N0cmluZygodXNlRnVuY3Rpb25LZXl3b3JkID8gJ2Z1bmN0aW9uICcgOiAnJykgKyBjcHVLZXJuZWwuY29sb3IudG9TdHJpbmcoKSwge1xuICAgICAgdGhpc0xvb2t1cDogKHByb3BlcnR5TmFtZSkgPT4ge1xuICAgICAgICBzd2l0Y2ggKHByb3BlcnR5TmFtZSkge1xuICAgICAgICAgIGNhc2UgJ19jb2xvckRhdGEnOlxuICAgICAgICAgICAgcmV0dXJuICdfY29sb3JEYXRhJztcbiAgICAgICAgICBjYXNlICdfaW1hZ2VEYXRhJzpcbiAgICAgICAgICAgIHJldHVybiAnX2ltYWdlRGF0YSc7XG4gICAgICAgICAgY2FzZSAnb3V0cHV0JzpcbiAgICAgICAgICAgIHJldHVybiAnb3V0cHV0JztcbiAgICAgICAgICBjYXNlICd0aHJlYWQnOlxuICAgICAgICAgICAgcmV0dXJuICd0aGlzLnRocmVhZCc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGNwdUtlcm5lbFtwcm9wZXJ0eU5hbWVdKTtcbiAgICAgIH0sXG4gICAgICBmaW5kRGVwZW5kZW5jeTogKG9iamVjdCwgbmFtZSkgPT4ge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGNvbnN0IGdldFBpeGVsc0ZuID0gdXRpbHMuZmxhdHRlbkZ1bmN0aW9uVG9TdHJpbmcoKHVzZUZ1bmN0aW9uS2V5d29yZCA/ICdmdW5jdGlvbiAnIDogJycpICsgY3B1S2VybmVsLmdldFBpeGVscy50b1N0cmluZygpLCB7XG4gICAgICB0aGlzTG9va3VwOiAocHJvcGVydHlOYW1lKSA9PiB7XG4gICAgICAgIHN3aXRjaCAocHJvcGVydHlOYW1lKSB7XG4gICAgICAgICAgY2FzZSAnX2NvbG9yRGF0YSc6XG4gICAgICAgICAgICByZXR1cm4gJ19jb2xvckRhdGEnO1xuICAgICAgICAgIGNhc2UgJ19pbWFnZURhdGEnOlxuICAgICAgICAgICAgcmV0dXJuICdfaW1hZ2VEYXRhJztcbiAgICAgICAgICBjYXNlICdvdXRwdXQnOlxuICAgICAgICAgICAgcmV0dXJuICdvdXRwdXQnO1xuICAgICAgICAgIGNhc2UgJ3RocmVhZCc6XG4gICAgICAgICAgICByZXR1cm4gJ3RoaXMudGhyZWFkJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoY3B1S2VybmVsW3Byb3BlcnR5TmFtZV0pO1xuICAgICAgfSxcbiAgICAgIGZpbmREZXBlbmRlbmN5OiAoKSA9PiB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgdGhpc1Byb3BlcnRpZXMucHVzaChcbiAgICAgICcgICAgX2ltYWdlRGF0YSwnLFxuICAgICAgJyAgICBfY29sb3JEYXRhLCcsXG4gICAgICBgICAgIGNvbG9yOiAke2NvbG9yRm59LGBcbiAgICApO1xuXG4gICAgYmVmb3JlUmV0dXJuLnB1c2goXG4gICAgICBgICBrZXJuZWwuZ2V0UGl4ZWxzID0gJHtnZXRQaXhlbHNGbn07YFxuICAgICk7XG4gIH1cblxuICBjb25zdCBjb25zdGFudFR5cGVzID0gW107XG4gIGNvbnN0IGNvbnN0YW50S2V5cyA9IE9iamVjdC5rZXlzKGNwdUtlcm5lbC5jb25zdGFudFR5cGVzKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb25zdGFudEtleXMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdGFudFR5cGVzLnB1c2goY3B1S2VybmVsLmNvbnN0YW50VHlwZXNbY29uc3RhbnRLZXlzXSk7XG4gIH1cbiAgaWYgKGNwdUtlcm5lbC5hcmd1bWVudFR5cGVzLmluZGV4T2YoJ0hUTUxJbWFnZUFycmF5JykgIT09IC0xIHx8IGNvbnN0YW50VHlwZXMuaW5kZXhPZignSFRNTEltYWdlQXJyYXknKSAhPT0gLTEpIHtcbiAgICBjb25zdCBmbGF0dGVuZWRJbWFnZVRvM0RBcnJheSA9IHV0aWxzLmZsYXR0ZW5GdW5jdGlvblRvU3RyaW5nKCh1c2VGdW5jdGlvbktleXdvcmQgPyAnZnVuY3Rpb24gJyA6ICcnKSArIGNwdUtlcm5lbC5faW1hZ2VUbzNEQXJyYXkudG9TdHJpbmcoKSwge1xuICAgICAgZG9Ob3REZWZpbmU6IFsnY2FudmFzJ10sXG4gICAgICBmaW5kRGVwZW5kZW5jeTogKG9iamVjdCwgbmFtZSkgPT4ge1xuICAgICAgICBpZiAob2JqZWN0ID09PSAndGhpcycpIHtcbiAgICAgICAgICByZXR1cm4gKHVzZUZ1bmN0aW9uS2V5d29yZCA/ICdmdW5jdGlvbiAnIDogJycpICsgY3B1S2VybmVsW25hbWVdLnRvU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9LFxuICAgICAgdGhpc0xvb2t1cDogKHByb3BlcnR5TmFtZSkgPT4ge1xuICAgICAgICBzd2l0Y2ggKHByb3BlcnR5TmFtZSkge1xuICAgICAgICAgIGNhc2UgJ2NhbnZhcyc6XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgY2FzZSAnY29udGV4dCc6XG4gICAgICAgICAgICByZXR1cm4gJ2NvbnRleHQnO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgYmVmb3JlUmV0dXJuLnB1c2goZmxhdHRlbmVkSW1hZ2VUbzNEQXJyYXkpO1xuICAgIHRoaXNQcm9wZXJ0aWVzLnB1c2goYCAgICBfbWVkaWFUbzJEQXJyYXksYCk7XG4gICAgdGhpc1Byb3BlcnRpZXMucHVzaChgICAgIF9pbWFnZVRvM0RBcnJheSxgKTtcbiAgfSBlbHNlIGlmIChjcHVLZXJuZWwuYXJndW1lbnRUeXBlcy5pbmRleE9mKCdIVE1MSW1hZ2UnKSAhPT0gLTEgfHwgY29uc3RhbnRUeXBlcy5pbmRleE9mKCdIVE1MSW1hZ2UnKSAhPT0gLTEpIHtcbiAgICBjb25zdCBmbGF0dGVuZWRJbWFnZVRvMkRBcnJheSA9IHV0aWxzLmZsYXR0ZW5GdW5jdGlvblRvU3RyaW5nKCh1c2VGdW5jdGlvbktleXdvcmQgPyAnZnVuY3Rpb24gJyA6ICcnKSArIGNwdUtlcm5lbC5fbWVkaWFUbzJEQXJyYXkudG9TdHJpbmcoKSwge1xuICAgICAgZmluZERlcGVuZGVuY3k6IChvYmplY3QsIG5hbWUpID0+IHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9LFxuICAgICAgdGhpc0xvb2t1cDogKHByb3BlcnR5TmFtZSkgPT4ge1xuICAgICAgICBzd2l0Y2ggKHByb3BlcnR5TmFtZSkge1xuICAgICAgICAgIGNhc2UgJ2NhbnZhcyc6XG4gICAgICAgICAgICByZXR1cm4gJ3NldHRpbmdzLmNhbnZhcyc7XG4gICAgICAgICAgY2FzZSAnY29udGV4dCc6XG4gICAgICAgICAgICByZXR1cm4gJ3NldHRpbmdzLmNvbnRleHQnO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigndW5oYW5kbGVkIHRoaXNMb29rdXAnKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBiZWZvcmVSZXR1cm4ucHVzaChmbGF0dGVuZWRJbWFnZVRvMkRBcnJheSk7XG4gICAgdGhpc1Byb3BlcnRpZXMucHVzaChgICAgIF9tZWRpYVRvMkRBcnJheSxgKTtcbiAgfVxuXG4gIHJldHVybiBgZnVuY3Rpb24oc2V0dGluZ3MpIHtcbiR7IGhlYWRlci5qb2luKCdcXG4nKSB9XG4gIGZvciAoY29uc3QgcCBpbiBfY29uc3RhbnRUeXBlcykge1xuICAgIGlmICghX2NvbnN0YW50VHlwZXMuaGFzT3duUHJvcGVydHkocCkpIGNvbnRpbnVlO1xuICAgIGNvbnN0IHR5cGUgPSBfY29uc3RhbnRUeXBlc1twXTtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgJ051bWJlcic6XG4gICAgICBjYXNlICdJbnRlZ2VyJzpcbiAgICAgIGNhc2UgJ0Zsb2F0JzpcbiAgICAgIGNhc2UgJ0Jvb2xlYW4nOlxuICAgICAgY2FzZSAnQXJyYXkoMiknOlxuICAgICAgY2FzZSAnQXJyYXkoMyknOlxuICAgICAgY2FzZSAnQXJyYXkoNCknOlxuICAgICAgY2FzZSAnTWF0cml4KDIpJzpcbiAgICAgIGNhc2UgJ01hdHJpeCgzKSc6XG4gICAgICBjYXNlICdNYXRyaXgoNCknOlxuICAgICAgICBpZiAoaW5jb21pbmdDb25zdGFudHMuaGFzT3duUHJvcGVydHkocCkpIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oJ2NvbnN0YW50ICcgKyBwICsgJyBvZiB0eXBlICcgKyB0eXBlICsgJyBjYW5ub3QgYmUgcmVzaWduZWQnKTtcbiAgICAgICAgfVxuICAgICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKCFpbmNvbWluZ0NvbnN0YW50cy5oYXNPd25Qcm9wZXJ0eShwKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdjb25zdGFudCAnICsgcCArICcgbm90IGZvdW5kJyk7XG4gICAgfVxuICAgIF9jb25zdGFudHNbcF0gPSBpbmNvbWluZ0NvbnN0YW50c1twXTtcbiAgfVxuICBjb25zdCBrZXJuZWwgPSAoZnVuY3Rpb24oKSB7XG4ke2NwdUtlcm5lbC5fa2VybmVsU3RyaW5nfVxuICB9KVxuICAgIC5hcHBseSh7ICR7dGhpc1Byb3BlcnRpZXMuam9pbignXFxuJyl9IH0pO1xuICAkeyBiZWZvcmVSZXR1cm4uam9pbignXFxuJykgfVxuICByZXR1cm4ga2VybmVsO1xufWA7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBjcHVLZXJuZWxTdHJpbmdcbn07XG59LHtcIi4uLy4uL3V0aWxzXCI6MTE0fV0sODpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5jb25zdCB7IEtlcm5lbCB9ID0gcmVxdWlyZSgnLi4va2VybmVsJyk7XG5jb25zdCB7IEZ1bmN0aW9uQnVpbGRlciB9ID0gcmVxdWlyZSgnLi4vZnVuY3Rpb24tYnVpbGRlcicpO1xuY29uc3QgeyBDUFVGdW5jdGlvbk5vZGUgfSA9IHJlcXVpcmUoJy4vZnVuY3Rpb24tbm9kZScpO1xuY29uc3QgeyB1dGlscyB9ID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMnKTtcbmNvbnN0IHsgY3B1S2VybmVsU3RyaW5nIH0gPSByZXF1aXJlKCcuL2tlcm5lbC1zdHJpbmcnKTtcblxuY2xhc3MgQ1BVS2VybmVsIGV4dGVuZHMgS2VybmVsIHtcbiAgc3RhdGljIGdldEZlYXR1cmVzKCkge1xuICAgIHJldHVybiB0aGlzLmZlYXR1cmVzO1xuICB9XG4gIHN0YXRpYyBnZXQgZmVhdHVyZXMoKSB7XG4gICAgcmV0dXJuIE9iamVjdC5mcmVlemUoe1xuICAgICAga2VybmVsTWFwOiB0cnVlLFxuICAgICAgaXNJbnRlZ2VyRGl2aXNpb25BY2N1cmF0ZTogdHJ1ZVxuICAgIH0pO1xuICB9XG4gIHN0YXRpYyBnZXQgaXNTdXBwb3J0ZWQoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgc3RhdGljIGlzQ29udGV4dE1hdGNoKGNvbnRleHQpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgc3RhdGljIGdldCBtb2RlKCkge1xuICAgIHJldHVybiAnY3B1JztcbiAgfVxuXG4gIHN0YXRpYyBuYXRpdmVGdW5jdGlvbkFyZ3VtZW50cygpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHN0YXRpYyBuYXRpdmVGdW5jdGlvblJldHVyblR5cGUoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBMb29raW5nIHVwIG5hdGl2ZSBmdW5jdGlvbiByZXR1cm4gdHlwZSBub3Qgc3VwcG9ydGVkIG9uICR7dGhpcy5uYW1lfWApO1xuICB9XG5cbiAgc3RhdGljIGNvbWJpbmVLZXJuZWxzKGNvbWJpbmVkS2VybmVsKSB7XG4gICAgcmV0dXJuIGNvbWJpbmVkS2VybmVsO1xuICB9XG5cbiAgc3RhdGljIGdldFNpZ25hdHVyZShrZXJuZWwsIGFyZ3VtZW50VHlwZXMpIHtcbiAgICByZXR1cm4gJ2NwdScgKyAoYXJndW1lbnRUeXBlcy5sZW5ndGggPiAwID8gJzonICsgYXJndW1lbnRUeXBlcy5qb2luKCcsJykgOiAnJyk7XG4gIH1cblxuICBjb25zdHJ1Y3Rvcihzb3VyY2UsIHNldHRpbmdzKSB7XG4gICAgc3VwZXIoc291cmNlLCBzZXR0aW5ncyk7XG4gICAgdGhpcy5tZXJnZVNldHRpbmdzKHNvdXJjZS5zZXR0aW5ncyB8fCBzZXR0aW5ncyk7XG5cbiAgICB0aGlzLl9pbWFnZURhdGEgPSBudWxsO1xuICAgIHRoaXMuX2NvbG9yRGF0YSA9IG51bGw7XG4gICAgdGhpcy5fa2VybmVsU3RyaW5nID0gbnVsbDtcbiAgICB0aGlzLl9wcmVwZW5kZWRTdHJpbmcgPSBbXTtcbiAgICB0aGlzLnRocmVhZCA9IHtcbiAgICAgIHg6IDAsXG4gICAgICB5OiAwLFxuICAgICAgejogMFxuICAgIH07XG4gICAgdGhpcy50cmFuc2xhdGVkU291cmNlcyA9IG51bGw7XG4gIH1cblxuICBpbml0Q2FudmFzKCkge1xuICAgIGlmICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgT2Zmc2NyZWVuQ2FudmFzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgcmV0dXJuIG5ldyBPZmZzY3JlZW5DYW52YXMoMCwgMCk7XG4gICAgfVxuICB9XG5cbiAgaW5pdENvbnRleHQoKSB7XG4gICAgaWYgKCF0aGlzLmNhbnZhcykgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuIHRoaXMuY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gIH1cblxuICBpbml0UGx1Z2lucyhzZXR0aW5ncykge1xuICAgIHJldHVybiBbXTtcbiAgfVxuXG4gIHZhbGlkYXRlU2V0dGluZ3MoYXJncykge1xuICAgIGlmICghdGhpcy5vdXRwdXQgfHwgdGhpcy5vdXRwdXQubGVuZ3RoID09PSAwKSB7XG4gICAgICBpZiAoYXJncy5sZW5ndGggIT09IDEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBdXRvIG91dHB1dCBvbmx5IHN1cHBvcnRlZCBmb3Iga2VybmVscyB3aXRoIG9ubHkgb25lIGlucHV0Jyk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGFyZ1R5cGUgPSB1dGlscy5nZXRWYXJpYWJsZVR5cGUoYXJnc1swXSwgdGhpcy5zdHJpY3RJbnRlZ2Vycyk7XG4gICAgICBpZiAoYXJnVHlwZSA9PT0gJ0FycmF5Jykge1xuICAgICAgICB0aGlzLm91dHB1dCA9IHV0aWxzLmdldERpbWVuc2lvbnMoYXJnVHlwZSk7XG4gICAgICB9IGVsc2UgaWYgKGFyZ1R5cGUgPT09ICdOdW1iZXJUZXh0dXJlJyB8fCBhcmdUeXBlID09PSAnQXJyYXlUZXh0dXJlKDQpJykge1xuICAgICAgICB0aGlzLm91dHB1dCA9IGFyZ3NbMF0ub3V0cHV0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBdXRvIG91dHB1dCBub3Qgc3VwcG9ydGVkIGZvciBpbnB1dCB0eXBlOiAnICsgYXJnVHlwZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuZ3JhcGhpY2FsKSB7XG4gICAgICBpZiAodGhpcy5vdXRwdXQubGVuZ3RoICE9PSAyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignT3V0cHV0IG11c3QgaGF2ZSAyIGRpbWVuc2lvbnMgb24gZ3JhcGhpY2FsIG1vZGUnKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmNoZWNrT3V0cHV0KCk7XG4gIH1cblxuICB0cmFuc2xhdGVTb3VyY2UoKSB7XG4gICAgdGhpcy5sZWFkaW5nUmV0dXJuU3RhdGVtZW50ID0gdGhpcy5vdXRwdXQubGVuZ3RoID4gMSA/ICdyZXN1bHRYW3hdID0gJyA6ICdyZXN1bHRbeF0gPSAnO1xuICAgIGlmICh0aGlzLnN1Yktlcm5lbHMpIHtcbiAgICAgIGNvbnN0IGZvbGxvd2luZ1JldHVyblN0YXRlbWVudCA9IFtdO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnN1Yktlcm5lbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIG5hbWVcbiAgICAgICAgfSA9IHRoaXMuc3ViS2VybmVsc1tpXTtcbiAgICAgICAgZm9sbG93aW5nUmV0dXJuU3RhdGVtZW50LnB1c2godGhpcy5vdXRwdXQubGVuZ3RoID4gMSA/IGByZXN1bHRYXyR7IG5hbWUgfVt4XSA9IHN1Yktlcm5lbFJlc3VsdF8keyBuYW1lIH07XFxuYCA6IGByZXN1bHRfJHsgbmFtZSB9W3hdID0gc3ViS2VybmVsUmVzdWx0XyR7IG5hbWUgfTtcXG5gKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZm9sbG93aW5nUmV0dXJuU3RhdGVtZW50ID0gZm9sbG93aW5nUmV0dXJuU3RhdGVtZW50LmpvaW4oJycpO1xuICAgIH1cbiAgICBjb25zdCBmdW5jdGlvbkJ1aWxkZXIgPSBGdW5jdGlvbkJ1aWxkZXIuZnJvbUtlcm5lbCh0aGlzLCBDUFVGdW5jdGlvbk5vZGUpO1xuICAgIHRoaXMudHJhbnNsYXRlZFNvdXJjZXMgPSBmdW5jdGlvbkJ1aWxkZXIuZ2V0UHJvdG90eXBlcygna2VybmVsJyk7XG4gICAgaWYgKCF0aGlzLmdyYXBoaWNhbCAmJiAhdGhpcy5yZXR1cm5UeXBlKSB7XG4gICAgICB0aGlzLnJldHVyblR5cGUgPSBmdW5jdGlvbkJ1aWxkZXIuZ2V0S2VybmVsUmVzdWx0VHlwZSgpO1xuICAgIH1cbiAgfVxuXG4gIGJ1aWxkKCkge1xuICAgIGlmICh0aGlzLmJ1aWx0KSByZXR1cm47XG4gICAgdGhpcy5zZXR1cENvbnN0YW50cygpO1xuICAgIHRoaXMuc2V0dXBBcmd1bWVudHMoYXJndW1lbnRzKTtcbiAgICB0aGlzLnZhbGlkYXRlU2V0dGluZ3MoYXJndW1lbnRzKTtcbiAgICB0aGlzLnRyYW5zbGF0ZVNvdXJjZSgpO1xuXG4gICAgaWYgKHRoaXMuZ3JhcGhpY2FsKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGNhbnZhcyxcbiAgICAgICAgb3V0cHV0XG4gICAgICB9ID0gdGhpcztcbiAgICAgIGlmICghY2FudmFzKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbm8gY2FudmFzIGF2YWlsYWJsZSBmb3IgdXNpbmcgZ3JhcGhpY2FsIG91dHB1dCcpO1xuICAgICAgfVxuICAgICAgY29uc3Qgd2lkdGggPSBvdXRwdXRbMF07XG4gICAgICBjb25zdCBoZWlnaHQgPSBvdXRwdXRbMV0gfHwgMTtcbiAgICAgIGNhbnZhcy53aWR0aCA9IHdpZHRoO1xuICAgICAgY2FudmFzLmhlaWdodCA9IGhlaWdodDtcbiAgICAgIHRoaXMuX2ltYWdlRGF0YSA9IHRoaXMuY29udGV4dC5jcmVhdGVJbWFnZURhdGEod2lkdGgsIGhlaWdodCk7XG4gICAgICB0aGlzLl9jb2xvckRhdGEgPSBuZXcgVWludDhDbGFtcGVkQXJyYXkod2lkdGggKiBoZWlnaHQgKiA0KTtcbiAgICB9XG5cbiAgICBjb25zdCBrZXJuZWxTdHJpbmcgPSB0aGlzLmdldEtlcm5lbFN0cmluZygpO1xuICAgIHRoaXMua2VybmVsU3RyaW5nID0ga2VybmVsU3RyaW5nO1xuXG4gICAgaWYgKHRoaXMuZGVidWcpIHtcbiAgICAgIGNvbnNvbGUubG9nKCdGdW5jdGlvbiBvdXRwdXQ6Jyk7XG4gICAgICBjb25zb2xlLmxvZyhrZXJuZWxTdHJpbmcpO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICB0aGlzLnJ1biA9IG5ldyBGdW5jdGlvbihbXSwga2VybmVsU3RyaW5nKS5iaW5kKHRoaXMpKCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgY29uc29sZS5lcnJvcignQW4gZXJyb3Igb2NjdXJyZWQgY29tcGlsaW5nIHRoZSBqYXZhc2NyaXB0OiAnLCBlKTtcbiAgICB9XG4gICAgdGhpcy5idWlsZFNpZ25hdHVyZShhcmd1bWVudHMpO1xuICAgIHRoaXMuYnVpbHQgPSB0cnVlO1xuICB9XG5cbiAgY29sb3IociwgZywgYiwgYSkge1xuICAgIGlmICh0eXBlb2YgYSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGEgPSAxO1xuICAgIH1cblxuICAgIHIgPSBNYXRoLmZsb29yKHIgKiAyNTUpO1xuICAgIGcgPSBNYXRoLmZsb29yKGcgKiAyNTUpO1xuICAgIGIgPSBNYXRoLmZsb29yKGIgKiAyNTUpO1xuICAgIGEgPSBNYXRoLmZsb29yKGEgKiAyNTUpO1xuXG4gICAgY29uc3Qgd2lkdGggPSB0aGlzLm91dHB1dFswXTtcbiAgICBjb25zdCBoZWlnaHQgPSB0aGlzLm91dHB1dFsxXTtcblxuICAgIGNvbnN0IHggPSB0aGlzLnRocmVhZC54O1xuICAgIGNvbnN0IHkgPSBoZWlnaHQgLSB0aGlzLnRocmVhZC55IC0gMTtcblxuICAgIGNvbnN0IGluZGV4ID0geCArIHkgKiB3aWR0aDtcblxuICAgIHRoaXMuX2NvbG9yRGF0YVtpbmRleCAqIDQgKyAwXSA9IHI7XG4gICAgdGhpcy5fY29sb3JEYXRhW2luZGV4ICogNCArIDFdID0gZztcbiAgICB0aGlzLl9jb2xvckRhdGFbaW5kZXggKiA0ICsgMl0gPSBiO1xuICAgIHRoaXMuX2NvbG9yRGF0YVtpbmRleCAqIDQgKyAzXSA9IGE7XG4gIH1cblxuICBnZXRLZXJuZWxTdHJpbmcoKSB7XG4gICAgaWYgKHRoaXMuX2tlcm5lbFN0cmluZyAhPT0gbnVsbCkgcmV0dXJuIHRoaXMuX2tlcm5lbFN0cmluZztcblxuICAgIGxldCBrZXJuZWxUaHJlYWRTdHJpbmcgPSBudWxsO1xuICAgIGxldCB7XG4gICAgICB0cmFuc2xhdGVkU291cmNlc1xuICAgIH0gPSB0aGlzO1xuICAgIGlmICh0cmFuc2xhdGVkU291cmNlcy5sZW5ndGggPiAxKSB7XG4gICAgICB0cmFuc2xhdGVkU291cmNlcyA9IHRyYW5zbGF0ZWRTb3VyY2VzLmZpbHRlcihmbiA9PiB7XG4gICAgICAgIGlmICgvXmZ1bmN0aW9uLy50ZXN0KGZuKSkgcmV0dXJuIGZuO1xuICAgICAgICBrZXJuZWxUaHJlYWRTdHJpbmcgPSBmbjtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGtlcm5lbFRocmVhZFN0cmluZyA9IHRyYW5zbGF0ZWRTb3VyY2VzLnNoaWZ0KCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9rZXJuZWxTdHJpbmcgPSBgICBjb25zdCBMT09QX01BWCA9ICR7IHRoaXMuX2dldExvb3BNYXhTdHJpbmcoKSB9O1xuICAkeyB0aGlzLmluamVjdGVkTmF0aXZlIHx8ICcnIH1cbiAgY29uc3QgX3RoaXMgPSB0aGlzO1xuICAkeyB0aGlzLl9yZXN1bHRLZXJuZWxIZWFkZXIoKSB9XG4gICR7IHRoaXMuX3Byb2Nlc3NDb25zdGFudHMoKSB9XG4gIHJldHVybiAoJHsgdGhpcy5hcmd1bWVudE5hbWVzLm1hcChhcmd1bWVudE5hbWUgPT4gJ3VzZXJfJyArIGFyZ3VtZW50TmFtZSkuam9pbignLCAnKSB9KSA9PiB7XG4gICAgJHsgdGhpcy5fcHJlcGVuZGVkU3RyaW5nLmpvaW4oJycpIH1cbiAgICAkeyB0aGlzLl9lYXJseVRocm93cygpIH1cbiAgICAkeyB0aGlzLl9wcm9jZXNzQXJndW1lbnRzKCkgfVxuICAgICR7IHRoaXMuZ3JhcGhpY2FsID8gdGhpcy5fZ3JhcGhpY2FsS2VybmVsQm9keShrZXJuZWxUaHJlYWRTdHJpbmcpIDogdGhpcy5fcmVzdWx0S2VybmVsQm9keShrZXJuZWxUaHJlYWRTdHJpbmcpIH1cbiAgICAkeyB0cmFuc2xhdGVkU291cmNlcy5sZW5ndGggPiAwID8gdHJhbnNsYXRlZFNvdXJjZXMuam9pbignXFxuJykgOiAnJyB9XG4gIH07YDtcbiAgfVxuXG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiBjcHVLZXJuZWxTdHJpbmcodGhpcyk7XG4gIH1cblxuICBfZ2V0TG9vcE1heFN0cmluZygpIHtcbiAgICByZXR1cm4gKFxuICAgICAgdGhpcy5sb29wTWF4SXRlcmF0aW9ucyA/XG4gICAgICBgICR7IHBhcnNlSW50KHRoaXMubG9vcE1heEl0ZXJhdGlvbnMpIH07YCA6XG4gICAgICAnIDEwMDA7J1xuICAgICk7XG4gIH1cblxuICBfcHJvY2Vzc0NvbnN0YW50cygpIHtcbiAgICBpZiAoIXRoaXMuY29uc3RhbnRzKSByZXR1cm4gJyc7XG5cbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICBmb3IgKGxldCBwIGluIHRoaXMuY29uc3RhbnRzKSB7XG4gICAgICBjb25zdCB0eXBlID0gdGhpcy5jb25zdGFudFR5cGVzW3BdO1xuICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgJ0hUTUxDYW52YXMnOlxuICAgICAgICBjYXNlICdIVE1MSW1hZ2UnOlxuICAgICAgICBjYXNlICdIVE1MVmlkZW8nOlxuICAgICAgICAgIHJlc3VsdC5wdXNoKGAgICAgY29uc3QgY29uc3RhbnRzXyR7cH0gPSB0aGlzLl9tZWRpYVRvMkRBcnJheSh0aGlzLmNvbnN0YW50cy4ke3B9KTtcXG5gKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnSFRNTEltYWdlQXJyYXknOlxuICAgICAgICAgIHJlc3VsdC5wdXNoKGAgICAgY29uc3QgY29uc3RhbnRzXyR7cH0gPSB0aGlzLl9pbWFnZVRvM0RBcnJheSh0aGlzLmNvbnN0YW50cy4ke3B9KTtcXG5gKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnSW5wdXQnOlxuICAgICAgICAgIHJlc3VsdC5wdXNoKGAgICAgY29uc3QgY29uc3RhbnRzXyR7cH0gPSB0aGlzLmNvbnN0YW50cy4ke3B9LnZhbHVlO1xcbmApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJlc3VsdC5wdXNoKGAgICAgY29uc3QgY29uc3RhbnRzXyR7cH0gPSB0aGlzLmNvbnN0YW50cy4ke3B9O1xcbmApO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0LmpvaW4oJycpO1xuICB9XG5cbiAgX2Vhcmx5VGhyb3dzKCkge1xuICAgIGlmICh0aGlzLmdyYXBoaWNhbCkgcmV0dXJuICcnO1xuICAgIGlmICh0aGlzLmltbXV0YWJsZSkgcmV0dXJuICcnO1xuICAgIGlmICghdGhpcy5waXBlbGluZSkgcmV0dXJuICcnO1xuICAgIGNvbnN0IGFycmF5QXJndW1lbnRzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmFyZ3VtZW50VHlwZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICh0aGlzLmFyZ3VtZW50VHlwZXNbaV0gPT09ICdBcnJheScpIHtcbiAgICAgICAgYXJyYXlBcmd1bWVudHMucHVzaCh0aGlzLmFyZ3VtZW50TmFtZXNbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoYXJyYXlBcmd1bWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gJyc7XG4gICAgY29uc3QgY2hlY2tzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnJheUFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgYXJndW1lbnROYW1lID0gYXJyYXlBcmd1bWVudHNbaV07XG4gICAgICBjb25zdCBjaGVja1N1Yktlcm5lbHMgPSB0aGlzLl9tYXBTdWJLZXJuZWxzKHN1Yktlcm5lbCA9PiBgdXNlcl8ke2FyZ3VtZW50TmFtZX0gPT09IHJlc3VsdF8ke3N1Yktlcm5lbC5uYW1lfWApLmpvaW4oJyB8fCAnKTtcbiAgICAgIGNoZWNrcy5wdXNoKGB1c2VyXyR7YXJndW1lbnROYW1lfSA9PT0gcmVzdWx0JHtjaGVja1N1Yktlcm5lbHMgPyBgIHx8ICR7Y2hlY2tTdWJLZXJuZWxzfWAgOiAnJ31gKTtcbiAgICB9XG4gICAgcmV0dXJuIGBpZiAoJHtjaGVja3Muam9pbignIHx8ICcpfSkgdGhyb3cgbmV3IEVycm9yKCdTb3VyY2UgYW5kIGRlc3RpbmF0aW9uIGFycmF5cyBhcmUgdGhlIHNhbWUuICBVc2UgaW1tdXRhYmxlID0gdHJ1ZScpO2A7XG4gIH1cblxuICBfcHJvY2Vzc0FyZ3VtZW50cygpIHtcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuYXJndW1lbnRUeXBlcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgdmFyaWFibGVOYW1lID0gYHVzZXJfJHt0aGlzLmFyZ3VtZW50TmFtZXNbaV19YDtcbiAgICAgIHN3aXRjaCAodGhpcy5hcmd1bWVudFR5cGVzW2ldKSB7XG4gICAgICAgIGNhc2UgJ0hUTUxDYW52YXMnOlxuICAgICAgICBjYXNlICdIVE1MSW1hZ2UnOlxuICAgICAgICBjYXNlICdIVE1MVmlkZW8nOlxuICAgICAgICAgIHJlc3VsdC5wdXNoKGAgICAgJHt2YXJpYWJsZU5hbWV9ID0gdGhpcy5fbWVkaWFUbzJEQXJyYXkoJHt2YXJpYWJsZU5hbWV9KTtcXG5gKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnSFRNTEltYWdlQXJyYXknOlxuICAgICAgICAgIHJlc3VsdC5wdXNoKGAgICAgJHt2YXJpYWJsZU5hbWV9ID0gdGhpcy5faW1hZ2VUbzNEQXJyYXkoJHt2YXJpYWJsZU5hbWV9KTtcXG5gKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnSW5wdXQnOlxuICAgICAgICAgIHJlc3VsdC5wdXNoKGAgICAgJHt2YXJpYWJsZU5hbWV9ID0gJHt2YXJpYWJsZU5hbWV9LnZhbHVlO1xcbmApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdBcnJheVRleHR1cmUoMSknOlxuICAgICAgICBjYXNlICdBcnJheVRleHR1cmUoMiknOlxuICAgICAgICBjYXNlICdBcnJheVRleHR1cmUoMyknOlxuICAgICAgICBjYXNlICdBcnJheVRleHR1cmUoNCknOlxuICAgICAgICBjYXNlICdOdW1iZXJUZXh0dXJlJzpcbiAgICAgICAgY2FzZSAnTWVtb3J5T3B0aW1pemVkTnVtYmVyVGV4dHVyZSc6XG4gICAgICAgICAgcmVzdWx0LnB1c2goYFxuICAgIGlmICgke3ZhcmlhYmxlTmFtZX0udG9BcnJheSkge1xuICAgICAgaWYgKCFfdGhpcy50ZXh0dXJlQ2FjaGUpIHtcbiAgICAgICAgX3RoaXMudGV4dHVyZUNhY2hlID0gW107XG4gICAgICAgIF90aGlzLmFycmF5Q2FjaGUgPSBbXTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHRleHR1cmVJbmRleCA9IF90aGlzLnRleHR1cmVDYWNoZS5pbmRleE9mKCR7dmFyaWFibGVOYW1lfSk7XG4gICAgICBpZiAodGV4dHVyZUluZGV4ICE9PSAtMSkge1xuICAgICAgICAke3ZhcmlhYmxlTmFtZX0gPSBfdGhpcy5hcnJheUNhY2hlW3RleHR1cmVJbmRleF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfdGhpcy50ZXh0dXJlQ2FjaGUucHVzaCgke3ZhcmlhYmxlTmFtZX0pO1xuICAgICAgICAke3ZhcmlhYmxlTmFtZX0gPSAke3ZhcmlhYmxlTmFtZX0udG9BcnJheSgpO1xuICAgICAgICBfdGhpcy5hcnJheUNhY2hlLnB1c2goJHt2YXJpYWJsZU5hbWV9KTtcbiAgICAgIH1cbiAgICB9YCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQuam9pbignJyk7XG4gIH1cblxuICBfbWVkaWFUbzJEQXJyYXkobWVkaWEpIHtcbiAgICBjb25zdCBjYW52YXMgPSB0aGlzLmNhbnZhcztcbiAgICBjb25zdCB3aWR0aCA9IG1lZGlhLndpZHRoID4gMCA/IG1lZGlhLndpZHRoIDogbWVkaWEudmlkZW9XaWR0aDtcbiAgICBjb25zdCBoZWlnaHQgPSBtZWRpYS5oZWlnaHQgPiAwID8gbWVkaWEuaGVpZ2h0IDogbWVkaWEudmlkZW9IZWlnaHQ7XG4gICAgaWYgKGNhbnZhcy53aWR0aCA8IHdpZHRoKSB7XG4gICAgICBjYW52YXMud2lkdGggPSB3aWR0aDtcbiAgICB9XG4gICAgaWYgKGNhbnZhcy5oZWlnaHQgPCBoZWlnaHQpIHtcbiAgICAgIGNhbnZhcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgfVxuICAgIGNvbnN0IGN0eCA9IHRoaXMuY29udGV4dDtcbiAgICBjdHguZHJhd0ltYWdlKG1lZGlhLCAwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICBjb25zdCBwaXhlbHNEYXRhID0gY3R4LmdldEltYWdlRGF0YSgwLCAwLCB3aWR0aCwgaGVpZ2h0KS5kYXRhO1xuICAgIGNvbnN0IGltYWdlQXJyYXkgPSBuZXcgQXJyYXkoaGVpZ2h0KTtcbiAgICBsZXQgaW5kZXggPSAwO1xuICAgIGZvciAobGV0IHkgPSBoZWlnaHQgLSAxOyB5ID49IDA7IHktLSkge1xuICAgICAgY29uc3Qgcm93ID0gaW1hZ2VBcnJheVt5XSA9IG5ldyBBcnJheSh3aWR0aCk7XG4gICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IHdpZHRoOyB4KyspIHtcbiAgICAgICAgY29uc3QgcGl4ZWwgPSBuZXcgRmxvYXQzMkFycmF5KDQpO1xuICAgICAgICBwaXhlbFswXSA9IHBpeGVsc0RhdGFbaW5kZXgrK10gLyAyNTU7IFxuICAgICAgICBwaXhlbFsxXSA9IHBpeGVsc0RhdGFbaW5kZXgrK10gLyAyNTU7IFxuICAgICAgICBwaXhlbFsyXSA9IHBpeGVsc0RhdGFbaW5kZXgrK10gLyAyNTU7IFxuICAgICAgICBwaXhlbFszXSA9IHBpeGVsc0RhdGFbaW5kZXgrK10gLyAyNTU7IFxuICAgICAgICByb3dbeF0gPSBwaXhlbDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGltYWdlQXJyYXk7XG4gIH1cblxuICBnZXRQaXhlbHMoZmxpcCkge1xuICAgIGNvbnN0IFt3aWR0aCwgaGVpZ2h0XSA9IHRoaXMub3V0cHV0O1xuICAgIHJldHVybiBmbGlwID8gdXRpbHMuZmxpcFBpeGVscyh0aGlzLl9pbWFnZURhdGEuZGF0YSwgd2lkdGgsIGhlaWdodCkgOiB0aGlzLl9pbWFnZURhdGEuZGF0YS5zbGljZSgwKTtcbiAgfVxuXG4gIF9pbWFnZVRvM0RBcnJheShpbWFnZXMpIHtcbiAgICBjb25zdCBpbWFnZXNBcnJheSA9IG5ldyBBcnJheShpbWFnZXMubGVuZ3RoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGltYWdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgaW1hZ2VzQXJyYXlbaV0gPSB0aGlzLl9tZWRpYVRvMkRBcnJheShpbWFnZXNbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gaW1hZ2VzQXJyYXk7XG4gIH1cblxuICBfcmVzdWx0S2VybmVsSGVhZGVyKCkge1xuICAgIGlmICh0aGlzLmdyYXBoaWNhbCkgcmV0dXJuICcnO1xuICAgIGlmICh0aGlzLmltbXV0YWJsZSkgcmV0dXJuICcnO1xuICAgIGlmICghdGhpcy5waXBlbGluZSkgcmV0dXJuICcnO1xuICAgIHN3aXRjaCAodGhpcy5vdXRwdXQubGVuZ3RoKSB7XG4gICAgICBjYXNlIDE6XG4gICAgICAgIHJldHVybiB0aGlzLl9tdXRhYmxlS2VybmVsMURSZXN1bHRzKCk7XG4gICAgICBjYXNlIDI6XG4gICAgICAgIHJldHVybiB0aGlzLl9tdXRhYmxlS2VybmVsMkRSZXN1bHRzKCk7XG4gICAgICBjYXNlIDM6XG4gICAgICAgIHJldHVybiB0aGlzLl9tdXRhYmxlS2VybmVsM0RSZXN1bHRzKCk7XG4gICAgfVxuICB9XG5cbiAgX3Jlc3VsdEtlcm5lbEJvZHkoa2VybmVsU3RyaW5nKSB7XG4gICAgc3dpdGNoICh0aGlzLm91dHB1dC5sZW5ndGgpIHtcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgcmV0dXJuICghdGhpcy5pbW11dGFibGUgJiYgdGhpcy5waXBlbGluZSA/IHRoaXMuX3Jlc3VsdE11dGFibGVLZXJuZWwxRExvb3Aoa2VybmVsU3RyaW5nKSA6IHRoaXMuX3Jlc3VsdEltbXV0YWJsZUtlcm5lbDFETG9vcChrZXJuZWxTdHJpbmcpKSArIHRoaXMuX2tlcm5lbE91dHB1dCgpO1xuICAgICAgY2FzZSAyOlxuICAgICAgICByZXR1cm4gKCF0aGlzLmltbXV0YWJsZSAmJiB0aGlzLnBpcGVsaW5lID8gdGhpcy5fcmVzdWx0TXV0YWJsZUtlcm5lbDJETG9vcChrZXJuZWxTdHJpbmcpIDogdGhpcy5fcmVzdWx0SW1tdXRhYmxlS2VybmVsMkRMb29wKGtlcm5lbFN0cmluZykpICsgdGhpcy5fa2VybmVsT3V0cHV0KCk7XG4gICAgICBjYXNlIDM6XG4gICAgICAgIHJldHVybiAoIXRoaXMuaW1tdXRhYmxlICYmIHRoaXMucGlwZWxpbmUgPyB0aGlzLl9yZXN1bHRNdXRhYmxlS2VybmVsM0RMb29wKGtlcm5lbFN0cmluZykgOiB0aGlzLl9yZXN1bHRJbW11dGFibGVLZXJuZWwzRExvb3Aoa2VybmVsU3RyaW5nKSkgKyB0aGlzLl9rZXJuZWxPdXRwdXQoKTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigndW5zdXBwb3J0ZWQgc2l6ZSBrZXJuZWwnKTtcbiAgICB9XG4gIH1cblxuICBfZ3JhcGhpY2FsS2VybmVsQm9keShrZXJuZWxUaHJlYWRTdHJpbmcpIHtcbiAgICBzd2l0Y2ggKHRoaXMub3V0cHV0Lmxlbmd0aCkge1xuICAgICAgY2FzZSAyOlxuICAgICAgICByZXR1cm4gdGhpcy5fZ3JhcGhpY2FsS2VybmVsMkRMb29wKGtlcm5lbFRocmVhZFN0cmluZykgKyB0aGlzLl9ncmFwaGljYWxPdXRwdXQoKTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigndW5zdXBwb3J0ZWQgc2l6ZSBrZXJuZWwnKTtcbiAgICB9XG4gIH1cblxuICBfZ3JhcGhpY2FsT3V0cHV0KCkge1xuICAgIHJldHVybiBgXG4gICAgdGhpcy5faW1hZ2VEYXRhLmRhdGEuc2V0KHRoaXMuX2NvbG9yRGF0YSk7XG4gICAgdGhpcy5jb250ZXh0LnB1dEltYWdlRGF0YSh0aGlzLl9pbWFnZURhdGEsIDAsIDApO1xuICAgIHJldHVybjtgXG4gIH1cblxuICBfZ2V0S2VybmVsUmVzdWx0VHlwZUNvbnN0cnVjdG9yU3RyaW5nKCkge1xuICAgIHN3aXRjaCAodGhpcy5yZXR1cm5UeXBlKSB7XG4gICAgICBjYXNlICdMaXRlcmFsSW50ZWdlcic6XG4gICAgICBjYXNlICdOdW1iZXInOlxuICAgICAgY2FzZSAnSW50ZWdlcic6XG4gICAgICBjYXNlICdGbG9hdCc6XG4gICAgICAgIHJldHVybiAnRmxvYXQzMkFycmF5JztcbiAgICAgIGNhc2UgJ0FycmF5KDIpJzpcbiAgICAgIGNhc2UgJ0FycmF5KDMpJzpcbiAgICAgIGNhc2UgJ0FycmF5KDQpJzpcbiAgICAgICAgcmV0dXJuICdBcnJheSc7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAodGhpcy5ncmFwaGljYWwpIHtcbiAgICAgICAgICByZXR1cm4gJ0Zsb2F0MzJBcnJheSc7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB1bmhhbmRsZWQgcmV0dXJuVHlwZSAkeyB0aGlzLnJldHVyblR5cGUgfWApO1xuICAgIH1cbiAgfVxuXG4gIF9yZXN1bHRJbW11dGFibGVLZXJuZWwxRExvb3Aoa2VybmVsU3RyaW5nKSB7XG4gICAgY29uc3QgY29uc3RydWN0b3JTdHJpbmcgPSB0aGlzLl9nZXRLZXJuZWxSZXN1bHRUeXBlQ29uc3RydWN0b3JTdHJpbmcoKTtcbiAgICByZXR1cm4gYCAgY29uc3Qgb3V0cHV0WCA9IF90aGlzLm91dHB1dFswXTtcbiAgICBjb25zdCByZXN1bHQgPSBuZXcgJHtjb25zdHJ1Y3RvclN0cmluZ30ob3V0cHV0WCk7XG4gICAgJHsgdGhpcy5fbWFwU3ViS2VybmVscyhzdWJLZXJuZWwgPT4gYGNvbnN0IHJlc3VsdF8keyBzdWJLZXJuZWwubmFtZSB9ID0gbmV3ICR7Y29uc3RydWN0b3JTdHJpbmd9KG91dHB1dFgpO1xcbmApLmpvaW4oJyAgICAnKSB9XG4gICAgJHsgdGhpcy5fbWFwU3ViS2VybmVscyhzdWJLZXJuZWwgPT4gYGxldCBzdWJLZXJuZWxSZXN1bHRfJHsgc3ViS2VybmVsLm5hbWUgfTtcXG5gKS5qb2luKCcgICAgJykgfVxuICAgIGZvciAobGV0IHggPSAwOyB4IDwgb3V0cHV0WDsgeCsrKSB7XG4gICAgICB0aGlzLnRocmVhZC54ID0geDtcbiAgICAgIHRoaXMudGhyZWFkLnkgPSAwO1xuICAgICAgdGhpcy50aHJlYWQueiA9IDA7XG4gICAgICAkeyBrZXJuZWxTdHJpbmcgfVxuICAgIH1gO1xuICB9XG5cbiAgX211dGFibGVLZXJuZWwxRFJlc3VsdHMoKSB7XG4gICAgY29uc3QgY29uc3RydWN0b3JTdHJpbmcgPSB0aGlzLl9nZXRLZXJuZWxSZXN1bHRUeXBlQ29uc3RydWN0b3JTdHJpbmcoKTtcbiAgICByZXR1cm4gYCAgY29uc3Qgb3V0cHV0WCA9IF90aGlzLm91dHB1dFswXTtcbiAgICBjb25zdCByZXN1bHQgPSBuZXcgJHtjb25zdHJ1Y3RvclN0cmluZ30ob3V0cHV0WCk7XG4gICAgJHsgdGhpcy5fbWFwU3ViS2VybmVscyhzdWJLZXJuZWwgPT4gYGNvbnN0IHJlc3VsdF8keyBzdWJLZXJuZWwubmFtZSB9ID0gbmV3ICR7Y29uc3RydWN0b3JTdHJpbmd9KG91dHB1dFgpO1xcbmApLmpvaW4oJyAgICAnKSB9XG4gICAgJHsgdGhpcy5fbWFwU3ViS2VybmVscyhzdWJLZXJuZWwgPT4gYGxldCBzdWJLZXJuZWxSZXN1bHRfJHsgc3ViS2VybmVsLm5hbWUgfTtcXG5gKS5qb2luKCcgICAgJykgfWA7XG4gIH1cblxuICBfcmVzdWx0TXV0YWJsZUtlcm5lbDFETG9vcChrZXJuZWxTdHJpbmcpIHtcbiAgICByZXR1cm4gYCAgY29uc3Qgb3V0cHV0WCA9IF90aGlzLm91dHB1dFswXTtcbiAgICBmb3IgKGxldCB4ID0gMDsgeCA8IG91dHB1dFg7IHgrKykge1xuICAgICAgdGhpcy50aHJlYWQueCA9IHg7XG4gICAgICB0aGlzLnRocmVhZC55ID0gMDtcbiAgICAgIHRoaXMudGhyZWFkLnogPSAwO1xuICAgICAgJHsga2VybmVsU3RyaW5nIH1cbiAgICB9YDtcbiAgfVxuXG4gIF9yZXN1bHRJbW11dGFibGVLZXJuZWwyRExvb3Aoa2VybmVsU3RyaW5nKSB7XG4gICAgY29uc3QgY29uc3RydWN0b3JTdHJpbmcgPSB0aGlzLl9nZXRLZXJuZWxSZXN1bHRUeXBlQ29uc3RydWN0b3JTdHJpbmcoKTtcbiAgICByZXR1cm4gYCAgY29uc3Qgb3V0cHV0WCA9IF90aGlzLm91dHB1dFswXTtcbiAgICBjb25zdCBvdXRwdXRZID0gX3RoaXMub3V0cHV0WzFdO1xuICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBBcnJheShvdXRwdXRZKTtcbiAgICAkeyB0aGlzLl9tYXBTdWJLZXJuZWxzKHN1Yktlcm5lbCA9PiBgY29uc3QgcmVzdWx0XyR7IHN1Yktlcm5lbC5uYW1lIH0gPSBuZXcgQXJyYXkob3V0cHV0WSk7XFxuYCkuam9pbignICAgICcpIH1cbiAgICAkeyB0aGlzLl9tYXBTdWJLZXJuZWxzKHN1Yktlcm5lbCA9PiBgbGV0IHN1Yktlcm5lbFJlc3VsdF8keyBzdWJLZXJuZWwubmFtZSB9O1xcbmApLmpvaW4oJyAgICAnKSB9XG4gICAgZm9yIChsZXQgeSA9IDA7IHkgPCBvdXRwdXRZOyB5KyspIHtcbiAgICAgIHRoaXMudGhyZWFkLnogPSAwO1xuICAgICAgdGhpcy50aHJlYWQueSA9IHk7XG4gICAgICBjb25zdCByZXN1bHRYID0gcmVzdWx0W3ldID0gbmV3ICR7Y29uc3RydWN0b3JTdHJpbmd9KG91dHB1dFgpO1xuICAgICAgJHsgdGhpcy5fbWFwU3ViS2VybmVscyhzdWJLZXJuZWwgPT4gYGNvbnN0IHJlc3VsdFhfJHsgc3ViS2VybmVsLm5hbWUgfSA9IHJlc3VsdF8ke3N1Yktlcm5lbC5uYW1lfVt5XSA9IG5ldyAke2NvbnN0cnVjdG9yU3RyaW5nfShvdXRwdXRYKTtcXG5gKS5qb2luKCcnKSB9XG4gICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IG91dHB1dFg7IHgrKykge1xuICAgICAgICB0aGlzLnRocmVhZC54ID0geDtcbiAgICAgICAgJHsga2VybmVsU3RyaW5nIH1cbiAgICAgIH1cbiAgICB9YDtcbiAgfVxuXG4gIF9tdXRhYmxlS2VybmVsMkRSZXN1bHRzKCkge1xuICAgIGNvbnN0IGNvbnN0cnVjdG9yU3RyaW5nID0gdGhpcy5fZ2V0S2VybmVsUmVzdWx0VHlwZUNvbnN0cnVjdG9yU3RyaW5nKCk7XG4gICAgcmV0dXJuIGAgIGNvbnN0IG91dHB1dFggPSBfdGhpcy5vdXRwdXRbMF07XG4gICAgY29uc3Qgb3V0cHV0WSA9IF90aGlzLm91dHB1dFsxXTtcbiAgICBjb25zdCByZXN1bHQgPSBuZXcgQXJyYXkob3V0cHV0WSk7XG4gICAgJHsgdGhpcy5fbWFwU3ViS2VybmVscyhzdWJLZXJuZWwgPT4gYGNvbnN0IHJlc3VsdF8keyBzdWJLZXJuZWwubmFtZSB9ID0gbmV3IEFycmF5KG91dHB1dFkpO1xcbmApLmpvaW4oJyAgICAnKSB9XG4gICAgJHsgdGhpcy5fbWFwU3ViS2VybmVscyhzdWJLZXJuZWwgPT4gYGxldCBzdWJLZXJuZWxSZXN1bHRfJHsgc3ViS2VybmVsLm5hbWUgfTtcXG5gKS5qb2luKCcgICAgJykgfVxuICAgIGZvciAobGV0IHkgPSAwOyB5IDwgb3V0cHV0WTsgeSsrKSB7XG4gICAgICBjb25zdCByZXN1bHRYID0gcmVzdWx0W3ldID0gbmV3ICR7Y29uc3RydWN0b3JTdHJpbmd9KG91dHB1dFgpO1xuICAgICAgJHsgdGhpcy5fbWFwU3ViS2VybmVscyhzdWJLZXJuZWwgPT4gYGNvbnN0IHJlc3VsdFhfJHsgc3ViS2VybmVsLm5hbWUgfSA9IHJlc3VsdF8ke3N1Yktlcm5lbC5uYW1lfVt5XSA9IG5ldyAke2NvbnN0cnVjdG9yU3RyaW5nfShvdXRwdXRYKTtcXG5gKS5qb2luKCcnKSB9XG4gICAgfWA7XG4gIH1cblxuICBfcmVzdWx0TXV0YWJsZUtlcm5lbDJETG9vcChrZXJuZWxTdHJpbmcpIHtcbiAgICBjb25zdCBjb25zdHJ1Y3RvclN0cmluZyA9IHRoaXMuX2dldEtlcm5lbFJlc3VsdFR5cGVDb25zdHJ1Y3RvclN0cmluZygpO1xuICAgIHJldHVybiBgICBjb25zdCBvdXRwdXRYID0gX3RoaXMub3V0cHV0WzBdO1xuICAgIGNvbnN0IG91dHB1dFkgPSBfdGhpcy5vdXRwdXRbMV07XG4gICAgZm9yIChsZXQgeSA9IDA7IHkgPCBvdXRwdXRZOyB5KyspIHtcbiAgICAgIHRoaXMudGhyZWFkLnogPSAwO1xuICAgICAgdGhpcy50aHJlYWQueSA9IHk7XG4gICAgICBjb25zdCByZXN1bHRYID0gcmVzdWx0W3ldO1xuICAgICAgJHsgdGhpcy5fbWFwU3ViS2VybmVscyhzdWJLZXJuZWwgPT4gYGNvbnN0IHJlc3VsdFhfJHsgc3ViS2VybmVsLm5hbWUgfSA9IHJlc3VsdF8ke3N1Yktlcm5lbC5uYW1lfVt5XSA9IG5ldyAke2NvbnN0cnVjdG9yU3RyaW5nfShvdXRwdXRYKTtcXG5gKS5qb2luKCcnKSB9XG4gICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IG91dHB1dFg7IHgrKykge1xuICAgICAgICB0aGlzLnRocmVhZC54ID0geDtcbiAgICAgICAgJHsga2VybmVsU3RyaW5nIH1cbiAgICAgIH1cbiAgICB9YDtcbiAgfVxuXG4gIF9ncmFwaGljYWxLZXJuZWwyRExvb3Aoa2VybmVsU3RyaW5nKSB7XG4gICAgcmV0dXJuIGAgIGNvbnN0IG91dHB1dFggPSBfdGhpcy5vdXRwdXRbMF07XG4gICAgY29uc3Qgb3V0cHV0WSA9IF90aGlzLm91dHB1dFsxXTtcbiAgICBmb3IgKGxldCB5ID0gMDsgeSA8IG91dHB1dFk7IHkrKykge1xuICAgICAgdGhpcy50aHJlYWQueiA9IDA7XG4gICAgICB0aGlzLnRocmVhZC55ID0geTtcbiAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgb3V0cHV0WDsgeCsrKSB7XG4gICAgICAgIHRoaXMudGhyZWFkLnggPSB4O1xuICAgICAgICAkeyBrZXJuZWxTdHJpbmcgfVxuICAgICAgfVxuICAgIH1gO1xuICB9XG5cbiAgX3Jlc3VsdEltbXV0YWJsZUtlcm5lbDNETG9vcChrZXJuZWxTdHJpbmcpIHtcbiAgICBjb25zdCBjb25zdHJ1Y3RvclN0cmluZyA9IHRoaXMuX2dldEtlcm5lbFJlc3VsdFR5cGVDb25zdHJ1Y3RvclN0cmluZygpO1xuICAgIHJldHVybiBgICBjb25zdCBvdXRwdXRYID0gX3RoaXMub3V0cHV0WzBdO1xuICAgIGNvbnN0IG91dHB1dFkgPSBfdGhpcy5vdXRwdXRbMV07XG4gICAgY29uc3Qgb3V0cHV0WiA9IF90aGlzLm91dHB1dFsyXTtcbiAgICBjb25zdCByZXN1bHQgPSBuZXcgQXJyYXkob3V0cHV0Wik7XG4gICAgJHsgdGhpcy5fbWFwU3ViS2VybmVscyhzdWJLZXJuZWwgPT4gYGNvbnN0IHJlc3VsdF8keyBzdWJLZXJuZWwubmFtZSB9ID0gbmV3IEFycmF5KG91dHB1dFopO1xcbmApLmpvaW4oJyAgICAnKSB9XG4gICAgJHsgdGhpcy5fbWFwU3ViS2VybmVscyhzdWJLZXJuZWwgPT4gYGxldCBzdWJLZXJuZWxSZXN1bHRfJHsgc3ViS2VybmVsLm5hbWUgfTtcXG5gKS5qb2luKCcgICAgJykgfVxuICAgIGZvciAobGV0IHogPSAwOyB6IDwgb3V0cHV0WjsgeisrKSB7XG4gICAgICB0aGlzLnRocmVhZC56ID0gejtcbiAgICAgIGNvbnN0IHJlc3VsdFkgPSByZXN1bHRbel0gPSBuZXcgQXJyYXkob3V0cHV0WSk7XG4gICAgICAkeyB0aGlzLl9tYXBTdWJLZXJuZWxzKHN1Yktlcm5lbCA9PiBgY29uc3QgcmVzdWx0WV8keyBzdWJLZXJuZWwubmFtZSB9ID0gcmVzdWx0XyR7c3ViS2VybmVsLm5hbWV9W3pdID0gbmV3IEFycmF5KG91dHB1dFkpO1xcbmApLmpvaW4oJyAgICAgICcpIH1cbiAgICAgIGZvciAobGV0IHkgPSAwOyB5IDwgb3V0cHV0WTsgeSsrKSB7XG4gICAgICAgIHRoaXMudGhyZWFkLnkgPSB5O1xuICAgICAgICBjb25zdCByZXN1bHRYID0gcmVzdWx0WVt5XSA9IG5ldyAke2NvbnN0cnVjdG9yU3RyaW5nfShvdXRwdXRYKTtcbiAgICAgICAgJHsgdGhpcy5fbWFwU3ViS2VybmVscyhzdWJLZXJuZWwgPT4gYGNvbnN0IHJlc3VsdFhfJHsgc3ViS2VybmVsLm5hbWUgfSA9IHJlc3VsdFlfJHtzdWJLZXJuZWwubmFtZX1beV0gPSBuZXcgJHtjb25zdHJ1Y3RvclN0cmluZ30ob3V0cHV0WCk7XFxuYCkuam9pbignICAgICAgICAnKSB9XG4gICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgb3V0cHV0WDsgeCsrKSB7XG4gICAgICAgICAgdGhpcy50aHJlYWQueCA9IHg7XG4gICAgICAgICAgJHsga2VybmVsU3RyaW5nIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1gO1xuICB9XG5cbiAgX211dGFibGVLZXJuZWwzRFJlc3VsdHMoKSB7XG4gICAgY29uc3QgY29uc3RydWN0b3JTdHJpbmcgPSB0aGlzLl9nZXRLZXJuZWxSZXN1bHRUeXBlQ29uc3RydWN0b3JTdHJpbmcoKTtcbiAgICByZXR1cm4gYCAgY29uc3Qgb3V0cHV0WCA9IF90aGlzLm91dHB1dFswXTtcbiAgICBjb25zdCBvdXRwdXRZID0gX3RoaXMub3V0cHV0WzFdO1xuICAgIGNvbnN0IG91dHB1dFogPSBfdGhpcy5vdXRwdXRbMl07XG4gICAgY29uc3QgcmVzdWx0ID0gbmV3IEFycmF5KG91dHB1dFopO1xuICAgICR7IHRoaXMuX21hcFN1Yktlcm5lbHMoc3ViS2VybmVsID0+IGBjb25zdCByZXN1bHRfJHsgc3ViS2VybmVsLm5hbWUgfSA9IG5ldyBBcnJheShvdXRwdXRaKTtcXG5gKS5qb2luKCcgICAgJykgfVxuICAgICR7IHRoaXMuX21hcFN1Yktlcm5lbHMoc3ViS2VybmVsID0+IGBsZXQgc3ViS2VybmVsUmVzdWx0XyR7IHN1Yktlcm5lbC5uYW1lIH07XFxuYCkuam9pbignICAgICcpIH1cbiAgICBmb3IgKGxldCB6ID0gMDsgeiA8IG91dHB1dFo7IHorKykge1xuICAgICAgY29uc3QgcmVzdWx0WSA9IHJlc3VsdFt6XSA9IG5ldyBBcnJheShvdXRwdXRZKTtcbiAgICAgICR7IHRoaXMuX21hcFN1Yktlcm5lbHMoc3ViS2VybmVsID0+IGBjb25zdCByZXN1bHRZXyR7IHN1Yktlcm5lbC5uYW1lIH0gPSByZXN1bHRfJHtzdWJLZXJuZWwubmFtZX1bel0gPSBuZXcgQXJyYXkob3V0cHV0WSk7XFxuYCkuam9pbignICAgICAgJykgfVxuICAgICAgZm9yIChsZXQgeSA9IDA7IHkgPCBvdXRwdXRZOyB5KyspIHtcbiAgICAgICAgY29uc3QgcmVzdWx0WCA9IHJlc3VsdFlbeV0gPSBuZXcgJHtjb25zdHJ1Y3RvclN0cmluZ30ob3V0cHV0WCk7XG4gICAgICAgICR7IHRoaXMuX21hcFN1Yktlcm5lbHMoc3ViS2VybmVsID0+IGBjb25zdCByZXN1bHRYXyR7IHN1Yktlcm5lbC5uYW1lIH0gPSByZXN1bHRZXyR7c3ViS2VybmVsLm5hbWV9W3ldID0gbmV3ICR7Y29uc3RydWN0b3JTdHJpbmd9KG91dHB1dFgpO1xcbmApLmpvaW4oJyAgICAgICAgJykgfVxuICAgICAgfVxuICAgIH1gO1xuICB9XG5cbiAgX3Jlc3VsdE11dGFibGVLZXJuZWwzRExvb3Aoa2VybmVsU3RyaW5nKSB7XG4gICAgcmV0dXJuIGAgIGNvbnN0IG91dHB1dFggPSBfdGhpcy5vdXRwdXRbMF07XG4gICAgY29uc3Qgb3V0cHV0WSA9IF90aGlzLm91dHB1dFsxXTtcbiAgICBjb25zdCBvdXRwdXRaID0gX3RoaXMub3V0cHV0WzJdO1xuICAgIGZvciAobGV0IHogPSAwOyB6IDwgb3V0cHV0WjsgeisrKSB7XG4gICAgICB0aGlzLnRocmVhZC56ID0gejtcbiAgICAgIGNvbnN0IHJlc3VsdFkgPSByZXN1bHRbel07XG4gICAgICBmb3IgKGxldCB5ID0gMDsgeSA8IG91dHB1dFk7IHkrKykge1xuICAgICAgICB0aGlzLnRocmVhZC55ID0geTtcbiAgICAgICAgY29uc3QgcmVzdWx0WCA9IHJlc3VsdFlbeV07XG4gICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgb3V0cHV0WDsgeCsrKSB7XG4gICAgICAgICAgdGhpcy50aHJlYWQueCA9IHg7XG4gICAgICAgICAgJHsga2VybmVsU3RyaW5nIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1gO1xuICB9XG5cbiAgX2tlcm5lbE91dHB1dCgpIHtcbiAgICBpZiAoIXRoaXMuc3ViS2VybmVscykge1xuICAgICAgcmV0dXJuICdcXG4gICAgcmV0dXJuIHJlc3VsdDsnO1xuICAgIH1cbiAgICByZXR1cm4gYFxcbiAgICByZXR1cm4ge1xuICAgICAgcmVzdWx0OiByZXN1bHQsXG4gICAgICAkeyB0aGlzLnN1Yktlcm5lbHMubWFwKHN1Yktlcm5lbCA9PiBgJHsgc3ViS2VybmVsLnByb3BlcnR5IH06IHJlc3VsdF8keyBzdWJLZXJuZWwubmFtZSB9YCkuam9pbignLFxcbiAgICAgICcpIH1cbiAgICB9O2A7XG4gIH1cblxuICBfbWFwU3ViS2VybmVscyhmbikge1xuICAgIHJldHVybiB0aGlzLnN1Yktlcm5lbHMgPT09IG51bGwgPyBbJyddIDpcbiAgICAgIHRoaXMuc3ViS2VybmVscy5tYXAoZm4pO1xuICB9XG5cbiAgZGVzdHJveShyZW1vdmVDYW52YXNSZWZlcmVuY2UpIHtcbiAgICBpZiAocmVtb3ZlQ2FudmFzUmVmZXJlbmNlKSB7XG4gICAgICBkZWxldGUgdGhpcy5jYW52YXM7XG4gICAgfVxuICB9XG5cbiAgc3RhdGljIGRlc3Ryb3lDb250ZXh0KGNvbnRleHQpIHt9XG5cbiAgdG9KU09OKCkge1xuICAgIGNvbnN0IGpzb24gPSBzdXBlci50b0pTT04oKTtcbiAgICBqc29uLmZ1bmN0aW9uTm9kZXMgPSBGdW5jdGlvbkJ1aWxkZXIuZnJvbUtlcm5lbCh0aGlzLCBDUFVGdW5jdGlvbk5vZGUpLnRvSlNPTigpO1xuICAgIHJldHVybiBqc29uO1xuICB9XG5cbiAgc2V0T3V0cHV0KG91dHB1dCkge1xuICAgIHN1cGVyLnNldE91dHB1dChvdXRwdXQpO1xuICAgIGNvbnN0IFt3aWR0aCwgaGVpZ2h0XSA9IHRoaXMub3V0cHV0O1xuICAgIGlmICh0aGlzLmdyYXBoaWNhbCkge1xuICAgICAgdGhpcy5faW1hZ2VEYXRhID0gdGhpcy5jb250ZXh0LmNyZWF0ZUltYWdlRGF0YSh3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIHRoaXMuX2NvbG9yRGF0YSA9IG5ldyBVaW50OENsYW1wZWRBcnJheSh3aWR0aCAqIGhlaWdodCAqIDQpO1xuICAgIH1cbiAgfVxuXG4gIHByZXBlbmRTdHJpbmcodmFsdWUpIHtcbiAgICBpZiAodGhpcy5fa2VybmVsU3RyaW5nKSB0aHJvdyBuZXcgRXJyb3IoJ0tlcm5lbCBhbHJlYWR5IGJ1aWx0Jyk7XG4gICAgdGhpcy5fcHJlcGVuZGVkU3RyaW5nLnB1c2godmFsdWUpO1xuICB9XG5cbiAgaGFzUHJlcGVuZFN0cmluZyh2YWx1ZSkge1xuICAgIHJldHVybiB0aGlzLl9wcmVwZW5kZWRTdHJpbmcuaW5kZXhPZih2YWx1ZSkgPiAtMTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgQ1BVS2VybmVsXG59O1xufSx7XCIuLi8uLi91dGlsc1wiOjExNCxcIi4uL2Z1bmN0aW9uLWJ1aWxkZXJcIjo5LFwiLi4va2VybmVsXCI6MzYsXCIuL2Z1bmN0aW9uLW5vZGVcIjo2LFwiLi9rZXJuZWwtc3RyaW5nXCI6N31dLDk6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuY2xhc3MgRnVuY3Rpb25CdWlsZGVyIHtcbiAgc3RhdGljIGZyb21LZXJuZWwoa2VybmVsLCBGdW5jdGlvbk5vZGUsIGV4dHJhTm9kZU9wdGlvbnMpIHtcbiAgICBjb25zdCB7XG4gICAgICBrZXJuZWxBcmd1bWVudHMsXG4gICAgICBrZXJuZWxDb25zdGFudHMsXG4gICAgICBhcmd1bWVudE5hbWVzLFxuICAgICAgYXJndW1lbnRTaXplcyxcbiAgICAgIGFyZ3VtZW50Qml0UmF0aW9zLFxuICAgICAgY29uc3RhbnRzLFxuICAgICAgY29uc3RhbnRCaXRSYXRpb3MsXG4gICAgICBkZWJ1ZyxcbiAgICAgIGxvb3BNYXhJdGVyYXRpb25zLFxuICAgICAgbmF0aXZlRnVuY3Rpb25zLFxuICAgICAgb3V0cHV0LFxuICAgICAgb3B0aW1pemVGbG9hdE1lbW9yeSxcbiAgICAgIHByZWNpc2lvbixcbiAgICAgIHBsdWdpbnMsXG4gICAgICBzb3VyY2UsXG4gICAgICBzdWJLZXJuZWxzLFxuICAgICAgZnVuY3Rpb25zLFxuICAgICAgbGVhZGluZ1JldHVyblN0YXRlbWVudCxcbiAgICAgIGZvbGxvd2luZ1JldHVyblN0YXRlbWVudCxcbiAgICAgIGR5bmFtaWNBcmd1bWVudHMsXG4gICAgICBkeW5hbWljT3V0cHV0LFxuICAgIH0gPSBrZXJuZWw7XG5cbiAgICBjb25zdCBhcmd1bWVudFR5cGVzID0gbmV3IEFycmF5KGtlcm5lbEFyZ3VtZW50cy5sZW5ndGgpO1xuICAgIGNvbnN0IGNvbnN0YW50VHlwZXMgPSB7fTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwga2VybmVsQXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBhcmd1bWVudFR5cGVzW2ldID0ga2VybmVsQXJndW1lbnRzW2ldLnR5cGU7XG4gICAgfVxuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXJuZWxDb25zdGFudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGtlcm5lbENvbnN0YW50ID0ga2VybmVsQ29uc3RhbnRzW2ldO1xuICAgICAgY29uc3RhbnRUeXBlc1trZXJuZWxDb25zdGFudC5uYW1lXSA9IGtlcm5lbENvbnN0YW50LnR5cGU7XG4gICAgfVxuXG4gICAgY29uc3QgbmVlZHNBcmd1bWVudFR5cGUgPSAoZnVuY3Rpb25OYW1lLCBpbmRleCkgPT4ge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uQnVpbGRlci5uZWVkc0FyZ3VtZW50VHlwZShmdW5jdGlvbk5hbWUsIGluZGV4KTtcbiAgICB9O1xuXG4gICAgY29uc3QgYXNzaWduQXJndW1lbnRUeXBlID0gKGZ1bmN0aW9uTmFtZSwgaW5kZXgsIHR5cGUpID0+IHtcbiAgICAgIGZ1bmN0aW9uQnVpbGRlci5hc3NpZ25Bcmd1bWVudFR5cGUoZnVuY3Rpb25OYW1lLCBpbmRleCwgdHlwZSk7XG4gICAgfTtcblxuICAgIGNvbnN0IGxvb2t1cFJldHVyblR5cGUgPSAoZnVuY3Rpb25OYW1lLCBhc3QsIHJlcXVlc3RpbmdOb2RlKSA9PiB7XG4gICAgICByZXR1cm4gZnVuY3Rpb25CdWlsZGVyLmxvb2t1cFJldHVyblR5cGUoZnVuY3Rpb25OYW1lLCBhc3QsIHJlcXVlc3RpbmdOb2RlKTtcbiAgICB9O1xuXG4gICAgY29uc3QgbG9va3VwRnVuY3Rpb25Bcmd1bWVudFR5cGVzID0gKGZ1bmN0aW9uTmFtZSkgPT4ge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uQnVpbGRlci5sb29rdXBGdW5jdGlvbkFyZ3VtZW50VHlwZXMoZnVuY3Rpb25OYW1lKTtcbiAgICB9O1xuXG4gICAgY29uc3QgbG9va3VwRnVuY3Rpb25Bcmd1bWVudE5hbWUgPSAoZnVuY3Rpb25OYW1lLCBhcmd1bWVudEluZGV4KSA9PiB7XG4gICAgICByZXR1cm4gZnVuY3Rpb25CdWlsZGVyLmxvb2t1cEZ1bmN0aW9uQXJndW1lbnROYW1lKGZ1bmN0aW9uTmFtZSwgYXJndW1lbnRJbmRleCk7XG4gICAgfTtcblxuICAgIGNvbnN0IGxvb2t1cEZ1bmN0aW9uQXJndW1lbnRCaXRSYXRpbyA9IChmdW5jdGlvbk5hbWUsIGFyZ3VtZW50TmFtZSkgPT4ge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uQnVpbGRlci5sb29rdXBGdW5jdGlvbkFyZ3VtZW50Qml0UmF0aW8oZnVuY3Rpb25OYW1lLCBhcmd1bWVudE5hbWUpO1xuICAgIH07XG5cbiAgICBjb25zdCB0cmlnZ2VySW1wbHlBcmd1bWVudFR5cGUgPSAoZnVuY3Rpb25OYW1lLCBpLCBhcmd1bWVudFR5cGUsIHJlcXVlc3RpbmdOb2RlKSA9PiB7XG4gICAgICBmdW5jdGlvbkJ1aWxkZXIuYXNzaWduQXJndW1lbnRUeXBlKGZ1bmN0aW9uTmFtZSwgaSwgYXJndW1lbnRUeXBlLCByZXF1ZXN0aW5nTm9kZSk7XG4gICAgfTtcblxuICAgIGNvbnN0IHRyaWdnZXJJbXBseUFyZ3VtZW50Qml0UmF0aW8gPSAoZnVuY3Rpb25OYW1lLCBhcmd1bWVudE5hbWUsIGNhbGxlZUZ1bmN0aW9uTmFtZSwgYXJndW1lbnRJbmRleCkgPT4ge1xuICAgICAgZnVuY3Rpb25CdWlsZGVyLmFzc2lnbkFyZ3VtZW50Qml0UmF0aW8oZnVuY3Rpb25OYW1lLCBhcmd1bWVudE5hbWUsIGNhbGxlZUZ1bmN0aW9uTmFtZSwgYXJndW1lbnRJbmRleCk7XG4gICAgfTtcblxuICAgIGNvbnN0IG9uRnVuY3Rpb25DYWxsID0gKGZ1bmN0aW9uTmFtZSwgY2FsbGVlRnVuY3Rpb25OYW1lLCBhcmdzKSA9PiB7XG4gICAgICBmdW5jdGlvbkJ1aWxkZXIudHJhY2tGdW5jdGlvbkNhbGwoZnVuY3Rpb25OYW1lLCBjYWxsZWVGdW5jdGlvbk5hbWUsIGFyZ3MpO1xuICAgIH07XG5cbiAgICBjb25zdCBvbk5lc3RlZEZ1bmN0aW9uID0gKGFzdCwgc291cmNlKSA9PiB7XG4gICAgICBjb25zdCBhcmd1bWVudE5hbWVzID0gW107XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFzdC5wYXJhbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgYXJndW1lbnROYW1lcy5wdXNoKGFzdC5wYXJhbXNbaV0ubmFtZSk7XG4gICAgICB9XG4gICAgICBjb25zdCBuZXN0ZWRGdW5jdGlvbiA9IG5ldyBGdW5jdGlvbk5vZGUoc291cmNlLCBPYmplY3QuYXNzaWduKHt9LCBub2RlT3B0aW9ucywge1xuICAgICAgICByZXR1cm5UeXBlOiBudWxsLFxuICAgICAgICBhc3QsXG4gICAgICAgIG5hbWU6IGFzdC5pZC5uYW1lLFxuICAgICAgICBhcmd1bWVudE5hbWVzLFxuICAgICAgICBsb29rdXBSZXR1cm5UeXBlLFxuICAgICAgICBsb29rdXBGdW5jdGlvbkFyZ3VtZW50VHlwZXMsXG4gICAgICAgIGxvb2t1cEZ1bmN0aW9uQXJndW1lbnROYW1lLFxuICAgICAgICBsb29rdXBGdW5jdGlvbkFyZ3VtZW50Qml0UmF0aW8sXG4gICAgICAgIG5lZWRzQXJndW1lbnRUeXBlLFxuICAgICAgICBhc3NpZ25Bcmd1bWVudFR5cGUsXG4gICAgICAgIHRyaWdnZXJJbXBseUFyZ3VtZW50VHlwZSxcbiAgICAgICAgdHJpZ2dlckltcGx5QXJndW1lbnRCaXRSYXRpbyxcbiAgICAgICAgb25GdW5jdGlvbkNhbGwsXG4gICAgICB9KSk7XG4gICAgICBuZXN0ZWRGdW5jdGlvbi50cmFjZUZ1bmN0aW9uQVNUKGFzdCk7XG4gICAgICBmdW5jdGlvbkJ1aWxkZXIuYWRkRnVuY3Rpb25Ob2RlKG5lc3RlZEZ1bmN0aW9uKTtcbiAgICB9O1xuXG4gICAgY29uc3Qgbm9kZU9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHtcbiAgICAgIGlzUm9vdEtlcm5lbDogZmFsc2UsXG4gICAgICBvbk5lc3RlZEZ1bmN0aW9uLFxuICAgICAgbG9va3VwUmV0dXJuVHlwZSxcbiAgICAgIGxvb2t1cEZ1bmN0aW9uQXJndW1lbnRUeXBlcyxcbiAgICAgIGxvb2t1cEZ1bmN0aW9uQXJndW1lbnROYW1lLFxuICAgICAgbG9va3VwRnVuY3Rpb25Bcmd1bWVudEJpdFJhdGlvLFxuICAgICAgbmVlZHNBcmd1bWVudFR5cGUsXG4gICAgICBhc3NpZ25Bcmd1bWVudFR5cGUsXG4gICAgICB0cmlnZ2VySW1wbHlBcmd1bWVudFR5cGUsXG4gICAgICB0cmlnZ2VySW1wbHlBcmd1bWVudEJpdFJhdGlvLFxuICAgICAgb25GdW5jdGlvbkNhbGwsXG4gICAgICBvcHRpbWl6ZUZsb2F0TWVtb3J5LFxuICAgICAgcHJlY2lzaW9uLFxuICAgICAgY29uc3RhbnRzLFxuICAgICAgY29uc3RhbnRUeXBlcyxcbiAgICAgIGNvbnN0YW50Qml0UmF0aW9zLFxuICAgICAgZGVidWcsXG4gICAgICBsb29wTWF4SXRlcmF0aW9ucyxcbiAgICAgIG91dHB1dCxcbiAgICAgIHBsdWdpbnMsXG4gICAgICBkeW5hbWljQXJndW1lbnRzLFxuICAgICAgZHluYW1pY091dHB1dCxcbiAgICB9LCBleHRyYU5vZGVPcHRpb25zIHx8IHt9KTtcblxuICAgIGNvbnN0IHJvb3ROb2RlT3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIG5vZGVPcHRpb25zLCB7XG4gICAgICBpc1Jvb3RLZXJuZWw6IHRydWUsXG4gICAgICBuYW1lOiAna2VybmVsJyxcbiAgICAgIGFyZ3VtZW50TmFtZXMsXG4gICAgICBhcmd1bWVudFR5cGVzLFxuICAgICAgYXJndW1lbnRTaXplcyxcbiAgICAgIGFyZ3VtZW50Qml0UmF0aW9zLFxuICAgICAgbGVhZGluZ1JldHVyblN0YXRlbWVudCxcbiAgICAgIGZvbGxvd2luZ1JldHVyblN0YXRlbWVudCxcbiAgICB9KTtcblxuICAgIGlmICh0eXBlb2Ygc291cmNlID09PSAnb2JqZWN0JyAmJiBzb3VyY2UuZnVuY3Rpb25Ob2Rlcykge1xuICAgICAgcmV0dXJuIG5ldyBGdW5jdGlvbkJ1aWxkZXIoKS5mcm9tSlNPTihzb3VyY2UuZnVuY3Rpb25Ob2RlcywgRnVuY3Rpb25Ob2RlKTtcbiAgICB9XG5cbiAgICBjb25zdCByb290Tm9kZSA9IG5ldyBGdW5jdGlvbk5vZGUoc291cmNlLCByb290Tm9kZU9wdGlvbnMpO1xuXG4gICAgbGV0IGZ1bmN0aW9uTm9kZXMgPSBudWxsO1xuICAgIGlmIChmdW5jdGlvbnMpIHtcbiAgICAgIGZ1bmN0aW9uTm9kZXMgPSBmdW5jdGlvbnMubWFwKChmbikgPT4gbmV3IEZ1bmN0aW9uTm9kZShmbi5zb3VyY2UsIHtcbiAgICAgICAgcmV0dXJuVHlwZTogZm4ucmV0dXJuVHlwZSxcbiAgICAgICAgYXJndW1lbnRUeXBlczogZm4uYXJndW1lbnRUeXBlcyxcbiAgICAgICAgb3V0cHV0LFxuICAgICAgICBwbHVnaW5zLFxuICAgICAgICBjb25zdGFudHMsXG4gICAgICAgIGNvbnN0YW50VHlwZXMsXG4gICAgICAgIGNvbnN0YW50Qml0UmF0aW9zLFxuICAgICAgICBvcHRpbWl6ZUZsb2F0TWVtb3J5LFxuICAgICAgICBwcmVjaXNpb24sXG4gICAgICAgIGxvb2t1cFJldHVyblR5cGUsXG4gICAgICAgIGxvb2t1cEZ1bmN0aW9uQXJndW1lbnRUeXBlcyxcbiAgICAgICAgbG9va3VwRnVuY3Rpb25Bcmd1bWVudE5hbWUsXG4gICAgICAgIGxvb2t1cEZ1bmN0aW9uQXJndW1lbnRCaXRSYXRpbyxcbiAgICAgICAgbmVlZHNBcmd1bWVudFR5cGUsXG4gICAgICAgIGFzc2lnbkFyZ3VtZW50VHlwZSxcbiAgICAgICAgdHJpZ2dlckltcGx5QXJndW1lbnRUeXBlLFxuICAgICAgICB0cmlnZ2VySW1wbHlBcmd1bWVudEJpdFJhdGlvLFxuICAgICAgICBvbkZ1bmN0aW9uQ2FsbCxcbiAgICAgICAgb25OZXN0ZWRGdW5jdGlvbixcbiAgICAgIH0pKTtcbiAgICB9XG5cbiAgICBsZXQgc3ViS2VybmVsTm9kZXMgPSBudWxsO1xuICAgIGlmIChzdWJLZXJuZWxzKSB7XG4gICAgICBzdWJLZXJuZWxOb2RlcyA9IHN1Yktlcm5lbHMubWFwKChzdWJLZXJuZWwpID0+IHtcbiAgICAgICAgY29uc3QgeyBuYW1lLCBzb3VyY2UgfSA9IHN1Yktlcm5lbDtcbiAgICAgICAgcmV0dXJuIG5ldyBGdW5jdGlvbk5vZGUoc291cmNlLCBPYmplY3QuYXNzaWduKHt9LCBub2RlT3B0aW9ucywge1xuICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgaXNTdWJLZXJuZWw6IHRydWUsXG4gICAgICAgICAgaXNSb290S2VybmVsOiBmYWxzZSxcbiAgICAgICAgfSkpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgY29uc3QgZnVuY3Rpb25CdWlsZGVyID0gbmV3IEZ1bmN0aW9uQnVpbGRlcih7XG4gICAgICBrZXJuZWwsXG4gICAgICByb290Tm9kZSxcbiAgICAgIGZ1bmN0aW9uTm9kZXMsXG4gICAgICBuYXRpdmVGdW5jdGlvbnMsXG4gICAgICBzdWJLZXJuZWxOb2Rlc1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uQnVpbGRlcjtcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKHNldHRpbmdzKSB7XG4gICAgc2V0dGluZ3MgPSBzZXR0aW5ncyB8fCB7fTtcbiAgICB0aGlzLmtlcm5lbCA9IHNldHRpbmdzLmtlcm5lbDtcbiAgICB0aGlzLnJvb3ROb2RlID0gc2V0dGluZ3Mucm9vdE5vZGU7XG4gICAgdGhpcy5mdW5jdGlvbk5vZGVzID0gc2V0dGluZ3MuZnVuY3Rpb25Ob2RlcyB8fCBbXTtcbiAgICB0aGlzLnN1Yktlcm5lbE5vZGVzID0gc2V0dGluZ3Muc3ViS2VybmVsTm9kZXMgfHwgW107XG4gICAgdGhpcy5uYXRpdmVGdW5jdGlvbnMgPSBzZXR0aW5ncy5uYXRpdmVGdW5jdGlvbnMgfHwgW107XG4gICAgdGhpcy5mdW5jdGlvbk1hcCA9IHt9O1xuICAgIHRoaXMubmF0aXZlRnVuY3Rpb25OYW1lcyA9IFtdO1xuICAgIHRoaXMubG9va3VwQ2hhaW4gPSBbXTtcbiAgICB0aGlzLmZ1bmN0aW9uTm9kZURlcGVuZGVuY2llcyA9IHt9O1xuICAgIHRoaXMuZnVuY3Rpb25DYWxscyA9IHt9O1xuXG4gICAgaWYgKHRoaXMucm9vdE5vZGUpIHtcbiAgICAgIHRoaXMuZnVuY3Rpb25NYXBbJ2tlcm5lbCddID0gdGhpcy5yb290Tm9kZTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5mdW5jdGlvbk5vZGVzKSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuZnVuY3Rpb25Ob2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLmZ1bmN0aW9uTWFwW3RoaXMuZnVuY3Rpb25Ob2Rlc1tpXS5uYW1lXSA9IHRoaXMuZnVuY3Rpb25Ob2Rlc1tpXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5zdWJLZXJuZWxOb2Rlcykge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnN1Yktlcm5lbE5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMuZnVuY3Rpb25NYXBbdGhpcy5zdWJLZXJuZWxOb2Rlc1tpXS5uYW1lXSA9IHRoaXMuc3ViS2VybmVsTm9kZXNbaV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMubmF0aXZlRnVuY3Rpb25zKSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubmF0aXZlRnVuY3Rpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IG5hdGl2ZUZ1bmN0aW9uID0gdGhpcy5uYXRpdmVGdW5jdGlvbnNbaV07XG4gICAgICAgIHRoaXMubmF0aXZlRnVuY3Rpb25OYW1lcy5wdXNoKG5hdGl2ZUZ1bmN0aW9uLm5hbWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGFkZEZ1bmN0aW9uTm9kZShmdW5jdGlvbk5vZGUpIHtcbiAgICBpZiAoIWZ1bmN0aW9uTm9kZS5uYW1lKSB0aHJvdyBuZXcgRXJyb3IoJ2Z1bmN0aW9uTm9kZS5uYW1lIG5lZWRzIHNldCcpO1xuICAgIHRoaXMuZnVuY3Rpb25NYXBbZnVuY3Rpb25Ob2RlLm5hbWVdID0gZnVuY3Rpb25Ob2RlO1xuICAgIGlmIChmdW5jdGlvbk5vZGUuaXNSb290S2VybmVsKSB7XG4gICAgICB0aGlzLnJvb3ROb2RlID0gZnVuY3Rpb25Ob2RlO1xuICAgIH1cbiAgfVxuXG4gIHRyYWNlRnVuY3Rpb25DYWxscyhmdW5jdGlvbk5hbWUsIHJldExpc3QpIHtcbiAgICBmdW5jdGlvbk5hbWUgPSBmdW5jdGlvbk5hbWUgfHwgJ2tlcm5lbCc7XG4gICAgcmV0TGlzdCA9IHJldExpc3QgfHwgW107XG5cbiAgICBpZiAodGhpcy5uYXRpdmVGdW5jdGlvbk5hbWVzLmluZGV4T2YoZnVuY3Rpb25OYW1lKSA+IC0xKSB7XG4gICAgICBjb25zdCBuYXRpdmVGdW5jdGlvbkluZGV4ID0gcmV0TGlzdC5pbmRleE9mKGZ1bmN0aW9uTmFtZSk7XG4gICAgICBpZiAobmF0aXZlRnVuY3Rpb25JbmRleCA9PT0gLTEpIHtcbiAgICAgICAgcmV0TGlzdC5wdXNoKGZ1bmN0aW9uTmFtZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBkZXBlbmRhbnROYXRpdmVGdW5jdGlvbk5hbWUgPSByZXRMaXN0LnNwbGljZShuYXRpdmVGdW5jdGlvbkluZGV4LCAxKVswXTtcbiAgICAgICAgcmV0TGlzdC5wdXNoKGRlcGVuZGFudE5hdGl2ZUZ1bmN0aW9uTmFtZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmV0TGlzdDtcbiAgICB9XG5cbiAgICBjb25zdCBmdW5jdGlvbk5vZGUgPSB0aGlzLmZ1bmN0aW9uTWFwW2Z1bmN0aW9uTmFtZV07XG4gICAgaWYgKGZ1bmN0aW9uTm9kZSkge1xuICAgICAgY29uc3QgZnVuY3Rpb25JbmRleCA9IHJldExpc3QuaW5kZXhPZihmdW5jdGlvbk5hbWUpO1xuICAgICAgaWYgKGZ1bmN0aW9uSW5kZXggPT09IC0xKSB7XG4gICAgICAgIHJldExpc3QucHVzaChmdW5jdGlvbk5hbWUpO1xuICAgICAgICBmdW5jdGlvbk5vZGUudG9TdHJpbmcoKTsgXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZnVuY3Rpb25Ob2RlLmNhbGxlZEZ1bmN0aW9ucy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIHRoaXMudHJhY2VGdW5jdGlvbkNhbGxzKGZ1bmN0aW9uTm9kZS5jYWxsZWRGdW5jdGlvbnNbaV0sIHJldExpc3QpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBkZXBlbmRhbnRGdW5jdGlvbk5hbWUgPSByZXRMaXN0LnNwbGljZShmdW5jdGlvbkluZGV4LCAxKVswXTtcbiAgICAgICAgcmV0TGlzdC5wdXNoKGRlcGVuZGFudEZ1bmN0aW9uTmFtZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJldExpc3Q7XG4gIH1cblxuICBnZXRQcm90b3R5cGVTdHJpbmcoZnVuY3Rpb25OYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0UHJvdG90eXBlcyhmdW5jdGlvbk5hbWUpLmpvaW4oJ1xcbicpO1xuICB9XG5cbiAgZ2V0UHJvdG90eXBlcyhmdW5jdGlvbk5hbWUpIHtcbiAgICBpZiAodGhpcy5yb290Tm9kZSkge1xuICAgICAgdGhpcy5yb290Tm9kZS50b1N0cmluZygpO1xuICAgIH1cbiAgICBpZiAoZnVuY3Rpb25OYW1lKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRQcm90b3R5cGVzRnJvbUZ1bmN0aW9uTmFtZXModGhpcy50cmFjZUZ1bmN0aW9uQ2FsbHMoZnVuY3Rpb25OYW1lLCBbXSkucmV2ZXJzZSgpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZ2V0UHJvdG90eXBlc0Zyb21GdW5jdGlvbk5hbWVzKE9iamVjdC5rZXlzKHRoaXMuZnVuY3Rpb25NYXApKTtcbiAgfVxuXG4gIGdldFN0cmluZ0Zyb21GdW5jdGlvbk5hbWVzKGZ1bmN0aW9uTGlzdCkge1xuICAgIGNvbnN0IHJldCA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZnVuY3Rpb25MaXN0Lmxlbmd0aDsgKytpKSB7XG4gICAgICBjb25zdCBub2RlID0gdGhpcy5mdW5jdGlvbk1hcFtmdW5jdGlvbkxpc3RbaV1dO1xuICAgICAgaWYgKG5vZGUpIHtcbiAgICAgICAgcmV0LnB1c2godGhpcy5mdW5jdGlvbk1hcFtmdW5jdGlvbkxpc3RbaV1dLnRvU3RyaW5nKCkpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmV0LmpvaW4oJ1xcbicpO1xuICB9XG5cbiAgZ2V0UHJvdG90eXBlc0Zyb21GdW5jdGlvbk5hbWVzKGZ1bmN0aW9uTGlzdCkge1xuICAgIGNvbnN0IHJldCA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZnVuY3Rpb25MaXN0Lmxlbmd0aDsgKytpKSB7XG4gICAgICBjb25zdCBmdW5jdGlvbk5hbWUgPSBmdW5jdGlvbkxpc3RbaV07XG4gICAgICBjb25zdCBmdW5jdGlvbkluZGV4ID0gdGhpcy5uYXRpdmVGdW5jdGlvbk5hbWVzLmluZGV4T2YoZnVuY3Rpb25OYW1lKTtcbiAgICAgIGlmIChmdW5jdGlvbkluZGV4ID4gLTEpIHtcbiAgICAgICAgcmV0LnB1c2godGhpcy5uYXRpdmVGdW5jdGlvbnNbZnVuY3Rpb25JbmRleF0uc291cmNlKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCBub2RlID0gdGhpcy5mdW5jdGlvbk1hcFtmdW5jdGlvbk5hbWVdO1xuICAgICAgaWYgKG5vZGUpIHtcbiAgICAgICAgcmV0LnB1c2gobm9kZS50b1N0cmluZygpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuXG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4gdGhpcy50cmFjZUZ1bmN0aW9uQ2FsbHModGhpcy5yb290Tm9kZS5uYW1lKS5yZXZlcnNlKCkubWFwKG5hbWUgPT4ge1xuICAgICAgY29uc3QgbmF0aXZlSW5kZXggPSB0aGlzLm5hdGl2ZUZ1bmN0aW9ucy5pbmRleE9mKG5hbWUpO1xuICAgICAgaWYgKG5hdGl2ZUluZGV4ID4gLTEpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBuYW1lLFxuICAgICAgICAgIHNvdXJjZTogdGhpcy5uYXRpdmVGdW5jdGlvbnNbbmF0aXZlSW5kZXhdLnNvdXJjZVxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIGlmICh0aGlzLmZ1bmN0aW9uTWFwW25hbWVdKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZ1bmN0aW9uTWFwW25hbWVdLnRvSlNPTigpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBmdW5jdGlvbiAkeyBuYW1lIH0gbm90IGZvdW5kYCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBmcm9tSlNPTihqc29uRnVuY3Rpb25Ob2RlcywgRnVuY3Rpb25Ob2RlKSB7XG4gICAgdGhpcy5mdW5jdGlvbk1hcCA9IHt9O1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwganNvbkZ1bmN0aW9uTm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGpzb25GdW5jdGlvbk5vZGUgPSBqc29uRnVuY3Rpb25Ob2Rlc1tpXTtcbiAgICAgIHRoaXMuZnVuY3Rpb25NYXBbanNvbkZ1bmN0aW9uTm9kZS5zZXR0aW5ncy5uYW1lXSA9IG5ldyBGdW5jdGlvbk5vZGUoanNvbkZ1bmN0aW9uTm9kZS5hc3QsIGpzb25GdW5jdGlvbk5vZGUuc2V0dGluZ3MpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGdldFN0cmluZyhmdW5jdGlvbk5hbWUpIHtcbiAgICBpZiAoZnVuY3Rpb25OYW1lKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRTdHJpbmdGcm9tRnVuY3Rpb25OYW1lcyh0aGlzLnRyYWNlRnVuY3Rpb25DYWxscyhmdW5jdGlvbk5hbWUpLnJldmVyc2UoKSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmdldFN0cmluZ0Zyb21GdW5jdGlvbk5hbWVzKE9iamVjdC5rZXlzKHRoaXMuZnVuY3Rpb25NYXApKTtcbiAgfVxuXG4gIGxvb2t1cFJldHVyblR5cGUoZnVuY3Rpb25OYW1lLCBhc3QsIHJlcXVlc3RpbmdOb2RlKSB7XG4gICAgaWYgKGFzdC50eXBlICE9PSAnQ2FsbEV4cHJlc3Npb24nKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYGV4cGVjdGVkIGFzdCB0eXBlIG9mIFwiQ2FsbEV4cHJlc3Npb25cIiwgYnV0IGlzICR7IGFzdC50eXBlIH1gKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX2lzTmF0aXZlRnVuY3Rpb24oZnVuY3Rpb25OYW1lKSkge1xuICAgICAgcmV0dXJuIHRoaXMuX2xvb2t1cE5hdGl2ZUZ1bmN0aW9uUmV0dXJuVHlwZShmdW5jdGlvbk5hbWUpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5faXNGdW5jdGlvbihmdW5jdGlvbk5hbWUpKSB7XG4gICAgICBjb25zdCBub2RlID0gdGhpcy5fZ2V0RnVuY3Rpb24oZnVuY3Rpb25OYW1lKTtcbiAgICAgIGlmIChub2RlLnJldHVyblR5cGUpIHtcbiAgICAgICAgcmV0dXJuIG5vZGUucmV0dXJuVHlwZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5sb29rdXBDaGFpbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmICh0aGlzLmxvb2t1cENoYWluW2ldLmFzdCA9PT0gYXN0KSB7XG4gICAgICAgICAgICBpZiAobm9kZS5hcmd1bWVudFR5cGVzLmxlbmd0aCA9PT0gMCAmJiBhc3QuYXJndW1lbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgY29uc3QgYXJncyA9IGFzdC5hcmd1bWVudHM7XG4gICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgYXJncy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgIHRoaXMubG9va3VwQ2hhaW4ucHVzaCh7XG4gICAgICAgICAgICAgICAgICBuYW1lOiByZXF1ZXN0aW5nTm9kZS5uYW1lLFxuICAgICAgICAgICAgICAgICAgYXN0OiBhcmdzW2ldLFxuICAgICAgICAgICAgICAgICAgcmVxdWVzdGluZ05vZGVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBub2RlLmFyZ3VtZW50VHlwZXNbal0gPSByZXF1ZXN0aW5nTm9kZS5nZXRUeXBlKGFyZ3Nbal0pO1xuICAgICAgICAgICAgICAgIHRoaXMubG9va3VwQ2hhaW4ucG9wKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIG5vZGUucmV0dXJuVHlwZSA9IG5vZGUuZ2V0VHlwZShub2RlLmdldEpzQVNUKCkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NpcmNsaWNhbCBsb2dpYyBkZXRlY3RlZCEnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sb29rdXBDaGFpbi5wdXNoKHtcbiAgICAgICAgICBuYW1lOiByZXF1ZXN0aW5nTm9kZS5uYW1lLFxuICAgICAgICAgIGFzdCxcbiAgICAgICAgICByZXF1ZXN0aW5nTm9kZVxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgdHlwZSA9IG5vZGUuZ2V0VHlwZShub2RlLmdldEpzQVNUKCkpO1xuICAgICAgICB0aGlzLmxvb2t1cENoYWluLnBvcCgpO1xuICAgICAgICByZXR1cm4gbm9kZS5yZXR1cm5UeXBlID0gdHlwZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIF9nZXRGdW5jdGlvbihmdW5jdGlvbk5hbWUpIHtcbiAgICBpZiAoIXRoaXMuX2lzRnVuY3Rpb24oZnVuY3Rpb25OYW1lKSkge1xuICAgICAgbmV3IEVycm9yKGBGdW5jdGlvbiAke2Z1bmN0aW9uTmFtZX0gbm90IGZvdW5kYCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmZ1bmN0aW9uTWFwW2Z1bmN0aW9uTmFtZV07XG4gIH1cblxuICBfaXNGdW5jdGlvbihmdW5jdGlvbk5hbWUpIHtcbiAgICByZXR1cm4gQm9vbGVhbih0aGlzLmZ1bmN0aW9uTWFwW2Z1bmN0aW9uTmFtZV0pO1xuICB9XG5cbiAgX2dldE5hdGl2ZUZ1bmN0aW9uKGZ1bmN0aW9uTmFtZSkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5uYXRpdmVGdW5jdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICh0aGlzLm5hdGl2ZUZ1bmN0aW9uc1tpXS5uYW1lID09PSBmdW5jdGlvbk5hbWUpIHJldHVybiB0aGlzLm5hdGl2ZUZ1bmN0aW9uc1tpXTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBfaXNOYXRpdmVGdW5jdGlvbihmdW5jdGlvbk5hbWUpIHtcbiAgICByZXR1cm4gQm9vbGVhbih0aGlzLl9nZXROYXRpdmVGdW5jdGlvbihmdW5jdGlvbk5hbWUpKTtcbiAgfVxuXG4gIF9sb29rdXBOYXRpdmVGdW5jdGlvblJldHVyblR5cGUoZnVuY3Rpb25OYW1lKSB7XG4gICAgbGV0IG5hdGl2ZUZ1bmN0aW9uID0gdGhpcy5fZ2V0TmF0aXZlRnVuY3Rpb24oZnVuY3Rpb25OYW1lKTtcbiAgICBpZiAobmF0aXZlRnVuY3Rpb24pIHtcbiAgICAgIHJldHVybiBuYXRpdmVGdW5jdGlvbi5yZXR1cm5UeXBlO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoYE5hdGl2ZSBmdW5jdGlvbiAkeyBmdW5jdGlvbk5hbWUgfSBub3QgZm91bmRgKTtcbiAgfVxuXG4gIGxvb2t1cEZ1bmN0aW9uQXJndW1lbnRUeXBlcyhmdW5jdGlvbk5hbWUpIHtcbiAgICBpZiAodGhpcy5faXNOYXRpdmVGdW5jdGlvbihmdW5jdGlvbk5hbWUpKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZ2V0TmF0aXZlRnVuY3Rpb24oZnVuY3Rpb25OYW1lKS5hcmd1bWVudFR5cGVzO1xuICAgIH0gZWxzZSBpZiAodGhpcy5faXNGdW5jdGlvbihmdW5jdGlvbk5hbWUpKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZ2V0RnVuY3Rpb24oZnVuY3Rpb25OYW1lKS5hcmd1bWVudFR5cGVzO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGxvb2t1cEZ1bmN0aW9uQXJndW1lbnROYW1lKGZ1bmN0aW9uTmFtZSwgYXJndW1lbnRJbmRleCkge1xuICAgIHJldHVybiB0aGlzLl9nZXRGdW5jdGlvbihmdW5jdGlvbk5hbWUpLmFyZ3VtZW50TmFtZXNbYXJndW1lbnRJbmRleF07XG4gIH1cblxuICBsb29rdXBGdW5jdGlvbkFyZ3VtZW50Qml0UmF0aW8oZnVuY3Rpb25OYW1lLCBhcmd1bWVudE5hbWUpIHtcbiAgICBpZiAoIXRoaXMuX2lzRnVuY3Rpb24oZnVuY3Rpb25OYW1lKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdmdW5jdGlvbiBub3QgZm91bmQnKTtcbiAgICB9XG4gICAgaWYgKHRoaXMucm9vdE5vZGUubmFtZSA9PT0gZnVuY3Rpb25OYW1lKSB7XG4gICAgICBjb25zdCBpID0gdGhpcy5yb290Tm9kZS5hcmd1bWVudE5hbWVzLmluZGV4T2YoYXJndW1lbnROYW1lKTtcbiAgICAgIGlmIChpICE9PSAtMSkge1xuICAgICAgICByZXR1cm4gdGhpcy5yb290Tm9kZS5hcmd1bWVudEJpdFJhdGlvc1tpXTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuX2dldEZ1bmN0aW9uKGZ1bmN0aW9uTmFtZSk7XG4gICAgY29uc3QgaSA9IG5vZGUuYXJndW1lbnROYW1lcy5pbmRleE9mKGFyZ3VtZW50TmFtZSk7XG4gICAgaWYgKGkgPT09IC0xKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2FyZ3VtZW50IG5vdCBmb3VuZCcpO1xuICAgIH1cbiAgICBjb25zdCBiaXRSYXRpbyA9IG5vZGUuYXJndW1lbnRCaXRSYXRpb3NbaV07XG4gICAgaWYgKHR5cGVvZiBiaXRSYXRpbyAhPT0gJ251bWJlcicpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignYXJndW1lbnQgYml0IHJhdGlvIG5vdCBmb3VuZCcpO1xuICAgIH1cbiAgICByZXR1cm4gYml0UmF0aW87XG4gIH1cblxuICBuZWVkc0FyZ3VtZW50VHlwZShmdW5jdGlvbk5hbWUsIGkpIHtcbiAgICBpZiAoIXRoaXMuX2lzRnVuY3Rpb24oZnVuY3Rpb25OYW1lKSkgcmV0dXJuIGZhbHNlO1xuICAgIGNvbnN0IGZuTm9kZSA9IHRoaXMuX2dldEZ1bmN0aW9uKGZ1bmN0aW9uTmFtZSk7XG4gICAgcmV0dXJuICFmbk5vZGUuYXJndW1lbnRUeXBlc1tpXTtcbiAgfVxuXG4gIGFzc2lnbkFyZ3VtZW50VHlwZShmdW5jdGlvbk5hbWUsIGksIGFyZ3VtZW50VHlwZSwgcmVxdWVzdGluZ05vZGUpIHtcbiAgICBpZiAoIXRoaXMuX2lzRnVuY3Rpb24oZnVuY3Rpb25OYW1lKSkgcmV0dXJuO1xuICAgIGNvbnN0IGZuTm9kZSA9IHRoaXMuX2dldEZ1bmN0aW9uKGZ1bmN0aW9uTmFtZSk7XG4gICAgaWYgKCFmbk5vZGUuYXJndW1lbnRUeXBlc1tpXSkge1xuICAgICAgZm5Ob2RlLmFyZ3VtZW50VHlwZXNbaV0gPSBhcmd1bWVudFR5cGU7XG4gICAgfVxuICB9XG5cbiAgYXNzaWduQXJndW1lbnRCaXRSYXRpbyhmdW5jdGlvbk5hbWUsIGFyZ3VtZW50TmFtZSwgY2FsbGVlRnVuY3Rpb25OYW1lLCBhcmd1bWVudEluZGV4KSB7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuX2dldEZ1bmN0aW9uKGZ1bmN0aW9uTmFtZSk7XG4gICAgaWYgKHRoaXMuX2lzTmF0aXZlRnVuY3Rpb24oY2FsbGVlRnVuY3Rpb25OYW1lKSkgcmV0dXJuIG51bGw7XG4gICAgY29uc3QgY2FsbGVlTm9kZSA9IHRoaXMuX2dldEZ1bmN0aW9uKGNhbGxlZUZ1bmN0aW9uTmFtZSk7XG4gICAgY29uc3QgaSA9IG5vZGUuYXJndW1lbnROYW1lcy5pbmRleE9mKGFyZ3VtZW50TmFtZSk7XG4gICAgaWYgKGkgPT09IC0xKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEFyZ3VtZW50ICR7YXJndW1lbnROYW1lfSBub3QgZm91bmQgaW4gYXJndW1lbnRzIGZyb20gZnVuY3Rpb24gJHtmdW5jdGlvbk5hbWV9YCk7XG4gICAgfVxuICAgIGNvbnN0IGJpdFJhdGlvID0gbm9kZS5hcmd1bWVudEJpdFJhdGlvc1tpXTtcbiAgICBpZiAodHlwZW9mIGJpdFJhdGlvICE9PSAnbnVtYmVyJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBCaXQgcmF0aW8gZm9yIGFyZ3VtZW50ICR7YXJndW1lbnROYW1lfSBub3QgZm91bmQgaW4gZnVuY3Rpb24gJHtmdW5jdGlvbk5hbWV9YCk7XG4gICAgfVxuICAgIGlmICghY2FsbGVlTm9kZS5hcmd1bWVudEJpdFJhdGlvcykge1xuICAgICAgY2FsbGVlTm9kZS5hcmd1bWVudEJpdFJhdGlvcyA9IG5ldyBBcnJheShjYWxsZWVOb2RlLmFyZ3VtZW50TmFtZXMubGVuZ3RoKTtcbiAgICB9XG4gICAgY29uc3QgY2FsbGVlQml0UmF0aW8gPSBjYWxsZWVOb2RlLmFyZ3VtZW50Qml0UmF0aW9zW2ldO1xuICAgIGlmICh0eXBlb2YgY2FsbGVlQml0UmF0aW8gPT09ICdudW1iZXInKSB7XG4gICAgICBpZiAoY2FsbGVlQml0UmF0aW8gIT09IGJpdFJhdGlvKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW5jb21wYXRpYmxlIGJpdCByYXRpbyBmb3VuZCBhdCBmdW5jdGlvbiAke2Z1bmN0aW9uTmFtZX0gYXQgYXJndW1lbnQgJHthcmd1bWVudE5hbWV9YCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gY2FsbGVlQml0UmF0aW87XG4gICAgfVxuICAgIGNhbGxlZU5vZGUuYXJndW1lbnRCaXRSYXRpb3NbaV0gPSBiaXRSYXRpbztcbiAgICByZXR1cm4gYml0UmF0aW87XG4gIH1cblxuICB0cmFja0Z1bmN0aW9uQ2FsbChmdW5jdGlvbk5hbWUsIGNhbGxlZUZ1bmN0aW9uTmFtZSwgYXJncykge1xuICAgIGlmICghdGhpcy5mdW5jdGlvbk5vZGVEZXBlbmRlbmNpZXNbZnVuY3Rpb25OYW1lXSkge1xuICAgICAgdGhpcy5mdW5jdGlvbk5vZGVEZXBlbmRlbmNpZXNbZnVuY3Rpb25OYW1lXSA9IG5ldyBTZXQoKTtcbiAgICAgIHRoaXMuZnVuY3Rpb25DYWxsc1tmdW5jdGlvbk5hbWVdID0gW107XG4gICAgfVxuICAgIHRoaXMuZnVuY3Rpb25Ob2RlRGVwZW5kZW5jaWVzW2Z1bmN0aW9uTmFtZV0uYWRkKGNhbGxlZUZ1bmN0aW9uTmFtZSk7XG4gICAgdGhpcy5mdW5jdGlvbkNhbGxzW2Z1bmN0aW9uTmFtZV0ucHVzaChhcmdzKTtcbiAgfVxuXG4gIGdldEtlcm5lbFJlc3VsdFR5cGUoKSB7XG4gICAgcmV0dXJuIHRoaXMucm9vdE5vZGUucmV0dXJuVHlwZSB8fCB0aGlzLnJvb3ROb2RlLmdldFR5cGUodGhpcy5yb290Tm9kZS5hc3QpO1xuICB9XG5cbiAgZ2V0U3ViS2VybmVsUmVzdWx0VHlwZShpbmRleCkge1xuICAgIGNvbnN0IHN1Yktlcm5lbE5vZGUgPSB0aGlzLnN1Yktlcm5lbE5vZGVzW2luZGV4XTtcbiAgICBsZXQgY2FsbGVkID0gZmFsc2U7XG4gICAgZm9yIChsZXQgZnVuY3Rpb25DYWxsSW5kZXggPSAwOyBmdW5jdGlvbkNhbGxJbmRleCA8IHRoaXMucm9vdE5vZGUuZnVuY3Rpb25DYWxscy5sZW5ndGg7IGZ1bmN0aW9uQ2FsbEluZGV4KyspIHtcbiAgICAgIGNvbnN0IGZ1bmN0aW9uQ2FsbCA9IHRoaXMucm9vdE5vZGUuZnVuY3Rpb25DYWxsc1tmdW5jdGlvbkNhbGxJbmRleF07XG4gICAgICBpZiAoZnVuY3Rpb25DYWxsLmFzdC5jYWxsZWUubmFtZSA9PT0gc3ViS2VybmVsTm9kZS5uYW1lKSB7XG4gICAgICAgIGNhbGxlZCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghY2FsbGVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFN1Yktlcm5lbCAkeyBzdWJLZXJuZWxOb2RlLm5hbWUgfSBuZXZlciBjYWxsZWQgYnkga2VybmVsYCk7XG4gICAgfVxuICAgIHJldHVybiBzdWJLZXJuZWxOb2RlLnJldHVyblR5cGUgfHwgc3ViS2VybmVsTm9kZS5nZXRUeXBlKHN1Yktlcm5lbE5vZGUuZ2V0SnNBU1QoKSk7XG4gIH1cblxuICBnZXRSZXR1cm5UeXBlcygpIHtcbiAgICBjb25zdCByZXN1bHQgPSB7XG4gICAgICBbdGhpcy5yb290Tm9kZS5uYW1lXTogdGhpcy5yb290Tm9kZS5nZXRUeXBlKHRoaXMucm9vdE5vZGUuYXN0KSxcbiAgICB9O1xuICAgIGNvbnN0IGxpc3QgPSB0aGlzLnRyYWNlRnVuY3Rpb25DYWxscyh0aGlzLnJvb3ROb2RlLm5hbWUpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgZnVuY3Rpb25OYW1lID0gbGlzdFtpXTtcbiAgICAgIGNvbnN0IGZ1bmN0aW9uTm9kZSA9IHRoaXMuZnVuY3Rpb25NYXBbZnVuY3Rpb25OYW1lXTtcbiAgICAgIHJlc3VsdFtmdW5jdGlvbk5hbWVdID0gZnVuY3Rpb25Ob2RlLmdldFR5cGUoZnVuY3Rpb25Ob2RlLmFzdCk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIEZ1bmN0aW9uQnVpbGRlclxufTtcbn0se31dLDEwOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbmNvbnN0IGFjb3JuID0gcmVxdWlyZSgnYWNvcm4nKTtcbmNvbnN0IHsgdXRpbHMgfSA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG5jb25zdCB7IEZ1bmN0aW9uVHJhY2VyIH0gPSByZXF1aXJlKCcuL2Z1bmN0aW9uLXRyYWNlcicpO1xuXG5jbGFzcyBGdW5jdGlvbk5vZGUge1xuICBjb25zdHJ1Y3Rvcihzb3VyY2UsIHNldHRpbmdzKSB7XG4gICAgaWYgKCFzb3VyY2UgJiYgIXNldHRpbmdzLmFzdCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdzb3VyY2UgcGFyYW1ldGVyIGlzIG1pc3NpbmcnKTtcbiAgICB9XG4gICAgc2V0dGluZ3MgPSBzZXR0aW5ncyB8fCB7fTtcbiAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICB0aGlzLmFzdCA9IG51bGw7XG4gICAgdGhpcy5uYW1lID0gdHlwZW9mIHNvdXJjZSA9PT0gJ3N0cmluZycgPyBzZXR0aW5ncy5pc1Jvb3RLZXJuZWwgP1xuICAgICAgJ2tlcm5lbCcgOlxuICAgICAgKHNldHRpbmdzLm5hbWUgfHwgdXRpbHMuZ2V0RnVuY3Rpb25OYW1lRnJvbVN0cmluZyhzb3VyY2UpKSA6IG51bGw7XG4gICAgdGhpcy5jYWxsZWRGdW5jdGlvbnMgPSBbXTtcbiAgICB0aGlzLmNvbnN0YW50cyA9IHt9O1xuICAgIHRoaXMuY29uc3RhbnRUeXBlcyA9IHt9O1xuICAgIHRoaXMuY29uc3RhbnRCaXRSYXRpb3MgPSB7fTtcbiAgICB0aGlzLmlzUm9vdEtlcm5lbCA9IGZhbHNlO1xuICAgIHRoaXMuaXNTdWJLZXJuZWwgPSBmYWxzZTtcbiAgICB0aGlzLmRlYnVnID0gbnVsbDtcbiAgICB0aGlzLmZ1bmN0aW9ucyA9IG51bGw7XG4gICAgdGhpcy5pZGVudGlmaWVycyA9IG51bGw7XG4gICAgdGhpcy5jb250ZXh0cyA9IG51bGw7XG4gICAgdGhpcy5mdW5jdGlvbkNhbGxzID0gbnVsbDtcbiAgICB0aGlzLnN0YXRlcyA9IFtdO1xuICAgIHRoaXMubmVlZHNBcmd1bWVudFR5cGUgPSBudWxsO1xuICAgIHRoaXMuYXNzaWduQXJndW1lbnRUeXBlID0gbnVsbDtcbiAgICB0aGlzLmxvb2t1cFJldHVyblR5cGUgPSBudWxsO1xuICAgIHRoaXMubG9va3VwRnVuY3Rpb25Bcmd1bWVudFR5cGVzID0gbnVsbDtcbiAgICB0aGlzLmxvb2t1cEZ1bmN0aW9uQXJndW1lbnRCaXRSYXRpbyA9IG51bGw7XG4gICAgdGhpcy50cmlnZ2VySW1wbHlBcmd1bWVudFR5cGUgPSBudWxsO1xuICAgIHRoaXMudHJpZ2dlckltcGx5QXJndW1lbnRCaXRSYXRpbyA9IG51bGw7XG4gICAgdGhpcy5vbk5lc3RlZEZ1bmN0aW9uID0gbnVsbDtcbiAgICB0aGlzLm9uRnVuY3Rpb25DYWxsID0gbnVsbDtcbiAgICB0aGlzLm9wdGltaXplRmxvYXRNZW1vcnkgPSBudWxsO1xuICAgIHRoaXMucHJlY2lzaW9uID0gbnVsbDtcbiAgICB0aGlzLmxvb3BNYXhJdGVyYXRpb25zID0gbnVsbDtcbiAgICB0aGlzLmFyZ3VtZW50TmFtZXMgPSAodHlwZW9mIHRoaXMuc291cmNlID09PSAnc3RyaW5nJyA/IHV0aWxzLmdldEFyZ3VtZW50TmFtZXNGcm9tU3RyaW5nKHRoaXMuc291cmNlKSA6IG51bGwpO1xuICAgIHRoaXMuYXJndW1lbnRUeXBlcyA9IFtdO1xuICAgIHRoaXMuYXJndW1lbnRTaXplcyA9IFtdO1xuICAgIHRoaXMuYXJndW1lbnRCaXRSYXRpb3MgPSBudWxsO1xuICAgIHRoaXMucmV0dXJuVHlwZSA9IG51bGw7XG4gICAgdGhpcy5vdXRwdXQgPSBbXTtcbiAgICB0aGlzLnBsdWdpbnMgPSBudWxsO1xuICAgIHRoaXMubGVhZGluZ1JldHVyblN0YXRlbWVudCA9IG51bGw7XG4gICAgdGhpcy5mb2xsb3dpbmdSZXR1cm5TdGF0ZW1lbnQgPSBudWxsO1xuICAgIHRoaXMuZHluYW1pY091dHB1dCA9IG51bGw7XG4gICAgdGhpcy5keW5hbWljQXJndW1lbnRzID0gbnVsbDtcbiAgICB0aGlzLnN0cmljdFR5cGluZ0NoZWNraW5nID0gZmFsc2U7XG4gICAgdGhpcy5maXhJbnRlZ2VyRGl2aXNpb25BY2N1cmFjeSA9IG51bGw7XG5cbiAgICBpZiAoc2V0dGluZ3MpIHtcbiAgICAgIGZvciAoY29uc3QgcCBpbiBzZXR0aW5ncykge1xuICAgICAgICBpZiAoIXNldHRpbmdzLmhhc093blByb3BlcnR5KHApKSBjb250aW51ZTtcbiAgICAgICAgaWYgKCF0aGlzLmhhc093blByb3BlcnR5KHApKSBjb250aW51ZTtcbiAgICAgICAgdGhpc1twXSA9IHNldHRpbmdzW3BdO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMubGl0ZXJhbFR5cGVzID0ge307XG5cbiAgICB0aGlzLnZhbGlkYXRlKCk7XG4gICAgdGhpcy5fc3RyaW5nID0gbnVsbDtcbiAgICB0aGlzLl9pbnRlcm5hbFZhcmlhYmxlTmFtZXMgPSB7fTtcbiAgfVxuXG4gIHZhbGlkYXRlKCkge1xuICAgIGlmICh0eXBlb2YgdGhpcy5zb3VyY2UgIT09ICdzdHJpbmcnICYmICF0aGlzLmFzdCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCd0aGlzLnNvdXJjZSBub3QgYSBzdHJpbmcnKTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuYXN0ICYmICF1dGlscy5pc0Z1bmN0aW9uU3RyaW5nKHRoaXMuc291cmNlKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCd0aGlzLnNvdXJjZSBub3QgYSBmdW5jdGlvbiBzdHJpbmcnKTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMubmFtZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCd0aGlzLm5hbWUgY291bGQgbm90IGJlIHNldCcpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmFyZ3VtZW50VHlwZXMubGVuZ3RoID4gMCAmJiB0aGlzLmFyZ3VtZW50VHlwZXMubGVuZ3RoICE9PSB0aGlzLmFyZ3VtZW50TmFtZXMubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYGFyZ3VtZW50VHlwZXMgY291bnQgb2YgJHsgdGhpcy5hcmd1bWVudFR5cGVzLmxlbmd0aCB9IGV4Y2VlZHMgJHsgdGhpcy5hcmd1bWVudE5hbWVzLmxlbmd0aCB9YCk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMub3V0cHV0Lmxlbmd0aCA8IDEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigndGhpcy5vdXRwdXQgaXMgbm90IGJpZyBlbm91Z2gnKTtcbiAgICB9XG4gIH1cblxuICBpc0lkZW50aWZpZXJDb25zdGFudChuYW1lKSB7XG4gICAgaWYgKCF0aGlzLmNvbnN0YW50cykgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiB0aGlzLmNvbnN0YW50cy5oYXNPd25Qcm9wZXJ0eShuYW1lKTtcbiAgfVxuXG4gIGlzSW5wdXQoYXJndW1lbnROYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMuYXJndW1lbnRUeXBlc1t0aGlzLmFyZ3VtZW50TmFtZXMuaW5kZXhPZihhcmd1bWVudE5hbWUpXSA9PT0gJ0lucHV0JztcbiAgfVxuXG4gIHB1c2hTdGF0ZShzdGF0ZSkge1xuICAgIHRoaXMuc3RhdGVzLnB1c2goc3RhdGUpO1xuICB9XG5cbiAgcG9wU3RhdGUoc3RhdGUpIHtcbiAgICBpZiAodGhpcy5zdGF0ZSAhPT0gc3RhdGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IHBvcFN0YXRlICR7IHN0YXRlIH0gd2hlbiBpbiAkeyB0aGlzLnN0YXRlIH1gKTtcbiAgICB9XG4gICAgdGhpcy5zdGF0ZXMucG9wKCk7XG4gIH1cblxuICBpc1N0YXRlKHN0YXRlKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGUgPT09IHN0YXRlO1xuICB9XG5cbiAgZ2V0IHN0YXRlKCkge1xuICAgIHJldHVybiB0aGlzLnN0YXRlc1t0aGlzLnN0YXRlcy5sZW5ndGggLSAxXTtcbiAgfVxuXG4gIGFzdE1lbWJlckV4cHJlc3Npb25VbnJvbGwoYXN0KSB7XG4gICAgaWYgKGFzdC50eXBlID09PSAnSWRlbnRpZmllcicpIHtcbiAgICAgIHJldHVybiBhc3QubmFtZTtcbiAgICB9IGVsc2UgaWYgKGFzdC50eXBlID09PSAnVGhpc0V4cHJlc3Npb24nKSB7XG4gICAgICByZXR1cm4gJ3RoaXMnO1xuICAgIH1cblxuICAgIGlmIChhc3QudHlwZSA9PT0gJ01lbWJlckV4cHJlc3Npb24nKSB7XG4gICAgICBpZiAoYXN0Lm9iamVjdCAmJiBhc3QucHJvcGVydHkpIHtcbiAgICAgICAgaWYgKGFzdC5vYmplY3QuaGFzT3duUHJvcGVydHkoJ25hbWUnKSAmJiBhc3Qub2JqZWN0Lm5hbWUgIT09ICdNYXRoJykge1xuICAgICAgICAgIHJldHVybiB0aGlzLmFzdE1lbWJlckV4cHJlc3Npb25VbnJvbGwoYXN0LnByb3BlcnR5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgdGhpcy5hc3RNZW1iZXJFeHByZXNzaW9uVW5yb2xsKGFzdC5vYmplY3QpICtcbiAgICAgICAgICAnLicgK1xuICAgICAgICAgIHRoaXMuYXN0TWVtYmVyRXhwcmVzc2lvblVucm9sbChhc3QucHJvcGVydHkpXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGFzdC5oYXNPd25Qcm9wZXJ0eSgnZXhwcmVzc2lvbnMnKSkge1xuICAgICAgY29uc3QgZmlyc3RFeHByZXNzaW9uID0gYXN0LmV4cHJlc3Npb25zWzBdO1xuICAgICAgaWYgKGZpcnN0RXhwcmVzc2lvbi50eXBlID09PSAnTGl0ZXJhbCcgJiYgZmlyc3RFeHByZXNzaW9uLnZhbHVlID09PSAwICYmIGFzdC5leHByZXNzaW9ucy5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXN0TWVtYmVyRXhwcmVzc2lvblVucm9sbChhc3QuZXhwcmVzc2lvbnNbMV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRocm93IHRoaXMuYXN0RXJyb3JPdXRwdXQoJ1Vua25vd24gYXN0TWVtYmVyRXhwcmVzc2lvblVucm9sbCcsIGFzdCk7XG4gIH1cblxuICBnZXRKc0FTVChpblBhcnNlcikge1xuICAgIGlmICh0aGlzLmFzdCkge1xuICAgICAgcmV0dXJuIHRoaXMuYXN0O1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHRoaXMuc291cmNlID09PSAnb2JqZWN0Jykge1xuICAgICAgdGhpcy50cmFjZUZ1bmN0aW9uQVNUKHRoaXMuc291cmNlKTtcbiAgICAgIHJldHVybiB0aGlzLmFzdCA9IHRoaXMuc291cmNlO1xuICAgIH1cblxuICAgIGluUGFyc2VyID0gaW5QYXJzZXIgfHwgYWNvcm47XG4gICAgaWYgKGluUGFyc2VyID09PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ01pc3NpbmcgSlMgdG8gQVNUIHBhcnNlcicpO1xuICAgIH1cblxuICAgIGNvbnN0IGFzdCA9IE9iamVjdC5mcmVlemUoaW5QYXJzZXIucGFyc2UoYGNvbnN0IHBhcnNlcl8keyB0aGlzLm5hbWUgfSA9ICR7IHRoaXMuc291cmNlIH07YCwge1xuICAgICAgbG9jYXRpb25zOiB0cnVlXG4gICAgfSkpO1xuICAgIGNvbnN0IGZ1bmN0aW9uQVNUID0gYXN0LmJvZHlbMF0uZGVjbGFyYXRpb25zWzBdLmluaXQ7XG4gICAgdGhpcy50cmFjZUZ1bmN0aW9uQVNUKGZ1bmN0aW9uQVNUKTtcblxuICAgIGlmICghYXN0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBwYXJzZSBKUyBjb2RlJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuYXN0ID0gZnVuY3Rpb25BU1Q7XG4gIH1cblxuICB0cmFjZUZ1bmN0aW9uQVNUKGFzdCkge1xuICAgIGNvbnN0IHsgY29udGV4dHMsIGRlY2xhcmF0aW9ucywgZnVuY3Rpb25zLCBpZGVudGlmaWVycywgZnVuY3Rpb25DYWxscyB9ID0gbmV3IEZ1bmN0aW9uVHJhY2VyKGFzdCk7XG4gICAgdGhpcy5jb250ZXh0cyA9IGNvbnRleHRzO1xuICAgIHRoaXMuaWRlbnRpZmllcnMgPSBpZGVudGlmaWVycztcbiAgICB0aGlzLmZ1bmN0aW9uQ2FsbHMgPSBmdW5jdGlvbkNhbGxzO1xuICAgIHRoaXMuZnVuY3Rpb25zID0gZnVuY3Rpb25zO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGVjbGFyYXRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBkZWNsYXJhdGlvbiA9IGRlY2xhcmF0aW9uc1tpXTtcbiAgICAgIGNvbnN0IHsgYXN0LCBpbkZvckxvb3BJbml0LCBpbkZvckxvb3BUZXN0IH0gPSBkZWNsYXJhdGlvbjtcbiAgICAgIGNvbnN0IHsgaW5pdCB9ID0gYXN0O1xuICAgICAgY29uc3QgZGVwZW5kZW5jaWVzID0gdGhpcy5nZXREZXBlbmRlbmNpZXMoaW5pdCk7XG4gICAgICBsZXQgdmFsdWVUeXBlID0gbnVsbDtcblxuICAgICAgaWYgKGluRm9yTG9vcEluaXQgJiYgaW5Gb3JMb29wVGVzdCkge1xuICAgICAgICB2YWx1ZVR5cGUgPSAnSW50ZWdlcic7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoaW5pdCkge1xuICAgICAgICAgIGNvbnN0IHJlYWxUeXBlID0gdGhpcy5nZXRUeXBlKGluaXQpO1xuICAgICAgICAgIHN3aXRjaCAocmVhbFR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ0ludGVnZXInOlxuICAgICAgICAgICAgY2FzZSAnRmxvYXQnOlxuICAgICAgICAgICAgY2FzZSAnTnVtYmVyJzpcbiAgICAgICAgICAgICAgaWYgKGluaXQudHlwZSA9PT0gJ01lbWJlckV4cHJlc3Npb24nKSB7XG4gICAgICAgICAgICAgICAgdmFsdWVUeXBlID0gcmVhbFR5cGU7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFsdWVUeXBlID0gJ051bWJlcic7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdMaXRlcmFsSW50ZWdlcic6XG4gICAgICAgICAgICAgIHZhbHVlVHlwZSA9ICdOdW1iZXInO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIHZhbHVlVHlwZSA9IHJlYWxUeXBlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZGVjbGFyYXRpb24udmFsdWVUeXBlID0gdmFsdWVUeXBlO1xuICAgICAgZGVjbGFyYXRpb24uZGVwZW5kZW5jaWVzID0gZGVwZW5kZW5jaWVzO1xuICAgICAgZGVjbGFyYXRpb24uaXNTYWZlID0gdGhpcy5pc1NhZmVEZXBlbmRlbmNpZXMoZGVwZW5kZW5jaWVzKTtcbiAgICB9XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZ1bmN0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy5vbk5lc3RlZEZ1bmN0aW9uKGZ1bmN0aW9uc1tpXSwgdGhpcy5zb3VyY2UpO1xuICAgIH1cbiAgfVxuXG4gIGdldERlY2xhcmF0aW9uKGFzdCkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5pZGVudGlmaWVycy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgaWRlbnRpZmllciA9IHRoaXMuaWRlbnRpZmllcnNbaV07XG4gICAgICBpZiAoYXN0ID09PSBpZGVudGlmaWVyLmFzdCkge1xuICAgICAgICByZXR1cm4gaWRlbnRpZmllci5kZWNsYXJhdGlvbjtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBnZXRWYXJpYWJsZVR5cGUoYXN0KSB7XG4gICAgaWYgKGFzdC50eXBlICE9PSAnSWRlbnRpZmllcicpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgYXN0IG9mICR7YXN0LnR5cGV9IG5vdCBcIklkZW50aWZpZXJcImApO1xuICAgIH1cbiAgICBsZXQgdHlwZSA9IG51bGw7XG4gICAgY29uc3QgYXJndW1lbnRJbmRleCA9IHRoaXMuYXJndW1lbnROYW1lcy5pbmRleE9mKGFzdC5uYW1lKTtcbiAgICBpZiAoYXJndW1lbnRJbmRleCA9PT0gLTEpIHtcbiAgICAgIGNvbnN0IGRlY2xhcmF0aW9uID0gdGhpcy5nZXREZWNsYXJhdGlvbihhc3QpO1xuICAgICAgaWYgKGRlY2xhcmF0aW9uKSB7XG4gICAgICAgIHJldHVybiBkZWNsYXJhdGlvbi52YWx1ZVR5cGU7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGFyZ3VtZW50VHlwZSA9IHRoaXMuYXJndW1lbnRUeXBlc1thcmd1bWVudEluZGV4XTtcbiAgICAgIGlmIChhcmd1bWVudFR5cGUpIHtcbiAgICAgICAgdHlwZSA9IGFyZ3VtZW50VHlwZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCF0eXBlICYmIHRoaXMuc3RyaWN0VHlwaW5nQ2hlY2tpbmcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRGVjbGFyYXRpb24gb2YgJHtuYW1lfSBub3QgZm91bmRgKTtcbiAgICB9XG4gICAgcmV0dXJuIHR5cGU7XG4gIH1cblxuICBnZXRMb29rdXBUeXBlKHR5cGUpIHtcbiAgICBpZiAoIXR5cGVMb29rdXBNYXAuaGFzT3duUHJvcGVydHkodHlwZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgdW5rbm93biB0eXBlTG9va3VwTWFwICR7IHR5cGUgfWApO1xuICAgIH1cbiAgICByZXR1cm4gdHlwZUxvb2t1cE1hcFt0eXBlXTtcbiAgfVxuXG4gIGdldENvbnN0YW50VHlwZShjb25zdGFudE5hbWUpIHtcbiAgICBpZiAodGhpcy5jb25zdGFudFR5cGVzW2NvbnN0YW50TmFtZV0pIHtcbiAgICAgIGNvbnN0IHR5cGUgPSB0aGlzLmNvbnN0YW50VHlwZXNbY29uc3RhbnROYW1lXTtcbiAgICAgIGlmICh0eXBlID09PSAnRmxvYXQnKSB7XG4gICAgICAgIHJldHVybiAnTnVtYmVyJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0eXBlO1xuICAgICAgfVxuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoYFR5cGUgZm9yIGNvbnN0YW50IFwiJHsgY29uc3RhbnROYW1lIH1cIiBub3QgZGVjbGFyZWRgKTtcbiAgfVxuXG4gIHRvU3RyaW5nKCkge1xuICAgIGlmICh0aGlzLl9zdHJpbmcpIHJldHVybiB0aGlzLl9zdHJpbmc7XG4gICAgcmV0dXJuIHRoaXMuX3N0cmluZyA9IHRoaXMuYXN0R2VuZXJpYyh0aGlzLmdldEpzQVNUKCksIFtdKS5qb2luKCcnKS50cmltKCk7XG4gIH1cblxuICB0b0pTT04oKSB7XG4gICAgY29uc3Qgc2V0dGluZ3MgPSB7XG4gICAgICBzb3VyY2U6IHRoaXMuc291cmNlLFxuICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgY29uc3RhbnRzOiB0aGlzLmNvbnN0YW50cyxcbiAgICAgIGNvbnN0YW50VHlwZXM6IHRoaXMuY29uc3RhbnRUeXBlcyxcbiAgICAgIGlzUm9vdEtlcm5lbDogdGhpcy5pc1Jvb3RLZXJuZWwsXG4gICAgICBpc1N1Yktlcm5lbDogdGhpcy5pc1N1Yktlcm5lbCxcbiAgICAgIGRlYnVnOiB0aGlzLmRlYnVnLFxuICAgICAgb3V0cHV0OiB0aGlzLm91dHB1dCxcbiAgICAgIGxvb3BNYXhJdGVyYXRpb25zOiB0aGlzLmxvb3BNYXhJdGVyYXRpb25zLFxuICAgICAgYXJndW1lbnROYW1lczogdGhpcy5hcmd1bWVudE5hbWVzLFxuICAgICAgYXJndW1lbnRUeXBlczogdGhpcy5hcmd1bWVudFR5cGVzLFxuICAgICAgYXJndW1lbnRTaXplczogdGhpcy5hcmd1bWVudFNpemVzLFxuICAgICAgcmV0dXJuVHlwZTogdGhpcy5yZXR1cm5UeXBlLFxuICAgICAgbGVhZGluZ1JldHVyblN0YXRlbWVudDogdGhpcy5sZWFkaW5nUmV0dXJuU3RhdGVtZW50LFxuICAgICAgZm9sbG93aW5nUmV0dXJuU3RhdGVtZW50OiB0aGlzLmZvbGxvd2luZ1JldHVyblN0YXRlbWVudCxcbiAgICB9O1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGFzdDogdGhpcy5hc3QsXG4gICAgICBzZXR0aW5nc1xuICAgIH07XG4gIH1cblxuICBnZXRUeXBlKGFzdCkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGFzdCkpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldFR5cGUoYXN0W2FzdC5sZW5ndGggLSAxXSk7XG4gICAgfVxuICAgIHN3aXRjaCAoYXN0LnR5cGUpIHtcbiAgICAgIGNhc2UgJ0Jsb2NrU3RhdGVtZW50JzpcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VHlwZShhc3QuYm9keSk7XG4gICAgICBjYXNlICdBcnJheUV4cHJlc3Npb24nOlxuICAgICAgICBjb25zdCBjaGlsZFR5cGUgPSB0aGlzLmdldFR5cGUoYXN0LmVsZW1lbnRzWzBdKTtcbiAgICAgICAgc3dpdGNoIChjaGlsZFR5cGUpIHtcbiAgICAgICAgICBjYXNlICdBcnJheSgyKSc6XG4gICAgICAgICAgY2FzZSAnQXJyYXkoMyknOlxuICAgICAgICAgIGNhc2UgJ0FycmF5KDQpJzpcbiAgICAgICAgICAgIHJldHVybiBgTWF0cml4KCR7YXN0LmVsZW1lbnRzLmxlbmd0aH0pYDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYEFycmF5KCR7IGFzdC5lbGVtZW50cy5sZW5ndGggfSlgO1xuICAgICAgY2FzZSAnTGl0ZXJhbCc6XG4gICAgICAgIGNvbnN0IGxpdGVyYWxLZXkgPSB0aGlzLmFzdEtleShhc3QpO1xuICAgICAgICBpZiAodGhpcy5saXRlcmFsVHlwZXNbbGl0ZXJhbEtleV0pIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5saXRlcmFsVHlwZXNbbGl0ZXJhbEtleV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKE51bWJlci5pc0ludGVnZXIoYXN0LnZhbHVlKSkge1xuICAgICAgICAgIHJldHVybiAnTGl0ZXJhbEludGVnZXInO1xuICAgICAgICB9IGVsc2UgaWYgKGFzdC52YWx1ZSA9PT0gdHJ1ZSB8fCBhc3QudmFsdWUgPT09IGZhbHNlKSB7XG4gICAgICAgICAgcmV0dXJuICdCb29sZWFuJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gJ051bWJlcic7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnQXNzaWdubWVudEV4cHJlc3Npb24nOlxuICAgICAgICAgIHJldHVybiB0aGlzLmdldFR5cGUoYXN0LmxlZnQpO1xuICAgICAgICBjYXNlICdDYWxsRXhwcmVzc2lvbic6XG4gICAgICAgICAgaWYgKHRoaXMuaXNBc3RNYXRoRnVuY3Rpb24oYXN0KSkge1xuICAgICAgICAgICAgcmV0dXJuICdOdW1iZXInO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIWFzdC5jYWxsZWUgfHwgIWFzdC5jYWxsZWUubmFtZSkge1xuICAgICAgICAgICAgaWYgKGFzdC5jYWxsZWUudHlwZSA9PT0gJ1NlcXVlbmNlRXhwcmVzc2lvbicgJiYgYXN0LmNhbGxlZS5leHByZXNzaW9uc1thc3QuY2FsbGVlLmV4cHJlc3Npb25zLmxlbmd0aCAtIDFdLnByb3BlcnR5Lm5hbWUpIHtcbiAgICAgICAgICAgICAgY29uc3QgZnVuY3Rpb25OYW1lID0gYXN0LmNhbGxlZS5leHByZXNzaW9uc1thc3QuY2FsbGVlLmV4cHJlc3Npb25zLmxlbmd0aCAtIDFdLnByb3BlcnR5Lm5hbWU7XG4gICAgICAgICAgICAgIHRoaXMuaW5mZXJBcmd1bWVudFR5cGVzSWZOZWVkZWQoZnVuY3Rpb25OYW1lLCBhc3QuYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9va3VwUmV0dXJuVHlwZShmdW5jdGlvbk5hbWUsIGFzdCwgdGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5nZXRWYXJpYWJsZVNpZ25hdHVyZShhc3QuY2FsbGVlLCB0cnVlKSA9PT0gJ3RoaXMuY29sb3InKSB7XG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGFzdC5jYWxsZWUudHlwZSA9PT0gJ01lbWJlckV4cHJlc3Npb24nICYmIGFzdC5jYWxsZWUub2JqZWN0ICYmIGFzdC5jYWxsZWUucHJvcGVydHkgJiYgYXN0LmNhbGxlZS5wcm9wZXJ0eS5uYW1lICYmIGFzdC5hcmd1bWVudHMpIHtcbiAgICAgICAgICAgICAgY29uc3QgZnVuY3Rpb25OYW1lID0gYXN0LmNhbGxlZS5wcm9wZXJ0eS5uYW1lO1xuICAgICAgICAgICAgICB0aGlzLmluZmVyQXJndW1lbnRUeXBlc0lmTmVlZGVkKGZ1bmN0aW9uTmFtZSwgYXN0LmFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLmxvb2t1cFJldHVyblR5cGUoZnVuY3Rpb25OYW1lLCBhc3QsIHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgdGhpcy5hc3RFcnJvck91dHB1dCgnVW5rbm93biBjYWxsIGV4cHJlc3Npb24nLCBhc3QpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoYXN0LmNhbGxlZSAmJiBhc3QuY2FsbGVlLm5hbWUpIHtcbiAgICAgICAgICAgIGNvbnN0IGZ1bmN0aW9uTmFtZSA9IGFzdC5jYWxsZWUubmFtZTtcbiAgICAgICAgICAgIHRoaXMuaW5mZXJBcmd1bWVudFR5cGVzSWZOZWVkZWQoZnVuY3Rpb25OYW1lLCBhc3QuYXJndW1lbnRzKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxvb2t1cFJldHVyblR5cGUoZnVuY3Rpb25OYW1lLCBhc3QsIHRoaXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aHJvdyB0aGlzLmFzdEVycm9yT3V0cHV0KGBVbmhhbmRsZWQgZ2V0VHlwZSBUeXBlIFwiJHsgYXN0LnR5cGUgfVwiYCwgYXN0KTtcbiAgICAgICAgY2FzZSAnTG9naWNhbEV4cHJlc3Npb24nOlxuICAgICAgICAgIHJldHVybiAnQm9vbGVhbic7XG4gICAgICAgIGNhc2UgJ0JpbmFyeUV4cHJlc3Npb24nOlxuICAgICAgICAgIHN3aXRjaCAoYXN0Lm9wZXJhdG9yKSB7XG4gICAgICAgICAgICBjYXNlICclJzpcbiAgICAgICAgICAgIGNhc2UgJy8nOlxuICAgICAgICAgICAgICBpZiAodGhpcy5maXhJbnRlZ2VyRGl2aXNpb25BY2N1cmFjeSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAnTnVtYmVyJztcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjYXNlICc+JzpcbiAgICAgICAgICAgICAgY2FzZSAnPCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuICdCb29sZWFuJztcbiAgICAgICAgICAgICAgY2FzZSAnJic6XG4gICAgICAgICAgICAgIGNhc2UgJ3wnOlxuICAgICAgICAgICAgICBjYXNlICdeJzpcbiAgICAgICAgICAgICAgY2FzZSAnPDwnOlxuICAgICAgICAgICAgICBjYXNlICc+Pic6XG4gICAgICAgICAgICAgIGNhc2UgJz4+Pic6XG4gICAgICAgICAgICAgICAgcmV0dXJuICdJbnRlZ2VyJztcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgdHlwZSA9IHRoaXMuZ2V0VHlwZShhc3QubGVmdCk7XG4gICAgICAgICAgaWYgKHRoaXMuaXNTdGF0ZSgnc2tpcC1saXRlcmFsLWNvcnJlY3Rpb24nKSkgcmV0dXJuIHR5cGU7XG4gICAgICAgICAgaWYgKHR5cGUgPT09ICdMaXRlcmFsSW50ZWdlcicpIHtcbiAgICAgICAgICAgIGNvbnN0IHJpZ2h0VHlwZSA9IHRoaXMuZ2V0VHlwZShhc3QucmlnaHQpO1xuICAgICAgICAgICAgaWYgKHJpZ2h0VHlwZSA9PT0gJ0xpdGVyYWxJbnRlZ2VyJykge1xuICAgICAgICAgICAgICBpZiAoYXN0LmxlZnQudmFsdWUgJSAxID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdJbnRlZ2VyJztcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ0Zsb2F0JztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJpZ2h0VHlwZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHR5cGVMb29rdXBNYXBbdHlwZV0gfHwgdHlwZTtcbiAgICAgICAgY2FzZSAnVXBkYXRlRXhwcmVzc2lvbic6XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VHlwZShhc3QuYXJndW1lbnQpO1xuICAgICAgICBjYXNlICdVbmFyeUV4cHJlc3Npb24nOlxuICAgICAgICAgIGlmIChhc3Qub3BlcmF0b3IgPT09ICd+Jykge1xuICAgICAgICAgICAgcmV0dXJuICdJbnRlZ2VyJztcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VHlwZShhc3QuYXJndW1lbnQpO1xuICAgICAgICBjYXNlICdWYXJpYWJsZURlY2xhcmF0aW9uJzoge1xuICAgICAgICAgIGNvbnN0IGRlY2xhcmF0aW9ucyA9IGFzdC5kZWNsYXJhdGlvbnM7XG4gICAgICAgICAgbGV0IGxhc3RUeXBlO1xuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGVjbGFyYXRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBkZWNsYXJhdGlvbiA9IGRlY2xhcmF0aW9uc1tpXTtcbiAgICAgICAgICAgIGxhc3RUeXBlID0gdGhpcy5nZXRUeXBlKGRlY2xhcmF0aW9uKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFsYXN0VHlwZSkge1xuICAgICAgICAgICAgdGhyb3cgdGhpcy5hc3RFcnJvck91dHB1dChgVW5hYmxlIHRvIGZpbmQgdHlwZSBmb3IgZGVjbGFyYXRpb25gLCBhc3QpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbGFzdFR5cGU7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnVmFyaWFibGVEZWNsYXJhdG9yJzpcbiAgICAgICAgICBjb25zdCBkZWNsYXJhdGlvbiA9IHRoaXMuZ2V0RGVjbGFyYXRpb24oYXN0LmlkKTtcbiAgICAgICAgICBpZiAoIWRlY2xhcmF0aW9uKSB7XG4gICAgICAgICAgICB0aHJvdyB0aGlzLmFzdEVycm9yT3V0cHV0KGBVbmFibGUgdG8gZmluZCBkZWNsYXJhdG9yYCwgYXN0KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoIWRlY2xhcmF0aW9uLnZhbHVlVHlwZSkge1xuICAgICAgICAgICAgdGhyb3cgdGhpcy5hc3RFcnJvck91dHB1dChgVW5hYmxlIHRvIGZpbmQgZGVjbGFyYXRvciB2YWx1ZVR5cGVgLCBhc3QpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBkZWNsYXJhdGlvbi52YWx1ZVR5cGU7XG4gICAgICAgIGNhc2UgJ0lkZW50aWZpZXInOlxuICAgICAgICAgIGlmIChhc3QubmFtZSA9PT0gJ0luZmluaXR5Jykge1xuICAgICAgICAgICAgcmV0dXJuICdOdW1iZXInO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodGhpcy5pc0FzdFZhcmlhYmxlKGFzdCkpIHtcbiAgICAgICAgICAgIGNvbnN0IHNpZ25hdHVyZSA9IHRoaXMuZ2V0VmFyaWFibGVTaWduYXR1cmUoYXN0KTtcbiAgICAgICAgICAgIGlmIChzaWduYXR1cmUgPT09ICd2YWx1ZScpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q2hlY2tWYXJpYWJsZVR5cGUoYXN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3Qgb3JpZ2luID0gdGhpcy5maW5kSWRlbnRpZmllck9yaWdpbihhc3QpO1xuICAgICAgICAgIGlmIChvcmlnaW4gJiYgb3JpZ2luLmluaXQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldFR5cGUob3JpZ2luLmluaXQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgY2FzZSAnUmV0dXJuU3RhdGVtZW50JzpcbiAgICAgICAgICByZXR1cm4gdGhpcy5nZXRUeXBlKGFzdC5hcmd1bWVudCk7XG4gICAgICAgIGNhc2UgJ01lbWJlckV4cHJlc3Npb24nOlxuICAgICAgICAgIGlmICh0aGlzLmlzQXN0TWF0aEZ1bmN0aW9uKGFzdCkpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoYXN0LnByb3BlcnR5Lm5hbWUpIHtcbiAgICAgICAgICAgICAgY2FzZSAnY2VpbCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuICdJbnRlZ2VyJztcbiAgICAgICAgICAgICAgY2FzZSAnZmxvb3InOlxuICAgICAgICAgICAgICAgIHJldHVybiAnSW50ZWdlcic7XG4gICAgICAgICAgICAgIGNhc2UgJ3JvdW5kJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gJ0ludGVnZXInO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuICdOdW1iZXInO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodGhpcy5pc0FzdFZhcmlhYmxlKGFzdCkpIHtcbiAgICAgICAgICAgIGNvbnN0IHZhcmlhYmxlU2lnbmF0dXJlID0gdGhpcy5nZXRWYXJpYWJsZVNpZ25hdHVyZShhc3QpO1xuICAgICAgICAgICAgc3dpdGNoICh2YXJpYWJsZVNpZ25hdHVyZSkge1xuICAgICAgICAgICAgICBjYXNlICd2YWx1ZVtdJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRMb29rdXBUeXBlKHRoaXMuZ2V0Q2hlY2tWYXJpYWJsZVR5cGUoYXN0Lm9iamVjdCkpO1xuICAgICAgICAgICAgICBjYXNlICd2YWx1ZVtdW10nOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldExvb2t1cFR5cGUodGhpcy5nZXRDaGVja1ZhcmlhYmxlVHlwZShhc3Qub2JqZWN0Lm9iamVjdCkpO1xuICAgICAgICAgICAgICBjYXNlICd2YWx1ZVtdW11bXSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TG9va3VwVHlwZSh0aGlzLmdldENoZWNrVmFyaWFibGVUeXBlKGFzdC5vYmplY3Qub2JqZWN0Lm9iamVjdCkpO1xuICAgICAgICAgICAgICBjYXNlICd2YWx1ZVtdW11bXVtdJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRMb29rdXBUeXBlKHRoaXMuZ2V0Q2hlY2tWYXJpYWJsZVR5cGUoYXN0Lm9iamVjdC5vYmplY3Qub2JqZWN0Lm9iamVjdCkpO1xuICAgICAgICAgICAgICBjYXNlICd2YWx1ZS50aHJlYWQudmFsdWUnOlxuICAgICAgICAgICAgICBjYXNlICd0aGlzLnRocmVhZC52YWx1ZSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuICdJbnRlZ2VyJztcbiAgICAgICAgICAgICAgY2FzZSAndGhpcy5vdXRwdXQudmFsdWUnOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmR5bmFtaWNPdXRwdXQgPyAnSW50ZWdlcicgOiAnTGl0ZXJhbEludGVnZXInO1xuICAgICAgICAgICAgICBjYXNlICd0aGlzLmNvbnN0YW50cy52YWx1ZSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q29uc3RhbnRUeXBlKGFzdC5wcm9wZXJ0eS5uYW1lKTtcbiAgICAgICAgICAgICAgY2FzZSAndGhpcy5jb25zdGFudHMudmFsdWVbXSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TG9va3VwVHlwZSh0aGlzLmdldENvbnN0YW50VHlwZShhc3Qub2JqZWN0LnByb3BlcnR5Lm5hbWUpKTtcbiAgICAgICAgICAgICAgY2FzZSAndGhpcy5jb25zdGFudHMudmFsdWVbXVtdJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRMb29rdXBUeXBlKHRoaXMuZ2V0Q29uc3RhbnRUeXBlKGFzdC5vYmplY3Qub2JqZWN0LnByb3BlcnR5Lm5hbWUpKTtcbiAgICAgICAgICAgICAgY2FzZSAndGhpcy5jb25zdGFudHMudmFsdWVbXVtdW10nOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldExvb2t1cFR5cGUodGhpcy5nZXRDb25zdGFudFR5cGUoYXN0Lm9iamVjdC5vYmplY3Qub2JqZWN0LnByb3BlcnR5Lm5hbWUpKTtcbiAgICAgICAgICAgICAgY2FzZSAndGhpcy5jb25zdGFudHMudmFsdWVbXVtdW11bXSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TG9va3VwVHlwZSh0aGlzLmdldENvbnN0YW50VHlwZShhc3Qub2JqZWN0Lm9iamVjdC5vYmplY3Qub2JqZWN0LnByb3BlcnR5Lm5hbWUpKTtcbiAgICAgICAgICAgICAgY2FzZSAnZm4oKVtdJzpcbiAgICAgICAgICAgICAgY2FzZSAnZm4oKVtdW10nOlxuICAgICAgICAgICAgICBjYXNlICdmbigpW11bXVtdJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRMb29rdXBUeXBlKHRoaXMuZ2V0VHlwZShhc3Qub2JqZWN0KSk7XG4gICAgICAgICAgICAgIGNhc2UgJ3ZhbHVlLnZhbHVlJzpcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pc0FzdE1hdGhWYXJpYWJsZShhc3QpKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gJ051bWJlcic7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN3aXRjaCAoYXN0LnByb3BlcnR5Lm5hbWUpIHtcbiAgICAgICAgICAgICAgICAgIGNhc2UgJ3InOlxuICAgICAgICAgICAgICAgICAgY2FzZSAnZyc6XG4gICAgICAgICAgICAgICAgICBjYXNlICdiJzpcbiAgICAgICAgICAgICAgICAgIGNhc2UgJ2EnOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRMb29rdXBUeXBlKHRoaXMuZ2V0Q2hlY2tWYXJpYWJsZVR5cGUoYXN0Lm9iamVjdCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlICdbXVtdJzpcbiAgICAgICAgICAgICAgICAgIHJldHVybiAnTnVtYmVyJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IHRoaXMuYXN0RXJyb3JPdXRwdXQoJ1VuaGFuZGxlZCBnZXRUeXBlIE1lbWJlckV4cHJlc3Npb24nLCBhc3QpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aHJvdyB0aGlzLmFzdEVycm9yT3V0cHV0KCdVbmhhbmRsZWQgZ2V0VHlwZSBNZW1iZXJFeHByZXNzaW9uJywgYXN0KTtcbiAgICAgICAgY2FzZSAnQ29uZGl0aW9uYWxFeHByZXNzaW9uJzpcbiAgICAgICAgICByZXR1cm4gdGhpcy5nZXRUeXBlKGFzdC5jb25zZXF1ZW50KTtcbiAgICAgICAgY2FzZSAnRnVuY3Rpb25EZWNsYXJhdGlvbic6XG4gICAgICAgIGNhc2UgJ0Z1bmN0aW9uRXhwcmVzc2lvbic6XG4gICAgICAgICAgY29uc3QgbGFzdFJldHVybiA9IHRoaXMuZmluZExhc3RSZXR1cm4oYXN0LmJvZHkpO1xuICAgICAgICAgIGlmIChsYXN0UmV0dXJuKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRUeXBlKGxhc3RSZXR1cm4pO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgY2FzZSAnSWZTdGF0ZW1lbnQnOlxuICAgICAgICAgIHJldHVybiB0aGlzLmdldFR5cGUoYXN0LmNvbnNlcXVlbnQpO1xuICAgICAgICBjYXNlICdTZXF1ZW5jZUV4cHJlc3Npb24nOlxuICAgICAgICAgIHJldHVybiB0aGlzLmdldFR5cGUoYXN0LmV4cHJlc3Npb25zW2FzdC5leHByZXNzaW9ucy5sZW5ndGggLSAxXSk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhyb3cgdGhpcy5hc3RFcnJvck91dHB1dChgVW5oYW5kbGVkIGdldFR5cGUgVHlwZSBcIiR7IGFzdC50eXBlIH1cImAsIGFzdCk7XG4gICAgfVxuICB9XG5cbiAgZ2V0Q2hlY2tWYXJpYWJsZVR5cGUoYXN0KSB7XG4gICAgY29uc3QgdHlwZSA9IHRoaXMuZ2V0VmFyaWFibGVUeXBlKGFzdCk7XG4gICAgaWYgKCF0eXBlKSB7XG4gICAgICB0aHJvdyB0aGlzLmFzdEVycm9yT3V0cHV0KGAke2FzdC50eXBlfSBpcyBub3QgZGVmaW5lZGAsIGFzdCk7XG4gICAgfVxuICAgIHJldHVybiB0eXBlO1xuICB9XG5cbiAgaW5mZXJBcmd1bWVudFR5cGVzSWZOZWVkZWQoZnVuY3Rpb25OYW1lLCBhcmdzKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoIXRoaXMubmVlZHNBcmd1bWVudFR5cGUoZnVuY3Rpb25OYW1lLCBpKSkgY29udGludWU7XG4gICAgICBjb25zdCB0eXBlID0gdGhpcy5nZXRUeXBlKGFyZ3NbaV0pO1xuICAgICAgaWYgKCF0eXBlKSB7XG4gICAgICAgIHRocm93IHRoaXMuYXN0RXJyb3JPdXRwdXQoYFVuYWJsZSB0byBpbmZlciBhcmd1bWVudCAke2l9YCwgYXJnc1tpXSk7XG4gICAgICB9XG4gICAgICB0aGlzLmFzc2lnbkFyZ3VtZW50VHlwZShmdW5jdGlvbk5hbWUsIGksIHR5cGUpO1xuICAgIH1cbiAgfVxuXG4gIGlzQXN0TWF0aFZhcmlhYmxlKGFzdCkge1xuICAgIGNvbnN0IG1hdGhQcm9wZXJ0aWVzID0gW1xuICAgICAgJ0UnLFxuICAgICAgJ1BJJyxcbiAgICAgICdTUVJUMicsXG4gICAgICAnU1FSVDFfMicsXG4gICAgICAnTE4yJyxcbiAgICAgICdMTjEwJyxcbiAgICAgICdMT0cyRScsXG4gICAgICAnTE9HMTBFJyxcbiAgICBdO1xuICAgIHJldHVybiBhc3QudHlwZSA9PT0gJ01lbWJlckV4cHJlc3Npb24nICYmXG4gICAgICBhc3Qub2JqZWN0ICYmIGFzdC5vYmplY3QudHlwZSA9PT0gJ0lkZW50aWZpZXInICYmXG4gICAgICBhc3Qub2JqZWN0Lm5hbWUgPT09ICdNYXRoJyAmJlxuICAgICAgYXN0LnByb3BlcnR5ICYmXG4gICAgICBhc3QucHJvcGVydHkudHlwZSA9PT0gJ0lkZW50aWZpZXInICYmXG4gICAgICBtYXRoUHJvcGVydGllcy5pbmRleE9mKGFzdC5wcm9wZXJ0eS5uYW1lKSA+IC0xO1xuICB9XG5cbiAgaXNBc3RNYXRoRnVuY3Rpb24oYXN0KSB7XG4gICAgY29uc3QgbWF0aEZ1bmN0aW9ucyA9IFtcbiAgICAgICdhYnMnLFxuICAgICAgJ2Fjb3MnLFxuICAgICAgJ2Fjb3NoJyxcbiAgICAgICdhc2luJyxcbiAgICAgICdhc2luaCcsXG4gICAgICAnYXRhbicsXG4gICAgICAnYXRhbjInLFxuICAgICAgJ2F0YW5oJyxcbiAgICAgICdjYnJ0JyxcbiAgICAgICdjZWlsJyxcbiAgICAgICdjbHozMicsXG4gICAgICAnY29zJyxcbiAgICAgICdjb3NoJyxcbiAgICAgICdleHBtMScsXG4gICAgICAnZXhwJyxcbiAgICAgICdmbG9vcicsXG4gICAgICAnZnJvdW5kJyxcbiAgICAgICdpbXVsJyxcbiAgICAgICdsb2cnLFxuICAgICAgJ2xvZzInLFxuICAgICAgJ2xvZzEwJyxcbiAgICAgICdsb2cxcCcsXG4gICAgICAnbWF4JyxcbiAgICAgICdtaW4nLFxuICAgICAgJ3BvdycsXG4gICAgICAncmFuZG9tJyxcbiAgICAgICdyb3VuZCcsXG4gICAgICAnc2lnbicsXG4gICAgICAnc2luJyxcbiAgICAgICdzaW5oJyxcbiAgICAgICdzcXJ0JyxcbiAgICAgICd0YW4nLFxuICAgICAgJ3RhbmgnLFxuICAgICAgJ3RydW5jJyxcbiAgICBdO1xuICAgIHJldHVybiBhc3QudHlwZSA9PT0gJ0NhbGxFeHByZXNzaW9uJyAmJlxuICAgICAgYXN0LmNhbGxlZSAmJlxuICAgICAgYXN0LmNhbGxlZS50eXBlID09PSAnTWVtYmVyRXhwcmVzc2lvbicgJiZcbiAgICAgIGFzdC5jYWxsZWUub2JqZWN0ICYmXG4gICAgICBhc3QuY2FsbGVlLm9iamVjdC50eXBlID09PSAnSWRlbnRpZmllcicgJiZcbiAgICAgIGFzdC5jYWxsZWUub2JqZWN0Lm5hbWUgPT09ICdNYXRoJyAmJlxuICAgICAgYXN0LmNhbGxlZS5wcm9wZXJ0eSAmJlxuICAgICAgYXN0LmNhbGxlZS5wcm9wZXJ0eS50eXBlID09PSAnSWRlbnRpZmllcicgJiZcbiAgICAgIG1hdGhGdW5jdGlvbnMuaW5kZXhPZihhc3QuY2FsbGVlLnByb3BlcnR5Lm5hbWUpID4gLTE7XG4gIH1cblxuICBpc0FzdFZhcmlhYmxlKGFzdCkge1xuICAgIHJldHVybiBhc3QudHlwZSA9PT0gJ0lkZW50aWZpZXInIHx8IGFzdC50eXBlID09PSAnTWVtYmVyRXhwcmVzc2lvbic7XG4gIH1cblxuICBpc1NhZmUoYXN0KSB7XG4gICAgcmV0dXJuIHRoaXMuaXNTYWZlRGVwZW5kZW5jaWVzKHRoaXMuZ2V0RGVwZW5kZW5jaWVzKGFzdCkpO1xuICB9XG5cbiAgaXNTYWZlRGVwZW5kZW5jaWVzKGRlcGVuZGVuY2llcykge1xuICAgIHJldHVybiBkZXBlbmRlbmNpZXMgJiYgZGVwZW5kZW5jaWVzLmV2ZXJ5ID8gZGVwZW5kZW5jaWVzLmV2ZXJ5KGRlcGVuZGVuY3kgPT4gZGVwZW5kZW5jeS5pc1NhZmUpIDogdHJ1ZTtcbiAgfVxuXG4gIGdldERlcGVuZGVuY2llcyhhc3QsIGRlcGVuZGVuY2llcywgaXNOb3RTYWZlKSB7XG4gICAgaWYgKCFkZXBlbmRlbmNpZXMpIHtcbiAgICAgIGRlcGVuZGVuY2llcyA9IFtdO1xuICAgIH1cbiAgICBpZiAoIWFzdCkgcmV0dXJuIG51bGw7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYXN0KSkge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy5nZXREZXBlbmRlbmNpZXMoYXN0W2ldLCBkZXBlbmRlbmNpZXMsIGlzTm90U2FmZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGVwZW5kZW5jaWVzO1xuICAgIH1cbiAgICBzd2l0Y2ggKGFzdC50eXBlKSB7XG4gICAgICBjYXNlICdBc3NpZ25tZW50RXhwcmVzc2lvbic6XG4gICAgICAgIHRoaXMuZ2V0RGVwZW5kZW5jaWVzKGFzdC5sZWZ0LCBkZXBlbmRlbmNpZXMsIGlzTm90U2FmZSk7XG4gICAgICAgIHRoaXMuZ2V0RGVwZW5kZW5jaWVzKGFzdC5yaWdodCwgZGVwZW5kZW5jaWVzLCBpc05vdFNhZmUpO1xuICAgICAgICByZXR1cm4gZGVwZW5kZW5jaWVzO1xuICAgICAgY2FzZSAnQ29uZGl0aW9uYWxFeHByZXNzaW9uJzpcbiAgICAgICAgdGhpcy5nZXREZXBlbmRlbmNpZXMoYXN0LnRlc3QsIGRlcGVuZGVuY2llcywgaXNOb3RTYWZlKTtcbiAgICAgICAgdGhpcy5nZXREZXBlbmRlbmNpZXMoYXN0LmFsdGVybmF0ZSwgZGVwZW5kZW5jaWVzLCBpc05vdFNhZmUpO1xuICAgICAgICB0aGlzLmdldERlcGVuZGVuY2llcyhhc3QuY29uc2VxdWVudCwgZGVwZW5kZW5jaWVzLCBpc05vdFNhZmUpO1xuICAgICAgICByZXR1cm4gZGVwZW5kZW5jaWVzO1xuICAgICAgY2FzZSAnTGl0ZXJhbCc6XG4gICAgICAgIGRlcGVuZGVuY2llcy5wdXNoKHtcbiAgICAgICAgICBvcmlnaW46ICdsaXRlcmFsJyxcbiAgICAgICAgICB2YWx1ZTogYXN0LnZhbHVlLFxuICAgICAgICAgIGlzU2FmZTogaXNOb3RTYWZlID09PSB0cnVlID8gZmFsc2UgOiBhc3QudmFsdWUgPiAtSW5maW5pdHkgJiYgYXN0LnZhbHVlIDwgSW5maW5pdHkgJiYgIWlzTmFOKGFzdC52YWx1ZSlcbiAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnVmFyaWFibGVEZWNsYXJhdG9yJzpcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0RGVwZW5kZW5jaWVzKGFzdC5pbml0LCBkZXBlbmRlbmNpZXMsIGlzTm90U2FmZSk7XG4gICAgICBjYXNlICdJZGVudGlmaWVyJzpcbiAgICAgICAgY29uc3QgZGVjbGFyYXRpb24gPSB0aGlzLmdldERlY2xhcmF0aW9uKGFzdCk7XG4gICAgICAgIGlmIChkZWNsYXJhdGlvbikge1xuICAgICAgICAgIGRlcGVuZGVuY2llcy5wdXNoKHtcbiAgICAgICAgICAgIG5hbWU6IGFzdC5uYW1lLFxuICAgICAgICAgICAgb3JpZ2luOiAnZGVjbGFyYXRpb24nLFxuICAgICAgICAgICAgaXNTYWZlOiBpc05vdFNhZmUgPyBmYWxzZSA6IHRoaXMuaXNTYWZlRGVwZW5kZW5jaWVzKGRlY2xhcmF0aW9uLmRlcGVuZGVuY2llcyksXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5hcmd1bWVudE5hbWVzLmluZGV4T2YoYXN0Lm5hbWUpID4gLTEpIHtcbiAgICAgICAgICBkZXBlbmRlbmNpZXMucHVzaCh7XG4gICAgICAgICAgICBuYW1lOiBhc3QubmFtZSxcbiAgICAgICAgICAgIG9yaWdpbjogJ2FyZ3VtZW50JyxcbiAgICAgICAgICAgIGlzU2FmZTogZmFsc2UsXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5zdHJpY3RUeXBpbmdDaGVja2luZykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IGZpbmQgaWRlbnRpZmllciBvcmlnaW4gXCIke2FzdC5uYW1lfVwiYCk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdGdW5jdGlvbkRlY2xhcmF0aW9uJzpcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0RGVwZW5kZW5jaWVzKGFzdC5ib2R5LmJvZHlbYXN0LmJvZHkuYm9keS5sZW5ndGggLSAxXSwgZGVwZW5kZW5jaWVzLCBpc05vdFNhZmUpO1xuICAgICAgY2FzZSAnUmV0dXJuU3RhdGVtZW50JzpcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0RGVwZW5kZW5jaWVzKGFzdC5hcmd1bWVudCwgZGVwZW5kZW5jaWVzKTtcbiAgICAgIGNhc2UgJ0JpbmFyeUV4cHJlc3Npb24nOlxuICAgICAgY2FzZSAnTG9naWNhbEV4cHJlc3Npb24nOlxuICAgICAgICBpc05vdFNhZmUgPSAoYXN0Lm9wZXJhdG9yID09PSAnLycgfHwgYXN0Lm9wZXJhdG9yID09PSAnKicpO1xuICAgICAgICB0aGlzLmdldERlcGVuZGVuY2llcyhhc3QubGVmdCwgZGVwZW5kZW5jaWVzLCBpc05vdFNhZmUpO1xuICAgICAgICB0aGlzLmdldERlcGVuZGVuY2llcyhhc3QucmlnaHQsIGRlcGVuZGVuY2llcywgaXNOb3RTYWZlKTtcbiAgICAgICAgcmV0dXJuIGRlcGVuZGVuY2llcztcbiAgICAgIGNhc2UgJ1VuYXJ5RXhwcmVzc2lvbic6XG4gICAgICBjYXNlICdVcGRhdGVFeHByZXNzaW9uJzpcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0RGVwZW5kZW5jaWVzKGFzdC5hcmd1bWVudCwgZGVwZW5kZW5jaWVzLCBpc05vdFNhZmUpO1xuICAgICAgY2FzZSAnVmFyaWFibGVEZWNsYXJhdGlvbic6XG4gICAgICAgIHJldHVybiB0aGlzLmdldERlcGVuZGVuY2llcyhhc3QuZGVjbGFyYXRpb25zLCBkZXBlbmRlbmNpZXMsIGlzTm90U2FmZSk7XG4gICAgICBjYXNlICdBcnJheUV4cHJlc3Npb24nOlxuICAgICAgICBkZXBlbmRlbmNpZXMucHVzaCh7XG4gICAgICAgICAgb3JpZ2luOiAnZGVjbGFyYXRpb24nLFxuICAgICAgICAgIGlzU2FmZTogdHJ1ZSxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBkZXBlbmRlbmNpZXM7XG4gICAgICBjYXNlICdDYWxsRXhwcmVzc2lvbic6XG4gICAgICAgIGRlcGVuZGVuY2llcy5wdXNoKHtcbiAgICAgICAgICBvcmlnaW46ICdmdW5jdGlvbicsXG4gICAgICAgICAgaXNTYWZlOiB0cnVlLFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGRlcGVuZGVuY2llcztcbiAgICAgIGNhc2UgJ01lbWJlckV4cHJlc3Npb24nOlxuICAgICAgICBjb25zdCBkZXRhaWxzID0gdGhpcy5nZXRNZW1iZXJFeHByZXNzaW9uRGV0YWlscyhhc3QpO1xuICAgICAgICBzd2l0Y2ggKGRldGFpbHMuc2lnbmF0dXJlKSB7XG4gICAgICAgICAgY2FzZSAndmFsdWVbXSc6XG4gICAgICAgICAgICB0aGlzLmdldERlcGVuZGVuY2llcyhhc3Qub2JqZWN0LCBkZXBlbmRlbmNpZXMsIGlzTm90U2FmZSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICd2YWx1ZVtdW10nOlxuICAgICAgICAgICAgdGhpcy5nZXREZXBlbmRlbmNpZXMoYXN0Lm9iamVjdC5vYmplY3QsIGRlcGVuZGVuY2llcywgaXNOb3RTYWZlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ3ZhbHVlW11bXVtdJzpcbiAgICAgICAgICAgIHRoaXMuZ2V0RGVwZW5kZW5jaWVzKGFzdC5vYmplY3Qub2JqZWN0Lm9iamVjdCwgZGVwZW5kZW5jaWVzLCBpc05vdFNhZmUpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAndGhpcy5vdXRwdXQudmFsdWUnOlxuICAgICAgICAgICAgaWYgKHRoaXMuZHluYW1pY091dHB1dCkge1xuICAgICAgICAgICAgICBkZXBlbmRlbmNpZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgbmFtZTogZGV0YWlscy5uYW1lLFxuICAgICAgICAgICAgICAgIG9yaWdpbjogJ291dHB1dCcsXG4gICAgICAgICAgICAgICAgaXNTYWZlOiBmYWxzZSxcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGV0YWlscykge1xuICAgICAgICAgIGlmIChkZXRhaWxzLnByb3BlcnR5KSB7XG4gICAgICAgICAgICB0aGlzLmdldERlcGVuZGVuY2llcyhkZXRhaWxzLnByb3BlcnR5LCBkZXBlbmRlbmNpZXMsIGlzTm90U2FmZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChkZXRhaWxzLnhQcm9wZXJ0eSkge1xuICAgICAgICAgICAgdGhpcy5nZXREZXBlbmRlbmNpZXMoZGV0YWlscy54UHJvcGVydHksIGRlcGVuZGVuY2llcywgaXNOb3RTYWZlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGRldGFpbHMueVByb3BlcnR5KSB7XG4gICAgICAgICAgICB0aGlzLmdldERlcGVuZGVuY2llcyhkZXRhaWxzLnlQcm9wZXJ0eSwgZGVwZW5kZW5jaWVzLCBpc05vdFNhZmUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZGV0YWlscy56UHJvcGVydHkpIHtcbiAgICAgICAgICAgIHRoaXMuZ2V0RGVwZW5kZW5jaWVzKGRldGFpbHMuelByb3BlcnR5LCBkZXBlbmRlbmNpZXMsIGlzTm90U2FmZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBkZXBlbmRlbmNpZXM7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnU2VxdWVuY2VFeHByZXNzaW9uJzpcbiAgICAgICAgICByZXR1cm4gdGhpcy5nZXREZXBlbmRlbmNpZXMoYXN0LmV4cHJlc3Npb25zLCBkZXBlbmRlbmNpZXMsIGlzTm90U2FmZSk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhyb3cgdGhpcy5hc3RFcnJvck91dHB1dChgVW5oYW5kbGVkIHR5cGUgJHsgYXN0LnR5cGUgfSBpbiBnZXREZXBlbmRlbmNpZXNgLCBhc3QpO1xuICAgIH1cbiAgICByZXR1cm4gZGVwZW5kZW5jaWVzO1xuICB9XG5cbiAgZ2V0VmFyaWFibGVTaWduYXR1cmUoYXN0LCByZXR1cm5SYXdWYWx1ZSkge1xuICAgIGlmICghdGhpcy5pc0FzdFZhcmlhYmxlKGFzdCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgYXN0IG9mIHR5cGUgXCIkeyBhc3QudHlwZSB9XCIgaXMgbm90IGEgdmFyaWFibGUgc2lnbmF0dXJlYCk7XG4gICAgfVxuICAgIGlmIChhc3QudHlwZSA9PT0gJ0lkZW50aWZpZXInKSB7XG4gICAgICByZXR1cm4gJ3ZhbHVlJztcbiAgICB9XG4gICAgY29uc3Qgc2lnbmF0dXJlID0gW107XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIGlmICghYXN0KSBicmVhaztcbiAgICAgIGlmIChhc3QuY29tcHV0ZWQpIHtcbiAgICAgICAgc2lnbmF0dXJlLnB1c2goJ1tdJyk7XG4gICAgICB9IGVsc2UgaWYgKGFzdC50eXBlID09PSAnVGhpc0V4cHJlc3Npb24nKSB7XG4gICAgICAgIHNpZ25hdHVyZS51bnNoaWZ0KCd0aGlzJyk7XG4gICAgICB9IGVsc2UgaWYgKGFzdC5wcm9wZXJ0eSAmJiBhc3QucHJvcGVydHkubmFtZSkge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgYXN0LnByb3BlcnR5Lm5hbWUgPT09ICd4JyB8fFxuICAgICAgICAgIGFzdC5wcm9wZXJ0eS5uYW1lID09PSAneScgfHxcbiAgICAgICAgICBhc3QucHJvcGVydHkubmFtZSA9PT0gJ3onXG4gICAgICAgICkge1xuICAgICAgICAgIHNpZ25hdHVyZS51bnNoaWZ0KHJldHVyblJhd1ZhbHVlID8gJy4nICsgYXN0LnByb3BlcnR5Lm5hbWUgOiAnLnZhbHVlJyk7XG4gICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAgYXN0LnByb3BlcnR5Lm5hbWUgPT09ICdjb25zdGFudHMnIHx8XG4gICAgICAgICAgYXN0LnByb3BlcnR5Lm5hbWUgPT09ICd0aHJlYWQnIHx8XG4gICAgICAgICAgYXN0LnByb3BlcnR5Lm5hbWUgPT09ICdvdXRwdXQnXG4gICAgICAgICkge1xuICAgICAgICAgIHNpZ25hdHVyZS51bnNoaWZ0KCcuJyArIGFzdC5wcm9wZXJ0eS5uYW1lKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzaWduYXR1cmUudW5zaGlmdChyZXR1cm5SYXdWYWx1ZSA/ICcuJyArIGFzdC5wcm9wZXJ0eS5uYW1lIDogJy52YWx1ZScpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGFzdC5uYW1lKSB7XG4gICAgICAgIHNpZ25hdHVyZS51bnNoaWZ0KHJldHVyblJhd1ZhbHVlID8gYXN0Lm5hbWUgOiAndmFsdWUnKTtcbiAgICAgIH0gZWxzZSBpZiAoYXN0LmNhbGxlZSAmJiBhc3QuY2FsbGVlLm5hbWUpIHtcbiAgICAgICAgc2lnbmF0dXJlLnVuc2hpZnQocmV0dXJuUmF3VmFsdWUgPyBhc3QuY2FsbGVlLm5hbWUgKyAnKCknIDogJ2ZuKCknKTtcbiAgICAgIH0gZWxzZSBpZiAoYXN0LmVsZW1lbnRzKSB7XG4gICAgICAgIHNpZ25hdHVyZS51bnNoaWZ0KCdbXScpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2lnbmF0dXJlLnVuc2hpZnQoJ3Vua25vd24nKTtcbiAgICAgIH1cbiAgICAgIGFzdCA9IGFzdC5vYmplY3Q7XG4gICAgfVxuXG4gICAgY29uc3Qgc2lnbmF0dXJlU3RyaW5nID0gc2lnbmF0dXJlLmpvaW4oJycpO1xuICAgIGlmIChyZXR1cm5SYXdWYWx1ZSkge1xuICAgICAgcmV0dXJuIHNpZ25hdHVyZVN0cmluZztcbiAgICB9XG5cbiAgICBjb25zdCBhbGxvd2VkRXhwcmVzc2lvbnMgPSBbXG4gICAgICAndmFsdWUnLFxuICAgICAgJ3ZhbHVlW10nLFxuICAgICAgJ3ZhbHVlW11bXScsXG4gICAgICAndmFsdWVbXVtdW10nLFxuICAgICAgJ3ZhbHVlW11bXVtdW10nLFxuICAgICAgJ3ZhbHVlLnZhbHVlJyxcbiAgICAgICd2YWx1ZS50aHJlYWQudmFsdWUnLFxuICAgICAgJ3RoaXMudGhyZWFkLnZhbHVlJyxcbiAgICAgICd0aGlzLm91dHB1dC52YWx1ZScsXG4gICAgICAndGhpcy5jb25zdGFudHMudmFsdWUnLFxuICAgICAgJ3RoaXMuY29uc3RhbnRzLnZhbHVlW10nLFxuICAgICAgJ3RoaXMuY29uc3RhbnRzLnZhbHVlW11bXScsXG4gICAgICAndGhpcy5jb25zdGFudHMudmFsdWVbXVtdW10nLFxuICAgICAgJ3RoaXMuY29uc3RhbnRzLnZhbHVlW11bXVtdW10nLFxuICAgICAgJ2ZuKClbXScsXG4gICAgICAnZm4oKVtdW10nLFxuICAgICAgJ2ZuKClbXVtdW10nLFxuICAgICAgJ1tdW10nLFxuICAgIF07XG4gICAgaWYgKGFsbG93ZWRFeHByZXNzaW9ucy5pbmRleE9mKHNpZ25hdHVyZVN0cmluZykgPiAtMSkge1xuICAgICAgcmV0dXJuIHNpZ25hdHVyZVN0cmluZztcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBidWlsZCgpIHtcbiAgICByZXR1cm4gdGhpcy50b1N0cmluZygpLmxlbmd0aCA+IDA7XG4gIH1cblxuICBhc3RHZW5lcmljKGFzdCwgcmV0QXJyKSB7XG4gICAgaWYgKGFzdCA9PT0gbnVsbCkge1xuICAgICAgdGhyb3cgdGhpcy5hc3RFcnJvck91dHB1dCgnTlVMTCBhc3QnLCBhc3QpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShhc3QpKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdGhpcy5hc3RHZW5lcmljKGFzdFtpXSwgcmV0QXJyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmV0QXJyO1xuICAgICAgfVxuXG4gICAgICBzd2l0Y2ggKGFzdC50eXBlKSB7XG4gICAgICAgIGNhc2UgJ0Z1bmN0aW9uRGVjbGFyYXRpb24nOlxuICAgICAgICAgIHJldHVybiB0aGlzLmFzdEZ1bmN0aW9uRGVjbGFyYXRpb24oYXN0LCByZXRBcnIpO1xuICAgICAgICBjYXNlICdGdW5jdGlvbkV4cHJlc3Npb24nOlxuICAgICAgICAgIHJldHVybiB0aGlzLmFzdEZ1bmN0aW9uRXhwcmVzc2lvbihhc3QsIHJldEFycik7XG4gICAgICAgIGNhc2UgJ1JldHVyblN0YXRlbWVudCc6XG4gICAgICAgICAgcmV0dXJuIHRoaXMuYXN0UmV0dXJuU3RhdGVtZW50KGFzdCwgcmV0QXJyKTtcbiAgICAgICAgY2FzZSAnTGl0ZXJhbCc6XG4gICAgICAgICAgcmV0dXJuIHRoaXMuYXN0TGl0ZXJhbChhc3QsIHJldEFycik7XG4gICAgICAgIGNhc2UgJ0JpbmFyeUV4cHJlc3Npb24nOlxuICAgICAgICAgIHJldHVybiB0aGlzLmFzdEJpbmFyeUV4cHJlc3Npb24oYXN0LCByZXRBcnIpO1xuICAgICAgICBjYXNlICdJZGVudGlmaWVyJzpcbiAgICAgICAgICByZXR1cm4gdGhpcy5hc3RJZGVudGlmaWVyRXhwcmVzc2lvbihhc3QsIHJldEFycik7XG4gICAgICAgIGNhc2UgJ0Fzc2lnbm1lbnRFeHByZXNzaW9uJzpcbiAgICAgICAgICByZXR1cm4gdGhpcy5hc3RBc3NpZ25tZW50RXhwcmVzc2lvbihhc3QsIHJldEFycik7XG4gICAgICAgIGNhc2UgJ0V4cHJlc3Npb25TdGF0ZW1lbnQnOlxuICAgICAgICAgIHJldHVybiB0aGlzLmFzdEV4cHJlc3Npb25TdGF0ZW1lbnQoYXN0LCByZXRBcnIpO1xuICAgICAgICBjYXNlICdFbXB0eVN0YXRlbWVudCc6XG4gICAgICAgICAgcmV0dXJuIHRoaXMuYXN0RW1wdHlTdGF0ZW1lbnQoYXN0LCByZXRBcnIpO1xuICAgICAgICBjYXNlICdCbG9ja1N0YXRlbWVudCc6XG4gICAgICAgICAgcmV0dXJuIHRoaXMuYXN0QmxvY2tTdGF0ZW1lbnQoYXN0LCByZXRBcnIpO1xuICAgICAgICBjYXNlICdJZlN0YXRlbWVudCc6XG4gICAgICAgICAgcmV0dXJuIHRoaXMuYXN0SWZTdGF0ZW1lbnQoYXN0LCByZXRBcnIpO1xuICAgICAgICBjYXNlICdTd2l0Y2hTdGF0ZW1lbnQnOlxuICAgICAgICAgIHJldHVybiB0aGlzLmFzdFN3aXRjaFN0YXRlbWVudChhc3QsIHJldEFycik7XG4gICAgICAgIGNhc2UgJ0JyZWFrU3RhdGVtZW50JzpcbiAgICAgICAgICByZXR1cm4gdGhpcy5hc3RCcmVha1N0YXRlbWVudChhc3QsIHJldEFycik7XG4gICAgICAgIGNhc2UgJ0NvbnRpbnVlU3RhdGVtZW50JzpcbiAgICAgICAgICByZXR1cm4gdGhpcy5hc3RDb250aW51ZVN0YXRlbWVudChhc3QsIHJldEFycik7XG4gICAgICAgIGNhc2UgJ0ZvclN0YXRlbWVudCc6XG4gICAgICAgICAgcmV0dXJuIHRoaXMuYXN0Rm9yU3RhdGVtZW50KGFzdCwgcmV0QXJyKTtcbiAgICAgICAgY2FzZSAnV2hpbGVTdGF0ZW1lbnQnOlxuICAgICAgICAgIHJldHVybiB0aGlzLmFzdFdoaWxlU3RhdGVtZW50KGFzdCwgcmV0QXJyKTtcbiAgICAgICAgY2FzZSAnRG9XaGlsZVN0YXRlbWVudCc6XG4gICAgICAgICAgcmV0dXJuIHRoaXMuYXN0RG9XaGlsZVN0YXRlbWVudChhc3QsIHJldEFycik7XG4gICAgICAgIGNhc2UgJ1ZhcmlhYmxlRGVjbGFyYXRpb24nOlxuICAgICAgICAgIHJldHVybiB0aGlzLmFzdFZhcmlhYmxlRGVjbGFyYXRpb24oYXN0LCByZXRBcnIpO1xuICAgICAgICBjYXNlICdWYXJpYWJsZURlY2xhcmF0b3InOlxuICAgICAgICAgIHJldHVybiB0aGlzLmFzdFZhcmlhYmxlRGVjbGFyYXRvcihhc3QsIHJldEFycik7XG4gICAgICAgIGNhc2UgJ1RoaXNFeHByZXNzaW9uJzpcbiAgICAgICAgICByZXR1cm4gdGhpcy5hc3RUaGlzRXhwcmVzc2lvbihhc3QsIHJldEFycik7XG4gICAgICAgIGNhc2UgJ1NlcXVlbmNlRXhwcmVzc2lvbic6XG4gICAgICAgICAgcmV0dXJuIHRoaXMuYXN0U2VxdWVuY2VFeHByZXNzaW9uKGFzdCwgcmV0QXJyKTtcbiAgICAgICAgY2FzZSAnVW5hcnlFeHByZXNzaW9uJzpcbiAgICAgICAgICByZXR1cm4gdGhpcy5hc3RVbmFyeUV4cHJlc3Npb24oYXN0LCByZXRBcnIpO1xuICAgICAgICBjYXNlICdVcGRhdGVFeHByZXNzaW9uJzpcbiAgICAgICAgICByZXR1cm4gdGhpcy5hc3RVcGRhdGVFeHByZXNzaW9uKGFzdCwgcmV0QXJyKTtcbiAgICAgICAgY2FzZSAnTG9naWNhbEV4cHJlc3Npb24nOlxuICAgICAgICAgIHJldHVybiB0aGlzLmFzdExvZ2ljYWxFeHByZXNzaW9uKGFzdCwgcmV0QXJyKTtcbiAgICAgICAgY2FzZSAnTWVtYmVyRXhwcmVzc2lvbic6XG4gICAgICAgICAgcmV0dXJuIHRoaXMuYXN0TWVtYmVyRXhwcmVzc2lvbihhc3QsIHJldEFycik7XG4gICAgICAgIGNhc2UgJ0NhbGxFeHByZXNzaW9uJzpcbiAgICAgICAgICByZXR1cm4gdGhpcy5hc3RDYWxsRXhwcmVzc2lvbihhc3QsIHJldEFycik7XG4gICAgICAgIGNhc2UgJ0FycmF5RXhwcmVzc2lvbic6XG4gICAgICAgICAgcmV0dXJuIHRoaXMuYXN0QXJyYXlFeHByZXNzaW9uKGFzdCwgcmV0QXJyKTtcbiAgICAgICAgY2FzZSAnRGVidWdnZXJTdGF0ZW1lbnQnOlxuICAgICAgICAgIHJldHVybiB0aGlzLmFzdERlYnVnZ2VyU3RhdGVtZW50KGFzdCwgcmV0QXJyKTtcbiAgICAgICAgY2FzZSAnQ29uZGl0aW9uYWxFeHByZXNzaW9uJzpcbiAgICAgICAgICByZXR1cm4gdGhpcy5hc3RDb25kaXRpb25hbEV4cHJlc3Npb24oYXN0LCByZXRBcnIpO1xuICAgICAgfVxuXG4gICAgICB0aHJvdyB0aGlzLmFzdEVycm9yT3V0cHV0KCdVbmtub3duIGFzdCB0eXBlIDogJyArIGFzdC50eXBlLCBhc3QpO1xuICAgIH1cbiAgfVxuICBhc3RFcnJvck91dHB1dChlcnJvciwgYXN0KSB7XG4gICAgaWYgKHR5cGVvZiB0aGlzLnNvdXJjZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiBuZXcgRXJyb3IoZXJyb3IpO1xuICAgIH1cblxuICAgIGNvbnN0IGRlYnVnU3RyaW5nID0gdXRpbHMuZ2V0QXN0U3RyaW5nKHRoaXMuc291cmNlLCBhc3QpO1xuICAgIGNvbnN0IGxlYWRpbmdTb3VyY2UgPSB0aGlzLnNvdXJjZS5zdWJzdHIoYXN0LnN0YXJ0KTtcbiAgICBjb25zdCBzcGxpdExpbmVzID0gbGVhZGluZ1NvdXJjZS5zcGxpdCgvXFxuLyk7XG4gICAgY29uc3QgbGluZUJlZm9yZSA9IHNwbGl0TGluZXMubGVuZ3RoID4gMCA/IHNwbGl0TGluZXNbc3BsaXRMaW5lcy5sZW5ndGggLSAxXSA6IDA7XG4gICAgcmV0dXJuIG5ldyBFcnJvcihgJHtlcnJvcn0gb24gbGluZSAkeyBzcGxpdExpbmVzLmxlbmd0aCB9LCBwb3NpdGlvbiAkeyBsaW5lQmVmb3JlLmxlbmd0aCB9OlxcbiAkeyBkZWJ1Z1N0cmluZyB9YCk7XG4gIH1cblxuICBhc3REZWJ1Z2dlclN0YXRlbWVudChhcnJOb2RlLCByZXRBcnIpIHtcbiAgICByZXR1cm4gcmV0QXJyO1xuICB9XG5cbiAgYXN0Q29uZGl0aW9uYWxFeHByZXNzaW9uKGFzdCwgcmV0QXJyKSB7XG4gICAgaWYgKGFzdC50eXBlICE9PSAnQ29uZGl0aW9uYWxFeHByZXNzaW9uJykge1xuICAgICAgdGhyb3cgdGhpcy5hc3RFcnJvck91dHB1dCgnTm90IGEgY29uZGl0aW9uYWwgZXhwcmVzc2lvbicsIGFzdCk7XG4gICAgfVxuICAgIHJldEFyci5wdXNoKCcoJyk7XG4gICAgdGhpcy5hc3RHZW5lcmljKGFzdC50ZXN0LCByZXRBcnIpO1xuICAgIHJldEFyci5wdXNoKCc/Jyk7XG4gICAgdGhpcy5hc3RHZW5lcmljKGFzdC5jb25zZXF1ZW50LCByZXRBcnIpO1xuICAgIHJldEFyci5wdXNoKCc6Jyk7XG4gICAgdGhpcy5hc3RHZW5lcmljKGFzdC5hbHRlcm5hdGUsIHJldEFycik7XG4gICAgcmV0QXJyLnB1c2goJyknKTtcbiAgICByZXR1cm4gcmV0QXJyO1xuICB9XG5cbiAgYXN0RnVuY3Rpb24oYXN0LCByZXRBcnIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFwiYXN0RnVuY3Rpb25cIiBub3QgZGVmaW5lZCBvbiAkeyB0aGlzLmNvbnN0cnVjdG9yLm5hbWUgfWApO1xuICB9XG5cbiAgYXN0RnVuY3Rpb25EZWNsYXJhdGlvbihhc3QsIHJldEFycikge1xuICAgIGlmICh0aGlzLmlzQ2hpbGRGdW5jdGlvbihhc3QpKSB7XG4gICAgICByZXR1cm4gcmV0QXJyO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5hc3RGdW5jdGlvbihhc3QsIHJldEFycik7XG4gIH1cbiAgYXN0RnVuY3Rpb25FeHByZXNzaW9uKGFzdCwgcmV0QXJyKSB7XG4gICAgaWYgKHRoaXMuaXNDaGlsZEZ1bmN0aW9uKGFzdCkpIHtcbiAgICAgIHJldHVybiByZXRBcnI7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmFzdEZ1bmN0aW9uKGFzdCwgcmV0QXJyKTtcbiAgfVxuICBpc0NoaWxkRnVuY3Rpb24oYXN0KSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmZ1bmN0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHRoaXMuZnVuY3Rpb25zW2ldID09PSBhc3QpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBhc3RSZXR1cm5TdGF0ZW1lbnQoYXN0LCByZXRBcnIpIHtcbiAgICByZXR1cm4gcmV0QXJyO1xuICB9XG4gIGFzdExpdGVyYWwoYXN0LCByZXRBcnIpIHtcbiAgICB0aGlzLmxpdGVyYWxUeXBlc1t0aGlzLmFzdEtleShhc3QpXSA9ICdOdW1iZXInO1xuICAgIHJldHVybiByZXRBcnI7XG4gIH1cbiAgYXN0QmluYXJ5RXhwcmVzc2lvbihhc3QsIHJldEFycikge1xuICAgIHJldHVybiByZXRBcnI7XG4gIH1cbiAgYXN0SWRlbnRpZmllckV4cHJlc3Npb24oYXN0LCByZXRBcnIpIHtcbiAgICByZXR1cm4gcmV0QXJyO1xuICB9XG4gIGFzdEFzc2lnbm1lbnRFeHByZXNzaW9uKGFzdCwgcmV0QXJyKSB7XG4gICAgcmV0dXJuIHJldEFycjtcbiAgfVxuICBhc3RFeHByZXNzaW9uU3RhdGVtZW50KGVzTm9kZSwgcmV0QXJyKSB7XG4gICAgdGhpcy5hc3RHZW5lcmljKGVzTm9kZS5leHByZXNzaW9uLCByZXRBcnIpO1xuICAgIHJldEFyci5wdXNoKCc7Jyk7XG4gICAgcmV0dXJuIHJldEFycjtcbiAgfVxuICBhc3RFbXB0eVN0YXRlbWVudChlTm9kZSwgcmV0QXJyKSB7XG4gICAgcmV0dXJuIHJldEFycjtcbiAgfVxuICBhc3RCbG9ja1N0YXRlbWVudChhc3QsIHJldEFycikge1xuICAgIHJldHVybiByZXRBcnI7XG4gIH1cbiAgYXN0SWZTdGF0ZW1lbnQoYXN0LCByZXRBcnIpIHtcbiAgICByZXR1cm4gcmV0QXJyO1xuICB9XG4gIGFzdFN3aXRjaFN0YXRlbWVudChhc3QsIHJldEFycikge1xuICAgIHJldHVybiByZXRBcnI7XG4gIH1cbiAgYXN0QnJlYWtTdGF0ZW1lbnQoYnJOb2RlLCByZXRBcnIpIHtcbiAgICByZXRBcnIucHVzaCgnYnJlYWs7Jyk7XG4gICAgcmV0dXJuIHJldEFycjtcbiAgfVxuICBhc3RDb250aW51ZVN0YXRlbWVudChjck5vZGUsIHJldEFycikge1xuICAgIHJldEFyci5wdXNoKCdjb250aW51ZTtcXG4nKTtcbiAgICByZXR1cm4gcmV0QXJyO1xuICB9XG4gIGFzdEZvclN0YXRlbWVudChhc3QsIHJldEFycikge1xuICAgIHJldHVybiByZXRBcnI7XG4gIH1cbiAgYXN0V2hpbGVTdGF0ZW1lbnQoYXN0LCByZXRBcnIpIHtcbiAgICByZXR1cm4gcmV0QXJyO1xuICB9XG4gIGFzdERvV2hpbGVTdGF0ZW1lbnQoYXN0LCByZXRBcnIpIHtcbiAgICByZXR1cm4gcmV0QXJyO1xuICB9XG4gIGFzdFZhcmlhYmxlRGVjbGFyYXRvcihpVmFyRGVjTm9kZSwgcmV0QXJyKSB7XG4gICAgdGhpcy5hc3RHZW5lcmljKGlWYXJEZWNOb2RlLmlkLCByZXRBcnIpO1xuICAgIGlmIChpVmFyRGVjTm9kZS5pbml0ICE9PSBudWxsKSB7XG4gICAgICByZXRBcnIucHVzaCgnPScpO1xuICAgICAgdGhpcy5hc3RHZW5lcmljKGlWYXJEZWNOb2RlLmluaXQsIHJldEFycik7XG4gICAgfVxuICAgIHJldHVybiByZXRBcnI7XG4gIH1cbiAgYXN0VGhpc0V4cHJlc3Npb24oYXN0LCByZXRBcnIpIHtcbiAgICByZXR1cm4gcmV0QXJyO1xuICB9XG4gIGFzdFNlcXVlbmNlRXhwcmVzc2lvbihzTm9kZSwgcmV0QXJyKSB7XG4gICAgY29uc3QgeyBleHByZXNzaW9ucyB9ID0gc05vZGU7XG4gICAgY29uc3Qgc2VxdWVuY2VSZXN1bHQgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGV4cHJlc3Npb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBleHByZXNzaW9uID0gZXhwcmVzc2lvbnNbaV07XG4gICAgICBjb25zdCBleHByZXNzaW9uUmVzdWx0ID0gW107XG4gICAgICB0aGlzLmFzdEdlbmVyaWMoZXhwcmVzc2lvbiwgZXhwcmVzc2lvblJlc3VsdCk7XG4gICAgICBzZXF1ZW5jZVJlc3VsdC5wdXNoKGV4cHJlc3Npb25SZXN1bHQuam9pbignJykpO1xuICAgIH1cbiAgICBpZiAoc2VxdWVuY2VSZXN1bHQubGVuZ3RoID4gMSkge1xuICAgICAgcmV0QXJyLnB1c2goJygnLCBzZXF1ZW5jZVJlc3VsdC5qb2luKCcsJyksICcpJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldEFyci5wdXNoKHNlcXVlbmNlUmVzdWx0WzBdKTtcbiAgICB9XG4gICAgcmV0dXJuIHJldEFycjtcbiAgfVxuICBhc3RVbmFyeUV4cHJlc3Npb24odU5vZGUsIHJldEFycikge1xuICAgIGNvbnN0IHVuYXJ5UmVzdWx0ID0gdGhpcy5jaGVja0FuZFVwY29udmVydEJpdHdpc2VVbmFyeSh1Tm9kZSwgcmV0QXJyKTtcbiAgICBpZiAodW5hcnlSZXN1bHQpIHtcbiAgICAgIHJldHVybiByZXRBcnI7XG4gICAgfVxuXG4gICAgaWYgKHVOb2RlLnByZWZpeCkge1xuICAgICAgcmV0QXJyLnB1c2godU5vZGUub3BlcmF0b3IpO1xuICAgICAgdGhpcy5hc3RHZW5lcmljKHVOb2RlLmFyZ3VtZW50LCByZXRBcnIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmFzdEdlbmVyaWModU5vZGUuYXJndW1lbnQsIHJldEFycik7XG4gICAgICByZXRBcnIucHVzaCh1Tm9kZS5vcGVyYXRvcik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJldEFycjtcbiAgfVxuXG4gIGNoZWNrQW5kVXBjb252ZXJ0Qml0d2lzZVVuYXJ5KHVOb2RlLCByZXRBcnIpIHt9XG5cbiAgYXN0VXBkYXRlRXhwcmVzc2lvbih1Tm9kZSwgcmV0QXJyKSB7XG4gICAgaWYgKHVOb2RlLnByZWZpeCkge1xuICAgICAgcmV0QXJyLnB1c2godU5vZGUub3BlcmF0b3IpO1xuICAgICAgdGhpcy5hc3RHZW5lcmljKHVOb2RlLmFyZ3VtZW50LCByZXRBcnIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmFzdEdlbmVyaWModU5vZGUuYXJndW1lbnQsIHJldEFycik7XG4gICAgICByZXRBcnIucHVzaCh1Tm9kZS5vcGVyYXRvcik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJldEFycjtcbiAgfVxuICBhc3RMb2dpY2FsRXhwcmVzc2lvbihsb2dOb2RlLCByZXRBcnIpIHtcbiAgICByZXRBcnIucHVzaCgnKCcpO1xuICAgIHRoaXMuYXN0R2VuZXJpYyhsb2dOb2RlLmxlZnQsIHJldEFycik7XG4gICAgcmV0QXJyLnB1c2gobG9nTm9kZS5vcGVyYXRvcik7XG4gICAgdGhpcy5hc3RHZW5lcmljKGxvZ05vZGUucmlnaHQsIHJldEFycik7XG4gICAgcmV0QXJyLnB1c2goJyknKTtcbiAgICByZXR1cm4gcmV0QXJyO1xuICB9XG4gIGFzdE1lbWJlckV4cHJlc3Npb24oYXN0LCByZXRBcnIpIHtcbiAgICByZXR1cm4gcmV0QXJyO1xuICB9XG4gIGFzdENhbGxFeHByZXNzaW9uKGFzdCwgcmV0QXJyKSB7XG4gICAgcmV0dXJuIHJldEFycjtcbiAgfVxuICBhc3RBcnJheUV4cHJlc3Npb24oYXN0LCByZXRBcnIpIHtcbiAgICByZXR1cm4gcmV0QXJyO1xuICB9XG5cbiAgZ2V0TWVtYmVyRXhwcmVzc2lvbkRldGFpbHMoYXN0KSB7XG4gICAgaWYgKGFzdC50eXBlICE9PSAnTWVtYmVyRXhwcmVzc2lvbicpIHtcbiAgICAgIHRocm93IHRoaXMuYXN0RXJyb3JPdXRwdXQoYEV4cHJlc3Npb24gJHsgYXN0LnR5cGUgfSBub3QgYSBNZW1iZXJFeHByZXNzaW9uYCwgYXN0KTtcbiAgICB9XG4gICAgbGV0IG5hbWUgPSBudWxsO1xuICAgIGxldCB0eXBlID0gbnVsbDtcbiAgICBjb25zdCB2YXJpYWJsZVNpZ25hdHVyZSA9IHRoaXMuZ2V0VmFyaWFibGVTaWduYXR1cmUoYXN0KTtcbiAgICBzd2l0Y2ggKHZhcmlhYmxlU2lnbmF0dXJlKSB7XG4gICAgICBjYXNlICd2YWx1ZSc6XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgY2FzZSAndmFsdWUudGhyZWFkLnZhbHVlJzpcbiAgICAgIGNhc2UgJ3RoaXMudGhyZWFkLnZhbHVlJzpcbiAgICAgIGNhc2UgJ3RoaXMub3V0cHV0LnZhbHVlJzpcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBzaWduYXR1cmU6IHZhcmlhYmxlU2lnbmF0dXJlLFxuICAgICAgICAgICAgdHlwZTogJ0ludGVnZXInLFxuICAgICAgICAgICAgbmFtZTogYXN0LnByb3BlcnR5Lm5hbWVcbiAgICAgICAgfTtcbiAgICAgIGNhc2UgJ3ZhbHVlW10nOlxuICAgICAgICBpZiAodHlwZW9mIGFzdC5vYmplY3QubmFtZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICB0aHJvdyB0aGlzLmFzdEVycm9yT3V0cHV0KCdVbmV4cGVjdGVkIGV4cHJlc3Npb24nLCBhc3QpO1xuICAgICAgICB9XG4gICAgICAgIG5hbWUgPSBhc3Qub2JqZWN0Lm5hbWU7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbmFtZSxcbiAgICAgICAgICBvcmlnaW46ICd1c2VyJyxcbiAgICAgICAgICAgIHNpZ25hdHVyZTogdmFyaWFibGVTaWduYXR1cmUsXG4gICAgICAgICAgICB0eXBlOiB0aGlzLmdldFZhcmlhYmxlVHlwZShhc3Qub2JqZWN0KSxcbiAgICAgICAgICAgIHhQcm9wZXJ0eTogYXN0LnByb3BlcnR5XG4gICAgICAgIH07XG4gICAgICBjYXNlICd2YWx1ZVtdW10nOlxuICAgICAgICBpZiAodHlwZW9mIGFzdC5vYmplY3Qub2JqZWN0Lm5hbWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgdGhyb3cgdGhpcy5hc3RFcnJvck91dHB1dCgnVW5leHBlY3RlZCBleHByZXNzaW9uJywgYXN0KTtcbiAgICAgICAgfVxuICAgICAgICBuYW1lID0gYXN0Lm9iamVjdC5vYmplY3QubmFtZTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBuYW1lLFxuICAgICAgICAgIG9yaWdpbjogJ3VzZXInLFxuICAgICAgICAgICAgc2lnbmF0dXJlOiB2YXJpYWJsZVNpZ25hdHVyZSxcbiAgICAgICAgICAgIHR5cGU6IHRoaXMuZ2V0VmFyaWFibGVUeXBlKGFzdC5vYmplY3Qub2JqZWN0KSxcbiAgICAgICAgICAgIHlQcm9wZXJ0eTogYXN0Lm9iamVjdC5wcm9wZXJ0eSxcbiAgICAgICAgICAgIHhQcm9wZXJ0eTogYXN0LnByb3BlcnR5LFxuICAgICAgICB9O1xuICAgICAgY2FzZSAndmFsdWVbXVtdW10nOlxuICAgICAgICBpZiAodHlwZW9mIGFzdC5vYmplY3Qub2JqZWN0Lm9iamVjdC5uYW1lICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgIHRocm93IHRoaXMuYXN0RXJyb3JPdXRwdXQoJ1VuZXhwZWN0ZWQgZXhwcmVzc2lvbicsIGFzdCk7XG4gICAgICAgIH1cbiAgICAgICAgbmFtZSA9IGFzdC5vYmplY3Qub2JqZWN0Lm9iamVjdC5uYW1lO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgb3JpZ2luOiAndXNlcicsXG4gICAgICAgICAgICBzaWduYXR1cmU6IHZhcmlhYmxlU2lnbmF0dXJlLFxuICAgICAgICAgICAgdHlwZTogdGhpcy5nZXRWYXJpYWJsZVR5cGUoYXN0Lm9iamVjdC5vYmplY3Qub2JqZWN0KSxcbiAgICAgICAgICAgIHpQcm9wZXJ0eTogYXN0Lm9iamVjdC5vYmplY3QucHJvcGVydHksXG4gICAgICAgICAgICB5UHJvcGVydHk6IGFzdC5vYmplY3QucHJvcGVydHksXG4gICAgICAgICAgICB4UHJvcGVydHk6IGFzdC5wcm9wZXJ0eSxcbiAgICAgICAgfTtcbiAgICAgIGNhc2UgJ3ZhbHVlW11bXVtdW10nOlxuICAgICAgICBpZiAodHlwZW9mIGFzdC5vYmplY3Qub2JqZWN0Lm9iamVjdC5vYmplY3QubmFtZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICB0aHJvdyB0aGlzLmFzdEVycm9yT3V0cHV0KCdVbmV4cGVjdGVkIGV4cHJlc3Npb24nLCBhc3QpO1xuICAgICAgICB9XG4gICAgICAgIG5hbWUgPSBhc3Qub2JqZWN0Lm9iamVjdC5vYmplY3Qub2JqZWN0Lm5hbWU7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbmFtZSxcbiAgICAgICAgICBvcmlnaW46ICd1c2VyJyxcbiAgICAgICAgICAgIHNpZ25hdHVyZTogdmFyaWFibGVTaWduYXR1cmUsXG4gICAgICAgICAgICB0eXBlOiB0aGlzLmdldFZhcmlhYmxlVHlwZShhc3Qub2JqZWN0Lm9iamVjdC5vYmplY3Qub2JqZWN0KSxcbiAgICAgICAgICAgIHpQcm9wZXJ0eTogYXN0Lm9iamVjdC5vYmplY3QucHJvcGVydHksXG4gICAgICAgICAgICB5UHJvcGVydHk6IGFzdC5vYmplY3QucHJvcGVydHksXG4gICAgICAgICAgICB4UHJvcGVydHk6IGFzdC5wcm9wZXJ0eSxcbiAgICAgICAgfTtcbiAgICAgIGNhc2UgJ3ZhbHVlLnZhbHVlJzpcbiAgICAgICAgaWYgKHR5cGVvZiBhc3QucHJvcGVydHkubmFtZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICB0aHJvdyB0aGlzLmFzdEVycm9yT3V0cHV0KCdVbmV4cGVjdGVkIGV4cHJlc3Npb24nLCBhc3QpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmlzQXN0TWF0aFZhcmlhYmxlKGFzdCkpIHtcbiAgICAgICAgICBuYW1lID0gYXN0LnByb3BlcnR5Lm5hbWU7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICBvcmlnaW46ICdNYXRoJyxcbiAgICAgICAgICAgIHR5cGU6ICdOdW1iZXInLFxuICAgICAgICAgICAgc2lnbmF0dXJlOiB2YXJpYWJsZVNpZ25hdHVyZSxcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAoYXN0LnByb3BlcnR5Lm5hbWUpIHtcbiAgICAgICAgICBjYXNlICdyJzpcbiAgICAgICAgICBjYXNlICdnJzpcbiAgICAgICAgICBjYXNlICdiJzpcbiAgICAgICAgICBjYXNlICdhJzpcbiAgICAgICAgICAgIG5hbWUgPSBhc3Qub2JqZWN0Lm5hbWU7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICBwcm9wZXJ0eTogYXN0LnByb3BlcnR5Lm5hbWUsXG4gICAgICAgICAgICAgICAgb3JpZ2luOiAndXNlcicsXG4gICAgICAgICAgICAgICAgc2lnbmF0dXJlOiB2YXJpYWJsZVNpZ25hdHVyZSxcbiAgICAgICAgICAgICAgICB0eXBlOiAnTnVtYmVyJ1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgdGhpcy5hc3RFcnJvck91dHB1dCgnVW5leHBlY3RlZCBleHByZXNzaW9uJywgYXN0KTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlICd0aGlzLmNvbnN0YW50cy52YWx1ZSc6XG4gICAgICAgICAgaWYgKHR5cGVvZiBhc3QucHJvcGVydHkubmFtZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHRocm93IHRoaXMuYXN0RXJyb3JPdXRwdXQoJ1VuZXhwZWN0ZWQgZXhwcmVzc2lvbicsIGFzdCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIG5hbWUgPSBhc3QucHJvcGVydHkubmFtZTtcbiAgICAgICAgICB0eXBlID0gdGhpcy5nZXRDb25zdGFudFR5cGUobmFtZSk7XG4gICAgICAgICAgaWYgKCF0eXBlKSB7XG4gICAgICAgICAgICB0aHJvdyB0aGlzLmFzdEVycm9yT3V0cHV0KCdDb25zdGFudCBoYXMgbm8gdHlwZScsIGFzdCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgIG9yaWdpbjogJ2NvbnN0YW50cycsXG4gICAgICAgICAgICAgIHNpZ25hdHVyZTogdmFyaWFibGVTaWduYXR1cmUsXG4gICAgICAgICAgfTtcbiAgICAgICAgY2FzZSAndGhpcy5jb25zdGFudHMudmFsdWVbXSc6XG4gICAgICAgICAgaWYgKHR5cGVvZiBhc3Qub2JqZWN0LnByb3BlcnR5Lm5hbWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB0aHJvdyB0aGlzLmFzdEVycm9yT3V0cHV0KCdVbmV4cGVjdGVkIGV4cHJlc3Npb24nLCBhc3QpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBuYW1lID0gYXN0Lm9iamVjdC5wcm9wZXJ0eS5uYW1lO1xuICAgICAgICAgIHR5cGUgPSB0aGlzLmdldENvbnN0YW50VHlwZShuYW1lKTtcbiAgICAgICAgICBpZiAoIXR5cGUpIHtcbiAgICAgICAgICAgIHRocm93IHRoaXMuYXN0RXJyb3JPdXRwdXQoJ0NvbnN0YW50IGhhcyBubyB0eXBlJywgYXN0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgb3JpZ2luOiAnY29uc3RhbnRzJyxcbiAgICAgICAgICAgICAgc2lnbmF0dXJlOiB2YXJpYWJsZVNpZ25hdHVyZSxcbiAgICAgICAgICAgICAgeFByb3BlcnR5OiBhc3QucHJvcGVydHksXG4gICAgICAgICAgfTtcbiAgICAgICAgY2FzZSAndGhpcy5jb25zdGFudHMudmFsdWVbXVtdJzoge1xuICAgICAgICAgIGlmICh0eXBlb2YgYXN0Lm9iamVjdC5vYmplY3QucHJvcGVydHkubmFtZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHRocm93IHRoaXMuYXN0RXJyb3JPdXRwdXQoJ1VuZXhwZWN0ZWQgZXhwcmVzc2lvbicsIGFzdCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIG5hbWUgPSBhc3Qub2JqZWN0Lm9iamVjdC5wcm9wZXJ0eS5uYW1lO1xuICAgICAgICAgIHR5cGUgPSB0aGlzLmdldENvbnN0YW50VHlwZShuYW1lKTtcbiAgICAgICAgICBpZiAoIXR5cGUpIHtcbiAgICAgICAgICAgIHRocm93IHRoaXMuYXN0RXJyb3JPdXRwdXQoJ0NvbnN0YW50IGhhcyBubyB0eXBlJywgYXN0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgb3JpZ2luOiAnY29uc3RhbnRzJyxcbiAgICAgICAgICAgIHNpZ25hdHVyZTogdmFyaWFibGVTaWduYXR1cmUsXG4gICAgICAgICAgICB5UHJvcGVydHk6IGFzdC5vYmplY3QucHJvcGVydHksXG4gICAgICAgICAgICB4UHJvcGVydHk6IGFzdC5wcm9wZXJ0eSxcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ3RoaXMuY29uc3RhbnRzLnZhbHVlW11bXVtdJzoge1xuICAgICAgICAgIGlmICh0eXBlb2YgYXN0Lm9iamVjdC5vYmplY3Qub2JqZWN0LnByb3BlcnR5Lm5hbWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB0aHJvdyB0aGlzLmFzdEVycm9yT3V0cHV0KCdVbmV4cGVjdGVkIGV4cHJlc3Npb24nLCBhc3QpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBuYW1lID0gYXN0Lm9iamVjdC5vYmplY3Qub2JqZWN0LnByb3BlcnR5Lm5hbWU7XG4gICAgICAgICAgdHlwZSA9IHRoaXMuZ2V0Q29uc3RhbnRUeXBlKG5hbWUpO1xuICAgICAgICAgIGlmICghdHlwZSkge1xuICAgICAgICAgICAgdGhyb3cgdGhpcy5hc3RFcnJvck91dHB1dCgnQ29uc3RhbnQgaGFzIG5vIHR5cGUnLCBhc3QpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICBvcmlnaW46ICdjb25zdGFudHMnLFxuICAgICAgICAgICAgc2lnbmF0dXJlOiB2YXJpYWJsZVNpZ25hdHVyZSxcbiAgICAgICAgICAgIHpQcm9wZXJ0eTogYXN0Lm9iamVjdC5vYmplY3QucHJvcGVydHksXG4gICAgICAgICAgICB5UHJvcGVydHk6IGFzdC5vYmplY3QucHJvcGVydHksXG4gICAgICAgICAgICB4UHJvcGVydHk6IGFzdC5wcm9wZXJ0eSxcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ2ZuKClbXSc6XG4gICAgICAgIGNhc2UgJ2ZuKClbXVtdJzpcbiAgICAgICAgY2FzZSAnW11bXSc6XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHNpZ25hdHVyZTogdmFyaWFibGVTaWduYXR1cmUsXG4gICAgICAgICAgICAgIHByb3BlcnR5OiBhc3QucHJvcGVydHksXG4gICAgICAgICAgfTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aHJvdyB0aGlzLmFzdEVycm9yT3V0cHV0KCdVbmV4cGVjdGVkIGV4cHJlc3Npb24nLCBhc3QpO1xuICAgIH1cbiAgfVxuXG4gIGZpbmRJZGVudGlmaWVyT3JpZ2luKGFzdFRvRmluZCkge1xuICAgIGNvbnN0IHN0YWNrID0gW3RoaXMuYXN0XTtcblxuICAgIHdoaWxlIChzdGFjay5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCBhdE5vZGUgPSBzdGFja1swXTtcbiAgICAgIGlmIChhdE5vZGUudHlwZSA9PT0gJ1ZhcmlhYmxlRGVjbGFyYXRvcicgJiYgYXROb2RlLmlkICYmIGF0Tm9kZS5pZC5uYW1lICYmIGF0Tm9kZS5pZC5uYW1lID09PSBhc3RUb0ZpbmQubmFtZSkge1xuICAgICAgICByZXR1cm4gYXROb2RlO1xuICAgICAgfVxuICAgICAgc3RhY2suc2hpZnQoKTtcbiAgICAgIGlmIChhdE5vZGUuYXJndW1lbnQpIHtcbiAgICAgICAgc3RhY2sucHVzaChhdE5vZGUuYXJndW1lbnQpO1xuICAgICAgfSBlbHNlIGlmIChhdE5vZGUuYm9keSkge1xuICAgICAgICBzdGFjay5wdXNoKGF0Tm9kZS5ib2R5KTtcbiAgICAgIH0gZWxzZSBpZiAoYXROb2RlLmRlY2xhcmF0aW9ucykge1xuICAgICAgICBzdGFjay5wdXNoKGF0Tm9kZS5kZWNsYXJhdGlvbnMpO1xuICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGF0Tm9kZSkpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhdE5vZGUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBzdGFjay5wdXNoKGF0Tm9kZVtpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBmaW5kTGFzdFJldHVybihhc3QpIHtcbiAgICBjb25zdCBzdGFjayA9IFthc3QgfHwgdGhpcy5hc3RdO1xuXG4gICAgd2hpbGUgKHN0YWNrLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IGF0Tm9kZSA9IHN0YWNrLnBvcCgpO1xuICAgICAgaWYgKGF0Tm9kZS50eXBlID09PSAnUmV0dXJuU3RhdGVtZW50Jykge1xuICAgICAgICByZXR1cm4gYXROb2RlO1xuICAgICAgfVxuICAgICAgaWYgKGF0Tm9kZS50eXBlID09PSAnRnVuY3Rpb25EZWNsYXJhdGlvbicpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAoYXROb2RlLmFyZ3VtZW50KSB7XG4gICAgICAgIHN0YWNrLnB1c2goYXROb2RlLmFyZ3VtZW50KTtcbiAgICAgIH0gZWxzZSBpZiAoYXROb2RlLmJvZHkpIHtcbiAgICAgICAgc3RhY2sucHVzaChhdE5vZGUuYm9keSk7XG4gICAgICB9IGVsc2UgaWYgKGF0Tm9kZS5kZWNsYXJhdGlvbnMpIHtcbiAgICAgICAgc3RhY2sucHVzaChhdE5vZGUuZGVjbGFyYXRpb25zKTtcbiAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShhdE5vZGUpKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXROb2RlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgc3RhY2sucHVzaChhdE5vZGVbaV0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGF0Tm9kZS5jb25zZXF1ZW50KSB7XG4gICAgICAgIHN0YWNrLnB1c2goYXROb2RlLmNvbnNlcXVlbnQpO1xuICAgICAgfSBlbHNlIGlmIChhdE5vZGUuY2FzZXMpIHtcbiAgICAgICAgc3RhY2sucHVzaChhdE5vZGUuY2FzZXMpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGdldEludGVybmFsVmFyaWFibGVOYW1lKG5hbWUpIHtcbiAgICBpZiAoIXRoaXMuX2ludGVybmFsVmFyaWFibGVOYW1lcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgdGhpcy5faW50ZXJuYWxWYXJpYWJsZU5hbWVzW25hbWVdID0gMDtcbiAgICB9XG4gICAgdGhpcy5faW50ZXJuYWxWYXJpYWJsZU5hbWVzW25hbWVdKys7XG4gICAgaWYgKHRoaXMuX2ludGVybmFsVmFyaWFibGVOYW1lc1tuYW1lXSA9PT0gMSkge1xuICAgICAgcmV0dXJuIG5hbWU7XG4gICAgfVxuICAgIHJldHVybiBuYW1lICsgdGhpcy5faW50ZXJuYWxWYXJpYWJsZU5hbWVzW25hbWVdO1xuICB9XG5cbiAgYXN0S2V5KGFzdCwgc2VwYXJhdG9yID0gJywnKSB7XG4gICAgaWYgKCFhc3Quc3RhcnQgfHwgIWFzdC5lbmQpIHRocm93IG5ldyBFcnJvcignQVNUIHN0YXJ0IGFuZCBlbmQgbmVlZGVkJyk7XG4gICAgcmV0dXJuIGAke2FzdC5zdGFydH0ke3NlcGFyYXRvcn0ke2FzdC5lbmR9YDtcbiAgfVxufVxuXG5jb25zdCB0eXBlTG9va3VwTWFwID0ge1xuICAnTnVtYmVyJzogJ051bWJlcicsXG4gICdGbG9hdCc6ICdGbG9hdCcsXG4gICdJbnRlZ2VyJzogJ0ludGVnZXInLFxuICAnQXJyYXknOiAnTnVtYmVyJyxcbiAgJ0FycmF5KDIpJzogJ051bWJlcicsXG4gICdBcnJheSgzKSc6ICdOdW1iZXInLFxuICAnQXJyYXkoNCknOiAnTnVtYmVyJyxcbiAgJ01hdHJpeCgyKSc6ICdOdW1iZXInLFxuICAnTWF0cml4KDMpJzogJ051bWJlcicsXG4gICdNYXRyaXgoNCknOiAnTnVtYmVyJyxcbiAgJ0FycmF5MkQnOiAnTnVtYmVyJyxcbiAgJ0FycmF5M0QnOiAnTnVtYmVyJyxcbiAgJ0lucHV0JzogJ051bWJlcicsXG4gICdIVE1MQ2FudmFzJzogJ0FycmF5KDQpJyxcbiAgJ0hUTUxJbWFnZSc6ICdBcnJheSg0KScsXG4gICdIVE1MVmlkZW8nOiAnQXJyYXkoNCknLFxuICAnSFRNTEltYWdlQXJyYXknOiAnQXJyYXkoNCknLFxuICAnTnVtYmVyVGV4dHVyZSc6ICdOdW1iZXInLFxuICAnTWVtb3J5T3B0aW1pemVkTnVtYmVyVGV4dHVyZSc6ICdOdW1iZXInLFxuICAnQXJyYXkxRCgyKSc6ICdBcnJheSgyKScsXG4gICdBcnJheTFEKDMpJzogJ0FycmF5KDMpJyxcbiAgJ0FycmF5MUQoNCknOiAnQXJyYXkoNCknLFxuICAnQXJyYXkyRCgyKSc6ICdBcnJheSgyKScsXG4gICdBcnJheTJEKDMpJzogJ0FycmF5KDMpJyxcbiAgJ0FycmF5MkQoNCknOiAnQXJyYXkoNCknLFxuICAnQXJyYXkzRCgyKSc6ICdBcnJheSgyKScsXG4gICdBcnJheTNEKDMpJzogJ0FycmF5KDMpJyxcbiAgJ0FycmF5M0QoNCknOiAnQXJyYXkoNCknLFxuICAnQXJyYXlUZXh0dXJlKDEpJzogJ051bWJlcicsXG4gICdBcnJheVRleHR1cmUoMiknOiAnQXJyYXkoMiknLFxuICAnQXJyYXlUZXh0dXJlKDMpJzogJ0FycmF5KDMpJyxcbiAgJ0FycmF5VGV4dHVyZSg0KSc6ICdBcnJheSg0KScsXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgRnVuY3Rpb25Ob2RlXG59O1xufSx7XCIuLi91dGlsc1wiOjExNCxcIi4vZnVuY3Rpb24tdHJhY2VyXCI6MTEsXCJhY29yblwiOjF9XSwxMTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5jb25zdCB7IHV0aWxzIH0gPSByZXF1aXJlKCcuLi91dGlscycpO1xuXG5mdW5jdGlvbiBsYXN0KGFycmF5KSB7XG4gIHJldHVybiBhcnJheS5sZW5ndGggPiAwID8gYXJyYXlbYXJyYXkubGVuZ3RoIC0gMV0gOiBudWxsO1xufVxuXG5jb25zdCBzdGF0ZXMgPSB7XG4gIHRyYWNrSWRlbnRpZmllcnM6ICd0cmFja0lkZW50aWZpZXJzJyxcbiAgbWVtYmVyRXhwcmVzc2lvbjogJ21lbWJlckV4cHJlc3Npb24nLFxuICBpbkZvckxvb3BJbml0OiAnaW5Gb3JMb29wSW5pdCdcbn07XG5cbmNsYXNzIEZ1bmN0aW9uVHJhY2VyIHtcbiAgY29uc3RydWN0b3IoYXN0KSB7XG4gICAgdGhpcy5ydW5uaW5nQ29udGV4dHMgPSBbXTtcbiAgICB0aGlzLmZ1bmN0aW9uQ29udGV4dHMgPSBbXTtcbiAgICB0aGlzLmNvbnRleHRzID0gW107XG4gICAgdGhpcy5mdW5jdGlvbkNhbGxzID0gW107XG4gICAgdGhpcy5kZWNsYXJhdGlvbnMgPSBbXTtcbiAgICB0aGlzLmlkZW50aWZpZXJzID0gW107XG4gICAgdGhpcy5mdW5jdGlvbnMgPSBbXTtcbiAgICB0aGlzLnJldHVyblN0YXRlbWVudHMgPSBbXTtcbiAgICB0aGlzLnRyYWNrZWRJZGVudGlmaWVycyA9IG51bGw7XG4gICAgdGhpcy5zdGF0ZXMgPSBbXTtcbiAgICB0aGlzLm5ld0Z1bmN0aW9uQ29udGV4dCgpO1xuICAgIHRoaXMuc2Nhbihhc3QpO1xuICB9XG5cbiAgaXNTdGF0ZShzdGF0ZSkge1xuICAgIHJldHVybiB0aGlzLnN0YXRlc1t0aGlzLnN0YXRlcy5sZW5ndGggLSAxXSA9PT0gc3RhdGU7XG4gIH1cblxuICBoYXNTdGF0ZShzdGF0ZSkge1xuICAgIHJldHVybiB0aGlzLnN0YXRlcy5pbmRleE9mKHN0YXRlKSA+IC0xO1xuICB9XG5cbiAgcHVzaFN0YXRlKHN0YXRlKSB7XG4gICAgdGhpcy5zdGF0ZXMucHVzaChzdGF0ZSk7XG4gIH1cblxuICBwb3BTdGF0ZShzdGF0ZSkge1xuICAgIGlmICh0aGlzLmlzU3RhdGUoc3RhdGUpKSB7XG4gICAgICB0aGlzLnN0YXRlcy5wb3AoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgcG9wIHRoZSBub24tYWN0aXZlIHN0YXRlIFwiJHtzdGF0ZX1cImApO1xuICAgIH1cbiAgfVxuXG4gIGdldCBjdXJyZW50RnVuY3Rpb25Db250ZXh0KCkge1xuICAgIHJldHVybiBsYXN0KHRoaXMuZnVuY3Rpb25Db250ZXh0cyk7XG4gIH1cblxuICBnZXQgY3VycmVudENvbnRleHQoKSB7XG4gICAgcmV0dXJuIGxhc3QodGhpcy5ydW5uaW5nQ29udGV4dHMpO1xuICB9XG5cbiAgbmV3RnVuY3Rpb25Db250ZXh0KCkge1xuICAgIGNvbnN0IG5ld0NvbnRleHQgPSB7ICdAY29udGV4dFR5cGUnOiAnZnVuY3Rpb24nIH07XG4gICAgdGhpcy5jb250ZXh0cy5wdXNoKG5ld0NvbnRleHQpO1xuICAgIHRoaXMuZnVuY3Rpb25Db250ZXh0cy5wdXNoKG5ld0NvbnRleHQpO1xuICB9XG5cbiAgbmV3Q29udGV4dChydW4pIHtcbiAgICBjb25zdCBuZXdDb250ZXh0ID0gT2JqZWN0LmFzc2lnbih7ICdAY29udGV4dFR5cGUnOiAnY29uc3QvbGV0JyB9LCB0aGlzLmN1cnJlbnRDb250ZXh0KTtcbiAgICB0aGlzLmNvbnRleHRzLnB1c2gobmV3Q29udGV4dCk7XG4gICAgdGhpcy5ydW5uaW5nQ29udGV4dHMucHVzaChuZXdDb250ZXh0KTtcbiAgICBydW4oKTtcbiAgICBjb25zdCB7IGN1cnJlbnRGdW5jdGlvbkNvbnRleHQgfSA9IHRoaXM7XG4gICAgZm9yIChjb25zdCBwIGluIGN1cnJlbnRGdW5jdGlvbkNvbnRleHQpIHtcbiAgICAgIGlmICghY3VycmVudEZ1bmN0aW9uQ29udGV4dC5oYXNPd25Qcm9wZXJ0eShwKSB8fCBuZXdDb250ZXh0Lmhhc093blByb3BlcnR5KHApKSBjb250aW51ZTtcbiAgICAgIG5ld0NvbnRleHRbcF0gPSBjdXJyZW50RnVuY3Rpb25Db250ZXh0W3BdO1xuICAgIH1cbiAgICB0aGlzLnJ1bm5pbmdDb250ZXh0cy5wb3AoKTtcbiAgICByZXR1cm4gbmV3Q29udGV4dDtcbiAgfVxuXG4gIHVzZUZ1bmN0aW9uQ29udGV4dChydW4pIHtcbiAgICBjb25zdCBmdW5jdGlvbkNvbnRleHQgPSBsYXN0KHRoaXMuZnVuY3Rpb25Db250ZXh0cyk7XG4gICAgdGhpcy5ydW5uaW5nQ29udGV4dHMucHVzaChmdW5jdGlvbkNvbnRleHQpO1xuICAgIHJ1bigpO1xuICAgIHRoaXMucnVubmluZ0NvbnRleHRzLnBvcCgpO1xuICB9XG5cbiAgZ2V0SWRlbnRpZmllcnMocnVuKSB7XG4gICAgY29uc3QgdHJhY2tlZElkZW50aWZpZXJzID0gdGhpcy50cmFja2VkSWRlbnRpZmllcnMgPSBbXTtcbiAgICB0aGlzLnB1c2hTdGF0ZShzdGF0ZXMudHJhY2tJZGVudGlmaWVycyk7XG4gICAgcnVuKCk7XG4gICAgdGhpcy50cmFja2VkSWRlbnRpZmllcnMgPSBudWxsO1xuICAgIHRoaXMucG9wU3RhdGUoc3RhdGVzLnRyYWNrSWRlbnRpZmllcnMpO1xuICAgIHJldHVybiB0cmFja2VkSWRlbnRpZmllcnM7XG4gIH1cblxuICBnZXREZWNsYXJhdGlvbihuYW1lKSB7XG4gICAgY29uc3QgeyBjdXJyZW50Q29udGV4dCwgY3VycmVudEZ1bmN0aW9uQ29udGV4dCwgcnVubmluZ0NvbnRleHRzIH0gPSB0aGlzO1xuICAgIGNvbnN0IGRlY2xhcmF0aW9uID0gY3VycmVudENvbnRleHRbbmFtZV0gfHwgY3VycmVudEZ1bmN0aW9uQ29udGV4dFtuYW1lXSB8fCBudWxsO1xuXG4gICAgaWYgKFxuICAgICAgIWRlY2xhcmF0aW9uICYmXG4gICAgICBjdXJyZW50Q29udGV4dCA9PT0gY3VycmVudEZ1bmN0aW9uQ29udGV4dCAmJlxuICAgICAgcnVubmluZ0NvbnRleHRzLmxlbmd0aCA+IDBcbiAgICApIHtcbiAgICAgIGNvbnN0IHByZXZpb3VzUnVubmluZ0NvbnRleHQgPSBydW5uaW5nQ29udGV4dHNbcnVubmluZ0NvbnRleHRzLmxlbmd0aCAtIDJdO1xuICAgICAgaWYgKHByZXZpb3VzUnVubmluZ0NvbnRleHRbbmFtZV0pIHtcbiAgICAgICAgcmV0dXJuIHByZXZpb3VzUnVubmluZ0NvbnRleHRbbmFtZV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGRlY2xhcmF0aW9uO1xuICB9XG5cbiAgc2Nhbihhc3QpIHtcbiAgICBpZiAoIWFzdCkgcmV0dXJuO1xuICAgIGlmIChBcnJheS5pc0FycmF5KGFzdCkpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMuc2Nhbihhc3RbaV0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzd2l0Y2ggKGFzdC50eXBlKSB7XG4gICAgICBjYXNlICdQcm9ncmFtJzpcbiAgICAgICAgdGhpcy51c2VGdW5jdGlvbkNvbnRleHQoKCkgPT4ge1xuICAgICAgICAgIHRoaXMuc2Nhbihhc3QuYm9keSk7XG4gICAgICAgIH0pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ0Jsb2NrU3RhdGVtZW50JzpcbiAgICAgICAgdGhpcy5uZXdDb250ZXh0KCgpID0+IHtcbiAgICAgICAgICB0aGlzLnNjYW4oYXN0LmJvZHkpO1xuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdBc3NpZ25tZW50RXhwcmVzc2lvbic6XG4gICAgICBjYXNlICdMb2dpY2FsRXhwcmVzc2lvbic6XG4gICAgICAgIHRoaXMuc2Nhbihhc3QubGVmdCk7XG4gICAgICAgIHRoaXMuc2Nhbihhc3QucmlnaHQpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ0JpbmFyeUV4cHJlc3Npb24nOlxuICAgICAgICB0aGlzLnNjYW4oYXN0LmxlZnQpO1xuICAgICAgICB0aGlzLnNjYW4oYXN0LnJpZ2h0KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdVcGRhdGVFeHByZXNzaW9uJzpcbiAgICAgICAgaWYgKGFzdC5vcGVyYXRvciA9PT0gJysrJykge1xuICAgICAgICAgIGNvbnN0IGRlY2xhcmF0aW9uID0gdGhpcy5nZXREZWNsYXJhdGlvbihhc3QuYXJndW1lbnQubmFtZSk7XG4gICAgICAgICAgaWYgKGRlY2xhcmF0aW9uKSB7XG4gICAgICAgICAgICBkZWNsYXJhdGlvbi5zdWdnZXN0ZWRUeXBlID0gJ0ludGVnZXInO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNjYW4oYXN0LmFyZ3VtZW50KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdVbmFyeUV4cHJlc3Npb24nOlxuICAgICAgICB0aGlzLnNjYW4oYXN0LmFyZ3VtZW50KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdWYXJpYWJsZURlY2xhcmF0aW9uJzpcbiAgICAgICAgaWYgKGFzdC5raW5kID09PSAndmFyJykge1xuICAgICAgICAgIHRoaXMudXNlRnVuY3Rpb25Db250ZXh0KCgpID0+IHtcbiAgICAgICAgICAgIGFzdC5kZWNsYXJhdGlvbnMgPSB1dGlscy5ub3JtYWxpemVEZWNsYXJhdGlvbnMoYXN0KTtcbiAgICAgICAgICAgIHRoaXMuc2Nhbihhc3QuZGVjbGFyYXRpb25zKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhc3QuZGVjbGFyYXRpb25zID0gdXRpbHMubm9ybWFsaXplRGVjbGFyYXRpb25zKGFzdCk7XG4gICAgICAgICAgdGhpcy5zY2FuKGFzdC5kZWNsYXJhdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnVmFyaWFibGVEZWNsYXJhdG9yJzoge1xuICAgICAgICBjb25zdCB7IGN1cnJlbnRDb250ZXh0IH0gPSB0aGlzO1xuICAgICAgICBjb25zdCBpbkZvckxvb3BJbml0ID0gdGhpcy5oYXNTdGF0ZShzdGF0ZXMuaW5Gb3JMb29wSW5pdCk7XG4gICAgICAgIGNvbnN0IGRlY2xhcmF0aW9uID0ge1xuICAgICAgICAgIGFzdDogYXN0LFxuICAgICAgICAgIGNvbnRleHQ6IGN1cnJlbnRDb250ZXh0LFxuICAgICAgICAgIG5hbWU6IGFzdC5pZC5uYW1lLFxuICAgICAgICAgIG9yaWdpbjogJ2RlY2xhcmF0aW9uJyxcbiAgICAgICAgICBpbkZvckxvb3BJbml0LFxuICAgICAgICAgIGluRm9yTG9vcFRlc3Q6IG51bGwsXG4gICAgICAgICAgYXNzaWduYWJsZTogY3VycmVudENvbnRleHQgPT09IHRoaXMuY3VycmVudEZ1bmN0aW9uQ29udGV4dCB8fCAoIWluRm9yTG9vcEluaXQgJiYgIWN1cnJlbnRDb250ZXh0Lmhhc093blByb3BlcnR5KGFzdC5pZC5uYW1lKSksXG4gICAgICAgICAgc3VnZ2VzdGVkVHlwZTogbnVsbCxcbiAgICAgICAgICB2YWx1ZVR5cGU6IG51bGwsXG4gICAgICAgICAgZGVwZW5kZW5jaWVzOiBudWxsLFxuICAgICAgICAgIGlzU2FmZTogbnVsbCxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKCFjdXJyZW50Q29udGV4dFthc3QuaWQubmFtZV0pIHtcbiAgICAgICAgICBjdXJyZW50Q29udGV4dFthc3QuaWQubmFtZV0gPSBkZWNsYXJhdGlvbjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRlY2xhcmF0aW9ucy5wdXNoKGRlY2xhcmF0aW9uKTtcbiAgICAgICAgdGhpcy5zY2FuKGFzdC5pZCk7XG4gICAgICAgIHRoaXMuc2Nhbihhc3QuaW5pdCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSAnRnVuY3Rpb25FeHByZXNzaW9uJzpcbiAgICAgIGNhc2UgJ0Z1bmN0aW9uRGVjbGFyYXRpb24nOlxuICAgICAgICBpZiAodGhpcy5ydW5uaW5nQ29udGV4dHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgdGhpcy5zY2FuKGFzdC5ib2R5KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmZ1bmN0aW9ucy5wdXNoKGFzdCk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdJZlN0YXRlbWVudCc6XG4gICAgICAgIHRoaXMuc2Nhbihhc3QudGVzdCk7XG4gICAgICAgIHRoaXMuc2Nhbihhc3QuY29uc2VxdWVudCk7XG4gICAgICAgIGlmIChhc3QuYWx0ZXJuYXRlKSB0aGlzLnNjYW4oYXN0LmFsdGVybmF0ZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnRm9yU3RhdGVtZW50Jzoge1xuICAgICAgICBsZXQgdGVzdElkZW50aWZpZXJzO1xuICAgICAgICBjb25zdCBjb250ZXh0ID0gdGhpcy5uZXdDb250ZXh0KCgpID0+IHtcbiAgICAgICAgICB0aGlzLnB1c2hTdGF0ZShzdGF0ZXMuaW5Gb3JMb29wSW5pdCk7XG4gICAgICAgICAgdGhpcy5zY2FuKGFzdC5pbml0KTtcbiAgICAgICAgICB0aGlzLnBvcFN0YXRlKHN0YXRlcy5pbkZvckxvb3BJbml0KTtcblxuICAgICAgICAgIHRlc3RJZGVudGlmaWVycyA9IHRoaXMuZ2V0SWRlbnRpZmllcnMoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5zY2FuKGFzdC50ZXN0KTtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHRoaXMuc2Nhbihhc3QudXBkYXRlKTtcbiAgICAgICAgICB0aGlzLm5ld0NvbnRleHQoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5zY2FuKGFzdC5ib2R5KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKHRlc3RJZGVudGlmaWVycykge1xuICAgICAgICAgIGZvciAoY29uc3QgcCBpbiBjb250ZXh0KSB7XG4gICAgICAgICAgICBpZiAocCA9PT0gJ0Bjb250ZXh0VHlwZScpIGNvbnRpbnVlO1xuICAgICAgICAgICAgaWYgKHRlc3RJZGVudGlmaWVycy5pbmRleE9mKHApID4gLTEpIHtcbiAgICAgICAgICAgICAgY29udGV4dFtwXS5pbkZvckxvb3BUZXN0ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlICdEb1doaWxlU3RhdGVtZW50JzpcbiAgICAgIGNhc2UgJ1doaWxlU3RhdGVtZW50JzpcbiAgICAgICAgdGhpcy5uZXdDb250ZXh0KCgpID0+IHtcbiAgICAgICAgICB0aGlzLnNjYW4oYXN0LmJvZHkpO1xuICAgICAgICAgIHRoaXMuc2Nhbihhc3QudGVzdCk7XG4gICAgICAgIH0pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ0lkZW50aWZpZXInOiB7XG4gICAgICAgIGlmICh0aGlzLmlzU3RhdGUoc3RhdGVzLnRyYWNrSWRlbnRpZmllcnMpKSB7XG4gICAgICAgICAgdGhpcy50cmFja2VkSWRlbnRpZmllcnMucHVzaChhc3QubmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pZGVudGlmaWVycy5wdXNoKHtcbiAgICAgICAgICBjb250ZXh0OiB0aGlzLmN1cnJlbnRDb250ZXh0LFxuICAgICAgICAgIGRlY2xhcmF0aW9uOiB0aGlzLmdldERlY2xhcmF0aW9uKGFzdC5uYW1lKSxcbiAgICAgICAgICBhc3QsXG4gICAgICAgIH0pO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgJ1JldHVyblN0YXRlbWVudCc6XG4gICAgICAgIHRoaXMucmV0dXJuU3RhdGVtZW50cy5wdXNoKGFzdCk7XG4gICAgICAgIHRoaXMuc2Nhbihhc3QuYXJndW1lbnQpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ01lbWJlckV4cHJlc3Npb24nOlxuICAgICAgICB0aGlzLnB1c2hTdGF0ZShzdGF0ZXMubWVtYmVyRXhwcmVzc2lvbik7XG4gICAgICAgIHRoaXMuc2Nhbihhc3Qub2JqZWN0KTtcbiAgICAgICAgdGhpcy5zY2FuKGFzdC5wcm9wZXJ0eSk7XG4gICAgICAgIHRoaXMucG9wU3RhdGUoc3RhdGVzLm1lbWJlckV4cHJlc3Npb24pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ0V4cHJlc3Npb25TdGF0ZW1lbnQnOlxuICAgICAgICB0aGlzLnNjYW4oYXN0LmV4cHJlc3Npb24pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ1NlcXVlbmNlRXhwcmVzc2lvbic6XG4gICAgICAgIHRoaXMuc2Nhbihhc3QuZXhwcmVzc2lvbnMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ0NhbGxFeHByZXNzaW9uJzpcbiAgICAgICAgdGhpcy5mdW5jdGlvbkNhbGxzLnB1c2goe1xuICAgICAgICAgIGNvbnRleHQ6IHRoaXMuY3VycmVudENvbnRleHQsXG4gICAgICAgICAgYXN0LFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5zY2FuKGFzdC5hcmd1bWVudHMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ0FycmF5RXhwcmVzc2lvbic6XG4gICAgICAgIHRoaXMuc2Nhbihhc3QuZWxlbWVudHMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ0NvbmRpdGlvbmFsRXhwcmVzc2lvbic6XG4gICAgICAgIHRoaXMuc2Nhbihhc3QudGVzdCk7XG4gICAgICAgIHRoaXMuc2Nhbihhc3QuYWx0ZXJuYXRlKTtcbiAgICAgICAgdGhpcy5zY2FuKGFzdC5jb25zZXF1ZW50KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdTd2l0Y2hTdGF0ZW1lbnQnOlxuICAgICAgICB0aGlzLnNjYW4oYXN0LmRpc2NyaW1pbmFudCk7XG4gICAgICAgIHRoaXMuc2Nhbihhc3QuY2FzZXMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ1N3aXRjaENhc2UnOlxuICAgICAgICB0aGlzLnNjYW4oYXN0LnRlc3QpO1xuICAgICAgICB0aGlzLnNjYW4oYXN0LmNvbnNlcXVlbnQpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnVGhpc0V4cHJlc3Npb24nOlxuICAgICAgY2FzZSAnTGl0ZXJhbCc6XG4gICAgICBjYXNlICdEZWJ1Z2dlclN0YXRlbWVudCc6XG4gICAgICBjYXNlICdFbXB0eVN0YXRlbWVudCc6XG4gICAgICBjYXNlICdCcmVha1N0YXRlbWVudCc6XG4gICAgICBjYXNlICdDb250aW51ZVN0YXRlbWVudCc6XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB1bmhhbmRsZWQgdHlwZSBcIiR7YXN0LnR5cGV9XCJgKTtcbiAgICB9XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIEZ1bmN0aW9uVHJhY2VyLFxufTtcbn0se1wiLi4vdXRpbHNcIjoxMTR9XSwxMjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5jb25zdCB7IGdsV2lyZXRhcCB9ID0gcmVxdWlyZSgnZ2wtd2lyZXRhcCcpO1xuY29uc3QgeyB1dGlscyB9ID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMnKTtcblxuZnVuY3Rpb24gdG9TdHJpbmdXaXRob3V0VXRpbHMoZm4pIHtcbiAgcmV0dXJuIGZuLnRvU3RyaW5nKClcbiAgICAucmVwbGFjZSgnPT4nLCAnJylcbiAgICAucmVwbGFjZSgvXmZ1bmN0aW9uIC8sICcnKVxuICAgIC5yZXBsYWNlKC91dGlsc1suXS9nLCAnLyp1dGlscy4qLycpO1xufVxuXG5mdW5jdGlvbiBnbEtlcm5lbFN0cmluZyhLZXJuZWwsIGFyZ3MsIG9yaWdpbktlcm5lbCwgc2V0dXBDb250ZXh0U3RyaW5nLCBkZXN0cm95Q29udGV4dFN0cmluZykge1xuICBpZiAoIW9yaWdpbktlcm5lbC5idWlsdCkge1xuICAgIG9yaWdpbktlcm5lbC5idWlsZC5hcHBseShvcmlnaW5LZXJuZWwsIGFyZ3MpO1xuICB9XG4gIGFyZ3MgPSBhcmdzID8gQXJyYXkuZnJvbShhcmdzKS5tYXAoYXJnID0+IHtcbiAgICBzd2l0Y2ggKHR5cGVvZiBhcmcpIHtcbiAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICByZXR1cm4gbmV3IEJvb2xlYW4oYXJnKTtcbiAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgIHJldHVybiBuZXcgTnVtYmVyKGFyZyk7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gYXJnO1xuICAgIH1cbiAgfSkgOiBudWxsO1xuICBjb25zdCB1cGxvYWRlZFZhbHVlcyA9IFtdO1xuICBjb25zdCBwb3N0UmVzdWx0ID0gW107XG4gIGNvbnN0IGNvbnRleHQgPSBnbFdpcmV0YXAob3JpZ2luS2VybmVsLmNvbnRleHQsIHtcbiAgICB1c2VUcmFja2FibGVQcmltaXRpdmVzOiB0cnVlLFxuICAgIG9uUmVhZFBpeGVsczogKHRhcmdldE5hbWUpID0+IHtcbiAgICAgIGlmIChrZXJuZWwuc3ViS2VybmVscykge1xuICAgICAgICBpZiAoIXN1Yktlcm5lbHNSZXN1bHRWYXJpYWJsZVNldHVwKSB7XG4gICAgICAgICAgcG9zdFJlc3VsdC5wdXNoKGAgICAgY29uc3QgcmVzdWx0ID0geyByZXN1bHQ6ICR7Z2V0UmVuZGVyU3RyaW5nKHRhcmdldE5hbWUsIGtlcm5lbCl9IH07YCk7XG4gICAgICAgICAgc3ViS2VybmVsc1Jlc3VsdFZhcmlhYmxlU2V0dXAgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IHByb3BlcnR5ID0ga2VybmVsLnN1Yktlcm5lbHNbc3ViS2VybmVsc1Jlc3VsdEluZGV4KytdLnByb3BlcnR5O1xuICAgICAgICAgIHBvc3RSZXN1bHQucHVzaChgICAgIHJlc3VsdCR7aXNOYU4ocHJvcGVydHkpID8gJy4nICsgcHJvcGVydHkgOiBgWyR7cHJvcGVydHl9XWB9ID0gJHtnZXRSZW5kZXJTdHJpbmcodGFyZ2V0TmFtZSwga2VybmVsKX07YCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN1Yktlcm5lbHNSZXN1bHRJbmRleCA9PT0ga2VybmVsLnN1Yktlcm5lbHMubGVuZ3RoKSB7XG4gICAgICAgICAgcG9zdFJlc3VsdC5wdXNoKCcgICAgcmV0dXJuIHJlc3VsdDsnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAodGFyZ2V0TmFtZSkge1xuICAgICAgICBwb3N0UmVzdWx0LnB1c2goYCAgICByZXR1cm4gJHtnZXRSZW5kZXJTdHJpbmcodGFyZ2V0TmFtZSwga2VybmVsKX07YCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwb3N0UmVzdWx0LnB1c2goYCAgICByZXR1cm4gbnVsbDtgKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIG9uVW5yZWNvZ25pemVkQXJndW1lbnRMb29rdXA6IChhcmd1bWVudCkgPT4ge1xuICAgICAgY29uc3QgYXJndW1lbnROYW1lID0gZmluZEtlcm5lbFZhbHVlKGFyZ3VtZW50LCBrZXJuZWwua2VybmVsQXJndW1lbnRzLCBbXSwgY29udGV4dCwgdXBsb2FkZWRWYWx1ZXMpO1xuICAgICAgaWYgKGFyZ3VtZW50TmFtZSkge1xuICAgICAgICByZXR1cm4gYXJndW1lbnROYW1lO1xuICAgICAgfVxuICAgICAgY29uc3QgY29uc3RhbnROYW1lID0gZmluZEtlcm5lbFZhbHVlKGFyZ3VtZW50LCBrZXJuZWwua2VybmVsQ29uc3RhbnRzLCBjb25zdGFudHMgPyBPYmplY3Qua2V5cyhjb25zdGFudHMpLm1hcChrZXkgPT4gY29uc3RhbnRzW2tleV0pIDogW10sIGNvbnRleHQsIHVwbG9hZGVkVmFsdWVzKTtcbiAgICAgIGlmIChjb25zdGFudE5hbWUpIHtcbiAgICAgICAgcmV0dXJuIGNvbnN0YW50TmFtZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfSk7XG4gIGxldCBzdWJLZXJuZWxzUmVzdWx0VmFyaWFibGVTZXR1cCA9IGZhbHNlO1xuICBsZXQgc3ViS2VybmVsc1Jlc3VsdEluZGV4ID0gMDtcbiAgY29uc3Qge1xuICAgIHNvdXJjZSxcbiAgICBjYW52YXMsXG4gICAgb3V0cHV0LFxuICAgIHBpcGVsaW5lLFxuICAgIGdyYXBoaWNhbCxcbiAgICBsb29wTWF4SXRlcmF0aW9ucyxcbiAgICBjb25zdGFudHMsXG4gICAgb3B0aW1pemVGbG9hdE1lbW9yeSxcbiAgICBwcmVjaXNpb24sXG4gICAgZml4SW50ZWdlckRpdmlzaW9uQWNjdXJhY3ksXG4gICAgZnVuY3Rpb25zLFxuICAgIG5hdGl2ZUZ1bmN0aW9ucyxcbiAgICBzdWJLZXJuZWxzLFxuICAgIGltbXV0YWJsZSxcbiAgICBhcmd1bWVudFR5cGVzLFxuICAgIGNvbnN0YW50VHlwZXMsXG4gICAga2VybmVsQXJndW1lbnRzLFxuICAgIGtlcm5lbENvbnN0YW50cyxcbiAgICB0YWN0aWMsXG4gIH0gPSBvcmlnaW5LZXJuZWw7XG4gIGNvbnN0IGtlcm5lbCA9IG5ldyBLZXJuZWwoc291cmNlLCB7XG4gICAgY2FudmFzLFxuICAgIGNvbnRleHQsXG4gICAgY2hlY2tDb250ZXh0OiBmYWxzZSxcbiAgICBvdXRwdXQsXG4gICAgcGlwZWxpbmUsXG4gICAgZ3JhcGhpY2FsLFxuICAgIGxvb3BNYXhJdGVyYXRpb25zLFxuICAgIGNvbnN0YW50cyxcbiAgICBvcHRpbWl6ZUZsb2F0TWVtb3J5LFxuICAgIHByZWNpc2lvbixcbiAgICBmaXhJbnRlZ2VyRGl2aXNpb25BY2N1cmFjeSxcbiAgICBmdW5jdGlvbnMsXG4gICAgbmF0aXZlRnVuY3Rpb25zLFxuICAgIHN1Yktlcm5lbHMsXG4gICAgaW1tdXRhYmxlLFxuICAgIGFyZ3VtZW50VHlwZXMsXG4gICAgY29uc3RhbnRUeXBlcyxcbiAgICB0YWN0aWMsXG4gIH0pO1xuICBsZXQgcmVzdWx0ID0gW107XG4gIGNvbnRleHQuc2V0SW5kZW50KDIpO1xuICBrZXJuZWwuYnVpbGQuYXBwbHkoa2VybmVsLCBhcmdzKTtcbiAgcmVzdWx0LnB1c2goY29udGV4dC50b1N0cmluZygpKTtcbiAgY29udGV4dC5yZXNldCgpO1xuXG4gIGtlcm5lbC5rZXJuZWxBcmd1bWVudHMuZm9yRWFjaCgoa2VybmVsQXJndW1lbnQsIGkpID0+IHtcbiAgICBzd2l0Y2ggKGtlcm5lbEFyZ3VtZW50LnR5cGUpIHtcbiAgICAgIGNhc2UgJ0ludGVnZXInOlxuICAgICAgY2FzZSAnQm9vbGVhbic6XG4gICAgICBjYXNlICdOdW1iZXInOlxuICAgICAgY2FzZSAnRmxvYXQnOlxuICAgICAgY2FzZSAnQXJyYXknOlxuICAgICAgY2FzZSAnQXJyYXkoMiknOlxuICAgICAgY2FzZSAnQXJyYXkoMyknOlxuICAgICAgY2FzZSAnQXJyYXkoNCknOlxuICAgICAgY2FzZSAnSFRNTENhbnZhcyc6XG4gICAgICBjYXNlICdIVE1MSW1hZ2UnOlxuICAgICAgY2FzZSAnSFRNTFZpZGVvJzpcbiAgICAgICAgY29udGV4dC5pbnNlcnRWYXJpYWJsZShgdXBsb2FkVmFsdWVfJHtrZXJuZWxBcmd1bWVudC5uYW1lfWAsIGtlcm5lbEFyZ3VtZW50LnVwbG9hZFZhbHVlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdIVE1MSW1hZ2VBcnJheSc6XG4gICAgICAgIGZvciAobGV0IGltYWdlSW5kZXggPSAwOyBpbWFnZUluZGV4IDwgYXJnc1tpXS5sZW5ndGg7IGltYWdlSW5kZXgrKykge1xuICAgICAgICAgIGNvbnN0IGFyZyA9IGFyZ3NbaV07XG4gICAgICAgICAgY29udGV4dC5pbnNlcnRWYXJpYWJsZShgdXBsb2FkVmFsdWVfJHtrZXJuZWxBcmd1bWVudC5uYW1lfVske2ltYWdlSW5kZXh9XWAsIGFyZ1tpbWFnZUluZGV4XSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdJbnB1dCc6XG4gICAgICAgIGNvbnRleHQuaW5zZXJ0VmFyaWFibGUoYHVwbG9hZFZhbHVlXyR7a2VybmVsQXJndW1lbnQubmFtZX1gLCBrZXJuZWxBcmd1bWVudC51cGxvYWRWYWx1ZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnTWVtb3J5T3B0aW1pemVkTnVtYmVyVGV4dHVyZSc6XG4gICAgICBjYXNlICdOdW1iZXJUZXh0dXJlJzpcbiAgICAgIGNhc2UgJ0FycmF5MUQoMiknOlxuICAgICAgY2FzZSAnQXJyYXkxRCgzKSc6XG4gICAgICBjYXNlICdBcnJheTFEKDQpJzpcbiAgICAgIGNhc2UgJ0FycmF5MkQoMiknOlxuICAgICAgY2FzZSAnQXJyYXkyRCgzKSc6XG4gICAgICBjYXNlICdBcnJheTJEKDQpJzpcbiAgICAgIGNhc2UgJ0FycmF5M0QoMiknOlxuICAgICAgY2FzZSAnQXJyYXkzRCgzKSc6XG4gICAgICBjYXNlICdBcnJheTNEKDQpJzpcbiAgICAgIGNhc2UgJ0FycmF5VGV4dHVyZSgxKSc6XG4gICAgICBjYXNlICdBcnJheVRleHR1cmUoMiknOlxuICAgICAgY2FzZSAnQXJyYXlUZXh0dXJlKDMpJzpcbiAgICAgIGNhc2UgJ0FycmF5VGV4dHVyZSg0KSc6XG4gICAgICAgIGNvbnRleHQuaW5zZXJ0VmFyaWFibGUoYHVwbG9hZFZhbHVlXyR7a2VybmVsQXJndW1lbnQubmFtZX1gLCBhcmdzW2ldLnRleHR1cmUpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgdW5oYW5kbGVkIGtlcm5lbEFyZ3VtZW50VHlwZSBpbnNlcnRpb24gZm9yIGdsV2lyZXRhcCBvZiB0eXBlICR7a2VybmVsQXJndW1lbnQudHlwZX1gKTtcbiAgICB9XG4gIH0pO1xuICByZXN1bHQucHVzaCgnLyoqIHN0YXJ0IG9mIGluamVjdGVkIGZ1bmN0aW9ucyAqKi8nKTtcbiAgcmVzdWx0LnB1c2goYGZ1bmN0aW9uICR7dG9TdHJpbmdXaXRob3V0VXRpbHModXRpbHMuZmxhdHRlblRvKX1gKTtcbiAgcmVzdWx0LnB1c2goYGZ1bmN0aW9uICR7dG9TdHJpbmdXaXRob3V0VXRpbHModXRpbHMuZmxhdHRlbjJkQXJyYXlUbyl9YCk7XG4gIHJlc3VsdC5wdXNoKGBmdW5jdGlvbiAke3RvU3RyaW5nV2l0aG91dFV0aWxzKHV0aWxzLmZsYXR0ZW4zZEFycmF5VG8pfWApO1xuICByZXN1bHQucHVzaChgZnVuY3Rpb24gJHt0b1N0cmluZ1dpdGhvdXRVdGlscyh1dGlscy5mbGF0dGVuNGRBcnJheVRvKX1gKTtcbiAgcmVzdWx0LnB1c2goYGZ1bmN0aW9uICR7dG9TdHJpbmdXaXRob3V0VXRpbHModXRpbHMuaXNBcnJheSl9YCk7XG4gIGlmIChrZXJuZWwucmVuZGVyT3V0cHV0ICE9PSBrZXJuZWwucmVuZGVyVGV4dHVyZSAmJiBrZXJuZWwuZm9ybWF0VmFsdWVzKSB7XG4gICAgcmVzdWx0LnB1c2goXG4gICAgICBgICBjb25zdCByZW5kZXJPdXRwdXQgPSBmdW5jdGlvbiAke3RvU3RyaW5nV2l0aG91dFV0aWxzKGtlcm5lbC5mb3JtYXRWYWx1ZXMpfTtgXG4gICAgKTtcbiAgfVxuICByZXN1bHQucHVzaCgnLyoqIGVuZCBvZiBpbmplY3RlZCBmdW5jdGlvbnMgKiovJyk7XG4gIHJlc3VsdC5wdXNoKGAgIGNvbnN0IGlubmVyS2VybmVsID0gZnVuY3Rpb24gKCR7a2VybmVsLmtlcm5lbEFyZ3VtZW50cy5tYXAoa2VybmVsQXJndW1lbnQgPT4ga2VybmVsQXJndW1lbnQudmFyTmFtZSkuam9pbignLCAnKX0pIHtgKTtcbiAgY29udGV4dC5zZXRJbmRlbnQoNCk7XG4gIGtlcm5lbC5ydW4uYXBwbHkoa2VybmVsLCBhcmdzKTtcbiAgaWYgKGtlcm5lbC5yZW5kZXJLZXJuZWxzKSB7XG4gICAga2VybmVsLnJlbmRlcktlcm5lbHMoKTtcbiAgfSBlbHNlIGlmIChrZXJuZWwucmVuZGVyT3V0cHV0KSB7XG4gICAga2VybmVsLnJlbmRlck91dHB1dCgpO1xuICB9XG4gIHJlc3VsdC5wdXNoKCcgICAgLyoqIHN0YXJ0IHNldHVwIHVwbG9hZHMgZm9yIGtlcm5lbCB2YWx1ZXMgKiovJyk7XG4gIGtlcm5lbC5rZXJuZWxBcmd1bWVudHMuZm9yRWFjaChrZXJuZWxBcmd1bWVudCA9PiB7XG4gICAgcmVzdWx0LnB1c2goJyAgICAnICsga2VybmVsQXJndW1lbnQuZ2V0U3RyaW5nVmFsdWVIYW5kbGVyKCkuc3BsaXQoJ1xcbicpLmpvaW4oJ1xcbiAgICAnKSk7XG4gIH0pO1xuICByZXN1bHQucHVzaCgnICAgIC8qKiBlbmQgc2V0dXAgdXBsb2FkcyBmb3Iga2VybmVsIHZhbHVlcyAqKi8nKTtcbiAgcmVzdWx0LnB1c2goY29udGV4dC50b1N0cmluZygpKTtcbiAgaWYgKGtlcm5lbC5yZW5kZXJPdXRwdXQgPT09IGtlcm5lbC5yZW5kZXJUZXh0dXJlKSB7XG4gICAgY29udGV4dC5yZXNldCgpO1xuICAgIGNvbnN0IGZyYW1lYnVmZmVyTmFtZSA9IGNvbnRleHQuZ2V0Q29udGV4dFZhcmlhYmxlTmFtZShrZXJuZWwuZnJhbWVidWZmZXIpO1xuICAgIGlmIChrZXJuZWwucmVuZGVyS2VybmVscykge1xuICAgICAgY29uc3QgcmVzdWx0cyA9IGtlcm5lbC5yZW5kZXJLZXJuZWxzKCk7XG4gICAgICBjb25zdCB0ZXh0dXJlTmFtZSA9IGNvbnRleHQuZ2V0Q29udGV4dFZhcmlhYmxlTmFtZShrZXJuZWwudGV4dHVyZS50ZXh0dXJlKTtcbiAgICAgIHJlc3VsdC5wdXNoKGAgICAgcmV0dXJuIHtcbiAgICAgIHJlc3VsdDoge1xuICAgICAgICB0ZXh0dXJlOiAkeyB0ZXh0dXJlTmFtZSB9LFxuICAgICAgICB0eXBlOiAnJHsgcmVzdWx0cy5yZXN1bHQudHlwZSB9JyxcbiAgICAgICAgdG9BcnJheTogJHsgZ2V0VG9BcnJheVN0cmluZyhyZXN1bHRzLnJlc3VsdCwgdGV4dHVyZU5hbWUsIGZyYW1lYnVmZmVyTmFtZSkgfVxuICAgICAgfSxgKTtcbiAgICAgIGNvbnN0IHsgc3ViS2VybmVscywgbWFwcGVkVGV4dHVyZXMgfSA9IGtlcm5lbDtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3ViS2VybmVscy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCB0ZXh0dXJlID0gbWFwcGVkVGV4dHVyZXNbaV07XG4gICAgICAgIGNvbnN0IHN1Yktlcm5lbCA9IHN1Yktlcm5lbHNbaV07XG4gICAgICAgIGNvbnN0IHN1Yktlcm5lbFJlc3VsdCA9IHJlc3VsdHNbc3ViS2VybmVsLnByb3BlcnR5XTtcbiAgICAgICAgY29uc3Qgc3ViS2VybmVsVGV4dHVyZU5hbWUgPSBjb250ZXh0LmdldENvbnRleHRWYXJpYWJsZU5hbWUodGV4dHVyZS50ZXh0dXJlKTtcbiAgICAgICAgcmVzdWx0LnB1c2goYFxuICAgICAgJHtzdWJLZXJuZWwucHJvcGVydHl9OiB7XG4gICAgICAgIHRleHR1cmU6ICR7IHN1Yktlcm5lbFRleHR1cmVOYW1lIH0sXG4gICAgICAgIHR5cGU6ICckeyBzdWJLZXJuZWxSZXN1bHQudHlwZSB9JyxcbiAgICAgICAgdG9BcnJheTogJHsgZ2V0VG9BcnJheVN0cmluZyhzdWJLZXJuZWxSZXN1bHQsIHN1Yktlcm5lbFRleHR1cmVOYW1lLCBmcmFtZWJ1ZmZlck5hbWUpIH1cbiAgICAgIH0sYCk7XG4gICAgICB9XG4gICAgICByZXN1bHQucHVzaChgICAgIH07YCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHJlbmRlcmVkID0ga2VybmVsLnJlbmRlck91dHB1dCgpO1xuICAgICAgY29uc3QgdGV4dHVyZU5hbWUgPSBjb250ZXh0LmdldENvbnRleHRWYXJpYWJsZU5hbWUoa2VybmVsLnRleHR1cmUudGV4dHVyZSk7XG4gICAgICByZXN1bHQucHVzaChgICAgIHJldHVybiB7XG4gICAgICAgIHRleHR1cmU6ICR7IHRleHR1cmVOYW1lIH0sXG4gICAgICAgIHR5cGU6ICckeyByZW5kZXJlZC50eXBlIH0nLFxuICAgICAgICB0b0FycmF5OiAkeyBnZXRUb0FycmF5U3RyaW5nKHJlbmRlcmVkLCB0ZXh0dXJlTmFtZSwgZnJhbWVidWZmZXJOYW1lKSB9XG4gICAgICB9O2ApO1xuICAgIH1cbiAgfVxuICByZXN1bHQucHVzaChgICAgICR7ZGVzdHJveUNvbnRleHRTdHJpbmcgPyAnXFxuJyArIGRlc3Ryb3lDb250ZXh0U3RyaW5nICsgJyAgICAnOiAnJ31gKTtcbiAgcmVzdWx0LnB1c2gocG9zdFJlc3VsdC5qb2luKCdcXG4nKSk7XG4gIHJlc3VsdC5wdXNoKCcgIH07Jyk7XG4gIGlmIChrZXJuZWwuZ3JhcGhpY2FsKSB7XG4gICAgcmVzdWx0LnB1c2goZ2V0R2V0UGl4ZWxzU3RyaW5nKGtlcm5lbCkpO1xuICAgIHJlc3VsdC5wdXNoKGAgIGlubmVyS2VybmVsLmdldFBpeGVscyA9IGdldFBpeGVscztgKTtcbiAgfVxuICByZXN1bHQucHVzaCgnICByZXR1cm4gaW5uZXJLZXJuZWw7Jyk7XG5cbiAgbGV0IGNvbnN0YW50c1VwbG9hZCA9IFtdO1xuICBrZXJuZWxDb25zdGFudHMuZm9yRWFjaCgoa2VybmVsQ29uc3RhbnQpID0+IHtcbiAgICBjb25zdGFudHNVcGxvYWQucHVzaChgJHtrZXJuZWxDb25zdGFudC5nZXRTdHJpbmdWYWx1ZUhhbmRsZXIoKX1gKTtcbiAgfSk7XG4gIHJldHVybiBgZnVuY3Rpb24ga2VybmVsKHNldHRpbmdzKSB7XG4gIGNvbnN0IHsgY29udGV4dCwgY29uc3RhbnRzIH0gPSBzZXR0aW5ncztcbiAgJHtjb25zdGFudHNVcGxvYWQuam9pbignJyl9XG4gICR7c2V0dXBDb250ZXh0U3RyaW5nID8gc2V0dXBDb250ZXh0U3RyaW5nIDogJyd9XG4ke3Jlc3VsdC5qb2luKCdcXG4nKX1cbn1gO1xufVxuXG5mdW5jdGlvbiBnZXRSZW5kZXJTdHJpbmcodGFyZ2V0TmFtZSwga2VybmVsKSB7XG4gIGNvbnN0IHJlYWRCYWNrVmFsdWUgPSBrZXJuZWwucHJlY2lzaW9uID09PSAnc2luZ2xlJyA/IHRhcmdldE5hbWUgOiBgbmV3IEZsb2F0MzJBcnJheSgke3RhcmdldE5hbWV9LmJ1ZmZlcilgO1xuICBpZiAoa2VybmVsLm91dHB1dFsyXSkge1xuICAgIHJldHVybiBgcmVuZGVyT3V0cHV0KCR7cmVhZEJhY2tWYWx1ZX0sICR7a2VybmVsLm91dHB1dFswXX0sICR7a2VybmVsLm91dHB1dFsxXX0sICR7a2VybmVsLm91dHB1dFsyXX0pYDtcbiAgfVxuICBpZiAoa2VybmVsLm91dHB1dFsxXSkge1xuICAgIHJldHVybiBgcmVuZGVyT3V0cHV0KCR7cmVhZEJhY2tWYWx1ZX0sICR7a2VybmVsLm91dHB1dFswXX0sICR7a2VybmVsLm91dHB1dFsxXX0pYDtcbiAgfVxuXG4gIHJldHVybiBgcmVuZGVyT3V0cHV0KCR7cmVhZEJhY2tWYWx1ZX0sICR7a2VybmVsLm91dHB1dFswXX0pYDtcbn1cblxuZnVuY3Rpb24gZ2V0R2V0UGl4ZWxzU3RyaW5nKGtlcm5lbCkge1xuICBjb25zdCBnZXRQaXhlbHMgPSBrZXJuZWwuZ2V0UGl4ZWxzLnRvU3RyaW5nKCk7XG4gIGNvbnN0IHVzZUZ1bmN0aW9uS2V5d29yZCA9ICEvXmZ1bmN0aW9uLy50ZXN0KGdldFBpeGVscyk7XG4gIHJldHVybiB1dGlscy5mbGF0dGVuRnVuY3Rpb25Ub1N0cmluZyhgJHt1c2VGdW5jdGlvbktleXdvcmQgPyAnZnVuY3Rpb24gJyA6ICcnfSR7IGdldFBpeGVscyB9YCwge1xuICAgIGZpbmREZXBlbmRlbmN5OiAob2JqZWN0LCBuYW1lKSA9PiB7XG4gICAgICBpZiAob2JqZWN0ID09PSAndXRpbHMnKSB7XG4gICAgICAgIHJldHVybiBgY29uc3QgJHtuYW1lfSA9ICR7dXRpbHNbbmFtZV0udG9TdHJpbmcoKX07YDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0sXG4gICAgdGhpc0xvb2t1cDogKHByb3BlcnR5KSA9PiB7XG4gICAgICBpZiAocHJvcGVydHkgPT09ICdjb250ZXh0Jykge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGlmIChrZXJuZWwuaGFzT3duUHJvcGVydHkocHJvcGVydHkpKSB7XG4gICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShrZXJuZWxbcHJvcGVydHldKTtcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBFcnJvcihgdW5oYW5kbGVkIHRoaXNMb29rdXAgJHsgcHJvcGVydHkgfWApO1xuICAgIH1cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGdldFRvQXJyYXlTdHJpbmcoa2VybmVsUmVzdWx0LCB0ZXh0dXJlTmFtZSwgZnJhbWVidWZmZXJOYW1lKSB7XG4gIGNvbnN0IHRvQXJyYXkgPSBrZXJuZWxSZXN1bHQudG9BcnJheS50b1N0cmluZygpO1xuICBjb25zdCB1c2VGdW5jdGlvbktleXdvcmQgPSAhL15mdW5jdGlvbi8udGVzdCh0b0FycmF5KTtcbiAgY29uc3QgZmxhdHRlbmVkRnVuY3Rpb25zID0gdXRpbHMuZmxhdHRlbkZ1bmN0aW9uVG9TdHJpbmcoYCR7dXNlRnVuY3Rpb25LZXl3b3JkID8gJ2Z1bmN0aW9uICcgOiAnJ30keyB0b0FycmF5IH1gLCB7XG4gICAgZmluZERlcGVuZGVuY3k6IChvYmplY3QsIG5hbWUpID0+IHtcbiAgICAgIGlmIChvYmplY3QgPT09ICd1dGlscycpIHtcbiAgICAgICAgcmV0dXJuIGBjb25zdCAke25hbWV9ID0gJHt1dGlsc1tuYW1lXS50b1N0cmluZygpfTtgO1xuICAgICAgfSBlbHNlIGlmIChvYmplY3QgPT09ICd0aGlzJykge1xuICAgICAgICBpZiAobmFtZSA9PT0gJ2ZyYW1lYnVmZmVyJykge1xuICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYCR7dXNlRnVuY3Rpb25LZXl3b3JkID8gJ2Z1bmN0aW9uICcgOiAnJ30ke2tlcm5lbFJlc3VsdFtuYW1lXS50b1N0cmluZygpfWA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3VuaGFuZGxlZCBmcm9tT2JqZWN0Jyk7XG4gICAgICB9XG4gICAgfSxcbiAgICB0aGlzTG9va3VwOiAocHJvcGVydHksIGlzRGVjbGFyYXRpb24pID0+IHtcbiAgICAgIGlmIChwcm9wZXJ0eSA9PT0gJ3RleHR1cmUnKSB7XG4gICAgICAgIHJldHVybiB0ZXh0dXJlTmFtZTtcbiAgICAgIH1cbiAgICAgIGlmIChwcm9wZXJ0eSA9PT0gJ2NvbnRleHQnKSB7XG4gICAgICAgIGlmIChpc0RlY2xhcmF0aW9uKSByZXR1cm4gbnVsbDtcbiAgICAgICAgcmV0dXJuICdnbCc7XG4gICAgICB9XG4gICAgICBpZiAoa2VybmVsUmVzdWx0Lmhhc093blByb3BlcnR5KHByb3BlcnR5KSkge1xuICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoa2VybmVsUmVzdWx0W3Byb3BlcnR5XSk7XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYHVuaGFuZGxlZCB0aGlzTG9va3VwICR7IHByb3BlcnR5IH1gKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gYCgpID0+IHtcbiAgZnVuY3Rpb24gZnJhbWVidWZmZXIoKSB7IHJldHVybiAke2ZyYW1lYnVmZmVyTmFtZX07IH07XG4gICR7ZmxhdHRlbmVkRnVuY3Rpb25zfVxuICByZXR1cm4gdG9BcnJheSgpO1xuICB9YDtcbn1cblxuZnVuY3Rpb24gZmluZEtlcm5lbFZhbHVlKGFyZ3VtZW50LCBrZXJuZWxWYWx1ZXMsIHZhbHVlcywgY29udGV4dCwgdXBsb2FkZWRWYWx1ZXMpIHtcbiAgaWYgKGFyZ3VtZW50ID09PSBudWxsKSByZXR1cm4gbnVsbDtcbiAgaWYgKGtlcm5lbFZhbHVlcyA9PT0gbnVsbCkgcmV0dXJuIG51bGw7XG4gIHN3aXRjaCAodHlwZW9mIGFyZ3VtZW50KSB7XG4gICAgY2FzZSAnYm9vbGVhbic6XG4gICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgIHJldHVybiBudWxsO1xuICB9XG4gIGlmIChcbiAgICB0eXBlb2YgSFRNTEltYWdlRWxlbWVudCAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICBhcmd1bWVudCBpbnN0YW5jZW9mIEhUTUxJbWFnZUVsZW1lbnRcbiAgKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXJuZWxWYWx1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGtlcm5lbFZhbHVlID0ga2VybmVsVmFsdWVzW2ldO1xuICAgICAgaWYgKGtlcm5lbFZhbHVlLnR5cGUgIT09ICdIVE1MSW1hZ2VBcnJheScgJiYga2VybmVsVmFsdWUpIGNvbnRpbnVlO1xuICAgICAgaWYgKGtlcm5lbFZhbHVlLnVwbG9hZFZhbHVlICE9PSBhcmd1bWVudCkgY29udGludWU7XG4gICAgICBjb25zdCB2YXJpYWJsZUluZGV4ID0gdmFsdWVzW2ldLmluZGV4T2YoYXJndW1lbnQpO1xuICAgICAgaWYgKHZhcmlhYmxlSW5kZXggPT09IC0xKSBjb250aW51ZTtcbiAgICAgIGNvbnN0IHZhcmlhYmxlTmFtZSA9IGB1cGxvYWRWYWx1ZV8ke2tlcm5lbFZhbHVlLm5hbWV9WyR7dmFyaWFibGVJbmRleH1dYDtcbiAgICAgIGNvbnRleHQuaW5zZXJ0VmFyaWFibGUodmFyaWFibGVOYW1lLCBhcmd1bWVudCk7XG4gICAgICByZXR1cm4gdmFyaWFibGVOYW1lO1xuICAgIH1cbiAgfVxuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwga2VybmVsVmFsdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3Qga2VybmVsVmFsdWUgPSBrZXJuZWxWYWx1ZXNbaV07XG4gICAgaWYgKGFyZ3VtZW50ICE9PSBrZXJuZWxWYWx1ZS51cGxvYWRWYWx1ZSkgY29udGludWU7XG4gICAgY29uc3QgdmFyaWFibGUgPSBgdXBsb2FkVmFsdWVfJHtrZXJuZWxWYWx1ZS5uYW1lfWA7XG4gICAgY29udGV4dC5pbnNlcnRWYXJpYWJsZSh2YXJpYWJsZSwga2VybmVsVmFsdWUpO1xuICAgIHJldHVybiB2YXJpYWJsZTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGdsS2VybmVsU3RyaW5nXG59O1xufSx7XCIuLi8uLi91dGlsc1wiOjExNCxcImdsLXdpcmV0YXBcIjozfV0sMTM6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuY29uc3QgeyBLZXJuZWwgfSA9IHJlcXVpcmUoJy4uL2tlcm5lbCcpO1xuY29uc3QgeyB1dGlscyB9ID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMnKTtcbmNvbnN0IHsgR0xUZXh0dXJlQXJyYXkyRmxvYXQgfSA9IHJlcXVpcmUoJy4vdGV4dHVyZS9hcnJheS0yLWZsb2F0Jyk7XG5jb25zdCB7IEdMVGV4dHVyZUFycmF5MkZsb2F0MkQgfSA9IHJlcXVpcmUoJy4vdGV4dHVyZS9hcnJheS0yLWZsb2F0LTJkJyk7XG5jb25zdCB7IEdMVGV4dHVyZUFycmF5MkZsb2F0M0QgfSA9IHJlcXVpcmUoJy4vdGV4dHVyZS9hcnJheS0yLWZsb2F0LTNkJyk7XG5jb25zdCB7IEdMVGV4dHVyZUFycmF5M0Zsb2F0IH0gPSByZXF1aXJlKCcuL3RleHR1cmUvYXJyYXktMy1mbG9hdCcpO1xuY29uc3QgeyBHTFRleHR1cmVBcnJheTNGbG9hdDJEIH0gPSByZXF1aXJlKCcuL3RleHR1cmUvYXJyYXktMy1mbG9hdC0yZCcpO1xuY29uc3QgeyBHTFRleHR1cmVBcnJheTNGbG9hdDNEIH0gPSByZXF1aXJlKCcuL3RleHR1cmUvYXJyYXktMy1mbG9hdC0zZCcpO1xuY29uc3QgeyBHTFRleHR1cmVBcnJheTRGbG9hdCB9ID0gcmVxdWlyZSgnLi90ZXh0dXJlL2FycmF5LTQtZmxvYXQnKTtcbmNvbnN0IHsgR0xUZXh0dXJlQXJyYXk0RmxvYXQyRCB9ID0gcmVxdWlyZSgnLi90ZXh0dXJlL2FycmF5LTQtZmxvYXQtMmQnKTtcbmNvbnN0IHsgR0xUZXh0dXJlQXJyYXk0RmxvYXQzRCB9ID0gcmVxdWlyZSgnLi90ZXh0dXJlL2FycmF5LTQtZmxvYXQtM2QnKTtcbmNvbnN0IHsgR0xUZXh0dXJlRmxvYXQgfSA9IHJlcXVpcmUoJy4vdGV4dHVyZS9mbG9hdCcpO1xuY29uc3QgeyBHTFRleHR1cmVGbG9hdDJEIH0gPSByZXF1aXJlKCcuL3RleHR1cmUvZmxvYXQtMmQnKTtcbmNvbnN0IHsgR0xUZXh0dXJlRmxvYXQzRCB9ID0gcmVxdWlyZSgnLi90ZXh0dXJlL2Zsb2F0LTNkJyk7XG5jb25zdCB7IEdMVGV4dHVyZU1lbW9yeU9wdGltaXplZCB9ID0gcmVxdWlyZSgnLi90ZXh0dXJlL21lbW9yeS1vcHRpbWl6ZWQnKTtcbmNvbnN0IHsgR0xUZXh0dXJlTWVtb3J5T3B0aW1pemVkMkQgfSA9IHJlcXVpcmUoJy4vdGV4dHVyZS9tZW1vcnktb3B0aW1pemVkLTJkJyk7XG5jb25zdCB7IEdMVGV4dHVyZU1lbW9yeU9wdGltaXplZDNEIH0gPSByZXF1aXJlKCcuL3RleHR1cmUvbWVtb3J5LW9wdGltaXplZC0zZCcpO1xuY29uc3QgeyBHTFRleHR1cmVVbnNpZ25lZCB9ID0gcmVxdWlyZSgnLi90ZXh0dXJlL3Vuc2lnbmVkJyk7XG5jb25zdCB7IEdMVGV4dHVyZVVuc2lnbmVkMkQgfSA9IHJlcXVpcmUoJy4vdGV4dHVyZS91bnNpZ25lZC0yZCcpO1xuY29uc3QgeyBHTFRleHR1cmVVbnNpZ25lZDNEIH0gPSByZXF1aXJlKCcuL3RleHR1cmUvdW5zaWduZWQtM2QnKTtcbmNvbnN0IHsgR0xUZXh0dXJlR3JhcGhpY2FsIH0gPSByZXF1aXJlKCcuL3RleHR1cmUvZ3JhcGhpY2FsJyk7XG5cbmNsYXNzIEdMS2VybmVsIGV4dGVuZHMgS2VybmVsIHtcbiAgc3RhdGljIGdldCBtb2RlKCkge1xuICAgIHJldHVybiAnZ3B1JztcbiAgfVxuXG4gIHN0YXRpYyBnZXRJc0Zsb2F0UmVhZCgpIHtcbiAgICBjb25zdCBrZXJuZWxTdHJpbmcgPSBgZnVuY3Rpb24ga2VybmVsRnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9YDtcbiAgICBjb25zdCBrZXJuZWwgPSBuZXcgdGhpcyhrZXJuZWxTdHJpbmcsIHtcbiAgICAgIGNvbnRleHQ6IHRoaXMudGVzdENvbnRleHQsXG4gICAgICBjYW52YXM6IHRoaXMudGVzdENhbnZhcyxcbiAgICAgIHZhbGlkYXRlOiBmYWxzZSxcbiAgICAgIG91dHB1dDogWzFdLFxuICAgICAgcHJlY2lzaW9uOiAnc2luZ2xlJyxcbiAgICAgIHJldHVyblR5cGU6ICdOdW1iZXInLFxuICAgICAgdGFjdGljOiAnc3BlZWQnLFxuICAgIH0pO1xuICAgIGtlcm5lbC5idWlsZCgpO1xuICAgIGtlcm5lbC5ydW4oKTtcbiAgICBjb25zdCByZXN1bHQgPSBrZXJuZWwucmVuZGVyT3V0cHV0KCk7XG4gICAga2VybmVsLmRlc3Ryb3kodHJ1ZSk7XG4gICAgcmV0dXJuIHJlc3VsdFswXSA9PT0gMTtcbiAgfVxuXG4gIHN0YXRpYyBnZXRJc0ludGVnZXJEaXZpc2lvbkFjY3VyYXRlKCkge1xuICAgIGZ1bmN0aW9uIGtlcm5lbEZ1bmN0aW9uKHYxLCB2Mikge1xuICAgICAgcmV0dXJuIHYxW3RoaXMudGhyZWFkLnhdIC8gdjJbdGhpcy50aHJlYWQueF07XG4gICAgfVxuICAgIGNvbnN0IGtlcm5lbCA9IG5ldyB0aGlzKGtlcm5lbEZ1bmN0aW9uLnRvU3RyaW5nKCksIHtcbiAgICAgIGNvbnRleHQ6IHRoaXMudGVzdENvbnRleHQsXG4gICAgICBjYW52YXM6IHRoaXMudGVzdENhbnZhcyxcbiAgICAgIHZhbGlkYXRlOiBmYWxzZSxcbiAgICAgIG91dHB1dDogWzJdLFxuICAgICAgcmV0dXJuVHlwZTogJ051bWJlcicsXG4gICAgICBwcmVjaXNpb246ICd1bnNpZ25lZCcsXG4gICAgICB0YWN0aWM6ICdzcGVlZCcsXG4gICAgfSk7XG4gICAgY29uc3QgYXJncyA9IFtcbiAgICAgIFs2LCA2MDMwNDAxXSxcbiAgICAgIFszLCAzOTkxXVxuICAgIF07XG4gICAga2VybmVsLmJ1aWxkLmFwcGx5KGtlcm5lbCwgYXJncyk7XG4gICAga2VybmVsLnJ1bi5hcHBseShrZXJuZWwsIGFyZ3MpO1xuICAgIGNvbnN0IHJlc3VsdCA9IGtlcm5lbC5yZW5kZXJPdXRwdXQoKTtcbiAgICBrZXJuZWwuZGVzdHJveSh0cnVlKTtcbiAgICByZXR1cm4gcmVzdWx0WzBdID09PSAyICYmIHJlc3VsdFsxXSA9PT0gMTUxMTtcbiAgfVxuXG4gIHN0YXRpYyBnZXRJc1NwZWVkVGFjdGljU3VwcG9ydGVkKCkge1xuICAgIGZ1bmN0aW9uIGtlcm5lbEZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWVbdGhpcy50aHJlYWQueF07XG4gICAgfVxuICAgIGNvbnN0IGtlcm5lbCA9IG5ldyB0aGlzKGtlcm5lbEZ1bmN0aW9uLnRvU3RyaW5nKCksIHtcbiAgICAgIGNvbnRleHQ6IHRoaXMudGVzdENvbnRleHQsXG4gICAgICBjYW52YXM6IHRoaXMudGVzdENhbnZhcyxcbiAgICAgIHZhbGlkYXRlOiBmYWxzZSxcbiAgICAgIG91dHB1dDogWzRdLFxuICAgICAgcmV0dXJuVHlwZTogJ051bWJlcicsXG4gICAgICBwcmVjaXNpb246ICd1bnNpZ25lZCcsXG4gICAgICB0YWN0aWM6ICdzcGVlZCcsXG4gICAgfSk7XG4gICAgY29uc3QgYXJncyA9IFtcbiAgICAgIFswLCAxLCAyLCAzXVxuICAgIF07XG4gICAga2VybmVsLmJ1aWxkLmFwcGx5KGtlcm5lbCwgYXJncyk7XG4gICAga2VybmVsLnJ1bi5hcHBseShrZXJuZWwsIGFyZ3MpO1xuICAgIGNvbnN0IHJlc3VsdCA9IGtlcm5lbC5yZW5kZXJPdXRwdXQoKTtcbiAgICBrZXJuZWwuZGVzdHJveSh0cnVlKTtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChyZXN1bHRbMF0pID09PSAwICYmIE1hdGgucm91bmQocmVzdWx0WzFdKSA9PT0gMSAmJiBNYXRoLnJvdW5kKHJlc3VsdFsyXSkgPT09IDIgJiYgTWF0aC5yb3VuZChyZXN1bHRbM10pID09PSAzO1xuICB9XG5cbiAgc3RhdGljIGdldCB0ZXN0Q2FudmFzKCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgXCJ0ZXN0Q2FudmFzXCIgbm90IGRlZmluZWQgb24gJHsgdGhpcy5uYW1lIH1gKTtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgdGVzdENvbnRleHQoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBcInRlc3RDb250ZXh0XCIgbm90IGRlZmluZWQgb24gJHsgdGhpcy5uYW1lIH1gKTtcbiAgfVxuXG4gIHN0YXRpYyBnZXRGZWF0dXJlcygpIHtcbiAgICBjb25zdCBnbCA9IHRoaXMudGVzdENvbnRleHQ7XG4gICAgY29uc3QgaXNEcmF3QnVmZmVycyA9IHRoaXMuZ2V0SXNEcmF3QnVmZmVycygpO1xuICAgIHJldHVybiBPYmplY3QuZnJlZXplKHtcbiAgICAgIGlzRmxvYXRSZWFkOiB0aGlzLmdldElzRmxvYXRSZWFkKCksXG4gICAgICBpc0ludGVnZXJEaXZpc2lvbkFjY3VyYXRlOiB0aGlzLmdldElzSW50ZWdlckRpdmlzaW9uQWNjdXJhdGUoKSxcbiAgICAgIGlzU3BlZWRUYWN0aWNTdXBwb3J0ZWQ6IHRoaXMuZ2V0SXNTcGVlZFRhY3RpY1N1cHBvcnRlZCgpLFxuICAgICAgaXNUZXh0dXJlRmxvYXQ6IHRoaXMuZ2V0SXNUZXh0dXJlRmxvYXQoKSxcbiAgICAgIGlzRHJhd0J1ZmZlcnMsXG4gICAgICBrZXJuZWxNYXA6IGlzRHJhd0J1ZmZlcnMsXG4gICAgICBjaGFubmVsQ291bnQ6IHRoaXMuZ2V0Q2hhbm5lbENvdW50KCksXG4gICAgICBtYXhUZXh0dXJlU2l6ZTogdGhpcy5nZXRNYXhUZXh0dXJlU2l6ZSgpLFxuICAgICAgbG93SW50UHJlY2lzaW9uOiBnbC5nZXRTaGFkZXJQcmVjaXNpb25Gb3JtYXQoZ2wuRlJBR01FTlRfU0hBREVSLCBnbC5MT1dfSU5UKSxcbiAgICAgIGxvd0Zsb2F0UHJlY2lzaW9uOiBnbC5nZXRTaGFkZXJQcmVjaXNpb25Gb3JtYXQoZ2wuRlJBR01FTlRfU0hBREVSLCBnbC5MT1dfRkxPQVQpLFxuICAgICAgbWVkaXVtSW50UHJlY2lzaW9uOiBnbC5nZXRTaGFkZXJQcmVjaXNpb25Gb3JtYXQoZ2wuRlJBR01FTlRfU0hBREVSLCBnbC5NRURJVU1fSU5UKSxcbiAgICAgIG1lZGl1bUZsb2F0UHJlY2lzaW9uOiBnbC5nZXRTaGFkZXJQcmVjaXNpb25Gb3JtYXQoZ2wuRlJBR01FTlRfU0hBREVSLCBnbC5NRURJVU1fRkxPQVQpLFxuICAgICAgaGlnaEludFByZWNpc2lvbjogZ2wuZ2V0U2hhZGVyUHJlY2lzaW9uRm9ybWF0KGdsLkZSQUdNRU5UX1NIQURFUiwgZ2wuSElHSF9JTlQpLFxuICAgICAgaGlnaEZsb2F0UHJlY2lzaW9uOiBnbC5nZXRTaGFkZXJQcmVjaXNpb25Gb3JtYXQoZ2wuRlJBR01FTlRfU0hBREVSLCBnbC5ISUdIX0ZMT0FUKSxcbiAgICB9KTtcbiAgfVxuXG4gIHN0YXRpYyBzZXR1cEZlYXR1cmVDaGVja3MoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBcInNldHVwRmVhdHVyZUNoZWNrc1wiIG5vdCBkZWZpbmVkIG9uICR7IHRoaXMubmFtZSB9YCk7XG4gIH1cblxuICBzdGF0aWMgZ2V0U2lnbmF0dXJlKGtlcm5lbCwgYXJndW1lbnRUeXBlcykge1xuICAgIHJldHVybiBrZXJuZWwuZ2V0VmFyaWFibGVQcmVjaXNpb25TdHJpbmcoKSArIChhcmd1bWVudFR5cGVzLmxlbmd0aCA+IDAgPyAnOicgKyBhcmd1bWVudFR5cGVzLmpvaW4oJywnKSA6ICcnKTtcbiAgfVxuXG4gIHNldEZpeEludGVnZXJEaXZpc2lvbkFjY3VyYWN5KGZpeCkge1xuICAgIHRoaXMuZml4SW50ZWdlckRpdmlzaW9uQWNjdXJhY3kgPSBmaXg7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBzZXRQcmVjaXNpb24oZmxhZykge1xuICAgIHRoaXMucHJlY2lzaW9uID0gZmxhZztcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHNldEZsb2F0VGV4dHVyZXMoZmxhZykge1xuICAgIHV0aWxzLndhcm5EZXByZWNhdGVkKCdtZXRob2QnLCAnc2V0RmxvYXRUZXh0dXJlcycsICdzZXRPcHRpbWl6ZUZsb2F0TWVtb3J5Jyk7XG4gICAgdGhpcy5mbG9hdFRleHR1cmVzID0gZmxhZztcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHN0YXRpYyBuYXRpdmVGdW5jdGlvbkFyZ3VtZW50cyhzb3VyY2UpIHtcbiAgICBjb25zdCBhcmd1bWVudFR5cGVzID0gW107XG4gICAgY29uc3QgYXJndW1lbnROYW1lcyA9IFtdO1xuICAgIGNvbnN0IHN0YXRlcyA9IFtdO1xuICAgIGNvbnN0IGlzU3RhcnRpbmdWYXJpYWJsZU5hbWUgPSAvXlthLXpBLVpfXS87XG4gICAgY29uc3QgaXNWYXJpYWJsZUNoYXIgPSAvW2EtekEtWl8wLTldLztcbiAgICBsZXQgaSA9IDA7XG4gICAgbGV0IGFyZ3VtZW50TmFtZSA9IG51bGw7XG4gICAgbGV0IGFyZ3VtZW50VHlwZSA9IG51bGw7XG4gICAgd2hpbGUgKGkgPCBzb3VyY2UubGVuZ3RoKSB7XG4gICAgICBjb25zdCBjaGFyID0gc291cmNlW2ldO1xuICAgICAgY29uc3QgbmV4dENoYXIgPSBzb3VyY2VbaSArIDFdO1xuICAgICAgY29uc3Qgc3RhdGUgPSBzdGF0ZXMubGVuZ3RoID4gMCA/IHN0YXRlc1tzdGF0ZXMubGVuZ3RoIC0gMV0gOiBudWxsO1xuXG4gICAgICBpZiAoc3RhdGUgPT09ICdGVU5DVElPTl9BUkdVTUVOVFMnICYmIGNoYXIgPT09ICcvJyAmJiBuZXh0Q2hhciA9PT0gJyonKSB7XG4gICAgICAgIHN0YXRlcy5wdXNoKCdNVUxUSV9MSU5FX0NPTU1FTlQnKTtcbiAgICAgICAgaSArPSAyO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH0gZWxzZSBpZiAoc3RhdGUgPT09ICdNVUxUSV9MSU5FX0NPTU1FTlQnICYmIGNoYXIgPT09ICcqJyAmJiBuZXh0Q2hhciA9PT0gJy8nKSB7XG4gICAgICAgIHN0YXRlcy5wb3AoKTtcbiAgICAgICAgaSArPSAyO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgZWxzZSBpZiAoc3RhdGUgPT09ICdGVU5DVElPTl9BUkdVTUVOVFMnICYmIGNoYXIgPT09ICcvJyAmJiBuZXh0Q2hhciA9PT0gJy8nKSB7XG4gICAgICAgIHN0YXRlcy5wdXNoKCdDT01NRU5UJyk7XG4gICAgICAgIGkgKz0gMjtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9IGVsc2UgaWYgKHN0YXRlID09PSAnQ09NTUVOVCcgJiYgY2hhciA9PT0gJ1xcbicpIHtcbiAgICAgICAgc3RhdGVzLnBvcCgpO1xuICAgICAgICBpKys7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBlbHNlIGlmIChzdGF0ZSA9PT0gbnVsbCAmJiBjaGFyID09PSAnKCcpIHtcbiAgICAgICAgc3RhdGVzLnB1c2goJ0ZVTkNUSU9OX0FSR1VNRU5UUycpO1xuICAgICAgICBpKys7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfSBlbHNlIGlmIChzdGF0ZSA9PT0gJ0ZVTkNUSU9OX0FSR1VNRU5UUycpIHtcbiAgICAgICAgaWYgKGNoYXIgPT09ICcpJykge1xuICAgICAgICAgIHN0YXRlcy5wb3AoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hhciA9PT0gJ2YnICYmIG5leHRDaGFyID09PSAnbCcgJiYgc291cmNlW2kgKyAyXSA9PT0gJ28nICYmIHNvdXJjZVtpICsgM10gPT09ICdhJyAmJiBzb3VyY2VbaSArIDRdID09PSAndCcgJiYgc291cmNlW2kgKyA1XSA9PT0gJyAnKSB7XG4gICAgICAgICAgc3RhdGVzLnB1c2goJ0RFQ0xBUkVfVkFSSUFCTEUnKTtcbiAgICAgICAgICBhcmd1bWVudFR5cGUgPSAnZmxvYXQnO1xuICAgICAgICAgIGFyZ3VtZW50TmFtZSA9ICcnO1xuICAgICAgICAgIGkgKz0gNjtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfSBlbHNlIGlmIChjaGFyID09PSAnaScgJiYgbmV4dENoYXIgPT09ICduJyAmJiBzb3VyY2VbaSArIDJdID09PSAndCcgJiYgc291cmNlW2kgKyAzXSA9PT0gJyAnKSB7XG4gICAgICAgICAgc3RhdGVzLnB1c2goJ0RFQ0xBUkVfVkFSSUFCTEUnKTtcbiAgICAgICAgICBhcmd1bWVudFR5cGUgPSAnaW50JztcbiAgICAgICAgICBhcmd1bWVudE5hbWUgPSAnJztcbiAgICAgICAgICBpICs9IDQ7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH0gZWxzZSBpZiAoY2hhciA9PT0gJ3YnICYmIG5leHRDaGFyID09PSAnZScgJiYgc291cmNlW2kgKyAyXSA9PT0gJ2MnICYmIHNvdXJjZVtpICsgM10gPT09ICcyJyAmJiBzb3VyY2VbaSArIDRdID09PSAnICcpIHtcbiAgICAgICAgICBzdGF0ZXMucHVzaCgnREVDTEFSRV9WQVJJQUJMRScpO1xuICAgICAgICAgIGFyZ3VtZW50VHlwZSA9ICd2ZWMyJztcbiAgICAgICAgICBhcmd1bWVudE5hbWUgPSAnJztcbiAgICAgICAgICBpICs9IDU7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH0gZWxzZSBpZiAoY2hhciA9PT0gJ3YnICYmIG5leHRDaGFyID09PSAnZScgJiYgc291cmNlW2kgKyAyXSA9PT0gJ2MnICYmIHNvdXJjZVtpICsgM10gPT09ICczJyAmJiBzb3VyY2VbaSArIDRdID09PSAnICcpIHtcbiAgICAgICAgICBzdGF0ZXMucHVzaCgnREVDTEFSRV9WQVJJQUJMRScpO1xuICAgICAgICAgIGFyZ3VtZW50VHlwZSA9ICd2ZWMzJztcbiAgICAgICAgICBhcmd1bWVudE5hbWUgPSAnJztcbiAgICAgICAgICBpICs9IDU7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH0gZWxzZSBpZiAoY2hhciA9PT0gJ3YnICYmIG5leHRDaGFyID09PSAnZScgJiYgc291cmNlW2kgKyAyXSA9PT0gJ2MnICYmIHNvdXJjZVtpICsgM10gPT09ICc0JyAmJiBzb3VyY2VbaSArIDRdID09PSAnICcpIHtcbiAgICAgICAgICBzdGF0ZXMucHVzaCgnREVDTEFSRV9WQVJJQUJMRScpO1xuICAgICAgICAgIGFyZ3VtZW50VHlwZSA9ICd2ZWM0JztcbiAgICAgICAgICBhcmd1bWVudE5hbWUgPSAnJztcbiAgICAgICAgICBpICs9IDU7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZWxzZSBpZiAoc3RhdGUgPT09ICdERUNMQVJFX1ZBUklBQkxFJykge1xuICAgICAgICBpZiAoYXJndW1lbnROYW1lID09PSAnJykge1xuICAgICAgICAgIGlmIChjaGFyID09PSAnICcpIHtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIWlzU3RhcnRpbmdWYXJpYWJsZU5hbWUudGVzdChjaGFyKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd2YXJpYWJsZSBuYW1lIGlzIG5vdCBleHBlY3RlZCBzdHJpbmcnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYXJndW1lbnROYW1lICs9IGNoYXI7XG4gICAgICAgIGlmICghaXNWYXJpYWJsZUNoYXIudGVzdChuZXh0Q2hhcikpIHtcbiAgICAgICAgICBzdGF0ZXMucG9wKCk7XG4gICAgICAgICAgYXJndW1lbnROYW1lcy5wdXNoKGFyZ3VtZW50TmFtZSk7XG4gICAgICAgICAgYXJndW1lbnRUeXBlcy5wdXNoKHR5cGVNYXBbYXJndW1lbnRUeXBlXSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaSsrO1xuICAgIH1cbiAgICBpZiAoc3RhdGVzLmxlbmd0aCA+IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignR0xTTCBmdW5jdGlvbiB3YXMgbm90IHBhcnNhYmxlJyk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBhcmd1bWVudE5hbWVzLFxuICAgICAgYXJndW1lbnRUeXBlcyxcbiAgICB9O1xuICB9XG5cbiAgc3RhdGljIG5hdGl2ZUZ1bmN0aW9uUmV0dXJuVHlwZShzb3VyY2UpIHtcbiAgICByZXR1cm4gdHlwZU1hcFtzb3VyY2UubWF0Y2goL2ludHxmbG9hdHx2ZWNbMi00XS8pWzBdXTtcbiAgfVxuXG4gIHN0YXRpYyBjb21iaW5lS2VybmVscyhjb21iaW5lZEtlcm5lbCwgbGFzdEtlcm5lbCkge1xuICAgIGNvbWJpbmVkS2VybmVsLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgY29uc3Qge1xuICAgICAgdGV4U2l6ZSxcbiAgICAgIGNvbnRleHQsXG4gICAgICB0aHJlYWREaW1cbiAgICB9ID0gbGFzdEtlcm5lbC50ZXhTaXplO1xuICAgIGxldCByZXN1bHQ7XG4gICAgaWYgKGxhc3RLZXJuZWwucHJlY2lzaW9uID09PSAnc2luZ2xlJykge1xuICAgICAgY29uc3QgdyA9IHRleFNpemVbMF07XG4gICAgICBjb25zdCBoID0gTWF0aC5jZWlsKHRleFNpemVbMV0gLyA0KTtcbiAgICAgIHJlc3VsdCA9IG5ldyBGbG9hdDMyQXJyYXkodyAqIGggKiA0ICogNCk7XG4gICAgICBjb250ZXh0LnJlYWRQaXhlbHMoMCwgMCwgdywgaCAqIDQsIGNvbnRleHQuUkdCQSwgY29udGV4dC5GTE9BVCwgcmVzdWx0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgYnl0ZXMgPSBuZXcgVWludDhBcnJheSh0ZXhTaXplWzBdICogdGV4U2l6ZVsxXSAqIDQpO1xuICAgICAgY29udGV4dC5yZWFkUGl4ZWxzKDAsIDAsIHRleFNpemVbMF0sIHRleFNpemVbMV0sIGNvbnRleHQuUkdCQSwgY29udGV4dC5VTlNJR05FRF9CWVRFLCBieXRlcyk7XG4gICAgICByZXN1bHQgPSBuZXcgRmxvYXQzMkFycmF5KGJ5dGVzLmJ1ZmZlcik7XG4gICAgfVxuXG4gICAgcmVzdWx0ID0gcmVzdWx0LnN1YmFycmF5KDAsIHRocmVhZERpbVswXSAqIHRocmVhZERpbVsxXSAqIHRocmVhZERpbVsyXSk7XG5cbiAgICBpZiAobGFzdEtlcm5lbC5vdXRwdXQubGVuZ3RoID09PSAxKSB7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0gZWxzZSBpZiAobGFzdEtlcm5lbC5vdXRwdXQubGVuZ3RoID09PSAyKSB7XG4gICAgICByZXR1cm4gdXRpbHMuc3BsaXRBcnJheShyZXN1bHQsIGxhc3RLZXJuZWwub3V0cHV0WzBdKTtcbiAgICB9IGVsc2UgaWYgKGxhc3RLZXJuZWwub3V0cHV0Lmxlbmd0aCA9PT0gMykge1xuICAgICAgY29uc3QgY3ViZSA9IHV0aWxzLnNwbGl0QXJyYXkocmVzdWx0LCBsYXN0S2VybmVsLm91dHB1dFswXSAqIGxhc3RLZXJuZWwub3V0cHV0WzFdKTtcbiAgICAgIHJldHVybiBjdWJlLm1hcChmdW5jdGlvbih4KSB7XG4gICAgICAgIHJldHVybiB1dGlscy5zcGxpdEFycmF5KHgsIGxhc3RLZXJuZWwub3V0cHV0WzBdKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0cnVjdG9yKHNvdXJjZSwgc2V0dGluZ3MpIHtcbiAgICBzdXBlcihzb3VyY2UsIHNldHRpbmdzKTtcbiAgICB0aGlzLnRyYW5zZmVyVmFsdWVzID0gbnVsbDtcbiAgICB0aGlzLmZvcm1hdFZhbHVlcyA9IG51bGw7XG4gICAgdGhpcy5UZXh0dXJlQ29uc3RydWN0b3IgPSBudWxsO1xuICAgIHRoaXMucmVuZGVyT3V0cHV0ID0gbnVsbDtcbiAgICB0aGlzLnJlbmRlclJhd091dHB1dCA9IG51bGw7XG4gICAgdGhpcy50ZXhTaXplID0gbnVsbDtcbiAgICB0aGlzLnRyYW5zbGF0ZWRTb3VyY2UgPSBudWxsO1xuICAgIHRoaXMuY29tcGlsZWRGcmFnbWVudFNoYWRlciA9IG51bGw7XG4gICAgdGhpcy5jb21waWxlZFZlcnRleFNoYWRlciA9IG51bGw7XG4gICAgdGhpcy5zd2l0Y2hpbmdLZXJuZWxzID0gbnVsbDtcbiAgICB0aGlzLl90ZXh0dXJlU3dpdGNoZWQgPSBudWxsO1xuICAgIHRoaXMuX21hcHBlZFRleHR1cmVTd2l0Y2hlZCA9IG51bGw7XG4gIH1cblxuICBjaGVja1RleHR1cmVTaXplKCkge1xuICAgIGNvbnN0IHsgZmVhdHVyZXMgfSA9IHRoaXMuY29uc3RydWN0b3I7XG4gICAgaWYgKHRoaXMudGV4U2l6ZVswXSA+IGZlYXR1cmVzLm1heFRleHR1cmVTaXplIHx8IHRoaXMudGV4U2l6ZVsxXSA+IGZlYXR1cmVzLm1heFRleHR1cmVTaXplKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFRleHR1cmUgc2l6ZSBbJHt0aGlzLnRleFNpemVbMF19LCR7dGhpcy50ZXhTaXplWzFdfV0gZ2VuZXJhdGVkIGJ5IGtlcm5lbCBpcyBsYXJnZXIgdGhhbiBzdXBwb3J0ZWQgc2l6ZSBbJHtmZWF0dXJlcy5tYXhUZXh0dXJlU2l6ZX0sJHtmZWF0dXJlcy5tYXhUZXh0dXJlU2l6ZX1dYCk7XG4gICAgfVxuICB9XG5cbiAgdHJhbnNsYXRlU291cmNlKCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgXCJ0cmFuc2xhdGVTb3VyY2VcIiBub3QgZGVmaW5lZCBvbiAke3RoaXMuY29uc3RydWN0b3IubmFtZX1gKTtcbiAgfVxuXG4gIHBpY2tSZW5kZXJTdHJhdGVneShhcmdzKSB7XG4gICAgaWYgKHRoaXMuZ3JhcGhpY2FsKSB7XG4gICAgICB0aGlzLnJlbmRlclJhd091dHB1dCA9IHRoaXMucmVhZFBhY2tlZFBpeGVsc1RvVWludDhBcnJheTtcbiAgICAgIHRoaXMudHJhbnNmZXJWYWx1ZXMgPSAocGl4ZWxzKSA9PiBwaXhlbHM7XG4gICAgICB0aGlzLlRleHR1cmVDb25zdHJ1Y3RvciA9IEdMVGV4dHVyZUdyYXBoaWNhbDtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAodGhpcy5wcmVjaXNpb24gPT09ICd1bnNpZ25lZCcpIHtcbiAgICAgIHRoaXMucmVuZGVyUmF3T3V0cHV0ID0gdGhpcy5yZWFkUGFja2VkUGl4ZWxzVG9VaW50OEFycmF5O1xuICAgICAgdGhpcy50cmFuc2ZlclZhbHVlcyA9IHRoaXMucmVhZFBhY2tlZFBpeGVsc1RvRmxvYXQzMkFycmF5O1xuICAgICAgaWYgKHRoaXMucGlwZWxpbmUpIHtcbiAgICAgICAgdGhpcy5yZW5kZXJPdXRwdXQgPSB0aGlzLnJlbmRlclRleHR1cmU7XG4gICAgICAgIGlmICh0aGlzLnN1Yktlcm5lbHMgIT09IG51bGwpIHtcbiAgICAgICAgICB0aGlzLnJlbmRlcktlcm5lbHMgPSB0aGlzLnJlbmRlcktlcm5lbHNUb1RleHR1cmVzO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAodGhpcy5yZXR1cm5UeXBlKSB7XG4gICAgICAgICAgY2FzZSAnTGl0ZXJhbEludGVnZXInOlxuICAgICAgICAgIGNhc2UgJ0Zsb2F0JzpcbiAgICAgICAgICBjYXNlICdOdW1iZXInOlxuICAgICAgICAgIGNhc2UgJ0ludGVnZXInOlxuICAgICAgICAgICAgaWYgKHRoaXMub3V0cHV0WzJdID4gMCkge1xuICAgICAgICAgICAgICB0aGlzLlRleHR1cmVDb25zdHJ1Y3RvciA9IEdMVGV4dHVyZVVuc2lnbmVkM0Q7XG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLm91dHB1dFsxXSA+IDApIHtcbiAgICAgICAgICAgICAgdGhpcy5UZXh0dXJlQ29uc3RydWN0b3IgPSBHTFRleHR1cmVVbnNpZ25lZDJEO1xuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRoaXMuVGV4dHVyZUNvbnN0cnVjdG9yID0gR0xUZXh0dXJlVW5zaWduZWQ7XG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAnQXJyYXkoMiknOlxuICAgICAgICAgICAgY2FzZSAnQXJyYXkoMyknOlxuICAgICAgICAgICAgY2FzZSAnQXJyYXkoNCknOlxuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yZXF1ZXN0RmFsbGJhY2soYXJncyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh0aGlzLnN1Yktlcm5lbHMgIT09IG51bGwpIHtcbiAgICAgICAgICB0aGlzLnJlbmRlcktlcm5lbHMgPSB0aGlzLnJlbmRlcktlcm5lbHNUb0FycmF5cztcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKHRoaXMucmV0dXJuVHlwZSkge1xuICAgICAgICAgIGNhc2UgJ0xpdGVyYWxJbnRlZ2VyJzpcbiAgICAgICAgICBjYXNlICdGbG9hdCc6XG4gICAgICAgICAgY2FzZSAnTnVtYmVyJzpcbiAgICAgICAgICBjYXNlICdJbnRlZ2VyJzpcbiAgICAgICAgICAgIHRoaXMucmVuZGVyT3V0cHV0ID0gdGhpcy5yZW5kZXJWYWx1ZXM7XG4gICAgICAgICAgICBpZiAodGhpcy5vdXRwdXRbMl0gPiAwKSB7XG4gICAgICAgICAgICAgIHRoaXMuVGV4dHVyZUNvbnN0cnVjdG9yID0gR0xUZXh0dXJlVW5zaWduZWQzRDtcbiAgICAgICAgICAgICAgdGhpcy5mb3JtYXRWYWx1ZXMgPSB1dGlscy5lcmVjdDNEUGFja2VkRmxvYXQ7XG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLm91dHB1dFsxXSA+IDApIHtcbiAgICAgICAgICAgICAgdGhpcy5UZXh0dXJlQ29uc3RydWN0b3IgPSBHTFRleHR1cmVVbnNpZ25lZDJEO1xuICAgICAgICAgICAgICB0aGlzLmZvcm1hdFZhbHVlcyA9IHV0aWxzLmVyZWN0MkRQYWNrZWRGbG9hdDtcbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aGlzLlRleHR1cmVDb25zdHJ1Y3RvciA9IEdMVGV4dHVyZVVuc2lnbmVkO1xuICAgICAgICAgICAgICB0aGlzLmZvcm1hdFZhbHVlcyA9IHV0aWxzLmVyZWN0UGFja2VkRmxvYXQ7XG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAnQXJyYXkoMiknOlxuICAgICAgICAgICAgY2FzZSAnQXJyYXkoMyknOlxuICAgICAgICAgICAgY2FzZSAnQXJyYXkoNCknOlxuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yZXF1ZXN0RmFsbGJhY2soYXJncyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHRoaXMucHJlY2lzaW9uID09PSAnc2luZ2xlJykge1xuICAgICAgdGhpcy5yZW5kZXJSYXdPdXRwdXQgPSB0aGlzLnJlYWRGbG9hdFBpeGVsc1RvRmxvYXQzMkFycmF5O1xuICAgICAgdGhpcy50cmFuc2ZlclZhbHVlcyA9IHRoaXMucmVhZEZsb2F0UGl4ZWxzVG9GbG9hdDMyQXJyYXk7XG4gICAgICBpZiAodGhpcy5waXBlbGluZSkge1xuICAgICAgICB0aGlzLnJlbmRlck91dHB1dCA9IHRoaXMucmVuZGVyVGV4dHVyZTtcbiAgICAgICAgaWYgKHRoaXMuc3ViS2VybmVscyAhPT0gbnVsbCkge1xuICAgICAgICAgIHRoaXMucmVuZGVyS2VybmVscyA9IHRoaXMucmVuZGVyS2VybmVsc1RvVGV4dHVyZXM7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoICh0aGlzLnJldHVyblR5cGUpIHtcbiAgICAgICAgICBjYXNlICdMaXRlcmFsSW50ZWdlcic6XG4gICAgICAgICAgY2FzZSAnRmxvYXQnOlxuICAgICAgICAgIGNhc2UgJ051bWJlcic6XG4gICAgICAgICAgY2FzZSAnSW50ZWdlcic6IHtcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGltaXplRmxvYXRNZW1vcnkpIHtcbiAgICAgICAgICAgICAgaWYgKHRoaXMub3V0cHV0WzJdID4gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuVGV4dHVyZUNvbnN0cnVjdG9yID0gR0xUZXh0dXJlTWVtb3J5T3B0aW1pemVkM0Q7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5vdXRwdXRbMV0gPiAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5UZXh0dXJlQ29uc3RydWN0b3IgPSBHTFRleHR1cmVNZW1vcnlPcHRpbWl6ZWQyRDtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLlRleHR1cmVDb25zdHJ1Y3RvciA9IEdMVGV4dHVyZU1lbW9yeU9wdGltaXplZDtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaWYgKHRoaXMub3V0cHV0WzJdID4gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuVGV4dHVyZUNvbnN0cnVjdG9yID0gR0xUZXh0dXJlRmxvYXQzRDtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLm91dHB1dFsxXSA+IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLlRleHR1cmVDb25zdHJ1Y3RvciA9IEdMVGV4dHVyZUZsb2F0MkQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5UZXh0dXJlQ29uc3RydWN0b3IgPSBHTFRleHR1cmVGbG9hdDtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlICdBcnJheSgyKSc6IHtcbiAgICAgICAgICAgIGlmICh0aGlzLm91dHB1dFsyXSA+IDApIHtcbiAgICAgICAgICAgICAgdGhpcy5UZXh0dXJlQ29uc3RydWN0b3IgPSBHTFRleHR1cmVBcnJheTJGbG9hdDNEO1xuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5vdXRwdXRbMV0gPiAwKSB7XG4gICAgICAgICAgICAgIHRoaXMuVGV4dHVyZUNvbnN0cnVjdG9yID0gR0xUZXh0dXJlQXJyYXkyRmxvYXQyRDtcbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aGlzLlRleHR1cmVDb25zdHJ1Y3RvciA9IEdMVGV4dHVyZUFycmF5MkZsb2F0O1xuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSAnQXJyYXkoMyknOiB7XG4gICAgICAgICAgICBpZiAodGhpcy5vdXRwdXRbMl0gPiAwKSB7XG4gICAgICAgICAgICAgIHRoaXMuVGV4dHVyZUNvbnN0cnVjdG9yID0gR0xUZXh0dXJlQXJyYXkzRmxvYXQzRDtcbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMub3V0cHV0WzFdID4gMCkge1xuICAgICAgICAgICAgICB0aGlzLlRleHR1cmVDb25zdHJ1Y3RvciA9IEdMVGV4dHVyZUFycmF5M0Zsb2F0MkQ7XG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhpcy5UZXh0dXJlQ29uc3RydWN0b3IgPSBHTFRleHR1cmVBcnJheTNGbG9hdDtcbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgJ0FycmF5KDQpJzoge1xuICAgICAgICAgICAgaWYgKHRoaXMub3V0cHV0WzJdID4gMCkge1xuICAgICAgICAgICAgICB0aGlzLlRleHR1cmVDb25zdHJ1Y3RvciA9IEdMVGV4dHVyZUFycmF5NEZsb2F0M0Q7XG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLm91dHB1dFsxXSA+IDApIHtcbiAgICAgICAgICAgICAgdGhpcy5UZXh0dXJlQ29uc3RydWN0b3IgPSBHTFRleHR1cmVBcnJheTRGbG9hdDJEO1xuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRoaXMuVGV4dHVyZUNvbnN0cnVjdG9yID0gR0xUZXh0dXJlQXJyYXk0RmxvYXQ7XG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5yZW5kZXJPdXRwdXQgPSB0aGlzLnJlbmRlclZhbHVlcztcbiAgICAgIGlmICh0aGlzLnN1Yktlcm5lbHMgIT09IG51bGwpIHtcbiAgICAgICAgdGhpcy5yZW5kZXJLZXJuZWxzID0gdGhpcy5yZW5kZXJLZXJuZWxzVG9BcnJheXM7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5vcHRpbWl6ZUZsb2F0TWVtb3J5KSB7XG4gICAgICAgIHN3aXRjaCAodGhpcy5yZXR1cm5UeXBlKSB7XG4gICAgICAgICAgY2FzZSAnTGl0ZXJhbEludGVnZXInOlxuICAgICAgICAgIGNhc2UgJ0Zsb2F0JzpcbiAgICAgICAgICBjYXNlICdOdW1iZXInOlxuICAgICAgICAgIGNhc2UgJ0ludGVnZXInOiB7XG4gICAgICAgICAgICBpZiAodGhpcy5vdXRwdXRbMl0gPiAwKSB7XG4gICAgICAgICAgICAgIHRoaXMuVGV4dHVyZUNvbnN0cnVjdG9yID0gR0xUZXh0dXJlTWVtb3J5T3B0aW1pemVkM0Q7XG4gICAgICAgICAgICAgIHRoaXMuZm9ybWF0VmFsdWVzID0gdXRpbHMuZXJlY3RNZW1vcnlPcHRpbWl6ZWQzREZsb2F0O1xuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5vdXRwdXRbMV0gPiAwKSB7XG4gICAgICAgICAgICAgIHRoaXMuVGV4dHVyZUNvbnN0cnVjdG9yID0gR0xUZXh0dXJlTWVtb3J5T3B0aW1pemVkMkQ7XG4gICAgICAgICAgICAgIHRoaXMuZm9ybWF0VmFsdWVzID0gdXRpbHMuZXJlY3RNZW1vcnlPcHRpbWl6ZWQyREZsb2F0O1xuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRoaXMuVGV4dHVyZUNvbnN0cnVjdG9yID0gR0xUZXh0dXJlTWVtb3J5T3B0aW1pemVkO1xuICAgICAgICAgICAgICB0aGlzLmZvcm1hdFZhbHVlcyA9IHV0aWxzLmVyZWN0TWVtb3J5T3B0aW1pemVkRmxvYXQ7XG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlICdBcnJheSgyKSc6IHtcbiAgICAgICAgICAgIGlmICh0aGlzLm91dHB1dFsyXSA+IDApIHtcbiAgICAgICAgICAgICAgdGhpcy5UZXh0dXJlQ29uc3RydWN0b3IgPSBHTFRleHR1cmVBcnJheTJGbG9hdDNEO1xuICAgICAgICAgICAgICB0aGlzLmZvcm1hdFZhbHVlcyA9IHV0aWxzLmVyZWN0M0RBcnJheTI7XG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLm91dHB1dFsxXSA+IDApIHtcbiAgICAgICAgICAgICAgdGhpcy5UZXh0dXJlQ29uc3RydWN0b3IgPSBHTFRleHR1cmVBcnJheTJGbG9hdDJEO1xuICAgICAgICAgICAgICB0aGlzLmZvcm1hdFZhbHVlcyA9IHV0aWxzLmVyZWN0MkRBcnJheTI7XG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhpcy5UZXh0dXJlQ29uc3RydWN0b3IgPSBHTFRleHR1cmVBcnJheTJGbG9hdDtcbiAgICAgICAgICAgICAgdGhpcy5mb3JtYXRWYWx1ZXMgPSB1dGlscy5lcmVjdEFycmF5MjtcbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgJ0FycmF5KDMpJzoge1xuICAgICAgICAgICAgaWYgKHRoaXMub3V0cHV0WzJdID4gMCkge1xuICAgICAgICAgICAgICB0aGlzLlRleHR1cmVDb25zdHJ1Y3RvciA9IEdMVGV4dHVyZUFycmF5M0Zsb2F0M0Q7XG4gICAgICAgICAgICAgIHRoaXMuZm9ybWF0VmFsdWVzID0gdXRpbHMuZXJlY3QzREFycmF5MztcbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMub3V0cHV0WzFdID4gMCkge1xuICAgICAgICAgICAgICB0aGlzLlRleHR1cmVDb25zdHJ1Y3RvciA9IEdMVGV4dHVyZUFycmF5M0Zsb2F0MkQ7XG4gICAgICAgICAgICAgIHRoaXMuZm9ybWF0VmFsdWVzID0gdXRpbHMuZXJlY3QyREFycmF5MztcbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aGlzLlRleHR1cmVDb25zdHJ1Y3RvciA9IEdMVGV4dHVyZUFycmF5M0Zsb2F0O1xuICAgICAgICAgICAgICB0aGlzLmZvcm1hdFZhbHVlcyA9IHV0aWxzLmVyZWN0QXJyYXkzO1xuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSAnQXJyYXkoNCknOiB7XG4gICAgICAgICAgICBpZiAodGhpcy5vdXRwdXRbMl0gPiAwKSB7XG4gICAgICAgICAgICAgIHRoaXMuVGV4dHVyZUNvbnN0cnVjdG9yID0gR0xUZXh0dXJlQXJyYXk0RmxvYXQzRDtcbiAgICAgICAgICAgICAgdGhpcy5mb3JtYXRWYWx1ZXMgPSB1dGlscy5lcmVjdDNEQXJyYXk0O1xuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5vdXRwdXRbMV0gPiAwKSB7XG4gICAgICAgICAgICAgIHRoaXMuVGV4dHVyZUNvbnN0cnVjdG9yID0gR0xUZXh0dXJlQXJyYXk0RmxvYXQyRDtcbiAgICAgICAgICAgICAgdGhpcy5mb3JtYXRWYWx1ZXMgPSB1dGlscy5lcmVjdDJEQXJyYXk0O1xuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRoaXMuVGV4dHVyZUNvbnN0cnVjdG9yID0gR0xUZXh0dXJlQXJyYXk0RmxvYXQ7XG4gICAgICAgICAgICAgIHRoaXMuZm9ybWF0VmFsdWVzID0gdXRpbHMuZXJlY3RBcnJheTQ7XG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3dpdGNoICh0aGlzLnJldHVyblR5cGUpIHtcbiAgICAgICAgICBjYXNlICdMaXRlcmFsSW50ZWdlcic6XG4gICAgICAgICAgY2FzZSAnRmxvYXQnOlxuICAgICAgICAgIGNhc2UgJ051bWJlcic6XG4gICAgICAgICAgY2FzZSAnSW50ZWdlcic6IHtcbiAgICAgICAgICAgIGlmICh0aGlzLm91dHB1dFsyXSA+IDApIHtcbiAgICAgICAgICAgICAgdGhpcy5UZXh0dXJlQ29uc3RydWN0b3IgPSBHTFRleHR1cmVGbG9hdDNEO1xuICAgICAgICAgICAgICB0aGlzLmZvcm1hdFZhbHVlcyA9IHV0aWxzLmVyZWN0M0RGbG9hdDtcbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMub3V0cHV0WzFdID4gMCkge1xuICAgICAgICAgICAgICB0aGlzLlRleHR1cmVDb25zdHJ1Y3RvciA9IEdMVGV4dHVyZUZsb2F0MkQ7XG4gICAgICAgICAgICAgIHRoaXMuZm9ybWF0VmFsdWVzID0gdXRpbHMuZXJlY3QyREZsb2F0O1xuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRoaXMuVGV4dHVyZUNvbnN0cnVjdG9yID0gR0xUZXh0dXJlRmxvYXQ7XG4gICAgICAgICAgICAgIHRoaXMuZm9ybWF0VmFsdWVzID0gdXRpbHMuZXJlY3RGbG9hdDtcbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgJ0FycmF5KDIpJzoge1xuICAgICAgICAgICAgaWYgKHRoaXMub3V0cHV0WzJdID4gMCkge1xuICAgICAgICAgICAgICB0aGlzLlRleHR1cmVDb25zdHJ1Y3RvciA9IEdMVGV4dHVyZUFycmF5MkZsb2F0M0Q7XG4gICAgICAgICAgICAgIHRoaXMuZm9ybWF0VmFsdWVzID0gdXRpbHMuZXJlY3QzREFycmF5MjtcbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMub3V0cHV0WzFdID4gMCkge1xuICAgICAgICAgICAgICB0aGlzLlRleHR1cmVDb25zdHJ1Y3RvciA9IEdMVGV4dHVyZUFycmF5MkZsb2F0MkQ7XG4gICAgICAgICAgICAgIHRoaXMuZm9ybWF0VmFsdWVzID0gdXRpbHMuZXJlY3QyREFycmF5MjtcbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aGlzLlRleHR1cmVDb25zdHJ1Y3RvciA9IEdMVGV4dHVyZUFycmF5MkZsb2F0O1xuICAgICAgICAgICAgICB0aGlzLmZvcm1hdFZhbHVlcyA9IHV0aWxzLmVyZWN0QXJyYXkyO1xuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSAnQXJyYXkoMyknOiB7XG4gICAgICAgICAgICBpZiAodGhpcy5vdXRwdXRbMl0gPiAwKSB7XG4gICAgICAgICAgICAgIHRoaXMuVGV4dHVyZUNvbnN0cnVjdG9yID0gR0xUZXh0dXJlQXJyYXkzRmxvYXQzRDtcbiAgICAgICAgICAgICAgdGhpcy5mb3JtYXRWYWx1ZXMgPSB1dGlscy5lcmVjdDNEQXJyYXkzO1xuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5vdXRwdXRbMV0gPiAwKSB7XG4gICAgICAgICAgICAgIHRoaXMuVGV4dHVyZUNvbnN0cnVjdG9yID0gR0xUZXh0dXJlQXJyYXkzRmxvYXQyRDtcbiAgICAgICAgICAgICAgdGhpcy5mb3JtYXRWYWx1ZXMgPSB1dGlscy5lcmVjdDJEQXJyYXkzO1xuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRoaXMuVGV4dHVyZUNvbnN0cnVjdG9yID0gR0xUZXh0dXJlQXJyYXkzRmxvYXQ7XG4gICAgICAgICAgICAgIHRoaXMuZm9ybWF0VmFsdWVzID0gdXRpbHMuZXJlY3RBcnJheTM7XG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlICdBcnJheSg0KSc6IHtcbiAgICAgICAgICAgIGlmICh0aGlzLm91dHB1dFsyXSA+IDApIHtcbiAgICAgICAgICAgICAgdGhpcy5UZXh0dXJlQ29uc3RydWN0b3IgPSBHTFRleHR1cmVBcnJheTRGbG9hdDNEO1xuICAgICAgICAgICAgICB0aGlzLmZvcm1hdFZhbHVlcyA9IHV0aWxzLmVyZWN0M0RBcnJheTQ7XG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLm91dHB1dFsxXSA+IDApIHtcbiAgICAgICAgICAgICAgdGhpcy5UZXh0dXJlQ29uc3RydWN0b3IgPSBHTFRleHR1cmVBcnJheTRGbG9hdDJEO1xuICAgICAgICAgICAgICB0aGlzLmZvcm1hdFZhbHVlcyA9IHV0aWxzLmVyZWN0MkRBcnJheTQ7XG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhpcy5UZXh0dXJlQ29uc3RydWN0b3IgPSBHTFRleHR1cmVBcnJheTRGbG9hdDtcbiAgICAgICAgICAgICAgdGhpcy5mb3JtYXRWYWx1ZXMgPSB1dGlscy5lcmVjdEFycmF5NDtcbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgdW5oYW5kbGVkIHByZWNpc2lvbiBvZiBcIiR7dGhpcy5wcmVjaXNpb259XCJgKTtcbiAgICB9XG5cbiAgICB0aHJvdyBuZXcgRXJyb3IoYHVuaGFuZGxlZCByZXR1cm4gdHlwZSBcIiR7dGhpcy5yZXR1cm5UeXBlfVwiYCk7XG4gIH1cblxuICBnZXRLZXJuZWxTdHJpbmcoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBhYnN0cmFjdCBtZXRob2QgY2FsbGApO1xuICB9XG5cbiAgZ2V0TWFpblJlc3VsdFRleHR1cmUoKSB7XG4gICAgc3dpdGNoICh0aGlzLnJldHVyblR5cGUpIHtcbiAgICAgIGNhc2UgJ0xpdGVyYWxJbnRlZ2VyJzpcbiAgICAgIGNhc2UgJ0Zsb2F0JzpcbiAgICAgIGNhc2UgJ0ludGVnZXInOlxuICAgICAgY2FzZSAnTnVtYmVyJzpcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TWFpblJlc3VsdE51bWJlclRleHR1cmUoKTtcbiAgICAgIGNhc2UgJ0FycmF5KDIpJzpcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TWFpblJlc3VsdEFycmF5MlRleHR1cmUoKTtcbiAgICAgIGNhc2UgJ0FycmF5KDMpJzpcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TWFpblJlc3VsdEFycmF5M1RleHR1cmUoKTtcbiAgICAgIGNhc2UgJ0FycmF5KDQpJzpcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TWFpblJlc3VsdEFycmF5NFRleHR1cmUoKTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgdW5oYW5kbGVkIHJldHVyblR5cGUgdHlwZSAkeyB0aGlzLnJldHVyblR5cGUgfWApO1xuICAgIH1cbiAgfVxuXG4gIGdldE1haW5SZXN1bHRLZXJuZWxOdW1iZXJUZXh0dXJlKCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgYWJzdHJhY3QgbWV0aG9kIGNhbGxgKTtcbiAgfVxuICBnZXRNYWluUmVzdWx0U3ViS2VybmVsTnVtYmVyVGV4dHVyZSgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYGFic3RyYWN0IG1ldGhvZCBjYWxsYCk7XG4gIH1cbiAgZ2V0TWFpblJlc3VsdEtlcm5lbEFycmF5MlRleHR1cmUoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBhYnN0cmFjdCBtZXRob2QgY2FsbGApO1xuICB9XG4gIGdldE1haW5SZXN1bHRTdWJLZXJuZWxBcnJheTJUZXh0dXJlKCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgYWJzdHJhY3QgbWV0aG9kIGNhbGxgKTtcbiAgfVxuICBnZXRNYWluUmVzdWx0S2VybmVsQXJyYXkzVGV4dHVyZSgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYGFic3RyYWN0IG1ldGhvZCBjYWxsYCk7XG4gIH1cbiAgZ2V0TWFpblJlc3VsdFN1Yktlcm5lbEFycmF5M1RleHR1cmUoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBhYnN0cmFjdCBtZXRob2QgY2FsbGApO1xuICB9XG4gIGdldE1haW5SZXN1bHRLZXJuZWxBcnJheTRUZXh0dXJlKCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgYWJzdHJhY3QgbWV0aG9kIGNhbGxgKTtcbiAgfVxuICBnZXRNYWluUmVzdWx0U3ViS2VybmVsQXJyYXk0VGV4dHVyZSgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYGFic3RyYWN0IG1ldGhvZCBjYWxsYCk7XG4gIH1cbiAgZ2V0TWFpblJlc3VsdEdyYXBoaWNhbCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYGFic3RyYWN0IG1ldGhvZCBjYWxsYCk7XG4gIH1cbiAgZ2V0TWFpblJlc3VsdE1lbW9yeU9wdGltaXplZEZsb2F0cygpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYGFic3RyYWN0IG1ldGhvZCBjYWxsYCk7XG4gIH1cbiAgZ2V0TWFpblJlc3VsdFBhY2tlZFBpeGVscygpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYGFic3RyYWN0IG1ldGhvZCBjYWxsYCk7XG4gIH1cblxuICBnZXRNYWluUmVzdWx0U3RyaW5nKCkge1xuICAgIGlmICh0aGlzLmdyYXBoaWNhbCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0TWFpblJlc3VsdEdyYXBoaWNhbCgpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5wcmVjaXNpb24gPT09ICdzaW5nbGUnKSB7XG4gICAgICBpZiAodGhpcy5vcHRpbWl6ZUZsb2F0TWVtb3J5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldE1haW5SZXN1bHRNZW1vcnlPcHRpbWl6ZWRGbG9hdHMoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLmdldE1haW5SZXN1bHRUZXh0dXJlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLmdldE1haW5SZXN1bHRQYWNrZWRQaXhlbHMoKTtcbiAgICB9XG4gIH1cblxuICBnZXRNYWluUmVzdWx0TnVtYmVyVGV4dHVyZSgpIHtcbiAgICByZXR1cm4gdXRpbHMubGluZXNUb1N0cmluZyh0aGlzLmdldE1haW5SZXN1bHRLZXJuZWxOdW1iZXJUZXh0dXJlKCkpICtcbiAgICAgIHV0aWxzLmxpbmVzVG9TdHJpbmcodGhpcy5nZXRNYWluUmVzdWx0U3ViS2VybmVsTnVtYmVyVGV4dHVyZSgpKTtcbiAgfVxuXG4gIGdldE1haW5SZXN1bHRBcnJheTJUZXh0dXJlKCkge1xuICAgIHJldHVybiB1dGlscy5saW5lc1RvU3RyaW5nKHRoaXMuZ2V0TWFpblJlc3VsdEtlcm5lbEFycmF5MlRleHR1cmUoKSkgK1xuICAgICAgdXRpbHMubGluZXNUb1N0cmluZyh0aGlzLmdldE1haW5SZXN1bHRTdWJLZXJuZWxBcnJheTJUZXh0dXJlKCkpO1xuICB9XG5cbiAgZ2V0TWFpblJlc3VsdEFycmF5M1RleHR1cmUoKSB7XG4gICAgcmV0dXJuIHV0aWxzLmxpbmVzVG9TdHJpbmcodGhpcy5nZXRNYWluUmVzdWx0S2VybmVsQXJyYXkzVGV4dHVyZSgpKSArXG4gICAgICB1dGlscy5saW5lc1RvU3RyaW5nKHRoaXMuZ2V0TWFpblJlc3VsdFN1Yktlcm5lbEFycmF5M1RleHR1cmUoKSk7XG4gIH1cblxuICBnZXRNYWluUmVzdWx0QXJyYXk0VGV4dHVyZSgpIHtcbiAgICByZXR1cm4gdXRpbHMubGluZXNUb1N0cmluZyh0aGlzLmdldE1haW5SZXN1bHRLZXJuZWxBcnJheTRUZXh0dXJlKCkpICtcbiAgICAgIHV0aWxzLmxpbmVzVG9TdHJpbmcodGhpcy5nZXRNYWluUmVzdWx0U3ViS2VybmVsQXJyYXk0VGV4dHVyZSgpKTtcbiAgfVxuXG4gIGdldEZsb2F0VGFjdGljRGVjbGFyYXRpb24oKSB7XG4gICAgY29uc3QgdmFyaWFibGVQcmVjaXNpb24gPSB0aGlzLmdldFZhcmlhYmxlUHJlY2lzaW9uU3RyaW5nKHRoaXMudGV4U2l6ZSwgdGhpcy50YWN0aWMpO1xuICAgIHJldHVybiBgcHJlY2lzaW9uICR7dmFyaWFibGVQcmVjaXNpb259IGZsb2F0O1xcbmA7XG4gIH1cblxuICBnZXRJbnRUYWN0aWNEZWNsYXJhdGlvbigpIHtcbiAgICByZXR1cm4gYHByZWNpc2lvbiAke3RoaXMuZ2V0VmFyaWFibGVQcmVjaXNpb25TdHJpbmcodGhpcy50ZXhTaXplLCB0aGlzLnRhY3RpYywgdHJ1ZSl9IGludDtcXG5gO1xuICB9XG5cbiAgZ2V0U2FtcGxlcjJEVGFjdGljRGVjbGFyYXRpb24oKSB7XG4gICAgcmV0dXJuIGBwcmVjaXNpb24gJHt0aGlzLmdldFZhcmlhYmxlUHJlY2lzaW9uU3RyaW5nKHRoaXMudGV4U2l6ZSwgdGhpcy50YWN0aWMpfSBzYW1wbGVyMkQ7XFxuYDtcbiAgfVxuXG4gIGdldFNhbXBsZXIyREFycmF5VGFjdGljRGVjbGFyYXRpb24oKSB7XG4gICAgcmV0dXJuIGBwcmVjaXNpb24gJHt0aGlzLmdldFZhcmlhYmxlUHJlY2lzaW9uU3RyaW5nKHRoaXMudGV4U2l6ZSwgdGhpcy50YWN0aWMpfSBzYW1wbGVyMkRBcnJheTtcXG5gO1xuICB9XG5cbiAgcmVuZGVyVGV4dHVyZSgpIHtcbiAgICByZXR1cm4gdGhpcy5pbW11dGFibGUgPyB0aGlzLnRleHR1cmUuY2xvbmUoKSA6IHRoaXMudGV4dHVyZTtcbiAgfVxuICByZWFkUGFja2VkUGl4ZWxzVG9VaW50OEFycmF5KCkge1xuICAgIGlmICh0aGlzLnByZWNpc2lvbiAhPT0gJ3Vuc2lnbmVkJykgdGhyb3cgbmV3IEVycm9yKCdSZXF1aXJlcyB0aGlzLnByZWNpc2lvbiB0byBiZSBcInVuc2lnbmVkXCInKTtcbiAgICBjb25zdCB7XG4gICAgICB0ZXhTaXplLFxuICAgICAgY29udGV4dDogZ2xcbiAgICB9ID0gdGhpcztcbiAgICBjb25zdCByZXN1bHQgPSBuZXcgVWludDhBcnJheSh0ZXhTaXplWzBdICogdGV4U2l6ZVsxXSAqIDQpO1xuICAgIGdsLnJlYWRQaXhlbHMoMCwgMCwgdGV4U2l6ZVswXSwgdGV4U2l6ZVsxXSwgZ2wuUkdCQSwgZ2wuVU5TSUdORURfQllURSwgcmVzdWx0KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgcmVhZFBhY2tlZFBpeGVsc1RvRmxvYXQzMkFycmF5KCkge1xuICAgIHJldHVybiBuZXcgRmxvYXQzMkFycmF5KHRoaXMucmVhZFBhY2tlZFBpeGVsc1RvVWludDhBcnJheSgpLmJ1ZmZlcik7XG4gIH1cblxuICByZWFkRmxvYXRQaXhlbHNUb0Zsb2F0MzJBcnJheSgpIHtcbiAgICBpZiAodGhpcy5wcmVjaXNpb24gIT09ICdzaW5nbGUnKSB0aHJvdyBuZXcgRXJyb3IoJ1JlcXVpcmVzIHRoaXMucHJlY2lzaW9uIHRvIGJlIFwic2luZ2xlXCInKTtcbiAgICBjb25zdCB7XG4gICAgICB0ZXhTaXplLFxuICAgICAgY29udGV4dDogZ2xcbiAgICB9ID0gdGhpcztcbiAgICBjb25zdCB3ID0gdGV4U2l6ZVswXTtcbiAgICBjb25zdCBoID0gdGV4U2l6ZVsxXTtcbiAgICBjb25zdCByZXN1bHQgPSBuZXcgRmxvYXQzMkFycmF5KHcgKiBoICogNCk7XG4gICAgZ2wucmVhZFBpeGVscygwLCAwLCB3LCBoLCBnbC5SR0JBLCBnbC5GTE9BVCwgcmVzdWx0KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgZ2V0UGl4ZWxzKGZsaXApIHtcbiAgICBjb25zdCB7XG4gICAgICBjb250ZXh0OiBnbCxcbiAgICAgIG91dHB1dFxuICAgIH0gPSB0aGlzO1xuICAgIGNvbnN0IFt3aWR0aCwgaGVpZ2h0XSA9IG91dHB1dDtcbiAgICBjb25zdCBwaXhlbHMgPSBuZXcgVWludDhBcnJheSh3aWR0aCAqIGhlaWdodCAqIDQpO1xuICAgIGdsLnJlYWRQaXhlbHMoMCwgMCwgd2lkdGgsIGhlaWdodCwgZ2wuUkdCQSwgZ2wuVU5TSUdORURfQllURSwgcGl4ZWxzKTtcbiAgICByZXR1cm4gbmV3IFVpbnQ4Q2xhbXBlZEFycmF5KChmbGlwID8gcGl4ZWxzIDogdXRpbHMuZmxpcFBpeGVscyhwaXhlbHMsIHdpZHRoLCBoZWlnaHQpKS5idWZmZXIpO1xuICB9XG5cbiAgcmVuZGVyS2VybmVsc1RvQXJyYXlzKCkge1xuICAgIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAgIHJlc3VsdDogdGhpcy5yZW5kZXJPdXRwdXQoKSxcbiAgICB9O1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5zdWJLZXJuZWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICByZXN1bHRbdGhpcy5zdWJLZXJuZWxzW2ldLnByb3BlcnR5XSA9IHRoaXMubWFwcGVkVGV4dHVyZXNbaV0udG9BcnJheSgpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgcmVuZGVyS2VybmVsc1RvVGV4dHVyZXMoKSB7XG4gICAgY29uc3QgcmVzdWx0ID0ge1xuICAgICAgcmVzdWx0OiB0aGlzLnJlbmRlck91dHB1dCgpLFxuICAgIH07XG4gICAgaWYgKHRoaXMuaW1tdXRhYmxlKSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuc3ViS2VybmVscy5sZW5ndGg7IGkrKykge1xuICAgICAgICByZXN1bHRbdGhpcy5zdWJLZXJuZWxzW2ldLnByb3BlcnR5XSA9IHRoaXMubWFwcGVkVGV4dHVyZXNbaV0uY2xvbmUoKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnN1Yktlcm5lbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcmVzdWx0W3RoaXMuc3ViS2VybmVsc1tpXS5wcm9wZXJ0eV0gPSB0aGlzLm1hcHBlZFRleHR1cmVzW2ldO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgcmVzZXRTd2l0Y2hpbmdLZXJuZWxzKCkge1xuICAgIGNvbnN0IGV4aXN0aW5nVmFsdWUgPSB0aGlzLnN3aXRjaGluZ0tlcm5lbHM7XG4gICAgdGhpcy5zd2l0Y2hpbmdLZXJuZWxzID0gbnVsbDtcbiAgICByZXR1cm4gZXhpc3RpbmdWYWx1ZTtcbiAgfVxuXG4gIHNldE91dHB1dChvdXRwdXQpIHtcbiAgICBjb25zdCBuZXdPdXRwdXQgPSB0aGlzLnRvS2VybmVsT3V0cHV0KG91dHB1dCk7XG4gICAgaWYgKHRoaXMucHJvZ3JhbSkge1xuICAgICAgaWYgKCF0aGlzLmR5bmFtaWNPdXRwdXQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdSZXNpemluZyBhIGtlcm5lbCB3aXRoIGR5bmFtaWNPdXRwdXQ6IGZhbHNlIGlzIG5vdCBwb3NzaWJsZScpO1xuICAgICAgfVxuICAgICAgY29uc3QgbmV3VGhyZWFkRGltID0gW25ld091dHB1dFswXSwgbmV3T3V0cHV0WzFdIHx8IDEsIG5ld091dHB1dFsyXSB8fCAxXTtcbiAgICAgIGNvbnN0IG5ld1RleFNpemUgPSB1dGlscy5nZXRLZXJuZWxUZXh0dXJlU2l6ZSh7XG4gICAgICAgIG9wdGltaXplRmxvYXRNZW1vcnk6IHRoaXMub3B0aW1pemVGbG9hdE1lbW9yeSxcbiAgICAgICAgcHJlY2lzaW9uOiB0aGlzLnByZWNpc2lvbixcbiAgICAgIH0sIG5ld1RocmVhZERpbSk7XG4gICAgICBjb25zdCBvbGRUZXhTaXplID0gdGhpcy50ZXhTaXplO1xuICAgICAgaWYgKG9sZFRleFNpemUpIHtcbiAgICAgICAgY29uc3Qgb2xkUHJlY2lzaW9uID0gdGhpcy5nZXRWYXJpYWJsZVByZWNpc2lvblN0cmluZyhvbGRUZXhTaXplLCB0aGlzLnRhY3RpYyk7XG4gICAgICAgIGNvbnN0IG5ld1ByZWNpc2lvbiA9IHRoaXMuZ2V0VmFyaWFibGVQcmVjaXNpb25TdHJpbmcobmV3VGV4U2l6ZSwgdGhpcy50YWN0aWMpO1xuICAgICAgICBpZiAob2xkUHJlY2lzaW9uICE9PSBuZXdQcmVjaXNpb24pIHtcbiAgICAgICAgICBpZiAodGhpcy5kZWJ1Zykge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdQcmVjaXNpb24gcmVxdWlyZW1lbnQgY2hhbmdlZCwgYXNraW5nIEdQVSBpbnN0YW5jZSB0byByZWNvbXBpbGUnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5zd2l0Y2hLZXJuZWxzKHtcbiAgICAgICAgICAgIHR5cGU6ICdvdXRwdXRQcmVjaXNpb25NaXNtYXRjaCcsXG4gICAgICAgICAgICBwcmVjaXNpb246IG5ld1ByZWNpc2lvbixcbiAgICAgICAgICAgIG5lZWRlZDogb3V0cHV0XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLm91dHB1dCA9IG5ld091dHB1dDtcbiAgICAgIHRoaXMudGhyZWFkRGltID0gbmV3VGhyZWFkRGltO1xuICAgICAgdGhpcy50ZXhTaXplID0gbmV3VGV4U2l6ZTtcbiAgICAgIGNvbnN0IHsgY29udGV4dDogZ2wgfSA9IHRoaXM7XG4gICAgICBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIHRoaXMuZnJhbWVidWZmZXIpO1xuICAgICAgdGhpcy51cGRhdGVNYXhUZXhTaXplKCk7XG4gICAgICB0aGlzLmZyYW1lYnVmZmVyLndpZHRoID0gdGhpcy50ZXhTaXplWzBdO1xuICAgICAgdGhpcy5mcmFtZWJ1ZmZlci5oZWlnaHQgPSB0aGlzLnRleFNpemVbMV07XG4gICAgICBnbC52aWV3cG9ydCgwLCAwLCB0aGlzLm1heFRleFNpemVbMF0sIHRoaXMubWF4VGV4U2l6ZVsxXSk7XG4gICAgICB0aGlzLmNhbnZhcy53aWR0aCA9IHRoaXMubWF4VGV4U2l6ZVswXTtcbiAgICAgIHRoaXMuY2FudmFzLmhlaWdodCA9IHRoaXMubWF4VGV4U2l6ZVsxXTtcbiAgICAgIGlmICh0aGlzLnRleHR1cmUpIHtcbiAgICAgICAgdGhpcy50ZXh0dXJlLmRlbGV0ZSgpO1xuICAgICAgfVxuICAgICAgdGhpcy50ZXh0dXJlID0gbnVsbDtcbiAgICAgIHRoaXMuX3NldHVwT3V0cHV0VGV4dHVyZSgpO1xuICAgICAgaWYgKHRoaXMubWFwcGVkVGV4dHVyZXMgJiYgdGhpcy5tYXBwZWRUZXh0dXJlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5tYXBwZWRUZXh0dXJlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHRoaXMubWFwcGVkVGV4dHVyZXNbaV0uZGVsZXRlKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tYXBwZWRUZXh0dXJlcyA9IG51bGw7XG4gICAgICAgIHRoaXMuX3NldHVwU3ViT3V0cHV0VGV4dHVyZXMoKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5vdXRwdXQgPSBuZXdPdXRwdXQ7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHJlbmRlclZhbHVlcygpIHtcbiAgICByZXR1cm4gdGhpcy5mb3JtYXRWYWx1ZXMoXG4gICAgICB0aGlzLnRyYW5zZmVyVmFsdWVzKCksXG4gICAgICB0aGlzLm91dHB1dFswXSxcbiAgICAgIHRoaXMub3V0cHV0WzFdLFxuICAgICAgdGhpcy5vdXRwdXRbMl1cbiAgICApO1xuICB9XG4gIHN3aXRjaEtlcm5lbHMocmVhc29uKSB7XG4gICAgaWYgKHRoaXMuc3dpdGNoaW5nS2VybmVscykge1xuICAgICAgdGhpcy5zd2l0Y2hpbmdLZXJuZWxzLnB1c2gocmVhc29uKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zd2l0Y2hpbmdLZXJuZWxzID0gW3JlYXNvbl07XG4gICAgfVxuICB9XG4gIGdldFZhcmlhYmxlUHJlY2lzaW9uU3RyaW5nKHRleHR1cmVTaXplID0gdGhpcy50ZXhTaXplLCB0YWN0aWMgPSB0aGlzLnRhY3RpYywgaXNJbnQgPSBmYWxzZSkge1xuICAgIGlmICghdGFjdGljKSB7XG4gICAgICBpZiAoIXRoaXMuY29uc3RydWN0b3IuZmVhdHVyZXMuaXNTcGVlZFRhY3RpY1N1cHBvcnRlZCkgcmV0dXJuICdoaWdocCc7XG4gICAgICBjb25zdCBsb3cgPSB0aGlzLmNvbnN0cnVjdG9yLmZlYXR1cmVzW2lzSW50ID8gJ2xvd0ludFByZWNpc2lvbicgOiAnbG93RmxvYXRQcmVjaXNpb24nXTtcbiAgICAgIGNvbnN0IG1lZGl1bSA9IHRoaXMuY29uc3RydWN0b3IuZmVhdHVyZXNbaXNJbnQgPyAnbWVkaXVtSW50UHJlY2lzaW9uJyA6ICdtZWRpdW1GbG9hdFByZWNpc2lvbiddO1xuICAgICAgY29uc3QgaGlnaCA9IHRoaXMuY29uc3RydWN0b3IuZmVhdHVyZXNbaXNJbnQgPyAnaGlnaEludFByZWNpc2lvbicgOiAnaGlnaEZsb2F0UHJlY2lzaW9uJ107XG4gICAgICBjb25zdCByZXF1aXJlZFNpemUgPSBNYXRoLmxvZzIodGV4dHVyZVNpemVbMF0gKiB0ZXh0dXJlU2l6ZVsxXSk7XG4gICAgICBpZiAocmVxdWlyZWRTaXplIDw9IGxvdy5yYW5nZU1heCkge1xuICAgICAgICByZXR1cm4gJ2xvd3AnO1xuICAgICAgfSBlbHNlIGlmIChyZXF1aXJlZFNpemUgPD0gbWVkaXVtLnJhbmdlTWF4KSB7XG4gICAgICAgIHJldHVybiAnbWVkaXVtcCc7XG4gICAgICB9IGVsc2UgaWYgKHJlcXVpcmVkU2l6ZSA8PSBoaWdoLnJhbmdlTWF4KSB7XG4gICAgICAgIHJldHVybiAnaGlnaHAnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgcmVxdWlyZWQgc2l6ZSBleGNlZWRzIHRoYXQgb2YgdGhlIGFiaWxpdHkgb2YgeW91ciBzeXN0ZW1gKTtcbiAgICAgIH1cbiAgICB9XG4gICAgc3dpdGNoICh0YWN0aWMpIHtcbiAgICAgIGNhc2UgJ3NwZWVkJzpcbiAgICAgICAgcmV0dXJuICdsb3dwJztcbiAgICAgIGNhc2UgJ2JhbGFuY2VkJzpcbiAgICAgICAgcmV0dXJuICdtZWRpdW1wJztcbiAgICAgIGNhc2UgJ3ByZWNpc2lvbic6XG4gICAgICAgIHJldHVybiAnaGlnaHAnO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIHRhY3RpYyBcIiR7dGFjdGljfVwiIHVzZSBcInNwZWVkXCIsIFwiYmFsYW5jZWRcIiwgXCJwcmVjaXNpb25cIiwgb3IgZW1wdHkgZm9yIGF1dG9gKTtcbiAgICB9XG4gIH1cblxuICB1cGRhdGVUZXh0dXJlQXJndW1lbnRSZWZzKGtlcm5lbFZhbHVlLCBhcmcpIHtcbiAgICBpZiAoIXRoaXMuaW1tdXRhYmxlKSByZXR1cm47XG4gICAgaWYgKHRoaXMudGV4dHVyZS50ZXh0dXJlID09PSBhcmcudGV4dHVyZSkge1xuICAgICAgY29uc3QgeyBwcmV2QXJnIH0gPSBrZXJuZWxWYWx1ZTtcbiAgICAgIGlmIChwcmV2QXJnKSB7XG4gICAgICAgIGlmIChwcmV2QXJnLnRleHR1cmUuX3JlZnMgPT09IDEpIHtcbiAgICAgICAgICB0aGlzLnRleHR1cmUuZGVsZXRlKCk7XG4gICAgICAgICAgdGhpcy50ZXh0dXJlID0gcHJldkFyZy5jbG9uZSgpO1xuICAgICAgICAgIHRoaXMuX3RleHR1cmVTd2l0Y2hlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcHJldkFyZy5kZWxldGUoKTtcbiAgICAgIH1cbiAgICAgIGtlcm5lbFZhbHVlLnByZXZBcmcgPSBhcmcuY2xvbmUoKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMubWFwcGVkVGV4dHVyZXMgJiYgdGhpcy5tYXBwZWRUZXh0dXJlcy5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCB7IG1hcHBlZFRleHR1cmVzIH0gPSB0aGlzO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXBwZWRUZXh0dXJlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBtYXBwZWRUZXh0dXJlID0gbWFwcGVkVGV4dHVyZXNbaV07XG4gICAgICAgIGlmIChtYXBwZWRUZXh0dXJlLnRleHR1cmUgPT09IGFyZy50ZXh0dXJlKSB7XG4gICAgICAgICAgY29uc3QgeyBwcmV2QXJnIH0gPSBrZXJuZWxWYWx1ZTtcbiAgICAgICAgICBpZiAocHJldkFyZykge1xuICAgICAgICAgICAgaWYgKHByZXZBcmcudGV4dHVyZS5fcmVmcyA9PT0gMSkge1xuICAgICAgICAgICAgICBtYXBwZWRUZXh0dXJlLmRlbGV0ZSgpO1xuICAgICAgICAgICAgICBtYXBwZWRUZXh0dXJlc1tpXSA9IHByZXZBcmcuY2xvbmUoKTtcbiAgICAgICAgICAgICAgdGhpcy5fbWFwcGVkVGV4dHVyZVN3aXRjaGVkW2ldID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHByZXZBcmcuZGVsZXRlKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGtlcm5lbFZhbHVlLnByZXZBcmcgPSBhcmcuY2xvbmUoKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBvbkFjdGl2YXRlKHByZXZpb3VzS2VybmVsKSB7XG4gICAgdGhpcy5fdGV4dHVyZVN3aXRjaGVkID0gdHJ1ZTtcbiAgICB0aGlzLnRleHR1cmUgPSBwcmV2aW91c0tlcm5lbC50ZXh0dXJlO1xuICAgIGlmICh0aGlzLm1hcHBlZFRleHR1cmVzKSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubWFwcGVkVGV4dHVyZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy5fbWFwcGVkVGV4dHVyZVN3aXRjaGVkW2ldID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHRoaXMubWFwcGVkVGV4dHVyZXMgPSBwcmV2aW91c0tlcm5lbC5tYXBwZWRUZXh0dXJlcztcbiAgICB9XG4gIH1cblxuICBpbml0Q2FudmFzKCkge31cbn1cblxuY29uc3QgdHlwZU1hcCA9IHtcbiAgaW50OiAnSW50ZWdlcicsXG4gIGZsb2F0OiAnTnVtYmVyJyxcbiAgdmVjMjogJ0FycmF5KDIpJyxcbiAgdmVjMzogJ0FycmF5KDMpJyxcbiAgdmVjNDogJ0FycmF5KDQpJyxcbn07XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBHTEtlcm5lbFxufTtcbn0se1wiLi4vLi4vdXRpbHNcIjoxMTQsXCIuLi9rZXJuZWxcIjozNixcIi4vdGV4dHVyZS9hcnJheS0yLWZsb2F0XCI6MTYsXCIuL3RleHR1cmUvYXJyYXktMi1mbG9hdC0yZFwiOjE0LFwiLi90ZXh0dXJlL2FycmF5LTItZmxvYXQtM2RcIjoxNSxcIi4vdGV4dHVyZS9hcnJheS0zLWZsb2F0XCI6MTksXCIuL3RleHR1cmUvYXJyYXktMy1mbG9hdC0yZFwiOjE3LFwiLi90ZXh0dXJlL2FycmF5LTMtZmxvYXQtM2RcIjoxOCxcIi4vdGV4dHVyZS9hcnJheS00LWZsb2F0XCI6MjIsXCIuL3RleHR1cmUvYXJyYXktNC1mbG9hdC0yZFwiOjIwLFwiLi90ZXh0dXJlL2FycmF5LTQtZmxvYXQtM2RcIjoyMSxcIi4vdGV4dHVyZS9mbG9hdFwiOjI1LFwiLi90ZXh0dXJlL2Zsb2F0LTJkXCI6MjMsXCIuL3RleHR1cmUvZmxvYXQtM2RcIjoyNCxcIi4vdGV4dHVyZS9ncmFwaGljYWxcIjoyNixcIi4vdGV4dHVyZS9tZW1vcnktb3B0aW1pemVkXCI6MzAsXCIuL3RleHR1cmUvbWVtb3J5LW9wdGltaXplZC0yZFwiOjI4LFwiLi90ZXh0dXJlL21lbW9yeS1vcHRpbWl6ZWQtM2RcIjoyOSxcIi4vdGV4dHVyZS91bnNpZ25lZFwiOjMzLFwiLi90ZXh0dXJlL3Vuc2lnbmVkLTJkXCI6MzEsXCIuL3RleHR1cmUvdW5zaWduZWQtM2RcIjozMn1dLDE0OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbmNvbnN0IHsgdXRpbHMgfSA9IHJlcXVpcmUoJy4uLy4uLy4uL3V0aWxzJyk7XG5jb25zdCB7IEdMVGV4dHVyZUZsb2F0IH0gPSByZXF1aXJlKCcuL2Zsb2F0Jyk7XG5cbmNsYXNzIEdMVGV4dHVyZUFycmF5MkZsb2F0MkQgZXh0ZW5kcyBHTFRleHR1cmVGbG9hdCB7XG4gIGNvbnN0cnVjdG9yKHNldHRpbmdzKSB7XG4gICAgc3VwZXIoc2V0dGluZ3MpO1xuICAgIHRoaXMudHlwZSA9ICdBcnJheVRleHR1cmUoMiknO1xuICB9XG4gIHRvQXJyYXkoKSB7XG4gICAgcmV0dXJuIHV0aWxzLmVyZWN0MkRBcnJheTIodGhpcy5yZW5kZXJWYWx1ZXMoKSwgdGhpcy5vdXRwdXRbMF0sIHRoaXMub3V0cHV0WzFdKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgR0xUZXh0dXJlQXJyYXkyRmxvYXQyRFxufTtcbn0se1wiLi4vLi4vLi4vdXRpbHNcIjoxMTQsXCIuL2Zsb2F0XCI6MjV9XSwxNTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5jb25zdCB7IHV0aWxzIH0gPSByZXF1aXJlKCcuLi8uLi8uLi91dGlscycpO1xuY29uc3QgeyBHTFRleHR1cmVGbG9hdCB9ID0gcmVxdWlyZSgnLi9mbG9hdCcpO1xuXG5jbGFzcyBHTFRleHR1cmVBcnJheTJGbG9hdDNEIGV4dGVuZHMgR0xUZXh0dXJlRmxvYXQge1xuICBjb25zdHJ1Y3RvcihzZXR0aW5ncykge1xuICAgIHN1cGVyKHNldHRpbmdzKTtcbiAgICB0aGlzLnR5cGUgPSAnQXJyYXlUZXh0dXJlKDIpJztcbiAgfVxuICB0b0FycmF5KCkge1xuICAgIHJldHVybiB1dGlscy5lcmVjdDNEQXJyYXkyKHRoaXMucmVuZGVyVmFsdWVzKCksIHRoaXMub3V0cHV0WzBdLCB0aGlzLm91dHB1dFsxXSwgdGhpcy5vdXRwdXRbMl0pO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBHTFRleHR1cmVBcnJheTJGbG9hdDNEXG59O1xufSx7XCIuLi8uLi8uLi91dGlsc1wiOjExNCxcIi4vZmxvYXRcIjoyNX1dLDE2OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbmNvbnN0IHsgdXRpbHMgfSA9IHJlcXVpcmUoJy4uLy4uLy4uL3V0aWxzJyk7XG5jb25zdCB7IEdMVGV4dHVyZUZsb2F0IH0gPSByZXF1aXJlKCcuL2Zsb2F0Jyk7XG5cbmNsYXNzIEdMVGV4dHVyZUFycmF5MkZsb2F0IGV4dGVuZHMgR0xUZXh0dXJlRmxvYXQge1xuICBjb25zdHJ1Y3RvcihzZXR0aW5ncykge1xuICAgIHN1cGVyKHNldHRpbmdzKTtcbiAgICB0aGlzLnR5cGUgPSAnQXJyYXlUZXh0dXJlKDIpJztcbiAgfVxuICB0b0FycmF5KCkge1xuICAgIHJldHVybiB1dGlscy5lcmVjdEFycmF5Mih0aGlzLnJlbmRlclZhbHVlcygpLCB0aGlzLm91dHB1dFswXSwgdGhpcy5vdXRwdXRbMV0pO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBHTFRleHR1cmVBcnJheTJGbG9hdFxufTtcbn0se1wiLi4vLi4vLi4vdXRpbHNcIjoxMTQsXCIuL2Zsb2F0XCI6MjV9XSwxNzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5jb25zdCB7IHV0aWxzIH0gPSByZXF1aXJlKCcuLi8uLi8uLi91dGlscycpO1xuY29uc3QgeyBHTFRleHR1cmVGbG9hdCB9ID0gcmVxdWlyZSgnLi9mbG9hdCcpO1xuXG5jbGFzcyBHTFRleHR1cmVBcnJheTNGbG9hdDJEIGV4dGVuZHMgR0xUZXh0dXJlRmxvYXQge1xuICBjb25zdHJ1Y3RvcihzZXR0aW5ncykge1xuICAgIHN1cGVyKHNldHRpbmdzKTtcbiAgICB0aGlzLnR5cGUgPSAnQXJyYXlUZXh0dXJlKDMpJztcbiAgfVxuICB0b0FycmF5KCkge1xuICAgIHJldHVybiB1dGlscy5lcmVjdDJEQXJyYXkzKHRoaXMucmVuZGVyVmFsdWVzKCksIHRoaXMub3V0cHV0WzBdLCB0aGlzLm91dHB1dFsxXSk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIEdMVGV4dHVyZUFycmF5M0Zsb2F0MkRcbn07XG59LHtcIi4uLy4uLy4uL3V0aWxzXCI6MTE0LFwiLi9mbG9hdFwiOjI1fV0sMTg6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuY29uc3QgeyB1dGlscyB9ID0gcmVxdWlyZSgnLi4vLi4vLi4vdXRpbHMnKTtcbmNvbnN0IHsgR0xUZXh0dXJlRmxvYXQgfSA9IHJlcXVpcmUoJy4vZmxvYXQnKTtcblxuY2xhc3MgR0xUZXh0dXJlQXJyYXkzRmxvYXQzRCBleHRlbmRzIEdMVGV4dHVyZUZsb2F0IHtcbiAgY29uc3RydWN0b3Ioc2V0dGluZ3MpIHtcbiAgICBzdXBlcihzZXR0aW5ncyk7XG4gICAgdGhpcy50eXBlID0gJ0FycmF5VGV4dHVyZSgzKSc7XG4gIH1cbiAgdG9BcnJheSgpIHtcbiAgICByZXR1cm4gdXRpbHMuZXJlY3QzREFycmF5Myh0aGlzLnJlbmRlclZhbHVlcygpLCB0aGlzLm91dHB1dFswXSwgdGhpcy5vdXRwdXRbMV0sIHRoaXMub3V0cHV0WzJdKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgR0xUZXh0dXJlQXJyYXkzRmxvYXQzRFxufTtcbn0se1wiLi4vLi4vLi4vdXRpbHNcIjoxMTQsXCIuL2Zsb2F0XCI6MjV9XSwxOTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5jb25zdCB7IHV0aWxzIH0gPSByZXF1aXJlKCcuLi8uLi8uLi91dGlscycpO1xuY29uc3QgeyBHTFRleHR1cmVGbG9hdCB9ID0gcmVxdWlyZSgnLi9mbG9hdCcpO1xuXG5jbGFzcyBHTFRleHR1cmVBcnJheTNGbG9hdCBleHRlbmRzIEdMVGV4dHVyZUZsb2F0IHtcbiAgY29uc3RydWN0b3Ioc2V0dGluZ3MpIHtcbiAgICBzdXBlcihzZXR0aW5ncyk7XG4gICAgdGhpcy50eXBlID0gJ0FycmF5VGV4dHVyZSgzKSc7XG4gIH1cbiAgdG9BcnJheSgpIHtcbiAgICByZXR1cm4gdXRpbHMuZXJlY3RBcnJheTModGhpcy5yZW5kZXJWYWx1ZXMoKSwgdGhpcy5vdXRwdXRbMF0pO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBHTFRleHR1cmVBcnJheTNGbG9hdFxufTtcbn0se1wiLi4vLi4vLi4vdXRpbHNcIjoxMTQsXCIuL2Zsb2F0XCI6MjV9XSwyMDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5jb25zdCB7IHV0aWxzIH0gPSByZXF1aXJlKCcuLi8uLi8uLi91dGlscycpO1xuY29uc3QgeyBHTFRleHR1cmVGbG9hdCB9ID0gcmVxdWlyZSgnLi9mbG9hdCcpO1xuXG5jbGFzcyBHTFRleHR1cmVBcnJheTRGbG9hdDJEIGV4dGVuZHMgR0xUZXh0dXJlRmxvYXQge1xuICBjb25zdHJ1Y3RvcihzZXR0aW5ncykge1xuICAgIHN1cGVyKHNldHRpbmdzKTtcbiAgICB0aGlzLnR5cGUgPSAnQXJyYXlUZXh0dXJlKDQpJztcbiAgfVxuICB0b0FycmF5KCkge1xuICAgIHJldHVybiB1dGlscy5lcmVjdDJEQXJyYXk0KHRoaXMucmVuZGVyVmFsdWVzKCksIHRoaXMub3V0cHV0WzBdLCB0aGlzLm91dHB1dFsxXSk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIEdMVGV4dHVyZUFycmF5NEZsb2F0MkRcbn07XG59LHtcIi4uLy4uLy4uL3V0aWxzXCI6MTE0LFwiLi9mbG9hdFwiOjI1fV0sMjE6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuY29uc3QgeyB1dGlscyB9ID0gcmVxdWlyZSgnLi4vLi4vLi4vdXRpbHMnKTtcbmNvbnN0IHsgR0xUZXh0dXJlRmxvYXQgfSA9IHJlcXVpcmUoJy4vZmxvYXQnKTtcblxuY2xhc3MgR0xUZXh0dXJlQXJyYXk0RmxvYXQzRCBleHRlbmRzIEdMVGV4dHVyZUZsb2F0IHtcbiAgY29uc3RydWN0b3Ioc2V0dGluZ3MpIHtcbiAgICBzdXBlcihzZXR0aW5ncyk7XG4gICAgdGhpcy50eXBlID0gJ0FycmF5VGV4dHVyZSg0KSc7XG4gIH1cbiAgdG9BcnJheSgpIHtcbiAgICByZXR1cm4gdXRpbHMuZXJlY3QzREFycmF5NCh0aGlzLnJlbmRlclZhbHVlcygpLCB0aGlzLm91dHB1dFswXSwgdGhpcy5vdXRwdXRbMV0sIHRoaXMub3V0cHV0WzJdKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgR0xUZXh0dXJlQXJyYXk0RmxvYXQzRFxufTtcbn0se1wiLi4vLi4vLi4vdXRpbHNcIjoxMTQsXCIuL2Zsb2F0XCI6MjV9XSwyMjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5jb25zdCB7IHV0aWxzIH0gPSByZXF1aXJlKCcuLi8uLi8uLi91dGlscycpO1xuY29uc3QgeyBHTFRleHR1cmVGbG9hdCB9ID0gcmVxdWlyZSgnLi9mbG9hdCcpO1xuXG5jbGFzcyBHTFRleHR1cmVBcnJheTRGbG9hdCBleHRlbmRzIEdMVGV4dHVyZUZsb2F0IHtcbiAgY29uc3RydWN0b3Ioc2V0dGluZ3MpIHtcbiAgICBzdXBlcihzZXR0aW5ncyk7XG4gICAgdGhpcy50eXBlID0gJ0FycmF5VGV4dHVyZSg0KSc7XG4gIH1cbiAgdG9BcnJheSgpIHtcbiAgICByZXR1cm4gdXRpbHMuZXJlY3RBcnJheTQodGhpcy5yZW5kZXJWYWx1ZXMoKSwgdGhpcy5vdXRwdXRbMF0pO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBHTFRleHR1cmVBcnJheTRGbG9hdFxufTtcbn0se1wiLi4vLi4vLi4vdXRpbHNcIjoxMTQsXCIuL2Zsb2F0XCI6MjV9XSwyMzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5jb25zdCB7IHV0aWxzIH0gPSByZXF1aXJlKCcuLi8uLi8uLi91dGlscycpO1xuY29uc3QgeyBHTFRleHR1cmVGbG9hdCB9ID0gcmVxdWlyZSgnLi9mbG9hdCcpO1xuXG5jbGFzcyBHTFRleHR1cmVGbG9hdDJEIGV4dGVuZHMgR0xUZXh0dXJlRmxvYXQge1xuICBjb25zdHJ1Y3RvcihzZXR0aW5ncykge1xuICAgIHN1cGVyKHNldHRpbmdzKTtcbiAgICB0aGlzLnR5cGUgPSAnQXJyYXlUZXh0dXJlKDEpJztcbiAgfVxuICB0b0FycmF5KCkge1xuICAgIHJldHVybiB1dGlscy5lcmVjdDJERmxvYXQodGhpcy5yZW5kZXJWYWx1ZXMoKSwgdGhpcy5vdXRwdXRbMF0sIHRoaXMub3V0cHV0WzFdKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgR0xUZXh0dXJlRmxvYXQyRFxufTtcbn0se1wiLi4vLi4vLi4vdXRpbHNcIjoxMTQsXCIuL2Zsb2F0XCI6MjV9XSwyNDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5jb25zdCB7IHV0aWxzIH0gPSByZXF1aXJlKCcuLi8uLi8uLi91dGlscycpO1xuY29uc3QgeyBHTFRleHR1cmVGbG9hdCB9ID0gcmVxdWlyZSgnLi9mbG9hdCcpO1xuXG5jbGFzcyBHTFRleHR1cmVGbG9hdDNEIGV4dGVuZHMgR0xUZXh0dXJlRmxvYXQge1xuICBjb25zdHJ1Y3RvcihzZXR0aW5ncykge1xuICAgIHN1cGVyKHNldHRpbmdzKTtcbiAgICB0aGlzLnR5cGUgPSAnQXJyYXlUZXh0dXJlKDEpJztcbiAgfVxuICB0b0FycmF5KCkge1xuICAgIHJldHVybiB1dGlscy5lcmVjdDNERmxvYXQodGhpcy5yZW5kZXJWYWx1ZXMoKSwgdGhpcy5vdXRwdXRbMF0sIHRoaXMub3V0cHV0WzFdLCB0aGlzLm91dHB1dFsyXSk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIEdMVGV4dHVyZUZsb2F0M0Rcbn07XG59LHtcIi4uLy4uLy4uL3V0aWxzXCI6MTE0LFwiLi9mbG9hdFwiOjI1fV0sMjU6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuY29uc3QgeyB1dGlscyB9ID0gcmVxdWlyZSgnLi4vLi4vLi4vdXRpbHMnKTtcbmNvbnN0IHsgR0xUZXh0dXJlIH0gPSByZXF1aXJlKCcuL2luZGV4Jyk7XG5cbmNsYXNzIEdMVGV4dHVyZUZsb2F0IGV4dGVuZHMgR0xUZXh0dXJlIHtcbiAgZ2V0IHRleHR1cmVUeXBlKCkge1xuICAgIHJldHVybiB0aGlzLmNvbnRleHQuRkxPQVQ7XG4gIH1cbiAgY29uc3RydWN0b3Ioc2V0dGluZ3MpIHtcbiAgICBzdXBlcihzZXR0aW5ncyk7XG4gICAgdGhpcy50eXBlID0gJ0FycmF5VGV4dHVyZSgxKSc7XG4gIH1cbiAgcmVuZGVyUmF3T3V0cHV0KCkge1xuICAgIGNvbnN0IGdsID0gdGhpcy5jb250ZXh0O1xuICAgIGNvbnN0IHNpemUgPSB0aGlzLnNpemU7XG4gICAgZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCB0aGlzLmZyYW1lYnVmZmVyKCkpO1xuICAgIGdsLmZyYW1lYnVmZmVyVGV4dHVyZTJEKFxuICAgICAgZ2wuRlJBTUVCVUZGRVIsXG4gICAgICBnbC5DT0xPUl9BVFRBQ0hNRU5UMCxcbiAgICAgIGdsLlRFWFRVUkVfMkQsXG4gICAgICB0aGlzLnRleHR1cmUsXG4gICAgICAwXG4gICAgKTtcbiAgICBjb25zdCByZXN1bHQgPSBuZXcgRmxvYXQzMkFycmF5KHNpemVbMF0gKiBzaXplWzFdICogNCk7XG4gICAgZ2wucmVhZFBpeGVscygwLCAwLCBzaXplWzBdLCBzaXplWzFdLCBnbC5SR0JBLCBnbC5GTE9BVCwgcmVzdWx0KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIHJlbmRlclZhbHVlcygpIHtcbiAgICBpZiAodGhpcy5fZGVsZXRlZCkgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuIHRoaXMucmVuZGVyUmF3T3V0cHV0KCk7XG4gIH1cbiAgdG9BcnJheSgpIHtcbiAgICByZXR1cm4gdXRpbHMuZXJlY3RGbG9hdCh0aGlzLnJlbmRlclZhbHVlcygpLCB0aGlzLm91dHB1dFswXSk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIEdMVGV4dHVyZUZsb2F0XG59O1xufSx7XCIuLi8uLi8uLi91dGlsc1wiOjExNCxcIi4vaW5kZXhcIjoyN31dLDI2OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbmNvbnN0IHsgR0xUZXh0dXJlVW5zaWduZWQgfSA9IHJlcXVpcmUoJy4vdW5zaWduZWQnKTtcblxuY2xhc3MgR0xUZXh0dXJlR3JhcGhpY2FsIGV4dGVuZHMgR0xUZXh0dXJlVW5zaWduZWQge1xuICBjb25zdHJ1Y3RvcihzZXR0aW5ncykge1xuICAgIHN1cGVyKHNldHRpbmdzKTtcbiAgICB0aGlzLnR5cGUgPSAnQXJyYXlUZXh0dXJlKDQpJztcbiAgfVxuICB0b0FycmF5KCkge1xuICAgIHJldHVybiB0aGlzLnJlbmRlclZhbHVlcygpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBHTFRleHR1cmVHcmFwaGljYWxcbn07XG59LHtcIi4vdW5zaWduZWRcIjozM31dLDI3OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbmNvbnN0IHsgVGV4dHVyZSB9ID0gcmVxdWlyZSgnLi4vLi4vLi4vdGV4dHVyZScpO1xuXG5jbGFzcyBHTFRleHR1cmUgZXh0ZW5kcyBUZXh0dXJlIHtcbiAgZ2V0IHRleHR1cmVUeXBlKCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgXCJ0ZXh0dXJlVHlwZVwiIG5vdCBpbXBsZW1lbnRlZCBvbiAkeyB0aGlzLm5hbWUgfWApO1xuICB9XG5cbiAgY2xvbmUoKSB7XG4gICAgcmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKHRoaXMpO1xuICB9XG5cbiAgYmVmb3JlTXV0YXRlKCkge1xuICAgIGlmICh0aGlzLnRleHR1cmUuX3JlZnMgPiAxKSB7XG4gICAgICB0aGlzLm5ld1RleHR1cmUoKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBjbG9uZVRleHR1cmUoKSB7XG4gICAgdGhpcy50ZXh0dXJlLl9yZWZzLS07XG4gICAgY29uc3QgeyBjb250ZXh0OiBnbCwgc2l6ZSwgdGV4dHVyZSwga2VybmVsIH0gPSB0aGlzO1xuICAgIGlmIChrZXJuZWwuZGVidWcpIHtcbiAgICAgIGNvbnNvbGUud2FybignY2xvbmluZyBpbnRlcm5hbCB0ZXh0dXJlJyk7XG4gICAgfVxuICAgIGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgdGhpcy5mcmFtZWJ1ZmZlcigpKTtcbiAgICBzZWxlY3RUZXh0dXJlKGdsLCB0ZXh0dXJlKTtcbiAgICBnbC5mcmFtZWJ1ZmZlclRleHR1cmUyRChnbC5GUkFNRUJVRkZFUiwgZ2wuQ09MT1JfQVRUQUNITUVOVDAsIGdsLlRFWFRVUkVfMkQsIHRleHR1cmUsIDApO1xuICAgIGNvbnN0IHRhcmdldCA9IGdsLmNyZWF0ZVRleHR1cmUoKTtcbiAgICBzZWxlY3RUZXh0dXJlKGdsLCB0YXJnZXQpO1xuICAgIGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgdGhpcy5pbnRlcm5hbEZvcm1hdCwgc2l6ZVswXSwgc2l6ZVsxXSwgMCwgdGhpcy50ZXh0dXJlRm9ybWF0LCB0aGlzLnRleHR1cmVUeXBlLCBudWxsKTtcbiAgICBnbC5jb3B5VGV4U3ViSW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCAwLCAwLCAwLCAwLCBzaXplWzBdLCBzaXplWzFdKTtcbiAgICB0YXJnZXQuX3JlZnMgPSAxO1xuICAgIHRoaXMudGV4dHVyZSA9IHRhcmdldDtcbiAgfVxuXG4gIG5ld1RleHR1cmUoKSB7XG4gICAgdGhpcy50ZXh0dXJlLl9yZWZzLS07XG4gICAgY29uc3QgZ2wgPSB0aGlzLmNvbnRleHQ7XG4gICAgY29uc3Qgc2l6ZSA9IHRoaXMuc2l6ZTtcbiAgICBjb25zdCBrZXJuZWwgPSB0aGlzLmtlcm5lbDtcbiAgICBpZiAoa2VybmVsLmRlYnVnKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ25ldyBpbnRlcm5hbCB0ZXh0dXJlJyk7XG4gICAgfVxuICAgIGNvbnN0IHRhcmdldCA9IGdsLmNyZWF0ZVRleHR1cmUoKTtcbiAgICBzZWxlY3RUZXh0dXJlKGdsLCB0YXJnZXQpO1xuICAgIGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgdGhpcy5pbnRlcm5hbEZvcm1hdCwgc2l6ZVswXSwgc2l6ZVsxXSwgMCwgdGhpcy50ZXh0dXJlRm9ybWF0LCB0aGlzLnRleHR1cmVUeXBlLCBudWxsKTtcbiAgICB0YXJnZXQuX3JlZnMgPSAxO1xuICAgIHRoaXMudGV4dHVyZSA9IHRhcmdldDtcbiAgfVxuXG4gIGNsZWFyKCkge1xuICAgIGlmICh0aGlzLnRleHR1cmUuX3JlZnMpIHtcbiAgICAgIHRoaXMudGV4dHVyZS5fcmVmcy0tO1xuICAgICAgY29uc3QgZ2wgPSB0aGlzLmNvbnRleHQ7XG4gICAgICBjb25zdCB0YXJnZXQgPSB0aGlzLnRleHR1cmUgPSBnbC5jcmVhdGVUZXh0dXJlKCk7XG4gICAgICBzZWxlY3RUZXh0dXJlKGdsLCB0YXJnZXQpO1xuICAgICAgY29uc3Qgc2l6ZSA9IHRoaXMuc2l6ZTtcbiAgICAgIHRhcmdldC5fcmVmcyA9IDE7XG4gICAgICBnbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIHRoaXMuaW50ZXJuYWxGb3JtYXQsIHNpemVbMF0sIHNpemVbMV0sIDAsIHRoaXMudGV4dHVyZUZvcm1hdCwgdGhpcy50ZXh0dXJlVHlwZSwgbnVsbCk7XG4gICAgfVxuICAgIGNvbnN0IHsgY29udGV4dDogZ2wsIHRleHR1cmUgfSA9IHRoaXM7XG4gICAgZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCB0aGlzLmZyYW1lYnVmZmVyKCkpO1xuICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRleHR1cmUpO1xuICAgIHNlbGVjdFRleHR1cmUoZ2wsIHRleHR1cmUpO1xuICAgIGdsLmZyYW1lYnVmZmVyVGV4dHVyZTJEKGdsLkZSQU1FQlVGRkVSLCBnbC5DT0xPUl9BVFRBQ0hNRU5UMCwgZ2wuVEVYVFVSRV8yRCwgdGV4dHVyZSwgMCk7XG4gICAgZ2wuY2xlYXJDb2xvcigwLCAwLCAwLCAwKTtcbiAgICBnbC5jbGVhcihnbC5DT0xPUl9CVUZGRVJfQklUIHwgZ2wuREVQVEhfQlVGRkVSX0JJVCk7XG4gIH1cblxuICBkZWxldGUoKSB7XG4gICAgaWYgKHRoaXMuX2RlbGV0ZWQpIHJldHVybjtcbiAgICB0aGlzLl9kZWxldGVkID0gdHJ1ZTtcbiAgICBpZiAodGhpcy50ZXh0dXJlLl9yZWZzKSB7XG4gICAgICB0aGlzLnRleHR1cmUuX3JlZnMtLTtcbiAgICAgIGlmICh0aGlzLnRleHR1cmUuX3JlZnMpIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5jb250ZXh0LmRlbGV0ZVRleHR1cmUodGhpcy50ZXh0dXJlKTtcbiAgfVxuXG4gIGZyYW1lYnVmZmVyKCkge1xuICAgIGlmICghdGhpcy5fZnJhbWVidWZmZXIpIHtcbiAgICAgIHRoaXMuX2ZyYW1lYnVmZmVyID0gdGhpcy5rZXJuZWwuZ2V0UmF3VmFsdWVGcmFtZWJ1ZmZlcih0aGlzLnNpemVbMF0sIHRoaXMuc2l6ZVsxXSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9mcmFtZWJ1ZmZlcjtcbiAgfVxufVxuXG5mdW5jdGlvbiBzZWxlY3RUZXh0dXJlKGdsLCB0ZXh0dXJlKSB7XG4gIGdsLmFjdGl2ZVRleHR1cmUoZ2wuVEVYVFVSRTE1KTtcbiAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGV4dHVyZSk7XG4gIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1MsIGdsLkNMQU1QX1RPX0VER0UpO1xuICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9ULCBnbC5DTEFNUF9UT19FREdFKTtcbiAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01JTl9GSUxURVIsIGdsLk5FQVJFU1QpO1xuICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUFHX0ZJTFRFUiwgZ2wuTkVBUkVTVCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0geyBHTFRleHR1cmUgfTtcbn0se1wiLi4vLi4vLi4vdGV4dHVyZVwiOjExM31dLDI4OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbmNvbnN0IHsgdXRpbHMgfSA9IHJlcXVpcmUoJy4uLy4uLy4uL3V0aWxzJyk7XG5jb25zdCB7IEdMVGV4dHVyZUZsb2F0IH0gPSByZXF1aXJlKCcuL2Zsb2F0Jyk7XG5cbmNsYXNzIEdMVGV4dHVyZU1lbW9yeU9wdGltaXplZDJEIGV4dGVuZHMgR0xUZXh0dXJlRmxvYXQge1xuICBjb25zdHJ1Y3RvcihzZXR0aW5ncykge1xuICAgIHN1cGVyKHNldHRpbmdzKTtcbiAgICB0aGlzLnR5cGUgPSAnTWVtb3J5T3B0aW1pemVkTnVtYmVyVGV4dHVyZSc7XG4gIH1cbiAgdG9BcnJheSgpIHtcbiAgICByZXR1cm4gdXRpbHMuZXJlY3RNZW1vcnlPcHRpbWl6ZWQyREZsb2F0KHRoaXMucmVuZGVyVmFsdWVzKCksIHRoaXMub3V0cHV0WzBdLCB0aGlzLm91dHB1dFsxXSk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIEdMVGV4dHVyZU1lbW9yeU9wdGltaXplZDJEXG59O1xufSx7XCIuLi8uLi8uLi91dGlsc1wiOjExNCxcIi4vZmxvYXRcIjoyNX1dLDI5OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbmNvbnN0IHsgdXRpbHMgfSA9IHJlcXVpcmUoJy4uLy4uLy4uL3V0aWxzJyk7XG5jb25zdCB7IEdMVGV4dHVyZUZsb2F0IH0gPSByZXF1aXJlKCcuL2Zsb2F0Jyk7XG5cbmNsYXNzIEdMVGV4dHVyZU1lbW9yeU9wdGltaXplZDNEIGV4dGVuZHMgR0xUZXh0dXJlRmxvYXQge1xuICBjb25zdHJ1Y3RvcihzZXR0aW5ncykge1xuICAgIHN1cGVyKHNldHRpbmdzKTtcbiAgICB0aGlzLnR5cGUgPSAnTWVtb3J5T3B0aW1pemVkTnVtYmVyVGV4dHVyZSc7XG4gIH1cbiAgdG9BcnJheSgpIHtcbiAgICByZXR1cm4gdXRpbHMuZXJlY3RNZW1vcnlPcHRpbWl6ZWQzREZsb2F0KHRoaXMucmVuZGVyVmFsdWVzKCksIHRoaXMub3V0cHV0WzBdLCB0aGlzLm91dHB1dFsxXSwgdGhpcy5vdXRwdXRbMl0pO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBHTFRleHR1cmVNZW1vcnlPcHRpbWl6ZWQzRFxufTtcbn0se1wiLi4vLi4vLi4vdXRpbHNcIjoxMTQsXCIuL2Zsb2F0XCI6MjV9XSwzMDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5jb25zdCB7IHV0aWxzIH0gPSByZXF1aXJlKCcuLi8uLi8uLi91dGlscycpO1xuY29uc3QgeyBHTFRleHR1cmVGbG9hdCB9ID0gcmVxdWlyZSgnLi9mbG9hdCcpO1xuXG5jbGFzcyBHTFRleHR1cmVNZW1vcnlPcHRpbWl6ZWQgZXh0ZW5kcyBHTFRleHR1cmVGbG9hdCB7XG4gIGNvbnN0cnVjdG9yKHNldHRpbmdzKSB7XG4gICAgc3VwZXIoc2V0dGluZ3MpO1xuICAgIHRoaXMudHlwZSA9ICdNZW1vcnlPcHRpbWl6ZWROdW1iZXJUZXh0dXJlJztcbiAgfVxuICB0b0FycmF5KCkge1xuICAgIHJldHVybiB1dGlscy5lcmVjdE1lbW9yeU9wdGltaXplZEZsb2F0KHRoaXMucmVuZGVyVmFsdWVzKCksIHRoaXMub3V0cHV0WzBdKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgR0xUZXh0dXJlTWVtb3J5T3B0aW1pemVkXG59O1xufSx7XCIuLi8uLi8uLi91dGlsc1wiOjExNCxcIi4vZmxvYXRcIjoyNX1dLDMxOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbmNvbnN0IHsgdXRpbHMgfSA9IHJlcXVpcmUoJy4uLy4uLy4uL3V0aWxzJyk7XG5jb25zdCB7IEdMVGV4dHVyZVVuc2lnbmVkIH0gPSByZXF1aXJlKCcuL3Vuc2lnbmVkJyk7XG5cbmNsYXNzIEdMVGV4dHVyZVVuc2lnbmVkMkQgZXh0ZW5kcyBHTFRleHR1cmVVbnNpZ25lZCB7XG4gIGNvbnN0cnVjdG9yKHNldHRpbmdzKSB7XG4gICAgc3VwZXIoc2V0dGluZ3MpO1xuICAgIHRoaXMudHlwZSA9ICdOdW1iZXJUZXh0dXJlJztcbiAgfVxuICB0b0FycmF5KCkge1xuICAgIHJldHVybiB1dGlscy5lcmVjdDJEUGFja2VkRmxvYXQodGhpcy5yZW5kZXJWYWx1ZXMoKSwgdGhpcy5vdXRwdXRbMF0sIHRoaXMub3V0cHV0WzFdKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgR0xUZXh0dXJlVW5zaWduZWQyRFxufTtcbn0se1wiLi4vLi4vLi4vdXRpbHNcIjoxMTQsXCIuL3Vuc2lnbmVkXCI6MzN9XSwzMjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5jb25zdCB7IHV0aWxzIH0gPSByZXF1aXJlKCcuLi8uLi8uLi91dGlscycpO1xuY29uc3QgeyBHTFRleHR1cmVVbnNpZ25lZCB9ID0gcmVxdWlyZSgnLi91bnNpZ25lZCcpO1xuXG5jbGFzcyBHTFRleHR1cmVVbnNpZ25lZDNEIGV4dGVuZHMgR0xUZXh0dXJlVW5zaWduZWQge1xuICBjb25zdHJ1Y3RvcihzZXR0aW5ncykge1xuICAgIHN1cGVyKHNldHRpbmdzKTtcbiAgICB0aGlzLnR5cGUgPSAnTnVtYmVyVGV4dHVyZSc7XG4gIH1cbiAgdG9BcnJheSgpIHtcbiAgICByZXR1cm4gdXRpbHMuZXJlY3QzRFBhY2tlZEZsb2F0KHRoaXMucmVuZGVyVmFsdWVzKCksIHRoaXMub3V0cHV0WzBdLCB0aGlzLm91dHB1dFsxXSwgdGhpcy5vdXRwdXRbMl0pO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBHTFRleHR1cmVVbnNpZ25lZDNEXG59O1xufSx7XCIuLi8uLi8uLi91dGlsc1wiOjExNCxcIi4vdW5zaWduZWRcIjozM31dLDMzOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbmNvbnN0IHsgdXRpbHMgfSA9IHJlcXVpcmUoJy4uLy4uLy4uL3V0aWxzJyk7XG5jb25zdCB7IEdMVGV4dHVyZSB9ID0gcmVxdWlyZSgnLi9pbmRleCcpO1xuXG5jbGFzcyBHTFRleHR1cmVVbnNpZ25lZCBleHRlbmRzIEdMVGV4dHVyZSB7XG4gIGdldCB0ZXh0dXJlVHlwZSgpIHtcbiAgICByZXR1cm4gdGhpcy5jb250ZXh0LlVOU0lHTkVEX0JZVEU7XG4gIH1cbiAgY29uc3RydWN0b3Ioc2V0dGluZ3MpIHtcbiAgICBzdXBlcihzZXR0aW5ncyk7XG4gICAgdGhpcy50eXBlID0gJ051bWJlclRleHR1cmUnO1xuICB9XG4gIHJlbmRlclJhd091dHB1dCgpIHtcbiAgICBjb25zdCB7IGNvbnRleHQ6IGdsIH0gPSB0aGlzO1xuICAgIGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgdGhpcy5mcmFtZWJ1ZmZlcigpKTtcbiAgICBnbC5mcmFtZWJ1ZmZlclRleHR1cmUyRChcbiAgICAgIGdsLkZSQU1FQlVGRkVSLFxuICAgICAgZ2wuQ09MT1JfQVRUQUNITUVOVDAsXG4gICAgICBnbC5URVhUVVJFXzJELFxuICAgICAgdGhpcy50ZXh0dXJlLFxuICAgICAgMFxuICAgICk7XG4gICAgY29uc3QgcmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5zaXplWzBdICogdGhpcy5zaXplWzFdICogNCk7XG4gICAgZ2wucmVhZFBpeGVscygwLCAwLCB0aGlzLnNpemVbMF0sIHRoaXMuc2l6ZVsxXSwgZ2wuUkdCQSwgZ2wuVU5TSUdORURfQllURSwgcmVzdWx0KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIHJlbmRlclZhbHVlcygpIHtcbiAgICBpZiAodGhpcy5fZGVsZXRlZCkgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuIG5ldyBGbG9hdDMyQXJyYXkodGhpcy5yZW5kZXJSYXdPdXRwdXQoKS5idWZmZXIpO1xuICB9XG4gIHRvQXJyYXkoKSB7XG4gICAgcmV0dXJuIHV0aWxzLmVyZWN0UGFja2VkRmxvYXQodGhpcy5yZW5kZXJWYWx1ZXMoKSwgdGhpcy5vdXRwdXRbMF0pO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBHTFRleHR1cmVVbnNpZ25lZFxufTtcbn0se1wiLi4vLi4vLi4vdXRpbHNcIjoxMTQsXCIuL2luZGV4XCI6Mjd9XSwzNDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5jb25zdCBnZXRDb250ZXh0ID0gcmVxdWlyZSgnZ2wnKTtcbmNvbnN0IHsgV2ViR0xLZXJuZWwgfSA9IHJlcXVpcmUoJy4uL3dlYi1nbC9rZXJuZWwnKTtcbmNvbnN0IHsgZ2xLZXJuZWxTdHJpbmcgfSA9IHJlcXVpcmUoJy4uL2dsL2tlcm5lbC1zdHJpbmcnKTtcblxubGV0IGlzU3VwcG9ydGVkID0gbnVsbDtcbmxldCB0ZXN0Q2FudmFzID0gbnVsbDtcbmxldCB0ZXN0Q29udGV4dCA9IG51bGw7XG5sZXQgdGVzdEV4dGVuc2lvbnMgPSBudWxsO1xubGV0IGZlYXR1cmVzID0gbnVsbDtcblxuY2xhc3MgSGVhZGxlc3NHTEtlcm5lbCBleHRlbmRzIFdlYkdMS2VybmVsIHtcbiAgc3RhdGljIGdldCBpc1N1cHBvcnRlZCgpIHtcbiAgICBpZiAoaXNTdXBwb3J0ZWQgIT09IG51bGwpIHJldHVybiBpc1N1cHBvcnRlZDtcbiAgICB0aGlzLnNldHVwRmVhdHVyZUNoZWNrcygpO1xuICAgIGlzU3VwcG9ydGVkID0gdGVzdENvbnRleHQgIT09IG51bGw7XG4gICAgcmV0dXJuIGlzU3VwcG9ydGVkO1xuICB9XG5cbiAgc3RhdGljIHNldHVwRmVhdHVyZUNoZWNrcygpIHtcbiAgICB0ZXN0Q2FudmFzID0gbnVsbDtcbiAgICB0ZXN0RXh0ZW5zaW9ucyA9IG51bGw7XG4gICAgaWYgKHR5cGVvZiBnZXRDb250ZXh0ICE9PSAnZnVuY3Rpb24nKSByZXR1cm47XG4gICAgdHJ5IHsgXG4gICAgICB0ZXN0Q29udGV4dCA9IGdldENvbnRleHQoMiwgMiwge1xuICAgICAgICBwcmVzZXJ2ZURyYXdpbmdCdWZmZXI6IHRydWVcbiAgICAgIH0pO1xuICAgICAgaWYgKCF0ZXN0Q29udGV4dCB8fCAhdGVzdENvbnRleHQuZ2V0RXh0ZW5zaW9uKSByZXR1cm47XG4gICAgICB0ZXN0RXh0ZW5zaW9ucyA9IHtcbiAgICAgICAgU1RBQ0tHTF9yZXNpemVfZHJhd2luZ2J1ZmZlcjogdGVzdENvbnRleHQuZ2V0RXh0ZW5zaW9uKCdTVEFDS0dMX3Jlc2l6ZV9kcmF3aW5nYnVmZmVyJyksXG4gICAgICAgIFNUQUNLR0xfZGVzdHJveV9jb250ZXh0OiB0ZXN0Q29udGV4dC5nZXRFeHRlbnNpb24oJ1NUQUNLR0xfZGVzdHJveV9jb250ZXh0JyksXG4gICAgICAgIE9FU190ZXh0dXJlX2Zsb2F0OiB0ZXN0Q29udGV4dC5nZXRFeHRlbnNpb24oJ09FU190ZXh0dXJlX2Zsb2F0JyksXG4gICAgICAgIE9FU190ZXh0dXJlX2Zsb2F0X2xpbmVhcjogdGVzdENvbnRleHQuZ2V0RXh0ZW5zaW9uKCdPRVNfdGV4dHVyZV9mbG9hdF9saW5lYXInKSxcbiAgICAgICAgT0VTX2VsZW1lbnRfaW5kZXhfdWludDogdGVzdENvbnRleHQuZ2V0RXh0ZW5zaW9uKCdPRVNfZWxlbWVudF9pbmRleF91aW50JyksXG4gICAgICAgIFdFQkdMX2RyYXdfYnVmZmVyczogdGVzdENvbnRleHQuZ2V0RXh0ZW5zaW9uKCdXRUJHTF9kcmF3X2J1ZmZlcnMnKSxcbiAgICAgICAgV0VCR0xfY29sb3JfYnVmZmVyX2Zsb2F0OiB0ZXN0Q29udGV4dC5nZXRFeHRlbnNpb24oJ1dFQkdMX2NvbG9yX2J1ZmZlcl9mbG9hdCcpLFxuICAgICAgfTtcbiAgICAgIGZlYXR1cmVzID0gdGhpcy5nZXRGZWF0dXJlcygpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGNvbnNvbGUud2FybihlKTtcbiAgICB9XG4gIH1cblxuICBzdGF0aWMgaXNDb250ZXh0TWF0Y2goY29udGV4dCkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gY29udGV4dC5nZXRQYXJhbWV0ZXIoY29udGV4dC5SRU5ERVJFUikgPT09ICdBTkdMRSc7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHN0YXRpYyBnZXRJc1RleHR1cmVGbG9hdCgpIHtcbiAgICByZXR1cm4gQm9vbGVhbih0ZXN0RXh0ZW5zaW9ucy5PRVNfdGV4dHVyZV9mbG9hdCk7XG4gIH1cblxuICBzdGF0aWMgZ2V0SXNEcmF3QnVmZmVycygpIHtcbiAgICByZXR1cm4gQm9vbGVhbih0ZXN0RXh0ZW5zaW9ucy5XRUJHTF9kcmF3X2J1ZmZlcnMpO1xuICB9XG5cbiAgc3RhdGljIGdldENoYW5uZWxDb3VudCgpIHtcbiAgICByZXR1cm4gdGVzdEV4dGVuc2lvbnMuV0VCR0xfZHJhd19idWZmZXJzID9cbiAgICAgIHRlc3RDb250ZXh0LmdldFBhcmFtZXRlcih0ZXN0RXh0ZW5zaW9ucy5XRUJHTF9kcmF3X2J1ZmZlcnMuTUFYX0RSQVdfQlVGRkVSU19XRUJHTCkgOlxuICAgICAgMTtcbiAgfVxuXG4gIHN0YXRpYyBnZXRNYXhUZXh0dXJlU2l6ZSgpIHtcbiAgICByZXR1cm4gdGVzdENvbnRleHQuZ2V0UGFyYW1ldGVyKHRlc3RDb250ZXh0Lk1BWF9URVhUVVJFX1NJWkUpO1xuICB9XG5cbiAgc3RhdGljIGdldCB0ZXN0Q2FudmFzKCkge1xuICAgIHJldHVybiB0ZXN0Q2FudmFzO1xuICB9XG5cbiAgc3RhdGljIGdldCB0ZXN0Q29udGV4dCgpIHtcbiAgICByZXR1cm4gdGVzdENvbnRleHQ7XG4gIH1cblxuICBzdGF0aWMgZ2V0IGZlYXR1cmVzKCkge1xuICAgIHJldHVybiBmZWF0dXJlcztcbiAgfVxuXG4gIGluaXRDYW52YXMoKSB7XG4gICAgcmV0dXJuIHt9O1xuICB9XG5cbiAgaW5pdENvbnRleHQoKSB7XG4gICAgcmV0dXJuIGdldENvbnRleHQoMiwgMiwge1xuICAgICAgcHJlc2VydmVEcmF3aW5nQnVmZmVyOiB0cnVlXG4gICAgfSk7XG4gIH1cblxuICBpbml0RXh0ZW5zaW9ucygpIHtcbiAgICB0aGlzLmV4dGVuc2lvbnMgPSB7XG4gICAgICBTVEFDS0dMX3Jlc2l6ZV9kcmF3aW5nYnVmZmVyOiB0aGlzLmNvbnRleHQuZ2V0RXh0ZW5zaW9uKCdTVEFDS0dMX3Jlc2l6ZV9kcmF3aW5nYnVmZmVyJyksXG4gICAgICBTVEFDS0dMX2Rlc3Ryb3lfY29udGV4dDogdGhpcy5jb250ZXh0LmdldEV4dGVuc2lvbignU1RBQ0tHTF9kZXN0cm95X2NvbnRleHQnKSxcbiAgICAgIE9FU190ZXh0dXJlX2Zsb2F0OiB0aGlzLmNvbnRleHQuZ2V0RXh0ZW5zaW9uKCdPRVNfdGV4dHVyZV9mbG9hdCcpLFxuICAgICAgT0VTX3RleHR1cmVfZmxvYXRfbGluZWFyOiB0aGlzLmNvbnRleHQuZ2V0RXh0ZW5zaW9uKCdPRVNfdGV4dHVyZV9mbG9hdF9saW5lYXInKSxcbiAgICAgIE9FU19lbGVtZW50X2luZGV4X3VpbnQ6IHRoaXMuY29udGV4dC5nZXRFeHRlbnNpb24oJ09FU19lbGVtZW50X2luZGV4X3VpbnQnKSxcbiAgICAgIFdFQkdMX2RyYXdfYnVmZmVyczogdGhpcy5jb250ZXh0LmdldEV4dGVuc2lvbignV0VCR0xfZHJhd19idWZmZXJzJyksXG4gICAgfTtcbiAgfVxuXG4gIGJ1aWxkKCkge1xuICAgIHN1cGVyLmJ1aWxkLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgaWYgKCF0aGlzLmZhbGxiYWNrUmVxdWVzdGVkKSB7XG4gICAgICB0aGlzLmV4dGVuc2lvbnMuU1RBQ0tHTF9yZXNpemVfZHJhd2luZ2J1ZmZlci5yZXNpemUodGhpcy5tYXhUZXhTaXplWzBdLCB0aGlzLm1heFRleFNpemVbMV0pO1xuICAgIH1cbiAgfVxuXG4gIGRlc3Ryb3lFeHRlbnNpb25zKCkge1xuICAgIHRoaXMuZXh0ZW5zaW9ucy5TVEFDS0dMX3Jlc2l6ZV9kcmF3aW5nYnVmZmVyID0gbnVsbDtcbiAgICB0aGlzLmV4dGVuc2lvbnMuU1RBQ0tHTF9kZXN0cm95X2NvbnRleHQgPSBudWxsO1xuICAgIHRoaXMuZXh0ZW5zaW9ucy5PRVNfdGV4dHVyZV9mbG9hdCA9IG51bGw7XG4gICAgdGhpcy5leHRlbnNpb25zLk9FU190ZXh0dXJlX2Zsb2F0X2xpbmVhciA9IG51bGw7XG4gICAgdGhpcy5leHRlbnNpb25zLk9FU19lbGVtZW50X2luZGV4X3VpbnQgPSBudWxsO1xuICAgIHRoaXMuZXh0ZW5zaW9ucy5XRUJHTF9kcmF3X2J1ZmZlcnMgPSBudWxsO1xuICB9XG5cbiAgc3RhdGljIGRlc3Ryb3lDb250ZXh0KGNvbnRleHQpIHtcbiAgICBjb25zdCBleHRlbnNpb24gPSBjb250ZXh0LmdldEV4dGVuc2lvbignU1RBQ0tHTF9kZXN0cm95X2NvbnRleHQnKTtcbiAgICBpZiAoZXh0ZW5zaW9uICYmIGV4dGVuc2lvbi5kZXN0cm95KSB7XG4gICAgICBleHRlbnNpb24uZGVzdHJveSgpO1xuICAgIH1cbiAgfVxuXG4gIHRvU3RyaW5nKCkge1xuICAgIGNvbnN0IHNldHVwQ29udGV4dFN0cmluZyA9IGBjb25zdCBnbCA9IGNvbnRleHQgfHwgcmVxdWlyZSgnZ2wnKSgxLCAxKTtcXG5gO1xuICAgIGNvbnN0IGRlc3Ryb3lDb250ZXh0U3RyaW5nID0gYCAgICBpZiAoIWNvbnRleHQpIHsgZ2wuZ2V0RXh0ZW5zaW9uKCdTVEFDS0dMX2Rlc3Ryb3lfY29udGV4dCcpLmRlc3Ryb3koKTsgfVxcbmA7XG4gICAgcmV0dXJuIGdsS2VybmVsU3RyaW5nKHRoaXMuY29uc3RydWN0b3IsIGFyZ3VtZW50cywgdGhpcywgc2V0dXBDb250ZXh0U3RyaW5nLCBkZXN0cm95Q29udGV4dFN0cmluZyk7XG4gIH1cblxuICBzZXRPdXRwdXQob3V0cHV0KSB7XG4gICAgc3VwZXIuc2V0T3V0cHV0KG91dHB1dCk7XG4gICAgaWYgKHRoaXMuZ3JhcGhpY2FsICYmIHRoaXMuZXh0ZW5zaW9ucy5TVEFDS0dMX3Jlc2l6ZV9kcmF3aW5nYnVmZmVyKSB7XG4gICAgICB0aGlzLmV4dGVuc2lvbnMuU1RBQ0tHTF9yZXNpemVfZHJhd2luZ2J1ZmZlci5yZXNpemUodGhpcy5tYXhUZXhTaXplWzBdLCB0aGlzLm1heFRleFNpemVbMV0pO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgSGVhZGxlc3NHTEtlcm5lbFxufTtcbn0se1wiLi4vZ2wva2VybmVsLXN0cmluZ1wiOjEyLFwiLi4vd2ViLWdsL2tlcm5lbFwiOjcwLFwiZ2xcIjoyfV0sMzU6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuY2xhc3MgS2VybmVsVmFsdWUge1xuICBjb25zdHJ1Y3Rvcih2YWx1ZSwgc2V0dGluZ3MpIHtcbiAgICBjb25zdCB7XG4gICAgICBuYW1lLFxuICAgICAga2VybmVsLFxuICAgICAgY29udGV4dCxcbiAgICAgIGNoZWNrQ29udGV4dCxcbiAgICAgIG9uUmVxdWVzdENvbnRleHRIYW5kbGUsXG4gICAgICBvblVwZGF0ZVZhbHVlTWlzbWF0Y2gsXG4gICAgICBvcmlnaW4sXG4gICAgICBzdHJpY3RJbnRlZ2VycyxcbiAgICAgIHR5cGUsXG4gICAgICB0YWN0aWMsXG4gICAgfSA9IHNldHRpbmdzO1xuICAgIGlmICghbmFtZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCduYW1lIG5vdCBzZXQnKTtcbiAgICB9XG4gICAgaWYgKCF0eXBlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3R5cGUgbm90IHNldCcpO1xuICAgIH1cbiAgICBpZiAoIW9yaWdpbikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdvcmlnaW4gbm90IHNldCcpO1xuICAgIH1cbiAgICBpZiAob3JpZ2luICE9PSAndXNlcicgJiYgb3JpZ2luICE9PSAnY29uc3RhbnRzJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBvcmlnaW4gbXVzdCBiZSBcInVzZXJcIiBvciBcImNvbnN0YW50c1wiIHZhbHVlIGlzIFwiJHsgb3JpZ2luIH1cImApO1xuICAgIH1cbiAgICBpZiAoIW9uUmVxdWVzdENvbnRleHRIYW5kbGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignb25SZXF1ZXN0Q29udGV4dEhhbmRsZSBpcyBub3Qgc2V0Jyk7XG4gICAgfVxuICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgdGhpcy5vcmlnaW4gPSBvcmlnaW47XG4gICAgdGhpcy50YWN0aWMgPSB0YWN0aWM7XG4gICAgdGhpcy52YXJOYW1lID0gb3JpZ2luID09PSAnY29uc3RhbnRzJyA/IGBjb25zdGFudHMuJHtuYW1lfWAgOiBuYW1lO1xuICAgIHRoaXMua2VybmVsID0ga2VybmVsO1xuICAgIHRoaXMuc3RyaWN0SW50ZWdlcnMgPSBzdHJpY3RJbnRlZ2VycztcbiAgICB0aGlzLnR5cGUgPSB2YWx1ZS50eXBlIHx8IHR5cGU7XG4gICAgdGhpcy5zaXplID0gdmFsdWUuc2l6ZSB8fCBudWxsO1xuICAgIHRoaXMuaW5kZXggPSBudWxsO1xuICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgdGhpcy5jaGVja0NvbnRleHQgPSBjaGVja0NvbnRleHQgIT09IG51bGwgJiYgY2hlY2tDb250ZXh0ICE9PSB1bmRlZmluZWQgPyBjaGVja0NvbnRleHQgOiB0cnVlO1xuICAgIHRoaXMuY29udGV4dEhhbmRsZSA9IG51bGw7XG4gICAgdGhpcy5vblJlcXVlc3RDb250ZXh0SGFuZGxlID0gb25SZXF1ZXN0Q29udGV4dEhhbmRsZTtcbiAgICB0aGlzLm9uVXBkYXRlVmFsdWVNaXNtYXRjaCA9IG9uVXBkYXRlVmFsdWVNaXNtYXRjaDtcbiAgICB0aGlzLmZvcmNlVXBsb2FkRWFjaFJ1biA9IG51bGw7XG4gIH1cblxuICBnZXQgaWQoKSB7XG4gICAgcmV0dXJuIGAke3RoaXMub3JpZ2lufV8ke25hbWV9YDtcbiAgfVxuXG4gIGdldFNvdXJjZSgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFwiZ2V0U291cmNlXCIgbm90IGRlZmluZWQgb24gJHsgdGhpcy5jb25zdHJ1Y3Rvci5uYW1lIH1gKTtcbiAgfVxuXG4gIHVwZGF0ZVZhbHVlKHZhbHVlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBcInVwZGF0ZVZhbHVlXCIgbm90IGRlZmluZWQgb24gJHsgdGhpcy5jb25zdHJ1Y3Rvci5uYW1lIH1gKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgS2VybmVsVmFsdWVcbn07XG59LHt9XSwzNjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5jb25zdCB7IHV0aWxzIH0gPSByZXF1aXJlKCcuLi91dGlscycpO1xuY29uc3QgeyBJbnB1dCB9ID0gcmVxdWlyZSgnLi4vaW5wdXQnKTtcblxuY2xhc3MgS2VybmVsIHtcbiAgc3RhdGljIGdldCBpc1N1cHBvcnRlZCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFwiaXNTdXBwb3J0ZWRcIiBub3QgaW1wbGVtZW50ZWQgb24gJHsgdGhpcy5uYW1lIH1gKTtcbiAgfVxuXG4gIHN0YXRpYyBpc0NvbnRleHRNYXRjaChjb250ZXh0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBcImlzQ29udGV4dE1hdGNoXCIgbm90IGltcGxlbWVudGVkIG9uICR7IHRoaXMubmFtZSB9YCk7XG4gIH1cblxuICBzdGF0aWMgZ2V0RmVhdHVyZXMoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBcImdldEZlYXR1cmVzXCIgbm90IGltcGxlbWVudGVkIG9uICR7IHRoaXMubmFtZSB9YCk7XG4gIH1cblxuICBzdGF0aWMgZGVzdHJveUNvbnRleHQoY29udGV4dCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgXCJkZXN0cm95Q29udGV4dFwiIGNhbGxlZCBvbiAkeyB0aGlzLm5hbWUgfWApO1xuICB9XG5cbiAgc3RhdGljIG5hdGl2ZUZ1bmN0aW9uQXJndW1lbnRzKCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgXCJuYXRpdmVGdW5jdGlvbkFyZ3VtZW50c1wiIGNhbGxlZCBvbiAkeyB0aGlzLm5hbWUgfWApO1xuICB9XG5cbiAgc3RhdGljIG5hdGl2ZUZ1bmN0aW9uUmV0dXJuVHlwZSgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFwibmF0aXZlRnVuY3Rpb25SZXR1cm5UeXBlXCIgY2FsbGVkIG9uICR7IHRoaXMubmFtZSB9YCk7XG4gIH1cblxuICBzdGF0aWMgY29tYmluZUtlcm5lbHMoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBcImNvbWJpbmVLZXJuZWxzXCIgY2FsbGVkIG9uICR7IHRoaXMubmFtZSB9YCk7XG4gIH1cblxuICBjb25zdHJ1Y3Rvcihzb3VyY2UsIHNldHRpbmdzKSB7XG4gICAgaWYgKHR5cGVvZiBzb3VyY2UgIT09ICdvYmplY3QnKSB7XG4gICAgICBpZiAodHlwZW9mIHNvdXJjZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzb3VyY2Ugbm90IGEgc3RyaW5nJyk7XG4gICAgICB9XG4gICAgICBpZiAoIXV0aWxzLmlzRnVuY3Rpb25TdHJpbmcoc291cmNlKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NvdXJjZSBub3QgYSBmdW5jdGlvbiBzdHJpbmcnKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy51c2VMZWdhY3lFbmNvZGVyID0gZmFsc2U7XG4gICAgdGhpcy5mYWxsYmFja1JlcXVlc3RlZCA9IGZhbHNlO1xuICAgIHRoaXMub25SZXF1ZXN0RmFsbGJhY2sgPSBudWxsO1xuXG4gICAgdGhpcy5hcmd1bWVudE5hbWVzID0gdHlwZW9mIHNvdXJjZSA9PT0gJ3N0cmluZycgPyB1dGlscy5nZXRBcmd1bWVudE5hbWVzRnJvbVN0cmluZyhzb3VyY2UpIDogbnVsbDtcbiAgICB0aGlzLmFyZ3VtZW50VHlwZXMgPSBudWxsO1xuICAgIHRoaXMuYXJndW1lbnRTaXplcyA9IG51bGw7XG4gICAgdGhpcy5hcmd1bWVudEJpdFJhdGlvcyA9IG51bGw7XG4gICAgdGhpcy5rZXJuZWxBcmd1bWVudHMgPSBudWxsO1xuICAgIHRoaXMua2VybmVsQ29uc3RhbnRzID0gbnVsbDtcbiAgICB0aGlzLmZvcmNlVXBsb2FkS2VybmVsQ29uc3RhbnRzID0gbnVsbDtcblxuXG4gICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG5cbiAgICB0aGlzLm91dHB1dCA9IG51bGw7XG5cbiAgICB0aGlzLmRlYnVnID0gZmFsc2U7XG5cbiAgICB0aGlzLmdyYXBoaWNhbCA9IGZhbHNlO1xuXG4gICAgdGhpcy5sb29wTWF4SXRlcmF0aW9ucyA9IDA7XG5cbiAgICB0aGlzLmNvbnN0YW50cyA9IG51bGw7XG5cbiAgICB0aGlzLmNvbnN0YW50VHlwZXMgPSBudWxsO1xuXG4gICAgdGhpcy5jb25zdGFudEJpdFJhdGlvcyA9IG51bGw7XG5cbiAgICB0aGlzLmR5bmFtaWNBcmd1bWVudHMgPSBmYWxzZTtcblxuICAgIHRoaXMuZHluYW1pY091dHB1dCA9IGZhbHNlO1xuXG4gICAgdGhpcy5jYW52YXMgPSBudWxsO1xuXG4gICAgdGhpcy5jb250ZXh0ID0gbnVsbDtcblxuICAgIHRoaXMuY2hlY2tDb250ZXh0ID0gbnVsbDtcblxuICAgIHRoaXMuZ3B1ID0gbnVsbDtcblxuICAgIHRoaXMuZnVuY3Rpb25zID0gbnVsbDtcblxuICAgIHRoaXMubmF0aXZlRnVuY3Rpb25zID0gbnVsbDtcblxuICAgIHRoaXMuaW5qZWN0ZWROYXRpdmUgPSBudWxsO1xuXG4gICAgdGhpcy5zdWJLZXJuZWxzID0gbnVsbDtcblxuICAgIHRoaXMudmFsaWRhdGUgPSB0cnVlO1xuXG4gICAgdGhpcy5pbW11dGFibGUgPSBmYWxzZTtcblxuICAgIHRoaXMucGlwZWxpbmUgPSBmYWxzZTtcblxuICAgIHRoaXMucHJlY2lzaW9uID0gbnVsbDtcblxuICAgIHRoaXMudGFjdGljID0gbnVsbDtcblxuICAgIHRoaXMucGx1Z2lucyA9IG51bGw7XG5cbiAgICB0aGlzLnJldHVyblR5cGUgPSBudWxsO1xuICAgIHRoaXMubGVhZGluZ1JldHVyblN0YXRlbWVudCA9IG51bGw7XG4gICAgdGhpcy5mb2xsb3dpbmdSZXR1cm5TdGF0ZW1lbnQgPSBudWxsO1xuICAgIHRoaXMub3B0aW1pemVGbG9hdE1lbW9yeSA9IG51bGw7XG4gICAgdGhpcy5zdHJpY3RJbnRlZ2VycyA9IGZhbHNlO1xuICAgIHRoaXMuZml4SW50ZWdlckRpdmlzaW9uQWNjdXJhY3kgPSBudWxsO1xuICAgIHRoaXMuYnVpbHQgPSBmYWxzZTtcbiAgICB0aGlzLnNpZ25hdHVyZSA9IG51bGw7XG4gIH1cblxuICBtZXJnZVNldHRpbmdzKHNldHRpbmdzKSB7XG4gICAgZm9yIChsZXQgcCBpbiBzZXR0aW5ncykge1xuICAgICAgaWYgKCFzZXR0aW5ncy5oYXNPd25Qcm9wZXJ0eShwKSB8fCAhdGhpcy5oYXNPd25Qcm9wZXJ0eShwKSkgY29udGludWU7XG4gICAgICBzd2l0Y2ggKHApIHtcbiAgICAgICAgY2FzZSAnb3V0cHV0JzpcbiAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoc2V0dGluZ3Mub3V0cHV0KSkge1xuICAgICAgICAgICAgdGhpcy5zZXRPdXRwdXQoc2V0dGluZ3Mub3V0cHV0KTsgXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2Z1bmN0aW9ucyc6XG4gICAgICAgICAgdGhpcy5mdW5jdGlvbnMgPSBbXTtcbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNldHRpbmdzLmZ1bmN0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdGhpcy5hZGRGdW5jdGlvbihzZXR0aW5ncy5mdW5jdGlvbnNbaV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgY2FzZSAnZ3JhcGhpY2FsJzpcbiAgICAgICAgICBpZiAoc2V0dGluZ3NbcF0gJiYgIXNldHRpbmdzLmhhc093blByb3BlcnR5KCdwcmVjaXNpb24nKSkge1xuICAgICAgICAgICAgdGhpcy5wcmVjaXNpb24gPSAndW5zaWduZWQnO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzW3BdID0gc2V0dGluZ3NbcF07XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIGNhc2UgJ25hdGl2ZUZ1bmN0aW9ucyc6XG4gICAgICAgICAgaWYgKCFzZXR0aW5ncy5uYXRpdmVGdW5jdGlvbnMpIGNvbnRpbnVlO1xuICAgICAgICAgIHRoaXMubmF0aXZlRnVuY3Rpb25zID0gW107XG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZXR0aW5ncy5uYXRpdmVGdW5jdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHMgPSBzZXR0aW5ncy5uYXRpdmVGdW5jdGlvbnNbaV07XG4gICAgICAgICAgICBjb25zdCB7IG5hbWUsIHNvdXJjZSB9ID0gcztcbiAgICAgICAgICAgIHRoaXMuYWRkTmF0aXZlRnVuY3Rpb24obmFtZSwgc291cmNlLCBzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICB0aGlzW3BdID0gc2V0dGluZ3NbcF07XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLmNhbnZhcykgdGhpcy5jYW52YXMgPSB0aGlzLmluaXRDYW52YXMoKTtcbiAgICBpZiAoIXRoaXMuY29udGV4dCkgdGhpcy5jb250ZXh0ID0gdGhpcy5pbml0Q29udGV4dCgpO1xuICAgIGlmICghdGhpcy5wbHVnaW5zKSB0aGlzLnBsdWdpbnMgPSB0aGlzLmluaXRQbHVnaW5zKHNldHRpbmdzKTtcbiAgfVxuICBidWlsZCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFwiYnVpbGRcIiBub3QgZGVmaW5lZCBvbiAkeyB0aGlzLmNvbnN0cnVjdG9yLm5hbWUgfWApO1xuICB9XG5cbiAgcnVuKCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgXCJydW5cIiBub3QgZGVmaW5lZCBvbiAkeyB0aGlzLmNvbnN0cnVjdG9yLm5hbWUgfWApXG4gIH1cblxuICBpbml0Q2FudmFzKCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgXCJpbml0Q2FudmFzXCIgbm90IGRlZmluZWQgb24gJHsgdGhpcy5jb25zdHJ1Y3Rvci5uYW1lIH1gKTtcbiAgfVxuXG4gIGluaXRDb250ZXh0KCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgXCJpbml0Q29udGV4dFwiIG5vdCBkZWZpbmVkIG9uICR7IHRoaXMuY29uc3RydWN0b3IubmFtZSB9YCk7XG4gIH1cblxuICBpbml0UGx1Z2lucyhzZXR0aW5ncykge1xuICAgIHRocm93IG5ldyBFcnJvcihgXCJpbml0UGx1Z2luc1wiIG5vdCBkZWZpbmVkIG9uICR7IHRoaXMuY29uc3RydWN0b3IubmFtZSB9YCk7XG4gIH1cblxuICBhZGRGdW5jdGlvbihzb3VyY2UsIHNldHRpbmdzID0ge30pIHtcbiAgICBpZiAoc291cmNlLm5hbWUgJiYgc291cmNlLnNvdXJjZSAmJiBzb3VyY2UuYXJndW1lbnRUeXBlcyAmJiAncmV0dXJuVHlwZScgaW4gc291cmNlKSB7XG4gICAgICB0aGlzLmZ1bmN0aW9ucy5wdXNoKHNvdXJjZSk7XG4gICAgfSBlbHNlIGlmICgnc2V0dGluZ3MnIGluIHNvdXJjZSAmJiAnc291cmNlJyBpbiBzb3VyY2UpIHtcbiAgICAgIHRoaXMuZnVuY3Rpb25zLnB1c2godGhpcy5mdW5jdGlvblRvSUdQVUZ1bmN0aW9uKHNvdXJjZS5zb3VyY2UsIHNvdXJjZS5zZXR0aW5ncykpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHNvdXJjZSA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHNvdXJjZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhpcy5mdW5jdGlvbnMucHVzaCh0aGlzLmZ1bmN0aW9uVG9JR1BVRnVuY3Rpb24oc291cmNlLCBzZXR0aW5ncykpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYGZ1bmN0aW9uIG5vdCBwcm9wZXJseSBkZWZpbmVkYCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgYWRkTmF0aXZlRnVuY3Rpb24obmFtZSwgc291cmNlLCBzZXR0aW5ncyA9IHt9KSB7XG4gICAgY29uc3QgeyBhcmd1bWVudFR5cGVzLCBhcmd1bWVudE5hbWVzIH0gPSBzZXR0aW5ncy5hcmd1bWVudFR5cGVzID9cbiAgICAgIHNwbGl0QXJndW1lbnRUeXBlcyhzZXR0aW5ncy5hcmd1bWVudFR5cGVzKSA6XG4gICAgICB0aGlzLmNvbnN0cnVjdG9yLm5hdGl2ZUZ1bmN0aW9uQXJndW1lbnRzKHNvdXJjZSkgfHwge307XG4gICAgdGhpcy5uYXRpdmVGdW5jdGlvbnMucHVzaCh7XG4gICAgICBuYW1lLFxuICAgICAgc291cmNlLFxuICAgICAgc2V0dGluZ3MsXG4gICAgICBhcmd1bWVudFR5cGVzLFxuICAgICAgYXJndW1lbnROYW1lcyxcbiAgICAgIHJldHVyblR5cGU6IHNldHRpbmdzLnJldHVyblR5cGUgfHwgdGhpcy5jb25zdHJ1Y3Rvci5uYXRpdmVGdW5jdGlvblJldHVyblR5cGUoc291cmNlKVxuICAgIH0pO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgc2V0dXBBcmd1bWVudHMoYXJncykge1xuICAgIHRoaXMua2VybmVsQXJndW1lbnRzID0gW107XG4gICAgaWYgKCF0aGlzLmFyZ3VtZW50VHlwZXMpIHtcbiAgICAgIGlmICghdGhpcy5hcmd1bWVudFR5cGVzKSB7XG4gICAgICAgIHRoaXMuYXJndW1lbnRUeXBlcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBjb25zdCBhcmdUeXBlID0gdXRpbHMuZ2V0VmFyaWFibGVUeXBlKGFyZ3NbaV0sIHRoaXMuc3RyaWN0SW50ZWdlcnMpO1xuICAgICAgICAgIGNvbnN0IHR5cGUgPSBhcmdUeXBlID09PSAnSW50ZWdlcicgPyAnTnVtYmVyJyA6IGFyZ1R5cGU7XG4gICAgICAgICAgdGhpcy5hcmd1bWVudFR5cGVzLnB1c2godHlwZSk7XG4gICAgICAgICAgdGhpcy5rZXJuZWxBcmd1bWVudHMucHVzaCh7XG4gICAgICAgICAgICB0eXBlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmFyZ3VtZW50VHlwZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy5rZXJuZWxBcmd1bWVudHMucHVzaCh7XG4gICAgICAgICAgdHlwZTogdGhpcy5hcmd1bWVudFR5cGVzW2ldXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuYXJndW1lbnRTaXplcyA9IG5ldyBBcnJheShhcmdzLmxlbmd0aCk7XG4gICAgdGhpcy5hcmd1bWVudEJpdFJhdGlvcyA9IG5ldyBJbnQzMkFycmF5KGFyZ3MubGVuZ3RoKTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgYXJnID0gYXJnc1tpXTtcbiAgICAgIHRoaXMuYXJndW1lbnRTaXplc1tpXSA9IGFyZy5jb25zdHJ1Y3RvciA9PT0gSW5wdXQgPyBhcmcuc2l6ZSA6IG51bGw7XG4gICAgICB0aGlzLmFyZ3VtZW50Qml0UmF0aW9zW2ldID0gdGhpcy5nZXRCaXRSYXRpbyhhcmcpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmFyZ3VtZW50TmFtZXMubGVuZ3RoICE9PSBhcmdzLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBhcmd1bWVudHMgYXJlIG1pc3MtYWxpZ25lZGApO1xuICAgIH1cbiAgfVxuXG4gIHNldHVwQ29uc3RhbnRzKCkge1xuICAgIHRoaXMua2VybmVsQ29uc3RhbnRzID0gW107XG4gICAgbGV0IG5lZWRzQ29uc3RhbnRUeXBlcyA9IHRoaXMuY29uc3RhbnRUeXBlcyA9PT0gbnVsbDtcbiAgICBpZiAobmVlZHNDb25zdGFudFR5cGVzKSB7XG4gICAgICB0aGlzLmNvbnN0YW50VHlwZXMgPSB7fTtcbiAgICB9XG4gICAgdGhpcy5jb25zdGFudEJpdFJhdGlvcyA9IHt9O1xuICAgIGlmICh0aGlzLmNvbnN0YW50cykge1xuICAgICAgZm9yIChsZXQgbmFtZSBpbiB0aGlzLmNvbnN0YW50cykge1xuICAgICAgICBpZiAobmVlZHNDb25zdGFudFR5cGVzKSB7XG4gICAgICAgICAgY29uc3QgdHlwZSA9IHV0aWxzLmdldFZhcmlhYmxlVHlwZSh0aGlzLmNvbnN0YW50c1tuYW1lXSwgdGhpcy5zdHJpY3RJbnRlZ2Vycyk7XG4gICAgICAgICAgdGhpcy5jb25zdGFudFR5cGVzW25hbWVdID0gdHlwZTtcbiAgICAgICAgICB0aGlzLmtlcm5lbENvbnN0YW50cy5wdXNoKHtcbiAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICB0eXBlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5rZXJuZWxDb25zdGFudHMucHVzaCh7XG4gICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgdHlwZTogdGhpcy5jb25zdGFudFR5cGVzW25hbWVdXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jb25zdGFudEJpdFJhdGlvc1tuYW1lXSA9IHRoaXMuZ2V0Qml0UmF0aW8odGhpcy5jb25zdGFudHNbbmFtZV0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHNldE9wdGltaXplRmxvYXRNZW1vcnkoZmxhZykge1xuICAgIHRoaXMub3B0aW1pemVGbG9hdE1lbW9yeSA9IGZsYWc7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICB0b0tlcm5lbE91dHB1dChvdXRwdXQpIHtcbiAgICBpZiAob3V0cHV0Lmhhc093blByb3BlcnR5KCd4JykpIHtcbiAgICAgIGlmIChvdXRwdXQuaGFzT3duUHJvcGVydHkoJ3knKSkge1xuICAgICAgICBpZiAob3V0cHV0Lmhhc093blByb3BlcnR5KCd6JykpIHtcbiAgICAgICAgICByZXR1cm4gW291dHB1dC54LCBvdXRwdXQueSwgb3V0cHV0LnpdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBbb3V0cHV0LngsIG91dHB1dC55XTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFtvdXRwdXQueF07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgfVxuICB9XG5cbiAgc2V0T3V0cHV0KG91dHB1dCkge1xuICAgIHRoaXMub3V0cHV0ID0gdGhpcy50b0tlcm5lbE91dHB1dChvdXRwdXQpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgc2V0RGVidWcoZmxhZykge1xuICAgIHRoaXMuZGVidWcgPSBmbGFnO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgc2V0R3JhcGhpY2FsKGZsYWcpIHtcbiAgICB0aGlzLmdyYXBoaWNhbCA9IGZsYWc7XG4gICAgdGhpcy5wcmVjaXNpb24gPSAndW5zaWduZWQnO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgc2V0TG9vcE1heEl0ZXJhdGlvbnMobWF4KSB7XG4gICAgdGhpcy5sb29wTWF4SXRlcmF0aW9ucyA9IG1heDtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHNldENvbnN0YW50cyhjb25zdGFudHMpIHtcbiAgICB0aGlzLmNvbnN0YW50cyA9IGNvbnN0YW50cztcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHNldENvbnN0YW50VHlwZXMoY29uc3RhbnRUeXBlcykge1xuICAgIHRoaXMuY29uc3RhbnRUeXBlcyA9IGNvbnN0YW50VHlwZXM7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBzZXRGdW5jdGlvbnMoZnVuY3Rpb25zKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmdW5jdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMuYWRkRnVuY3Rpb24oZnVuY3Rpb25zW2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBzZXROYXRpdmVGdW5jdGlvbnMobmF0aXZlRnVuY3Rpb25zKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuYXRpdmVGdW5jdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHNldHRpbmdzID0gbmF0aXZlRnVuY3Rpb25zW2ldO1xuICAgICAgY29uc3QgeyBuYW1lLCBzb3VyY2UgfSA9IHNldHRpbmdzO1xuICAgICAgdGhpcy5hZGROYXRpdmVGdW5jdGlvbihuYW1lLCBzb3VyY2UsIHNldHRpbmdzKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBzZXRJbmplY3RlZE5hdGl2ZShpbmplY3RlZE5hdGl2ZSkge1xuICAgIHRoaXMuaW5qZWN0ZWROYXRpdmUgPSBpbmplY3RlZE5hdGl2ZTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHNldFBpcGVsaW5lKGZsYWcpIHtcbiAgICB0aGlzLnBpcGVsaW5lID0gZmxhZztcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHNldFByZWNpc2lvbihmbGFnKSB7XG4gICAgdGhpcy5wcmVjaXNpb24gPSBmbGFnO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgc2V0RGltZW5zaW9ucyhmbGFnKSB7XG4gICAgdXRpbHMud2FybkRlcHJlY2F0ZWQoJ21ldGhvZCcsICdzZXREaW1lbnNpb25zJywgJ3NldE91dHB1dCcpO1xuICAgIHRoaXMub3V0cHV0ID0gZmxhZztcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHNldE91dHB1dFRvVGV4dHVyZShmbGFnKSB7XG4gICAgdXRpbHMud2FybkRlcHJlY2F0ZWQoJ21ldGhvZCcsICdzZXRPdXRwdXRUb1RleHR1cmUnLCAnc2V0UGlwZWxpbmUnKTtcbiAgICB0aGlzLnBpcGVsaW5lID0gZmxhZztcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHNldEltbXV0YWJsZShmbGFnKSB7XG4gICAgdGhpcy5pbW11dGFibGUgPSBmbGFnO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgc2V0Q2FudmFzKGNhbnZhcykge1xuICAgIHRoaXMuY2FudmFzID0gY2FudmFzO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgc2V0U3RyaWN0SW50ZWdlcnMoZmxhZykge1xuICAgIHRoaXMuc3RyaWN0SW50ZWdlcnMgPSBmbGFnO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgc2V0RHluYW1pY091dHB1dChmbGFnKSB7XG4gICAgdGhpcy5keW5hbWljT3V0cHV0ID0gZmxhZztcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHNldEhhcmRjb2RlQ29uc3RhbnRzKGZsYWcpIHtcbiAgICB1dGlscy53YXJuRGVwcmVjYXRlZCgnbWV0aG9kJywgJ3NldEhhcmRjb2RlQ29uc3RhbnRzJyk7XG4gICAgdGhpcy5zZXREeW5hbWljT3V0cHV0KGZsYWcpO1xuICAgIHRoaXMuc2V0RHluYW1pY0FyZ3VtZW50cyhmbGFnKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHNldER5bmFtaWNBcmd1bWVudHMoZmxhZykge1xuICAgIHRoaXMuZHluYW1pY0FyZ3VtZW50cyA9IGZsYWc7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBzZXRVc2VMZWdhY3lFbmNvZGVyKGZsYWcpIHtcbiAgICB0aGlzLnVzZUxlZ2FjeUVuY29kZXIgPSBmbGFnO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgc2V0V2FyblZhclVzYWdlKGZsYWcpIHtcbiAgICB1dGlscy53YXJuRGVwcmVjYXRlZCgnbWV0aG9kJywgJ3NldFdhcm5WYXJVc2FnZScpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgZ2V0Q2FudmFzKCkge1xuICAgIHV0aWxzLndhcm5EZXByZWNhdGVkKCdtZXRob2QnLCAnZ2V0Q2FudmFzJyk7XG4gICAgcmV0dXJuIHRoaXMuY2FudmFzO1xuICB9XG5cbiAgZ2V0V2ViR2woKSB7XG4gICAgdXRpbHMud2FybkRlcHJlY2F0ZWQoJ21ldGhvZCcsICdnZXRXZWJHbCcpO1xuICAgIHJldHVybiB0aGlzLmNvbnRleHQ7XG4gIH1cblxuICBzZXRDb250ZXh0KGNvbnRleHQpIHtcbiAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgc2V0QXJndW1lbnRUeXBlcyhhcmd1bWVudFR5cGVzKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYXJndW1lbnRUeXBlcykpIHtcbiAgICAgIHRoaXMuYXJndW1lbnRUeXBlcyA9IGFyZ3VtZW50VHlwZXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYXJndW1lbnRUeXBlcyA9IFtdO1xuICAgICAgZm9yIChjb25zdCBwIGluIGFyZ3VtZW50VHlwZXMpIHtcbiAgICAgICAgaWYgKCFhcmd1bWVudFR5cGVzLmhhc093blByb3BlcnR5KHApKSBjb250aW51ZTtcbiAgICAgICAgY29uc3QgYXJndW1lbnRJbmRleCA9IHRoaXMuYXJndW1lbnROYW1lcy5pbmRleE9mKHApO1xuICAgICAgICBpZiAoYXJndW1lbnRJbmRleCA9PT0gLTEpIHRocm93IG5ldyBFcnJvcihgdW5hYmxlIHRvIGZpbmQgYXJndW1lbnQgJHsgcCB9YCk7XG4gICAgICAgIHRoaXMuYXJndW1lbnRUeXBlc1thcmd1bWVudEluZGV4XSA9IGFyZ3VtZW50VHlwZXNbcF07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgc2V0VGFjdGljKHRhY3RpYykge1xuICAgIHRoaXMudGFjdGljID0gdGFjdGljO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgcmVxdWVzdEZhbGxiYWNrKGFyZ3MpIHtcbiAgICBpZiAoIXRoaXMub25SZXF1ZXN0RmFsbGJhY2spIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgXCJvblJlcXVlc3RGYWxsYmFja1wiIG5vdCBkZWZpbmVkIG9uICR7IHRoaXMuY29uc3RydWN0b3IubmFtZSB9YCk7XG4gICAgfVxuICAgIHRoaXMuZmFsbGJhY2tSZXF1ZXN0ZWQgPSB0cnVlO1xuICAgIHJldHVybiB0aGlzLm9uUmVxdWVzdEZhbGxiYWNrKGFyZ3MpO1xuICB9XG5cbiAgdmFsaWRhdGVTZXR0aW5ncygpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFwidmFsaWRhdGVTZXR0aW5nc1wiIG5vdCBkZWZpbmVkIG9uICR7IHRoaXMuY29uc3RydWN0b3IubmFtZSB9YCk7XG4gIH1cblxuICBhZGRTdWJLZXJuZWwoc3ViS2VybmVsKSB7XG4gICAgaWYgKHRoaXMuc3ViS2VybmVscyA9PT0gbnVsbCkge1xuICAgICAgdGhpcy5zdWJLZXJuZWxzID0gW107XG4gICAgfVxuICAgIGlmICghc3ViS2VybmVsLnNvdXJjZSkgdGhyb3cgbmV3IEVycm9yKCdzdWJLZXJuZWwgbWlzc2luZyBcInNvdXJjZVwiIHByb3BlcnR5Jyk7XG4gICAgaWYgKCFzdWJLZXJuZWwucHJvcGVydHkgJiYgaXNOYU4oc3ViS2VybmVsLnByb3BlcnR5KSkgdGhyb3cgbmV3IEVycm9yKCdzdWJLZXJuZWwgbWlzc2luZyBcInByb3BlcnR5XCIgcHJvcGVydHknKTtcbiAgICBpZiAoIXN1Yktlcm5lbC5uYW1lKSB0aHJvdyBuZXcgRXJyb3IoJ3N1Yktlcm5lbCBtaXNzaW5nIFwibmFtZVwiIHByb3BlcnR5Jyk7XG4gICAgdGhpcy5zdWJLZXJuZWxzLnB1c2goc3ViS2VybmVsKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGRlc3Ryb3kocmVtb3ZlQ2FudmFzUmVmZXJlbmNlcykge1xuICAgIHRocm93IG5ldyBFcnJvcihgXCJkZXN0cm95XCIgY2FsbGVkIG9uICR7IHRoaXMuY29uc3RydWN0b3IubmFtZSB9YCk7XG4gIH1cblxuICBnZXRCaXRSYXRpbyh2YWx1ZSkge1xuICAgIGlmICh0aGlzLnByZWNpc2lvbiA9PT0gJ3NpbmdsZScpIHtcbiAgICAgIHJldHVybiA0O1xuICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZVswXSkpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldEJpdFJhdGlvKHZhbHVlWzBdKTtcbiAgICB9IGVsc2UgaWYgKHZhbHVlLmNvbnN0cnVjdG9yID09PSBJbnB1dCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0Qml0UmF0aW8odmFsdWUudmFsdWUpO1xuICAgIH1cbiAgICBzd2l0Y2ggKHZhbHVlLmNvbnN0cnVjdG9yKSB7XG4gICAgICBjYXNlIFVpbnQ4Q2xhbXBlZEFycmF5OlxuICAgICAgY2FzZSBVaW50OEFycmF5OlxuICAgICAgY2FzZSBJbnQ4QXJyYXk6XG4gICAgICAgIHJldHVybiAxO1xuICAgICAgY2FzZSBVaW50MTZBcnJheTpcbiAgICAgIGNhc2UgSW50MTZBcnJheTpcbiAgICAgICAgcmV0dXJuIDI7XG4gICAgICBjYXNlIEZsb2F0MzJBcnJheTpcbiAgICAgIGNhc2UgSW50MzJBcnJheTpcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiA0O1xuICAgIH1cbiAgfVxuXG4gIGdldFBpeGVscyhmbGlwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBcImdldFBpeGVsc1wiIGNhbGxlZCBvbiAkeyB0aGlzLmNvbnN0cnVjdG9yLm5hbWUgfWApO1xuICB9XG5cbiAgY2hlY2tPdXRwdXQoKSB7XG4gICAgaWYgKCF0aGlzLm91dHB1dCB8fCAhdXRpbHMuaXNBcnJheSh0aGlzLm91dHB1dCkpIHRocm93IG5ldyBFcnJvcigna2VybmVsLm91dHB1dCBub3QgYW4gYXJyYXknKTtcbiAgICBpZiAodGhpcy5vdXRwdXQubGVuZ3RoIDwgMSkgdGhyb3cgbmV3IEVycm9yKCdrZXJuZWwub3V0cHV0IGlzIGVtcHR5LCBuZWVkcyBhdCBsZWFzdCAxIHZhbHVlJyk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLm91dHB1dC5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGlzTmFOKHRoaXMub3V0cHV0W2ldKSB8fCB0aGlzLm91dHB1dFtpXSA8IDEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAkeyB0aGlzLmNvbnN0cnVjdG9yLm5hbWUgfS5vdXRwdXRbJHsgaSB9XSBpbmNvcnJlY3RseSBkZWZpbmVkIGFzIFxcYCR7IHRoaXMub3V0cHV0W2ldIH1cXGAsIG5lZWRzIHRvIGJlIG51bWVyaWMsIGFuZCBncmVhdGVyIHRoYW4gMGApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHByZXBlbmRTdHJpbmcodmFsdWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFwicHJlcGVuZFN0cmluZ1wiIGNhbGxlZCBvbiAkeyB0aGlzLmNvbnN0cnVjdG9yLm5hbWUgfWApO1xuICB9XG5cbiAgaGFzUHJlcGVuZFN0cmluZyh2YWx1ZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgXCJoYXNQcmVwZW5kU3RyaW5nXCIgY2FsbGVkIG9uICR7IHRoaXMuY29uc3RydWN0b3IubmFtZSB9YCk7XG4gIH1cblxuICB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHNldHRpbmdzOiB7XG4gICAgICAgIG91dHB1dDogdGhpcy5vdXRwdXQsXG4gICAgICAgIHBpcGVsaW5lOiB0aGlzLnBpcGVsaW5lLFxuICAgICAgICBhcmd1bWVudE5hbWVzOiB0aGlzLmFyZ3VtZW50TmFtZXMsXG4gICAgICAgIGFyZ3VtZW50c1R5cGVzOiB0aGlzLmFyZ3VtZW50VHlwZXMsXG4gICAgICAgIGNvbnN0YW50czogdGhpcy5jb25zdGFudHMsXG4gICAgICAgIHBsdWdpbk5hbWVzOiB0aGlzLnBsdWdpbnMgPyB0aGlzLnBsdWdpbnMubWFwKHBsdWdpbiA9PiBwbHVnaW4ubmFtZSkgOiBudWxsLFxuICAgICAgICByZXR1cm5UeXBlOiB0aGlzLnJldHVyblR5cGUsXG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIGJ1aWxkU2lnbmF0dXJlKGFyZ3MpIHtcbiAgICBjb25zdCBDb25zdHJ1Y3RvciA9IHRoaXMuY29uc3RydWN0b3I7XG4gICAgdGhpcy5zaWduYXR1cmUgPSBDb25zdHJ1Y3Rvci5nZXRTaWduYXR1cmUodGhpcywgQ29uc3RydWN0b3IuZ2V0QXJndW1lbnRUeXBlcyh0aGlzLCBhcmdzKSk7XG4gIH1cblxuICBzdGF0aWMgZ2V0QXJndW1lbnRUeXBlcyhrZXJuZWwsIGFyZ3MpIHtcbiAgICBjb25zdCBhcmd1bWVudFR5cGVzID0gbmV3IEFycmF5KGFyZ3MubGVuZ3RoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGFyZyA9IGFyZ3NbaV07XG4gICAgICBjb25zdCB0eXBlID0ga2VybmVsLmFyZ3VtZW50VHlwZXNbaV07XG4gICAgICBpZiAoYXJnLnR5cGUpIHtcbiAgICAgICAgYXJndW1lbnRUeXBlc1tpXSA9IGFyZy50eXBlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgY2FzZSAnTnVtYmVyJzpcbiAgICAgICAgICBjYXNlICdJbnRlZ2VyJzpcbiAgICAgICAgICBjYXNlICdGbG9hdCc6XG4gICAgICAgICAgY2FzZSAnQXJyYXlUZXh0dXJlKDEpJzpcbiAgICAgICAgICAgIGFyZ3VtZW50VHlwZXNbaV0gPSB1dGlscy5nZXRWYXJpYWJsZVR5cGUoYXJnKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBhcmd1bWVudFR5cGVzW2ldID0gdHlwZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYXJndW1lbnRUeXBlcztcbiAgfVxuXG4gIHN0YXRpYyBnZXRTaWduYXR1cmUoa2VybmVsLCBhcmd1bWVudFR5cGVzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBcImdldFNpZ25hdHVyZVwiIG5vdCBpbXBsZW1lbnRlZCBvbiAkeyB0aGlzLm5hbWUgfWApO1xuICB9XG5cbiAgZnVuY3Rpb25Ub0lHUFVGdW5jdGlvbihzb3VyY2UsIHNldHRpbmdzID0ge30pIHtcbiAgICBpZiAodHlwZW9mIHNvdXJjZSAhPT0gJ3N0cmluZycgJiYgdHlwZW9mIHNvdXJjZSAhPT0gJ2Z1bmN0aW9uJykgdGhyb3cgbmV3IEVycm9yKCdzb3VyY2Ugbm90IGEgc3RyaW5nIG9yIGZ1bmN0aW9uJyk7XG4gICAgY29uc3Qgc291cmNlU3RyaW5nID0gdHlwZW9mIHNvdXJjZSA9PT0gJ3N0cmluZycgPyBzb3VyY2UgOiBzb3VyY2UudG9TdHJpbmcoKTtcbiAgICBsZXQgYXJndW1lbnRUeXBlcyA9IFtdO1xuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoc2V0dGluZ3MuYXJndW1lbnRUeXBlcykpIHtcbiAgICAgIGFyZ3VtZW50VHlwZXMgPSBzZXR0aW5ncy5hcmd1bWVudFR5cGVzO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHNldHRpbmdzLmFyZ3VtZW50VHlwZXMgPT09ICdvYmplY3QnKSB7XG4gICAgICBhcmd1bWVudFR5cGVzID0gdXRpbHMuZ2V0QXJndW1lbnROYW1lc0Zyb21TdHJpbmcoc291cmNlU3RyaW5nKVxuICAgICAgICAubWFwKG5hbWUgPT4gc2V0dGluZ3MuYXJndW1lbnRUeXBlc1tuYW1lXSkgfHwgW107XG4gICAgfSBlbHNlIHtcbiAgICAgIGFyZ3VtZW50VHlwZXMgPSBzZXR0aW5ncy5hcmd1bWVudFR5cGVzIHx8IFtdO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBuYW1lOiB1dGlscy5nZXRGdW5jdGlvbk5hbWVGcm9tU3RyaW5nKHNvdXJjZVN0cmluZykgfHwgbnVsbCxcbiAgICAgIHNvdXJjZTogc291cmNlU3RyaW5nLFxuICAgICAgYXJndW1lbnRUeXBlcyxcbiAgICAgIHJldHVyblR5cGU6IHNldHRpbmdzLnJldHVyblR5cGUgfHwgbnVsbCxcbiAgICB9O1xuICB9XG5cbiAgb25BY3RpdmF0ZShwcmV2aW91c0tlcm5lbCkge31cbn1cblxuZnVuY3Rpb24gc3BsaXRBcmd1bWVudFR5cGVzKGFyZ3VtZW50VHlwZXNPYmplY3QpIHtcbiAgY29uc3QgYXJndW1lbnROYW1lcyA9IE9iamVjdC5rZXlzKGFyZ3VtZW50VHlwZXNPYmplY3QpO1xuICBjb25zdCBhcmd1bWVudFR5cGVzID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYXJndW1lbnROYW1lcy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGFyZ3VtZW50TmFtZSA9IGFyZ3VtZW50TmFtZXNbaV07XG4gICAgYXJndW1lbnRUeXBlcy5wdXNoKGFyZ3VtZW50VHlwZXNPYmplY3RbYXJndW1lbnROYW1lXSk7XG4gIH1cbiAgcmV0dXJuIHsgYXJndW1lbnRUeXBlcywgYXJndW1lbnROYW1lcyB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgS2VybmVsXG59O1xufSx7XCIuLi9pbnB1dFwiOjExMCxcIi4uL3V0aWxzXCI6MTE0fV0sMzc6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuY29uc3QgZnJhZ21lbnRTaGFkZXIgPSBgX19IRUFERVJfXztcbl9fRkxPQVRfVEFDVElDX0RFQ0xBUkFUSU9OX187XG5fX0lOVF9UQUNUSUNfREVDTEFSQVRJT05fXztcbl9fU0FNUExFUl8yRF9UQUNUSUNfREVDTEFSQVRJT05fXztcblxuY29uc3QgaW50IExPT1BfTUFYID0gX19MT09QX01BWF9fO1xuXG5fX1BMVUdJTlNfXztcbl9fQ09OU1RBTlRTX187XG5cbnZhcnlpbmcgdmVjMiB2VGV4Q29vcmQ7XG5cbmZsb2F0IGFjb3NoKGZsb2F0IHgpIHtcbiAgcmV0dXJuIGxvZyh4ICsgc3FydCh4ICogeCAtIDEuMCkpO1xufVxuXG5mbG9hdCBzaW5oKGZsb2F0IHgpIHtcbiAgcmV0dXJuIChwb3coJHtNYXRoLkV9LCB4KSAtIHBvdygke01hdGguRX0sIC14KSkgLyAyLjA7XG59XG5cbmZsb2F0IGFzaW5oKGZsb2F0IHgpIHtcbiAgcmV0dXJuIGxvZyh4ICsgc3FydCh4ICogeCArIDEuMCkpO1xufVxuXG5mbG9hdCBhdGFuMihmbG9hdCB2MSwgZmxvYXQgdjIpIHtcbiAgaWYgKHYxID09IDAuMCB8fCB2MiA9PSAwLjApIHJldHVybiAwLjA7XG4gIHJldHVybiBhdGFuKHYxIC8gdjIpO1xufVxuXG5mbG9hdCBhdGFuaChmbG9hdCB4KSB7XG4gIHggPSAoeCArIDEuMCkgLyAoeCAtIDEuMCk7XG4gIGlmICh4IDwgMC4wKSB7XG4gICAgcmV0dXJuIDAuNSAqIGxvZygteCk7XG4gIH1cbiAgcmV0dXJuIDAuNSAqIGxvZyh4KTtcbn1cblxuZmxvYXQgY2JydChmbG9hdCB4KSB7XG4gIGlmICh4ID49IDAuMCkge1xuICAgIHJldHVybiBwb3coeCwgMS4wIC8gMy4wKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gLXBvdyh4LCAxLjAgLyAzLjApO1xuICB9XG59XG5cbmZsb2F0IGNvc2goZmxvYXQgeCkge1xuICByZXR1cm4gKHBvdygke01hdGguRX0sIHgpICsgcG93KCR7TWF0aC5FfSwgLXgpKSAvIDIuMDsgXG59XG5cbmZsb2F0IGV4cG0xKGZsb2F0IHgpIHtcbiAgcmV0dXJuIHBvdygke01hdGguRX0sIHgpIC0gMS4wOyBcbn1cblxuZmxvYXQgZnJvdW5kKGhpZ2hwIGZsb2F0IHgpIHtcbiAgcmV0dXJuIHg7XG59XG5cbmZsb2F0IGltdWwoZmxvYXQgdjEsIGZsb2F0IHYyKSB7XG4gIHJldHVybiBmbG9hdChpbnQodjEpICogaW50KHYyKSk7XG59XG5cbmZsb2F0IGxvZzEwKGZsb2F0IHgpIHtcbiAgcmV0dXJuIGxvZzIoeCkgKiAoMS4wIC8gbG9nMigxMC4wKSk7XG59XG5cbmZsb2F0IGxvZzFwKGZsb2F0IHgpIHtcbiAgcmV0dXJuIGxvZygxLjAgKyB4KTtcbn1cblxuZmxvYXQgX3BvdyhmbG9hdCB2MSwgZmxvYXQgdjIpIHtcbiAgaWYgKHYyID09IDAuMCkgcmV0dXJuIDEuMDtcbiAgcmV0dXJuIHBvdyh2MSwgdjIpO1xufVxuXG5mbG9hdCB0YW5oKGZsb2F0IHgpIHtcbiAgZmxvYXQgZSA9IGV4cCgyLjAgKiB4KTtcbiAgcmV0dXJuIChlIC0gMS4wKSAvIChlICsgMS4wKTtcbn1cblxuZmxvYXQgdHJ1bmMoZmxvYXQgeCkge1xuICBpZiAoeCA+PSAwLjApIHtcbiAgICByZXR1cm4gZmxvb3IoeCk7IFxuICB9IGVsc2Uge1xuICAgIHJldHVybiBjZWlsKHgpO1xuICB9XG59XG5cbnZlYzQgX3JvdW5kKHZlYzQgeCkge1xuICByZXR1cm4gZmxvb3IoeCArIDAuNSk7XG59XG5cbmZsb2F0IF9yb3VuZChmbG9hdCB4KSB7XG4gIHJldHVybiBmbG9vcih4ICsgMC41KTtcbn1cblxuY29uc3QgaW50IEJJVF9DT1VOVCA9IDMyO1xuaW50IG1vZGkoaW50IHgsIGludCB5KSB7XG4gIHJldHVybiB4IC0geSAqICh4IC8geSk7XG59XG5cbmludCBiaXR3aXNlT3IoaW50IGEsIGludCBiKSB7XG4gIGludCByZXN1bHQgPSAwO1xuICBpbnQgbiA9IDE7XG4gIFxuICBmb3IgKGludCBpID0gMDsgaSA8IEJJVF9DT1VOVDsgaSsrKSB7XG4gICAgaWYgKChtb2RpKGEsIDIpID09IDEpIHx8IChtb2RpKGIsIDIpID09IDEpKSB7XG4gICAgICByZXN1bHQgKz0gbjtcbiAgICB9XG4gICAgYSA9IGEgLyAyO1xuICAgIGIgPSBiIC8gMjtcbiAgICBuID0gbiAqIDI7XG4gICAgaWYoIShhID4gMCB8fCBiID4gMCkpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuaW50IGJpdHdpc2VYT1IoaW50IGEsIGludCBiKSB7XG4gIGludCByZXN1bHQgPSAwO1xuICBpbnQgbiA9IDE7XG4gIFxuICBmb3IgKGludCBpID0gMDsgaSA8IEJJVF9DT1VOVDsgaSsrKSB7XG4gICAgaWYgKChtb2RpKGEsIDIpID09IDEpICE9IChtb2RpKGIsIDIpID09IDEpKSB7XG4gICAgICByZXN1bHQgKz0gbjtcbiAgICB9XG4gICAgYSA9IGEgLyAyO1xuICAgIGIgPSBiIC8gMjtcbiAgICBuID0gbiAqIDI7XG4gICAgaWYoIShhID4gMCB8fCBiID4gMCkpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuaW50IGJpdHdpc2VBbmQoaW50IGEsIGludCBiKSB7XG4gIGludCByZXN1bHQgPSAwO1xuICBpbnQgbiA9IDE7XG4gIGZvciAoaW50IGkgPSAwOyBpIDwgQklUX0NPVU5UOyBpKyspIHtcbiAgICBpZiAoKG1vZGkoYSwgMikgPT0gMSkgJiYgKG1vZGkoYiwgMikgPT0gMSkpIHtcbiAgICAgIHJlc3VsdCArPSBuO1xuICAgIH1cbiAgICBhID0gYSAvIDI7XG4gICAgYiA9IGIgLyAyO1xuICAgIG4gPSBuICogMjtcbiAgICBpZighKGEgPiAwICYmIGIgPiAwKSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5pbnQgYml0d2lzZU5vdChpbnQgYSkge1xuICBpbnQgcmVzdWx0ID0gMDtcbiAgaW50IG4gPSAxO1xuICBcbiAgZm9yIChpbnQgaSA9IDA7IGkgPCBCSVRfQ09VTlQ7IGkrKykge1xuICAgIGlmIChtb2RpKGEsIDIpID09IDApIHtcbiAgICAgIHJlc3VsdCArPSBuOyAgICBcbiAgICB9XG4gICAgYSA9IGEgLyAyO1xuICAgIG4gPSBuICogMjtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuaW50IGJpdHdpc2VaZXJvRmlsbExlZnRTaGlmdChpbnQgbiwgaW50IHNoaWZ0KSB7XG4gIGludCBtYXhCeXRlcyA9IEJJVF9DT1VOVDtcbiAgZm9yIChpbnQgaSA9IDA7IGkgPCBCSVRfQ09VTlQ7IGkrKykge1xuICAgIGlmIChtYXhCeXRlcyA+PSBuKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgbWF4Qnl0ZXMgKj0gMjtcbiAgfVxuICBmb3IgKGludCBpID0gMDsgaSA8IEJJVF9DT1VOVDsgaSsrKSB7XG4gICAgaWYgKGkgPj0gc2hpZnQpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBuICo9IDI7XG4gIH1cblxuICBpbnQgcmVzdWx0ID0gMDtcbiAgaW50IGJ5dGVWYWwgPSAxO1xuICBmb3IgKGludCBpID0gMDsgaSA8IEJJVF9DT1VOVDsgaSsrKSB7XG4gICAgaWYgKGkgPj0gbWF4Qnl0ZXMpIGJyZWFrO1xuICAgIGlmIChtb2RpKG4sIDIpID4gMCkgeyByZXN1bHQgKz0gYnl0ZVZhbDsgfVxuICAgIG4gPSBpbnQobiAvIDIpO1xuICAgIGJ5dGVWYWwgKj0gMjtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5pbnQgYml0d2lzZVNpZ25lZFJpZ2h0U2hpZnQoaW50IG51bSwgaW50IHNoaWZ0cykge1xuICByZXR1cm4gaW50KGZsb29yKGZsb2F0KG51bSkgLyBwb3coMi4wLCBmbG9hdChzaGlmdHMpKSkpO1xufVxuXG5pbnQgYml0d2lzZVplcm9GaWxsUmlnaHRTaGlmdChpbnQgbiwgaW50IHNoaWZ0KSB7XG4gIGludCBtYXhCeXRlcyA9IEJJVF9DT1VOVDtcbiAgZm9yIChpbnQgaSA9IDA7IGkgPCBCSVRfQ09VTlQ7IGkrKykge1xuICAgIGlmIChtYXhCeXRlcyA+PSBuKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgbWF4Qnl0ZXMgKj0gMjtcbiAgfVxuICBmb3IgKGludCBpID0gMDsgaSA8IEJJVF9DT1VOVDsgaSsrKSB7XG4gICAgaWYgKGkgPj0gc2hpZnQpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBuIC89IDI7XG4gIH1cbiAgaW50IHJlc3VsdCA9IDA7XG4gIGludCBieXRlVmFsID0gMTtcbiAgZm9yIChpbnQgaSA9IDA7IGkgPCBCSVRfQ09VTlQ7IGkrKykge1xuICAgIGlmIChpID49IG1heEJ5dGVzKSBicmVhaztcbiAgICBpZiAobW9kaShuLCAyKSA+IDApIHsgcmVzdWx0ICs9IGJ5dGVWYWw7IH1cbiAgICBuID0gaW50KG4gLyAyKTtcbiAgICBieXRlVmFsICo9IDI7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxudmVjMiBpbnRlZ2VyTW9kKHZlYzIgeCwgZmxvYXQgeSkge1xuICB2ZWMyIHJlcyA9IGZsb29yKG1vZCh4LCB5KSk7XG4gIHJldHVybiByZXMgKiBzdGVwKDEuMCAtIGZsb29yKHkpLCAtcmVzKTtcbn1cblxudmVjMyBpbnRlZ2VyTW9kKHZlYzMgeCwgZmxvYXQgeSkge1xuICB2ZWMzIHJlcyA9IGZsb29yKG1vZCh4LCB5KSk7XG4gIHJldHVybiByZXMgKiBzdGVwKDEuMCAtIGZsb29yKHkpLCAtcmVzKTtcbn1cblxudmVjNCBpbnRlZ2VyTW9kKHZlYzQgeCwgdmVjNCB5KSB7XG4gIHZlYzQgcmVzID0gZmxvb3IobW9kKHgsIHkpKTtcbiAgcmV0dXJuIHJlcyAqIHN0ZXAoMS4wIC0gZmxvb3IoeSksIC1yZXMpO1xufVxuXG5mbG9hdCBpbnRlZ2VyTW9kKGZsb2F0IHgsIGZsb2F0IHkpIHtcbiAgZmxvYXQgcmVzID0gZmxvb3IobW9kKHgsIHkpKTtcbiAgcmV0dXJuIHJlcyAqIChyZXMgPiBmbG9vcih5KSAtIDEuMCA/IDAuMCA6IDEuMCk7XG59XG5cbmludCBpbnRlZ2VyTW9kKGludCB4LCBpbnQgeSkge1xuICByZXR1cm4geCAtICh5ICogaW50KHggLyB5KSk7XG59XG5cbl9fRElWSURFX1dJVEhfSU5URUdFUl9DSEVDS19fO1xuXG4vLyBIZXJlIGJlIGRyYWdvbnMhXG4vLyBETyBOT1QgT1BUSU1JWkUgVEhJUyBDT0RFXG4vLyBZT1UgV0lMTCBCUkVBSyBTT01FVEhJTkcgT04gU09NRUJPRFlcXCdTIE1BQ0hJTkVcbi8vIExFQVZFIElUIEFTIElUIElTLCBMRVNUIFlPVSBXQVNURSBZT1VSIE9XTiBUSU1FXG5jb25zdCB2ZWMyIE1BR0lDX1ZFQyA9IHZlYzIoMS4wLCAtMjU2LjApO1xuY29uc3QgdmVjNCBTQ0FMRV9GQUNUT1IgPSB2ZWM0KDEuMCwgMjU2LjAsIDY1NTM2LjAsIDAuMCk7XG5jb25zdCB2ZWM0IFNDQUxFX0ZBQ1RPUl9JTlYgPSB2ZWM0KDEuMCwgMC4wMDM5MDYyNSwgMC4wMDAwMTUyNTg3ODkwNjI1LCAwLjApOyAvLyAxLCAxLzI1NiwgMS82NTUzNlxuZmxvYXQgZGVjb2RlMzIodmVjNCB0ZXhlbCkge1xuICBfX0RFQ09ERTMyX0VORElBTk5FU1NfXztcbiAgdGV4ZWwgKj0gMjU1LjA7XG4gIHZlYzIgZ3RlMTI4O1xuICBndGUxMjgueCA9IHRleGVsLmIgPj0gMTI4LjAgPyAxLjAgOiAwLjA7XG4gIGd0ZTEyOC55ID0gdGV4ZWwuYSA+PSAxMjguMCA/IDEuMCA6IDAuMDtcbiAgZmxvYXQgZXhwb25lbnQgPSAyLjAgKiB0ZXhlbC5hIC0gMTI3LjAgKyBkb3QoZ3RlMTI4LCBNQUdJQ19WRUMpO1xuICBmbG9hdCByZXMgPSBleHAyKF9yb3VuZChleHBvbmVudCkpO1xuICB0ZXhlbC5iID0gdGV4ZWwuYiAtIDEyOC4wICogZ3RlMTI4Lng7XG4gIHJlcyA9IGRvdCh0ZXhlbCwgU0NBTEVfRkFDVE9SKSAqIGV4cDIoX3JvdW5kKGV4cG9uZW50LTIzLjApKSArIHJlcztcbiAgcmVzICo9IGd0ZTEyOC55ICogLTIuMCArIDEuMDtcbiAgcmV0dXJuIHJlcztcbn1cblxuZmxvYXQgZGVjb2RlMTYodmVjNCB0ZXhlbCwgaW50IGluZGV4KSB7XG4gIGludCBjaGFubmVsID0gaW50ZWdlck1vZChpbmRleCwgMik7XG4gIGlmIChjaGFubmVsID09IDApIHJldHVybiB0ZXhlbC5yICogMjU1LjAgKyB0ZXhlbC5nICogNjUyODAuMDtcbiAgaWYgKGNoYW5uZWwgPT0gMSkgcmV0dXJuIHRleGVsLmIgKiAyNTUuMCArIHRleGVsLmEgKiA2NTI4MC4wO1xuICByZXR1cm4gMC4wO1xufVxuXG5mbG9hdCBkZWNvZGU4KHZlYzQgdGV4ZWwsIGludCBpbmRleCkge1xuICBpbnQgY2hhbm5lbCA9IGludGVnZXJNb2QoaW5kZXgsIDQpO1xuICBpZiAoY2hhbm5lbCA9PSAwKSByZXR1cm4gdGV4ZWwuciAqIDI1NS4wO1xuICBpZiAoY2hhbm5lbCA9PSAxKSByZXR1cm4gdGV4ZWwuZyAqIDI1NS4wO1xuICBpZiAoY2hhbm5lbCA9PSAyKSByZXR1cm4gdGV4ZWwuYiAqIDI1NS4wO1xuICBpZiAoY2hhbm5lbCA9PSAzKSByZXR1cm4gdGV4ZWwuYSAqIDI1NS4wO1xuICByZXR1cm4gMC4wO1xufVxuXG52ZWM0IGxlZ2FjeUVuY29kZTMyKGZsb2F0IGYpIHtcbiAgZmxvYXQgRiA9IGFicyhmKTtcbiAgZmxvYXQgc2lnbiA9IGYgPCAwLjAgPyAxLjAgOiAwLjA7XG4gIGZsb2F0IGV4cG9uZW50ID0gZmxvb3IobG9nMihGKSk7XG4gIGZsb2F0IG1hbnRpc3NhID0gKGV4cDIoLWV4cG9uZW50KSAqIEYpO1xuICAvLyBleHBvbmVudCArPSBmbG9vcihsb2cyKG1hbnRpc3NhKSk7XG4gIHZlYzQgdGV4ZWwgPSB2ZWM0KEYgKiBleHAyKDIzLjAtZXhwb25lbnQpKSAqIFNDQUxFX0ZBQ1RPUl9JTlY7XG4gIHRleGVsLnJnID0gaW50ZWdlck1vZCh0ZXhlbC5yZywgMjU2LjApO1xuICB0ZXhlbC5iID0gaW50ZWdlck1vZCh0ZXhlbC5iLCAxMjguMCk7XG4gIHRleGVsLmEgPSBleHBvbmVudCowLjUgKyA2My41O1xuICB0ZXhlbC5iYSArPSB2ZWMyKGludGVnZXJNb2QoZXhwb25lbnQrMTI3LjAsIDIuMCksIHNpZ24pICogMTI4LjA7XG4gIHRleGVsID0gZmxvb3IodGV4ZWwpO1xuICB0ZXhlbCAqPSAwLjAwMzkyMTU2OTsgLy8gMS8yNTVcbiAgX19FTkNPREUzMl9FTkRJQU5ORVNTX187XG4gIHJldHVybiB0ZXhlbDtcbn1cblxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2dwdWpzL2dwdS5qcy93aWtpL0VuY29kZXItZGV0YWlsc1xudmVjNCBlbmNvZGUzMihmbG9hdCB2YWx1ZSkge1xuICBpZiAodmFsdWUgPT0gMC4wKSByZXR1cm4gdmVjNCgwLCAwLCAwLCAwKTtcblxuICBmbG9hdCBleHBvbmVudDtcbiAgZmxvYXQgbWFudGlzc2E7XG4gIHZlYzQgIHJlc3VsdDtcbiAgZmxvYXQgc2duO1xuXG4gIHNnbiA9IHN0ZXAoMC4wLCAtdmFsdWUpO1xuICB2YWx1ZSA9IGFicyh2YWx1ZSk7XG5cbiAgZXhwb25lbnQgPSBmbG9vcihsb2cyKHZhbHVlKSk7XG5cbiAgbWFudGlzc2EgPSB2YWx1ZSpwb3coMi4wLCAtZXhwb25lbnQpLTEuMDtcbiAgZXhwb25lbnQgPSBleHBvbmVudCsxMjcuMDtcbiAgcmVzdWx0ICAgPSB2ZWM0KDAsMCwwLDApO1xuXG4gIHJlc3VsdC5hID0gZmxvb3IoZXhwb25lbnQvMi4wKTtcbiAgZXhwb25lbnQgPSBleHBvbmVudCAtIHJlc3VsdC5hKjIuMDtcbiAgcmVzdWx0LmEgPSByZXN1bHQuYSArIDEyOC4wKnNnbjtcblxuICByZXN1bHQuYiA9IGZsb29yKG1hbnRpc3NhICogMTI4LjApO1xuICBtYW50aXNzYSA9IG1hbnRpc3NhIC0gcmVzdWx0LmIgLyAxMjguMDtcbiAgcmVzdWx0LmIgPSByZXN1bHQuYiArIGV4cG9uZW50KjEyOC4wO1xuXG4gIHJlc3VsdC5nID0gZmxvb3IobWFudGlzc2EqMzI3NjguMCk7XG4gIG1hbnRpc3NhID0gbWFudGlzc2EgLSByZXN1bHQuZy8zMjc2OC4wO1xuXG4gIHJlc3VsdC5yID0gZmxvb3IobWFudGlzc2EqODM4ODYwOC4wKTtcbiAgcmV0dXJuIHJlc3VsdC8yNTUuMDtcbn1cbi8vIERyYWdvbnMgZW5kIGhlcmVcblxuaW50IGluZGV4O1xuaXZlYzMgdGhyZWFkSWQ7XG5cbml2ZWMzIGluZGV4VG8zRChpbnQgaWR4LCBpdmVjMyB0ZXhEaW0pIHtcbiAgaW50IHogPSBpbnQoaWR4IC8gKHRleERpbS54ICogdGV4RGltLnkpKTtcbiAgaWR4IC09IHogKiBpbnQodGV4RGltLnggKiB0ZXhEaW0ueSk7XG4gIGludCB5ID0gaW50KGlkeCAvIHRleERpbS54KTtcbiAgaW50IHggPSBpbnQoaW50ZWdlck1vZChpZHgsIHRleERpbS54KSk7XG4gIHJldHVybiBpdmVjMyh4LCB5LCB6KTtcbn1cblxuZmxvYXQgZ2V0MzIoc2FtcGxlcjJEIHRleCwgaXZlYzIgdGV4U2l6ZSwgaXZlYzMgdGV4RGltLCBpbnQgeiwgaW50IHksIGludCB4KSB7XG4gIGludCBpbmRleCA9IHggKyB0ZXhEaW0ueCAqICh5ICsgdGV4RGltLnkgKiB6KTtcbiAgaW50IHcgPSB0ZXhTaXplLng7XG4gIHZlYzIgc3QgPSB2ZWMyKGZsb2F0KGludGVnZXJNb2QoaW5kZXgsIHcpKSwgZmxvYXQoaW5kZXggLyB3KSkgKyAwLjU7XG4gIHZlYzQgdGV4ZWwgPSB0ZXh0dXJlMkQodGV4LCBzdCAvIHZlYzIodGV4U2l6ZSkpO1xuICByZXR1cm4gZGVjb2RlMzIodGV4ZWwpO1xufVxuXG5mbG9hdCBnZXQxNihzYW1wbGVyMkQgdGV4LCBpdmVjMiB0ZXhTaXplLCBpdmVjMyB0ZXhEaW0sIGludCB6LCBpbnQgeSwgaW50IHgpIHtcbiAgaW50IGluZGV4ID0geCArIHRleERpbS54ICogKHkgKyB0ZXhEaW0ueSAqIHopO1xuICBpbnQgdyA9IHRleFNpemUueCAqIDI7XG4gIHZlYzIgc3QgPSB2ZWMyKGZsb2F0KGludGVnZXJNb2QoaW5kZXgsIHcpKSwgZmxvYXQoaW5kZXggLyB3KSkgKyAwLjU7XG4gIHZlYzQgdGV4ZWwgPSB0ZXh0dXJlMkQodGV4LCBzdCAvIHZlYzIodGV4U2l6ZS54ICogMiwgdGV4U2l6ZS55KSk7XG4gIHJldHVybiBkZWNvZGUxNih0ZXhlbCwgaW5kZXgpO1xufVxuXG5mbG9hdCBnZXQ4KHNhbXBsZXIyRCB0ZXgsIGl2ZWMyIHRleFNpemUsIGl2ZWMzIHRleERpbSwgaW50IHosIGludCB5LCBpbnQgeCkge1xuICBpbnQgaW5kZXggPSB4ICsgdGV4RGltLnggKiAoeSArIHRleERpbS55ICogeik7XG4gIGludCB3ID0gdGV4U2l6ZS54ICogNDtcbiAgdmVjMiBzdCA9IHZlYzIoZmxvYXQoaW50ZWdlck1vZChpbmRleCwgdykpLCBmbG9hdChpbmRleCAvIHcpKSArIDAuNTtcbiAgdmVjNCB0ZXhlbCA9IHRleHR1cmUyRCh0ZXgsIHN0IC8gdmVjMih0ZXhTaXplLnggKiA0LCB0ZXhTaXplLnkpKTtcbiAgcmV0dXJuIGRlY29kZTgodGV4ZWwsIGluZGV4KTtcbn1cblxuZmxvYXQgZ2V0TWVtb3J5T3B0aW1pemVkMzIoc2FtcGxlcjJEIHRleCwgaXZlYzIgdGV4U2l6ZSwgaXZlYzMgdGV4RGltLCBpbnQgeiwgaW50IHksIGludCB4KSB7XG4gIGludCBpbmRleCA9IHggKyB0ZXhEaW0ueCAqICh5ICsgdGV4RGltLnkgKiB6KTtcbiAgaW50IGNoYW5uZWwgPSBpbnRlZ2VyTW9kKGluZGV4LCA0KTtcbiAgaW5kZXggPSBpbmRleCAvIDQ7XG4gIGludCB3ID0gdGV4U2l6ZS54O1xuICB2ZWMyIHN0ID0gdmVjMihmbG9hdChpbnRlZ2VyTW9kKGluZGV4LCB3KSksIGZsb2F0KGluZGV4IC8gdykpICsgMC41O1xuICB2ZWM0IHRleGVsID0gdGV4dHVyZTJEKHRleCwgc3QgLyB2ZWMyKHRleFNpemUpKTtcbiAgaWYgKGNoYW5uZWwgPT0gMCkgcmV0dXJuIHRleGVsLnI7XG4gIGlmIChjaGFubmVsID09IDEpIHJldHVybiB0ZXhlbC5nO1xuICBpZiAoY2hhbm5lbCA9PSAyKSByZXR1cm4gdGV4ZWwuYjtcbiAgaWYgKGNoYW5uZWwgPT0gMykgcmV0dXJuIHRleGVsLmE7XG4gIHJldHVybiAwLjA7XG59XG5cbnZlYzQgZ2V0SW1hZ2UyRChzYW1wbGVyMkQgdGV4LCBpdmVjMiB0ZXhTaXplLCBpdmVjMyB0ZXhEaW0sIGludCB6LCBpbnQgeSwgaW50IHgpIHtcbiAgaW50IGluZGV4ID0geCArIHRleERpbS54ICogKHkgKyB0ZXhEaW0ueSAqIHopO1xuICBpbnQgdyA9IHRleFNpemUueDtcbiAgdmVjMiBzdCA9IHZlYzIoZmxvYXQoaW50ZWdlck1vZChpbmRleCwgdykpLCBmbG9hdChpbmRleCAvIHcpKSArIDAuNTtcbiAgcmV0dXJuIHRleHR1cmUyRCh0ZXgsIHN0IC8gdmVjMih0ZXhTaXplKSk7XG59XG5cbmZsb2F0IGdldEZsb2F0RnJvbVNhbXBsZXIyRChzYW1wbGVyMkQgdGV4LCBpdmVjMiB0ZXhTaXplLCBpdmVjMyB0ZXhEaW0sIGludCB6LCBpbnQgeSwgaW50IHgpIHtcbiAgdmVjNCByZXN1bHQgPSBnZXRJbWFnZTJEKHRleCwgdGV4U2l6ZSwgdGV4RGltLCB6LCB5LCB4KTtcbiAgcmV0dXJuIHJlc3VsdFswXTtcbn1cblxudmVjMiBnZXRWZWMyRnJvbVNhbXBsZXIyRChzYW1wbGVyMkQgdGV4LCBpdmVjMiB0ZXhTaXplLCBpdmVjMyB0ZXhEaW0sIGludCB6LCBpbnQgeSwgaW50IHgpIHtcbiAgdmVjNCByZXN1bHQgPSBnZXRJbWFnZTJEKHRleCwgdGV4U2l6ZSwgdGV4RGltLCB6LCB5LCB4KTtcbiAgcmV0dXJuIHZlYzIocmVzdWx0WzBdLCByZXN1bHRbMV0pO1xufVxuXG52ZWMyIGdldE1lbW9yeU9wdGltaXplZFZlYzIoc2FtcGxlcjJEIHRleCwgaXZlYzIgdGV4U2l6ZSwgaXZlYzMgdGV4RGltLCBpbnQgeiwgaW50IHksIGludCB4KSB7XG4gIGludCBpbmRleCA9IHggKyAodGV4RGltLnggKiAoeSArICh0ZXhEaW0ueSAqIHopKSk7XG4gIGludCBjaGFubmVsID0gaW50ZWdlck1vZChpbmRleCwgMik7XG4gIGluZGV4ID0gaW5kZXggLyAyO1xuICBpbnQgdyA9IHRleFNpemUueDtcbiAgdmVjMiBzdCA9IHZlYzIoZmxvYXQoaW50ZWdlck1vZChpbmRleCwgdykpLCBmbG9hdChpbmRleCAvIHcpKSArIDAuNTtcbiAgdmVjNCB0ZXhlbCA9IHRleHR1cmUyRCh0ZXgsIHN0IC8gdmVjMih0ZXhTaXplKSk7XG4gIGlmIChjaGFubmVsID09IDApIHJldHVybiB2ZWMyKHRleGVsLnIsIHRleGVsLmcpO1xuICBpZiAoY2hhbm5lbCA9PSAxKSByZXR1cm4gdmVjMih0ZXhlbC5iLCB0ZXhlbC5hKTtcbiAgcmV0dXJuIHZlYzIoMC4wLCAwLjApO1xufVxuXG52ZWMzIGdldFZlYzNGcm9tU2FtcGxlcjJEKHNhbXBsZXIyRCB0ZXgsIGl2ZWMyIHRleFNpemUsIGl2ZWMzIHRleERpbSwgaW50IHosIGludCB5LCBpbnQgeCkge1xuICB2ZWM0IHJlc3VsdCA9IGdldEltYWdlMkQodGV4LCB0ZXhTaXplLCB0ZXhEaW0sIHosIHksIHgpO1xuICByZXR1cm4gdmVjMyhyZXN1bHRbMF0sIHJlc3VsdFsxXSwgcmVzdWx0WzJdKTtcbn1cblxudmVjMyBnZXRNZW1vcnlPcHRpbWl6ZWRWZWMzKHNhbXBsZXIyRCB0ZXgsIGl2ZWMyIHRleFNpemUsIGl2ZWMzIHRleERpbSwgaW50IHosIGludCB5LCBpbnQgeCkge1xuICBpbnQgZmllbGRJbmRleCA9IDMgKiAoeCArIHRleERpbS54ICogKHkgKyB0ZXhEaW0ueSAqIHopKTtcbiAgaW50IHZlY3RvckluZGV4ID0gZmllbGRJbmRleCAvIDQ7XG4gIGludCB2ZWN0b3JPZmZzZXQgPSBmaWVsZEluZGV4IC0gdmVjdG9ySW5kZXggKiA0O1xuICBpbnQgcmVhZFkgPSB2ZWN0b3JJbmRleCAvIHRleFNpemUueDtcbiAgaW50IHJlYWRYID0gdmVjdG9ySW5kZXggLSByZWFkWSAqIHRleFNpemUueDtcbiAgdmVjNCB0ZXgxID0gdGV4dHVyZTJEKHRleCwgKHZlYzIocmVhZFgsIHJlYWRZKSArIDAuNSkgLyB2ZWMyKHRleFNpemUpKTtcbiAgXG4gIGlmICh2ZWN0b3JPZmZzZXQgPT0gMCkge1xuICAgIHJldHVybiB0ZXgxLnh5ejtcbiAgfSBlbHNlIGlmICh2ZWN0b3JPZmZzZXQgPT0gMSkge1xuICAgIHJldHVybiB0ZXgxLnl6dztcbiAgfSBlbHNlIHtcbiAgICByZWFkWCsrO1xuICAgIGlmIChyZWFkWCA+PSB0ZXhTaXplLngpIHtcbiAgICAgIHJlYWRYID0gMDtcbiAgICAgIHJlYWRZKys7XG4gICAgfVxuICAgIHZlYzQgdGV4MiA9IHRleHR1cmUyRCh0ZXgsIHZlYzIocmVhZFgsIHJlYWRZKSAvIHZlYzIodGV4U2l6ZSkpO1xuICAgIGlmICh2ZWN0b3JPZmZzZXQgPT0gMikge1xuICAgICAgcmV0dXJuIHZlYzModGV4MS56LCB0ZXgxLncsIHRleDIueCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB2ZWMzKHRleDEudywgdGV4Mi54LCB0ZXgyLnkpO1xuICAgIH1cbiAgfVxufVxuXG52ZWM0IGdldFZlYzRGcm9tU2FtcGxlcjJEKHNhbXBsZXIyRCB0ZXgsIGl2ZWMyIHRleFNpemUsIGl2ZWMzIHRleERpbSwgaW50IHosIGludCB5LCBpbnQgeCkge1xuICByZXR1cm4gZ2V0SW1hZ2UyRCh0ZXgsIHRleFNpemUsIHRleERpbSwgeiwgeSwgeCk7XG59XG5cbnZlYzQgZ2V0TWVtb3J5T3B0aW1pemVkVmVjNChzYW1wbGVyMkQgdGV4LCBpdmVjMiB0ZXhTaXplLCBpdmVjMyB0ZXhEaW0sIGludCB6LCBpbnQgeSwgaW50IHgpIHtcbiAgaW50IGluZGV4ID0geCArIHRleERpbS54ICogKHkgKyB0ZXhEaW0ueSAqIHopO1xuICBpbnQgY2hhbm5lbCA9IGludGVnZXJNb2QoaW5kZXgsIDIpO1xuICBpbnQgdyA9IHRleFNpemUueDtcbiAgdmVjMiBzdCA9IHZlYzIoZmxvYXQoaW50ZWdlck1vZChpbmRleCwgdykpLCBmbG9hdChpbmRleCAvIHcpKSArIDAuNTtcbiAgdmVjNCB0ZXhlbCA9IHRleHR1cmUyRCh0ZXgsIHN0IC8gdmVjMih0ZXhTaXplKSk7XG4gIHJldHVybiB2ZWM0KHRleGVsLnIsIHRleGVsLmcsIHRleGVsLmIsIHRleGVsLmEpO1xufVxuXG52ZWM0IGFjdHVhbENvbG9yO1xudm9pZCBjb2xvcihmbG9hdCByLCBmbG9hdCBnLCBmbG9hdCBiLCBmbG9hdCBhKSB7XG4gIGFjdHVhbENvbG9yID0gdmVjNChyLGcsYixhKTtcbn1cblxudm9pZCBjb2xvcihmbG9hdCByLCBmbG9hdCBnLCBmbG9hdCBiKSB7XG4gIGNvbG9yKHIsZyxiLDEuMCk7XG59XG5cbnZvaWQgY29sb3Ioc2FtcGxlcjJEIGltYWdlKSB7XG4gIGFjdHVhbENvbG9yID0gdGV4dHVyZTJEKGltYWdlLCB2VGV4Q29vcmQpO1xufVxuXG5mbG9hdCBtb2R1bG8oZmxvYXQgbnVtYmVyLCBmbG9hdCBkaXZpc29yKSB7XG4gIGlmIChudW1iZXIgPCAwLjApIHtcbiAgICBudW1iZXIgPSBhYnMobnVtYmVyKTtcbiAgICBpZiAoZGl2aXNvciA8IDAuMCkge1xuICAgICAgZGl2aXNvciA9IGFicyhkaXZpc29yKTtcbiAgICB9XG4gICAgcmV0dXJuIC1tb2QobnVtYmVyLCBkaXZpc29yKTtcbiAgfVxuICBpZiAoZGl2aXNvciA8IDAuMCkge1xuICAgIGRpdmlzb3IgPSBhYnMoZGl2aXNvcik7XG4gIH1cbiAgcmV0dXJuIG1vZChudW1iZXIsIGRpdmlzb3IpO1xufVxuXG5fX0lOSkVDVEVEX05BVElWRV9fO1xuX19NQUlOX0NPTlNUQU5UU19fO1xuX19NQUlOX0FSR1VNRU5UU19fO1xuX19LRVJORUxfXztcblxudm9pZCBtYWluKHZvaWQpIHtcbiAgaW5kZXggPSBpbnQodlRleENvb3JkLnMgKiBmbG9hdCh1VGV4U2l6ZS54KSkgKyBpbnQodlRleENvb3JkLnQgKiBmbG9hdCh1VGV4U2l6ZS55KSkgKiB1VGV4U2l6ZS54O1xuICBfX01BSU5fUkVTVUxUX187XG59YDtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGZyYWdtZW50U2hhZGVyXG59O1xufSx7fV0sMzg6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuY29uc3QgeyB1dGlscyB9ID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMnKTtcbmNvbnN0IHsgRnVuY3Rpb25Ob2RlIH0gPSByZXF1aXJlKCcuLi9mdW5jdGlvbi1ub2RlJyk7XG5cbmNsYXNzIFdlYkdMRnVuY3Rpb25Ob2RlIGV4dGVuZHMgRnVuY3Rpb25Ob2RlIHtcbiAgY29uc3RydWN0b3Ioc291cmNlLCBzZXR0aW5ncykge1xuICAgIHN1cGVyKHNvdXJjZSwgc2V0dGluZ3MpO1xuICAgIGlmIChzZXR0aW5ncyAmJiBzZXR0aW5ncy5oYXNPd25Qcm9wZXJ0eSgnZml4SW50ZWdlckRpdmlzaW9uQWNjdXJhY3knKSkge1xuICAgICAgdGhpcy5maXhJbnRlZ2VyRGl2aXNpb25BY2N1cmFjeSA9IHNldHRpbmdzLmZpeEludGVnZXJEaXZpc2lvbkFjY3VyYWN5O1xuICAgIH1cbiAgfVxuXG4gIGFzdENvbmRpdGlvbmFsRXhwcmVzc2lvbihhc3QsIHJldEFycikge1xuICAgIGlmIChhc3QudHlwZSAhPT0gJ0NvbmRpdGlvbmFsRXhwcmVzc2lvbicpIHtcbiAgICAgIHRocm93IHRoaXMuYXN0RXJyb3JPdXRwdXQoJ05vdCBhIGNvbmRpdGlvbmFsIGV4cHJlc3Npb24nLCBhc3QpO1xuICAgIH1cbiAgICBjb25zdCBjb25zZXF1ZW50VHlwZSA9IHRoaXMuZ2V0VHlwZShhc3QuY29uc2VxdWVudCk7XG4gICAgY29uc3QgYWx0ZXJuYXRlVHlwZSA9IHRoaXMuZ2V0VHlwZShhc3QuYWx0ZXJuYXRlKTtcbiAgICBpZiAoY29uc2VxdWVudFR5cGUgPT09IG51bGwgJiYgYWx0ZXJuYXRlVHlwZSA9PT0gbnVsbCkge1xuICAgICAgcmV0QXJyLnB1c2goJ2lmICgnKTtcbiAgICAgIHRoaXMuYXN0R2VuZXJpYyhhc3QudGVzdCwgcmV0QXJyKTtcbiAgICAgIHJldEFyci5wdXNoKCcpIHsnKTtcbiAgICAgIHRoaXMuYXN0R2VuZXJpYyhhc3QuY29uc2VxdWVudCwgcmV0QXJyKTtcbiAgICAgIHJldEFyci5wdXNoKCc7Jyk7XG4gICAgICByZXRBcnIucHVzaCgnfSBlbHNlIHsnKTtcbiAgICAgIHRoaXMuYXN0R2VuZXJpYyhhc3QuYWx0ZXJuYXRlLCByZXRBcnIpO1xuICAgICAgcmV0QXJyLnB1c2goJzsnKTtcbiAgICAgIHJldEFyci5wdXNoKCd9Jyk7XG4gICAgICByZXR1cm4gcmV0QXJyO1xuICAgIH1cbiAgICByZXRBcnIucHVzaCgnKCcpO1xuICAgIHRoaXMuYXN0R2VuZXJpYyhhc3QudGVzdCwgcmV0QXJyKTtcbiAgICByZXRBcnIucHVzaCgnPycpO1xuICAgIHRoaXMuYXN0R2VuZXJpYyhhc3QuY29uc2VxdWVudCwgcmV0QXJyKTtcbiAgICByZXRBcnIucHVzaCgnOicpO1xuICAgIHRoaXMuYXN0R2VuZXJpYyhhc3QuYWx0ZXJuYXRlLCByZXRBcnIpO1xuICAgIHJldEFyci5wdXNoKCcpJyk7XG4gICAgcmV0dXJuIHJldEFycjtcbiAgfVxuXG4gIGFzdEZ1bmN0aW9uKGFzdCwgcmV0QXJyKSB7XG4gICAgaWYgKHRoaXMuaXNSb290S2VybmVsKSB7XG4gICAgICByZXRBcnIucHVzaCgndm9pZCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoIXRoaXMucmV0dXJuVHlwZSkge1xuICAgICAgICBjb25zdCBsYXN0UmV0dXJuID0gdGhpcy5maW5kTGFzdFJldHVybigpO1xuICAgICAgICBpZiAobGFzdFJldHVybikge1xuICAgICAgICAgIHRoaXMucmV0dXJuVHlwZSA9IHRoaXMuZ2V0VHlwZShhc3QuYm9keSk7XG4gICAgICAgICAgaWYgKHRoaXMucmV0dXJuVHlwZSA9PT0gJ0xpdGVyYWxJbnRlZ2VyJykge1xuICAgICAgICAgICAgdGhpcy5yZXR1cm5UeXBlID0gJ051bWJlcic7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHsgcmV0dXJuVHlwZSB9ID0gdGhpcztcbiAgICAgIGlmICghcmV0dXJuVHlwZSkge1xuICAgICAgICByZXRBcnIucHVzaCgndm9pZCcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgdHlwZSA9IHR5cGVNYXBbcmV0dXJuVHlwZV07XG4gICAgICAgIGlmICghdHlwZSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgdW5rbm93biB0eXBlICR7cmV0dXJuVHlwZX1gKTtcbiAgICAgICAgfVxuICAgICAgICByZXRBcnIucHVzaCh0eXBlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0QXJyLnB1c2goJyAnKTtcbiAgICByZXRBcnIucHVzaCh0aGlzLm5hbWUpO1xuICAgIHJldEFyci5wdXNoKCcoJyk7XG5cbiAgICBpZiAoIXRoaXMuaXNSb290S2VybmVsKSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuYXJndW1lbnROYW1lcy5sZW5ndGg7ICsraSkge1xuICAgICAgICBjb25zdCBhcmd1bWVudE5hbWUgPSB0aGlzLmFyZ3VtZW50TmFtZXNbaV07XG5cbiAgICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgICAgcmV0QXJyLnB1c2goJywgJyk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGFyZ3VtZW50VHlwZSA9IHRoaXMuYXJndW1lbnRUeXBlc1t0aGlzLmFyZ3VtZW50TmFtZXMuaW5kZXhPZihhcmd1bWVudE5hbWUpXTtcbiAgICAgICAgaWYgKCFhcmd1bWVudFR5cGUpIHtcbiAgICAgICAgICB0aHJvdyB0aGlzLmFzdEVycm9yT3V0cHV0KGBVbmtub3duIGFyZ3VtZW50ICR7YXJndW1lbnROYW1lfSB0eXBlYCwgYXN0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYXJndW1lbnRUeXBlID09PSAnTGl0ZXJhbEludGVnZXInKSB7XG4gICAgICAgICAgdGhpcy5hcmd1bWVudFR5cGVzW2ldID0gYXJndW1lbnRUeXBlID0gJ051bWJlcic7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdHlwZSA9IHR5cGVNYXBbYXJndW1lbnRUeXBlXTtcbiAgICAgICAgaWYgKCF0eXBlKSB7XG4gICAgICAgICAgdGhyb3cgdGhpcy5hc3RFcnJvck91dHB1dCgnVW5leHBlY3RlZCBleHByZXNzaW9uJywgYXN0KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuYW1lID0gdXRpbHMuc2FuaXRpemVOYW1lKGFyZ3VtZW50TmFtZSk7XG4gICAgICAgIGlmICh0eXBlID09PSAnc2FtcGxlcjJEJyB8fCB0eXBlID09PSAnc2FtcGxlcjJEQXJyYXknKSB7XG4gICAgICAgICAgcmV0QXJyLnB1c2goYCR7dHlwZX0gdXNlcl8ke25hbWV9LGl2ZWMyIHVzZXJfJHtuYW1lfVNpemUsaXZlYzMgdXNlcl8ke25hbWV9RGltYCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0QXJyLnB1c2goYCR7dHlwZX0gdXNlcl8ke25hbWV9YCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXRBcnIucHVzaCgnKSB7XFxuJyk7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFzdC5ib2R5LmJvZHkubGVuZ3RoOyArK2kpIHtcbiAgICAgIHRoaXMuYXN0R2VuZXJpYyhhc3QuYm9keS5ib2R5W2ldLCByZXRBcnIpO1xuICAgICAgcmV0QXJyLnB1c2goJ1xcbicpO1xuICAgIH1cblxuICAgIHJldEFyci5wdXNoKCd9XFxuJyk7XG4gICAgcmV0dXJuIHJldEFycjtcbiAgfVxuXG4gIGFzdFJldHVyblN0YXRlbWVudChhc3QsIHJldEFycikge1xuICAgIGlmICghYXN0LmFyZ3VtZW50KSB0aHJvdyB0aGlzLmFzdEVycm9yT3V0cHV0KCdVbmV4cGVjdGVkIHJldHVybiBzdGF0ZW1lbnQnLCBhc3QpO1xuICAgIHRoaXMucHVzaFN0YXRlKCdza2lwLWxpdGVyYWwtY29ycmVjdGlvbicpO1xuICAgIGNvbnN0IHR5cGUgPSB0aGlzLmdldFR5cGUoYXN0LmFyZ3VtZW50KTtcbiAgICB0aGlzLnBvcFN0YXRlKCdza2lwLWxpdGVyYWwtY29ycmVjdGlvbicpO1xuXG4gICAgY29uc3QgcmVzdWx0ID0gW107XG5cbiAgICBpZiAoIXRoaXMucmV0dXJuVHlwZSkge1xuICAgICAgaWYgKHR5cGUgPT09ICdMaXRlcmFsSW50ZWdlcicgfHwgdHlwZSA9PT0gJ0ludGVnZXInKSB7XG4gICAgICAgIHRoaXMucmV0dXJuVHlwZSA9ICdOdW1iZXInO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5yZXR1cm5UeXBlID0gdHlwZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzd2l0Y2ggKHRoaXMucmV0dXJuVHlwZSkge1xuICAgICAgY2FzZSAnTGl0ZXJhbEludGVnZXInOlxuICAgICAgY2FzZSAnTnVtYmVyJzpcbiAgICAgIGNhc2UgJ0Zsb2F0JzpcbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgY2FzZSAnSW50ZWdlcic6XG4gICAgICAgICAgICByZXN1bHQucHVzaCgnZmxvYXQoJyk7XG4gICAgICAgICAgICB0aGlzLmFzdEdlbmVyaWMoYXN0LmFyZ3VtZW50LCByZXN1bHQpO1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goJyknKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ0xpdGVyYWxJbnRlZ2VyJzpcbiAgICAgICAgICAgIHRoaXMuY2FzdExpdGVyYWxUb0Zsb2F0KGFzdC5hcmd1bWVudCwgcmVzdWx0KTtcblxuICAgICAgICAgICAgaWYgKHRoaXMuZ2V0VHlwZShhc3QpID09PSAnSW50ZWdlcicpIHtcbiAgICAgICAgICAgICAgcmVzdWx0LnVuc2hpZnQoJ2Zsb2F0KCcpO1xuICAgICAgICAgICAgICByZXN1bHQucHVzaCgnKScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRoaXMuYXN0R2VuZXJpYyhhc3QuYXJndW1lbnQsIHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdJbnRlZ2VyJzpcbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgY2FzZSAnRmxvYXQnOlxuICAgICAgICAgIGNhc2UgJ051bWJlcic6XG4gICAgICAgICAgICB0aGlzLmNhc3RWYWx1ZVRvSW50ZWdlcihhc3QuYXJndW1lbnQsIHJlc3VsdCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdMaXRlcmFsSW50ZWdlcic6XG4gICAgICAgICAgICB0aGlzLmNhc3RMaXRlcmFsVG9JbnRlZ2VyKGFzdC5hcmd1bWVudCwgcmVzdWx0KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aGlzLmFzdEdlbmVyaWMoYXN0LmFyZ3VtZW50LCByZXN1bHQpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnQXJyYXkoNCknOlxuICAgICAgY2FzZSAnQXJyYXkoMyknOlxuICAgICAgY2FzZSAnQXJyYXkoMiknOlxuICAgICAgY2FzZSAnTWF0cml4KDIpJzpcbiAgICAgIGNhc2UgJ01hdHJpeCgzKSc6XG4gICAgICBjYXNlICdNYXRyaXgoNCknOlxuICAgICAgY2FzZSAnSW5wdXQnOlxuICAgICAgICB0aGlzLmFzdEdlbmVyaWMoYXN0LmFyZ3VtZW50LCByZXN1bHQpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IHRoaXMuYXN0RXJyb3JPdXRwdXQoYHVuaGFuZGxlZCByZXR1cm4gdHlwZSAke3RoaXMucmV0dXJuVHlwZX1gLCBhc3QpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmlzUm9vdEtlcm5lbCkge1xuICAgICAgcmV0QXJyLnB1c2goYGtlcm5lbFJlc3VsdCA9ICR7IHJlc3VsdC5qb2luKCcnKSB9O2ApO1xuICAgICAgcmV0QXJyLnB1c2goJ3JldHVybjsnKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuaXNTdWJLZXJuZWwpIHtcbiAgICAgIHJldEFyci5wdXNoKGBzdWJLZXJuZWxSZXN1bHRfJHsgdGhpcy5uYW1lIH0gPSAkeyByZXN1bHQuam9pbignJykgfTtgKTtcbiAgICAgIHJldEFyci5wdXNoKGByZXR1cm4gc3ViS2VybmVsUmVzdWx0XyR7IHRoaXMubmFtZSB9O2ApO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXRBcnIucHVzaChgcmV0dXJuICR7IHJlc3VsdC5qb2luKCcnKSB9O2ApO1xuICAgIH1cbiAgICByZXR1cm4gcmV0QXJyO1xuICB9XG5cbiAgYXN0TGl0ZXJhbChhc3QsIHJldEFycikge1xuICAgIGlmIChpc05hTihhc3QudmFsdWUpKSB7XG4gICAgICB0aHJvdyB0aGlzLmFzdEVycm9yT3V0cHV0KFxuICAgICAgICAnTm9uLW51bWVyaWMgbGl0ZXJhbCBub3Qgc3VwcG9ydGVkIDogJyArIGFzdC52YWx1ZSxcbiAgICAgICAgYXN0XG4gICAgICApO1xuICAgIH1cblxuICAgIGNvbnN0IGtleSA9IHRoaXMuYXN0S2V5KGFzdCk7XG4gICAgaWYgKE51bWJlci5pc0ludGVnZXIoYXN0LnZhbHVlKSkge1xuICAgICAgaWYgKHRoaXMuaXNTdGF0ZSgnY2FzdGluZy10by1pbnRlZ2VyJykgfHwgdGhpcy5pc1N0YXRlKCdidWlsZGluZy1pbnRlZ2VyJykpIHtcbiAgICAgICAgdGhpcy5saXRlcmFsVHlwZXNba2V5XSA9ICdJbnRlZ2VyJztcbiAgICAgICAgcmV0QXJyLnB1c2goYCR7YXN0LnZhbHVlfWApO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLmlzU3RhdGUoJ2Nhc3RpbmctdG8tZmxvYXQnKSB8fCB0aGlzLmlzU3RhdGUoJ2J1aWxkaW5nLWZsb2F0JykpIHtcbiAgICAgICAgdGhpcy5saXRlcmFsVHlwZXNba2V5XSA9ICdOdW1iZXInO1xuICAgICAgICByZXRBcnIucHVzaChgJHthc3QudmFsdWV9LjBgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMubGl0ZXJhbFR5cGVzW2tleV0gPSAnTnVtYmVyJztcbiAgICAgICAgcmV0QXJyLnB1c2goYCR7YXN0LnZhbHVlfS4wYCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0aGlzLmlzU3RhdGUoJ2Nhc3RpbmctdG8taW50ZWdlcicpIHx8IHRoaXMuaXNTdGF0ZSgnYnVpbGRpbmctaW50ZWdlcicpKSB7XG4gICAgICB0aGlzLmxpdGVyYWxUeXBlc1trZXldID0gJ0ludGVnZXInO1xuICAgICAgcmV0QXJyLnB1c2goTWF0aC5yb3VuZChhc3QudmFsdWUpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5saXRlcmFsVHlwZXNba2V5XSA9ICdOdW1iZXInO1xuICAgICAgcmV0QXJyLnB1c2goYCR7YXN0LnZhbHVlfWApO1xuICAgIH1cbiAgICByZXR1cm4gcmV0QXJyO1xuICB9XG5cbiAgYXN0QmluYXJ5RXhwcmVzc2lvbihhc3QsIHJldEFycikge1xuICAgIGlmICh0aGlzLmNoZWNrQW5kVXBjb252ZXJ0T3BlcmF0b3IoYXN0LCByZXRBcnIpKSB7XG4gICAgICByZXR1cm4gcmV0QXJyO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmZpeEludGVnZXJEaXZpc2lvbkFjY3VyYWN5ICYmIGFzdC5vcGVyYXRvciA9PT0gJy8nKSB7XG4gICAgICByZXRBcnIucHVzaCgnZGl2V2l0aEludENoZWNrKCcpO1xuICAgICAgdGhpcy5wdXNoU3RhdGUoJ2J1aWxkaW5nLWZsb2F0Jyk7XG4gICAgICBzd2l0Y2ggKHRoaXMuZ2V0VHlwZShhc3QubGVmdCkpIHtcbiAgICAgICAgY2FzZSAnSW50ZWdlcic6XG4gICAgICAgICAgdGhpcy5jYXN0VmFsdWVUb0Zsb2F0KGFzdC5sZWZ0LCByZXRBcnIpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdMaXRlcmFsSW50ZWdlcic6XG4gICAgICAgICAgdGhpcy5jYXN0TGl0ZXJhbFRvRmxvYXQoYXN0LmxlZnQsIHJldEFycik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhpcy5hc3RHZW5lcmljKGFzdC5sZWZ0LCByZXRBcnIpO1xuICAgICAgfVxuICAgICAgcmV0QXJyLnB1c2goJywgJyk7XG4gICAgICBzd2l0Y2ggKHRoaXMuZ2V0VHlwZShhc3QucmlnaHQpKSB7XG4gICAgICAgIGNhc2UgJ0ludGVnZXInOlxuICAgICAgICAgIHRoaXMuY2FzdFZhbHVlVG9GbG9hdChhc3QucmlnaHQsIHJldEFycik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ0xpdGVyYWxJbnRlZ2VyJzpcbiAgICAgICAgICB0aGlzLmNhc3RMaXRlcmFsVG9GbG9hdChhc3QucmlnaHQsIHJldEFycik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhpcy5hc3RHZW5lcmljKGFzdC5yaWdodCwgcmV0QXJyKTtcbiAgICAgIH1cbiAgICAgIHRoaXMucG9wU3RhdGUoJ2J1aWxkaW5nLWZsb2F0Jyk7XG4gICAgICByZXRBcnIucHVzaCgnKScpO1xuICAgICAgcmV0dXJuIHJldEFycjtcbiAgICB9XG5cbiAgICByZXRBcnIucHVzaCgnKCcpO1xuICAgIGNvbnN0IGxlZnRUeXBlID0gdGhpcy5nZXRUeXBlKGFzdC5sZWZ0KSB8fCAnTnVtYmVyJztcbiAgICBjb25zdCByaWdodFR5cGUgPSB0aGlzLmdldFR5cGUoYXN0LnJpZ2h0KSB8fCAnTnVtYmVyJztcbiAgICBpZiAoIWxlZnRUeXBlIHx8ICFyaWdodFR5cGUpIHtcbiAgICAgIHRocm93IHRoaXMuYXN0RXJyb3JPdXRwdXQoYFVuaGFuZGxlZCBiaW5hcnkgZXhwcmVzc2lvbmAsIGFzdCk7XG4gICAgfVxuICAgIGNvbnN0IGtleSA9IGxlZnRUeXBlICsgJyAmICcgKyByaWdodFR5cGU7XG4gICAgc3dpdGNoIChrZXkpIHtcbiAgICAgIGNhc2UgJ0ludGVnZXIgJiBJbnRlZ2VyJzpcbiAgICAgICAgdGhpcy5wdXNoU3RhdGUoJ2J1aWxkaW5nLWludGVnZXInKTtcbiAgICAgICAgdGhpcy5hc3RHZW5lcmljKGFzdC5sZWZ0LCByZXRBcnIpO1xuICAgICAgICByZXRBcnIucHVzaChvcGVyYXRvck1hcFthc3Qub3BlcmF0b3JdIHx8IGFzdC5vcGVyYXRvcik7XG4gICAgICAgIHRoaXMuYXN0R2VuZXJpYyhhc3QucmlnaHQsIHJldEFycik7XG4gICAgICAgIHRoaXMucG9wU3RhdGUoJ2J1aWxkaW5nLWludGVnZXInKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdOdW1iZXIgJiBGbG9hdCc6XG4gICAgICBjYXNlICdGbG9hdCAmIE51bWJlcic6XG4gICAgICBjYXNlICdGbG9hdCAmIEZsb2F0JzpcbiAgICAgIGNhc2UgJ051bWJlciAmIE51bWJlcic6XG4gICAgICAgIHRoaXMucHVzaFN0YXRlKCdidWlsZGluZy1mbG9hdCcpO1xuICAgICAgICB0aGlzLmFzdEdlbmVyaWMoYXN0LmxlZnQsIHJldEFycik7XG4gICAgICAgIHJldEFyci5wdXNoKG9wZXJhdG9yTWFwW2FzdC5vcGVyYXRvcl0gfHwgYXN0Lm9wZXJhdG9yKTtcbiAgICAgICAgdGhpcy5hc3RHZW5lcmljKGFzdC5yaWdodCwgcmV0QXJyKTtcbiAgICAgICAgdGhpcy5wb3BTdGF0ZSgnYnVpbGRpbmctZmxvYXQnKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdMaXRlcmFsSW50ZWdlciAmIExpdGVyYWxJbnRlZ2VyJzpcbiAgICAgICAgaWYgKHRoaXMuaXNTdGF0ZSgnY2FzdGluZy10by1pbnRlZ2VyJykgfHwgdGhpcy5pc1N0YXRlKCdidWlsZGluZy1pbnRlZ2VyJykpIHtcbiAgICAgICAgICB0aGlzLnB1c2hTdGF0ZSgnYnVpbGRpbmctaW50ZWdlcicpO1xuICAgICAgICAgIHRoaXMuYXN0R2VuZXJpYyhhc3QubGVmdCwgcmV0QXJyKTtcbiAgICAgICAgICByZXRBcnIucHVzaChvcGVyYXRvck1hcFthc3Qub3BlcmF0b3JdIHx8IGFzdC5vcGVyYXRvcik7XG4gICAgICAgICAgdGhpcy5hc3RHZW5lcmljKGFzdC5yaWdodCwgcmV0QXJyKTtcbiAgICAgICAgICB0aGlzLnBvcFN0YXRlKCdidWlsZGluZy1pbnRlZ2VyJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5wdXNoU3RhdGUoJ2J1aWxkaW5nLWZsb2F0Jyk7XG4gICAgICAgICAgdGhpcy5jYXN0TGl0ZXJhbFRvRmxvYXQoYXN0LmxlZnQsIHJldEFycik7XG4gICAgICAgICAgcmV0QXJyLnB1c2gob3BlcmF0b3JNYXBbYXN0Lm9wZXJhdG9yXSB8fCBhc3Qub3BlcmF0b3IpO1xuICAgICAgICAgIHRoaXMuY2FzdExpdGVyYWxUb0Zsb2F0KGFzdC5yaWdodCwgcmV0QXJyKTtcbiAgICAgICAgICB0aGlzLnBvcFN0YXRlKCdidWlsZGluZy1mbG9hdCcpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdJbnRlZ2VyICYgRmxvYXQnOlxuICAgICAgY2FzZSAnSW50ZWdlciAmIE51bWJlcic6XG4gICAgICAgIGlmIChhc3Qub3BlcmF0b3IgPT09ICc+JyB8fCBhc3Qub3BlcmF0b3IgPT09ICc8JyAmJiBhc3QucmlnaHQudHlwZSA9PT0gJ0xpdGVyYWwnKSB7XG4gICAgICAgICAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKGFzdC5yaWdodC52YWx1ZSkpIHtcbiAgICAgICAgICAgIHRoaXMucHVzaFN0YXRlKCdidWlsZGluZy1mbG9hdCcpO1xuICAgICAgICAgICAgdGhpcy5jYXN0VmFsdWVUb0Zsb2F0KGFzdC5sZWZ0LCByZXRBcnIpO1xuICAgICAgICAgICAgcmV0QXJyLnB1c2gob3BlcmF0b3JNYXBbYXN0Lm9wZXJhdG9yXSB8fCBhc3Qub3BlcmF0b3IpO1xuICAgICAgICAgICAgdGhpcy5hc3RHZW5lcmljKGFzdC5yaWdodCwgcmV0QXJyKTtcbiAgICAgICAgICAgIHRoaXMucG9wU3RhdGUoJ2J1aWxkaW5nLWZsb2F0Jyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wdXNoU3RhdGUoJ2J1aWxkaW5nLWludGVnZXInKTtcbiAgICAgICAgdGhpcy5hc3RHZW5lcmljKGFzdC5sZWZ0LCByZXRBcnIpO1xuICAgICAgICByZXRBcnIucHVzaChvcGVyYXRvck1hcFthc3Qub3BlcmF0b3JdIHx8IGFzdC5vcGVyYXRvcik7XG4gICAgICAgIHRoaXMucHVzaFN0YXRlKCdjYXN0aW5nLXRvLWludGVnZXInKTtcbiAgICAgICAgaWYgKGFzdC5yaWdodC50eXBlID09PSAnTGl0ZXJhbCcpIHtcbiAgICAgICAgICBjb25zdCBsaXRlcmFsUmVzdWx0ID0gW107XG4gICAgICAgICAgdGhpcy5hc3RHZW5lcmljKGFzdC5yaWdodCwgbGl0ZXJhbFJlc3VsdCk7XG4gICAgICAgICAgY29uc3QgbGl0ZXJhbFR5cGUgPSB0aGlzLmdldFR5cGUoYXN0LnJpZ2h0KTtcbiAgICAgICAgICBpZiAobGl0ZXJhbFR5cGUgPT09ICdJbnRlZ2VyJykge1xuICAgICAgICAgICAgcmV0QXJyLnB1c2gobGl0ZXJhbFJlc3VsdC5qb2luKCcnKSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IHRoaXMuYXN0RXJyb3JPdXRwdXQoYFVuaGFuZGxlZCBiaW5hcnkgZXhwcmVzc2lvbiB3aXRoIGxpdGVyYWxgLCBhc3QpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXRBcnIucHVzaCgnaW50KCcpO1xuICAgICAgICAgIHRoaXMuYXN0R2VuZXJpYyhhc3QucmlnaHQsIHJldEFycik7XG4gICAgICAgICAgcmV0QXJyLnB1c2goJyknKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBvcFN0YXRlKCdjYXN0aW5nLXRvLWludGVnZXInKTtcbiAgICAgICAgdGhpcy5wb3BTdGF0ZSgnYnVpbGRpbmctaW50ZWdlcicpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ0ludGVnZXIgJiBMaXRlcmFsSW50ZWdlcic6XG4gICAgICAgIHRoaXMucHVzaFN0YXRlKCdidWlsZGluZy1pbnRlZ2VyJyk7XG4gICAgICAgIHRoaXMuYXN0R2VuZXJpYyhhc3QubGVmdCwgcmV0QXJyKTtcbiAgICAgICAgcmV0QXJyLnB1c2gob3BlcmF0b3JNYXBbYXN0Lm9wZXJhdG9yXSB8fCBhc3Qub3BlcmF0b3IpO1xuICAgICAgICB0aGlzLmNhc3RMaXRlcmFsVG9JbnRlZ2VyKGFzdC5yaWdodCwgcmV0QXJyKTtcbiAgICAgICAgdGhpcy5wb3BTdGF0ZSgnYnVpbGRpbmctaW50ZWdlcicpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnTnVtYmVyICYgSW50ZWdlcic6XG4gICAgICAgIHRoaXMucHVzaFN0YXRlKCdidWlsZGluZy1mbG9hdCcpO1xuICAgICAgICB0aGlzLmFzdEdlbmVyaWMoYXN0LmxlZnQsIHJldEFycik7XG4gICAgICAgIHJldEFyci5wdXNoKG9wZXJhdG9yTWFwW2FzdC5vcGVyYXRvcl0gfHwgYXN0Lm9wZXJhdG9yKTtcbiAgICAgICAgdGhpcy5jYXN0VmFsdWVUb0Zsb2F0KGFzdC5yaWdodCwgcmV0QXJyKTtcbiAgICAgICAgdGhpcy5wb3BTdGF0ZSgnYnVpbGRpbmctZmxvYXQnKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdGbG9hdCAmIExpdGVyYWxJbnRlZ2VyJzpcbiAgICAgIGNhc2UgJ051bWJlciAmIExpdGVyYWxJbnRlZ2VyJzpcbiAgICAgICAgdGhpcy5wdXNoU3RhdGUoJ2J1aWxkaW5nLWZsb2F0Jyk7XG4gICAgICAgIHRoaXMuYXN0R2VuZXJpYyhhc3QubGVmdCwgcmV0QXJyKTtcbiAgICAgICAgcmV0QXJyLnB1c2gob3BlcmF0b3JNYXBbYXN0Lm9wZXJhdG9yXSB8fCBhc3Qub3BlcmF0b3IpO1xuICAgICAgICB0aGlzLmNhc3RMaXRlcmFsVG9GbG9hdChhc3QucmlnaHQsIHJldEFycik7XG4gICAgICAgIHRoaXMucG9wU3RhdGUoJ2J1aWxkaW5nLWZsb2F0Jyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnTGl0ZXJhbEludGVnZXIgJiBGbG9hdCc6XG4gICAgICBjYXNlICdMaXRlcmFsSW50ZWdlciAmIE51bWJlcic6XG4gICAgICAgIGlmICh0aGlzLmlzU3RhdGUoJ2Nhc3RpbmctdG8taW50ZWdlcicpKSB7XG4gICAgICAgICAgdGhpcy5wdXNoU3RhdGUoJ2J1aWxkaW5nLWludGVnZXInKTtcbiAgICAgICAgICB0aGlzLmNhc3RMaXRlcmFsVG9JbnRlZ2VyKGFzdC5sZWZ0LCByZXRBcnIpO1xuICAgICAgICAgIHJldEFyci5wdXNoKG9wZXJhdG9yTWFwW2FzdC5vcGVyYXRvcl0gfHwgYXN0Lm9wZXJhdG9yKTtcbiAgICAgICAgICB0aGlzLmNhc3RWYWx1ZVRvSW50ZWdlcihhc3QucmlnaHQsIHJldEFycik7XG4gICAgICAgICAgdGhpcy5wb3BTdGF0ZSgnYnVpbGRpbmctaW50ZWdlcicpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMucHVzaFN0YXRlKCdidWlsZGluZy1mbG9hdCcpO1xuICAgICAgICAgIHRoaXMuYXN0R2VuZXJpYyhhc3QubGVmdCwgcmV0QXJyKTtcbiAgICAgICAgICByZXRBcnIucHVzaChvcGVyYXRvck1hcFthc3Qub3BlcmF0b3JdIHx8IGFzdC5vcGVyYXRvcik7XG4gICAgICAgICAgdGhpcy5wdXNoU3RhdGUoJ2Nhc3RpbmctdG8tZmxvYXQnKTtcbiAgICAgICAgICB0aGlzLmFzdEdlbmVyaWMoYXN0LnJpZ2h0LCByZXRBcnIpO1xuICAgICAgICAgIHRoaXMucG9wU3RhdGUoJ2Nhc3RpbmctdG8tZmxvYXQnKTtcbiAgICAgICAgICB0aGlzLnBvcFN0YXRlKCdidWlsZGluZy1mbG9hdCcpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnTGl0ZXJhbEludGVnZXIgJiBJbnRlZ2VyJzpcbiAgICAgICAgdGhpcy5wdXNoU3RhdGUoJ2J1aWxkaW5nLWludGVnZXInKTtcbiAgICAgICAgdGhpcy5jYXN0TGl0ZXJhbFRvSW50ZWdlcihhc3QubGVmdCwgcmV0QXJyKTtcbiAgICAgICAgcmV0QXJyLnB1c2gob3BlcmF0b3JNYXBbYXN0Lm9wZXJhdG9yXSB8fCBhc3Qub3BlcmF0b3IpO1xuICAgICAgICB0aGlzLmFzdEdlbmVyaWMoYXN0LnJpZ2h0LCByZXRBcnIpO1xuICAgICAgICB0aGlzLnBvcFN0YXRlKCdidWlsZGluZy1pbnRlZ2VyJyk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdCb29sZWFuICYgQm9vbGVhbic6XG4gICAgICAgIHRoaXMucHVzaFN0YXRlKCdidWlsZGluZy1ib29sZWFuJyk7XG4gICAgICAgIHRoaXMuYXN0R2VuZXJpYyhhc3QubGVmdCwgcmV0QXJyKTtcbiAgICAgICAgcmV0QXJyLnB1c2gob3BlcmF0b3JNYXBbYXN0Lm9wZXJhdG9yXSB8fCBhc3Qub3BlcmF0b3IpO1xuICAgICAgICB0aGlzLmFzdEdlbmVyaWMoYXN0LnJpZ2h0LCByZXRBcnIpO1xuICAgICAgICB0aGlzLnBvcFN0YXRlKCdidWlsZGluZy1ib29sZWFuJyk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdGbG9hdCAmIEludGVnZXInOlxuICAgICAgICB0aGlzLnB1c2hTdGF0ZSgnYnVpbGRpbmctZmxvYXQnKTtcbiAgICAgICAgdGhpcy5hc3RHZW5lcmljKGFzdC5sZWZ0LCByZXRBcnIpO1xuICAgICAgICByZXRBcnIucHVzaChvcGVyYXRvck1hcFthc3Qub3BlcmF0b3JdIHx8IGFzdC5vcGVyYXRvcik7XG4gICAgICAgIHRoaXMuY2FzdFZhbHVlVG9GbG9hdChhc3QucmlnaHQsIHJldEFycik7XG4gICAgICAgIHRoaXMucG9wU3RhdGUoJ2J1aWxkaW5nLWZsb2F0Jyk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyB0aGlzLmFzdEVycm9yT3V0cHV0KGBVbmhhbmRsZWQgYmluYXJ5IGV4cHJlc3Npb24gYmV0d2VlbiAke2tleX1gLCBhc3QpO1xuICAgIH1cbiAgICByZXRBcnIucHVzaCgnKScpO1xuXG4gICAgcmV0dXJuIHJldEFycjtcbiAgfVxuXG4gIGNoZWNrQW5kVXBjb252ZXJ0T3BlcmF0b3IoYXN0LCByZXRBcnIpIHtcbiAgICBjb25zdCBiaXR3aXNlUmVzdWx0ID0gdGhpcy5jaGVja0FuZFVwY29udmVydEJpdHdpc2VPcGVyYXRvcnMoYXN0LCByZXRBcnIpO1xuICAgIGlmIChiaXR3aXNlUmVzdWx0KSB7XG4gICAgICByZXR1cm4gYml0d2lzZVJlc3VsdDtcbiAgICB9XG4gICAgY29uc3QgdXBjb252ZXJ0YWJsZU9wZXJhdG9ycyA9IHtcbiAgICAgICclJzogdGhpcy5maXhJbnRlZ2VyRGl2aXNpb25BY2N1cmFjeSA/ICdpbnRlZ2VyQ29ycmVjdGlvbk1vZHVsbycgOiAnbW9kdWxvJyxcbiAgICAgICcqKic6ICdwb3cnLFxuICAgIH07XG4gICAgY29uc3QgZm91bmRPcGVyYXRvciA9IHVwY29udmVydGFibGVPcGVyYXRvcnNbYXN0Lm9wZXJhdG9yXTtcbiAgICBpZiAoIWZvdW5kT3BlcmF0b3IpIHJldHVybiBudWxsO1xuICAgIHJldEFyci5wdXNoKGZvdW5kT3BlcmF0b3IpO1xuICAgIHJldEFyci5wdXNoKCcoJyk7XG4gICAgc3dpdGNoICh0aGlzLmdldFR5cGUoYXN0LmxlZnQpKSB7XG4gICAgICBjYXNlICdJbnRlZ2VyJzpcbiAgICAgICAgdGhpcy5jYXN0VmFsdWVUb0Zsb2F0KGFzdC5sZWZ0LCByZXRBcnIpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ0xpdGVyYWxJbnRlZ2VyJzpcbiAgICAgICAgdGhpcy5jYXN0TGl0ZXJhbFRvRmxvYXQoYXN0LmxlZnQsIHJldEFycik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhpcy5hc3RHZW5lcmljKGFzdC5sZWZ0LCByZXRBcnIpO1xuICAgIH1cbiAgICByZXRBcnIucHVzaCgnLCcpO1xuICAgIHN3aXRjaCAodGhpcy5nZXRUeXBlKGFzdC5yaWdodCkpIHtcbiAgICAgIGNhc2UgJ0ludGVnZXInOlxuICAgICAgICB0aGlzLmNhc3RWYWx1ZVRvRmxvYXQoYXN0LnJpZ2h0LCByZXRBcnIpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ0xpdGVyYWxJbnRlZ2VyJzpcbiAgICAgICAgdGhpcy5jYXN0TGl0ZXJhbFRvRmxvYXQoYXN0LnJpZ2h0LCByZXRBcnIpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRoaXMuYXN0R2VuZXJpYyhhc3QucmlnaHQsIHJldEFycik7XG4gICAgfVxuICAgIHJldEFyci5wdXNoKCcpJyk7XG4gICAgcmV0dXJuIHJldEFycjtcbiAgfVxuXG4gIGNoZWNrQW5kVXBjb252ZXJ0Qml0d2lzZU9wZXJhdG9ycyhhc3QsIHJldEFycikge1xuICAgIGNvbnN0IHVwY29udmVydGFibGVPcGVyYXRvcnMgPSB7XG4gICAgICAnJic6ICdiaXR3aXNlQW5kJyxcbiAgICAgICd8JzogJ2JpdHdpc2VPcicsXG4gICAgICAnXic6ICdiaXR3aXNlWE9SJyxcbiAgICAgICc8PCc6ICdiaXR3aXNlWmVyb0ZpbGxMZWZ0U2hpZnQnLFxuICAgICAgJz4+JzogJ2JpdHdpc2VTaWduZWRSaWdodFNoaWZ0JyxcbiAgICAgICc+Pj4nOiAnYml0d2lzZVplcm9GaWxsUmlnaHRTaGlmdCcsXG4gICAgfTtcbiAgICBjb25zdCBmb3VuZE9wZXJhdG9yID0gdXBjb252ZXJ0YWJsZU9wZXJhdG9yc1thc3Qub3BlcmF0b3JdO1xuICAgIGlmICghZm91bmRPcGVyYXRvcikgcmV0dXJuIG51bGw7XG4gICAgcmV0QXJyLnB1c2goZm91bmRPcGVyYXRvcik7XG4gICAgcmV0QXJyLnB1c2goJygnKTtcbiAgICBjb25zdCBsZWZ0VHlwZSA9IHRoaXMuZ2V0VHlwZShhc3QubGVmdCk7XG4gICAgc3dpdGNoIChsZWZ0VHlwZSkge1xuICAgICAgY2FzZSAnTnVtYmVyJzpcbiAgICAgIGNhc2UgJ0Zsb2F0JzpcbiAgICAgICAgdGhpcy5jYXN0VmFsdWVUb0ludGVnZXIoYXN0LmxlZnQsIHJldEFycik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnTGl0ZXJhbEludGVnZXInOlxuICAgICAgICB0aGlzLmNhc3RMaXRlcmFsVG9JbnRlZ2VyKGFzdC5sZWZ0LCByZXRBcnIpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRoaXMuYXN0R2VuZXJpYyhhc3QubGVmdCwgcmV0QXJyKTtcbiAgICB9XG4gICAgcmV0QXJyLnB1c2goJywnKTtcbiAgICBjb25zdCByaWdodFR5cGUgPSB0aGlzLmdldFR5cGUoYXN0LnJpZ2h0KTtcbiAgICBzd2l0Y2ggKHJpZ2h0VHlwZSkge1xuICAgICAgY2FzZSAnTnVtYmVyJzpcbiAgICAgIGNhc2UgJ0Zsb2F0JzpcbiAgICAgICAgdGhpcy5jYXN0VmFsdWVUb0ludGVnZXIoYXN0LnJpZ2h0LCByZXRBcnIpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ0xpdGVyYWxJbnRlZ2VyJzpcbiAgICAgICAgdGhpcy5jYXN0TGl0ZXJhbFRvSW50ZWdlcihhc3QucmlnaHQsIHJldEFycik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhpcy5hc3RHZW5lcmljKGFzdC5yaWdodCwgcmV0QXJyKTtcbiAgICB9XG4gICAgcmV0QXJyLnB1c2goJyknKTtcbiAgICByZXR1cm4gcmV0QXJyO1xuICB9XG5cbiAgY2hlY2tBbmRVcGNvbnZlcnRCaXR3aXNlVW5hcnkoYXN0LCByZXRBcnIpIHtcbiAgICBjb25zdCB1cGNvbnZlcnRhYmxlT3BlcmF0b3JzID0ge1xuICAgICAgJ34nOiAnYml0d2lzZU5vdCcsXG4gICAgfTtcbiAgICBjb25zdCBmb3VuZE9wZXJhdG9yID0gdXBjb252ZXJ0YWJsZU9wZXJhdG9yc1thc3Qub3BlcmF0b3JdO1xuICAgIGlmICghZm91bmRPcGVyYXRvcikgcmV0dXJuIG51bGw7XG4gICAgcmV0QXJyLnB1c2goZm91bmRPcGVyYXRvcik7XG4gICAgcmV0QXJyLnB1c2goJygnKTtcbiAgICBzd2l0Y2ggKHRoaXMuZ2V0VHlwZShhc3QuYXJndW1lbnQpKSB7XG4gICAgICBjYXNlICdOdW1iZXInOlxuICAgICAgY2FzZSAnRmxvYXQnOlxuICAgICAgICB0aGlzLmNhc3RWYWx1ZVRvSW50ZWdlcihhc3QuYXJndW1lbnQsIHJldEFycik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnTGl0ZXJhbEludGVnZXInOlxuICAgICAgICB0aGlzLmNhc3RMaXRlcmFsVG9JbnRlZ2VyKGFzdC5hcmd1bWVudCwgcmV0QXJyKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aGlzLmFzdEdlbmVyaWMoYXN0LmFyZ3VtZW50LCByZXRBcnIpO1xuICAgIH1cbiAgICByZXRBcnIucHVzaCgnKScpO1xuICAgIHJldHVybiByZXRBcnI7XG4gIH1cblxuICBjYXN0TGl0ZXJhbFRvSW50ZWdlcihhc3QsIHJldEFycikge1xuICAgIHRoaXMucHVzaFN0YXRlKCdjYXN0aW5nLXRvLWludGVnZXInKTtcbiAgICB0aGlzLmFzdEdlbmVyaWMoYXN0LCByZXRBcnIpO1xuICAgIHRoaXMucG9wU3RhdGUoJ2Nhc3RpbmctdG8taW50ZWdlcicpO1xuICAgIHJldHVybiByZXRBcnI7XG4gIH1cblxuICBjYXN0TGl0ZXJhbFRvRmxvYXQoYXN0LCByZXRBcnIpIHtcbiAgICB0aGlzLnB1c2hTdGF0ZSgnY2FzdGluZy10by1mbG9hdCcpO1xuICAgIHRoaXMuYXN0R2VuZXJpYyhhc3QsIHJldEFycik7XG4gICAgdGhpcy5wb3BTdGF0ZSgnY2FzdGluZy10by1mbG9hdCcpO1xuICAgIHJldHVybiByZXRBcnI7XG4gIH1cblxuICBjYXN0VmFsdWVUb0ludGVnZXIoYXN0LCByZXRBcnIpIHtcbiAgICB0aGlzLnB1c2hTdGF0ZSgnY2FzdGluZy10by1pbnRlZ2VyJyk7XG4gICAgcmV0QXJyLnB1c2goJ2ludCgnKTtcbiAgICB0aGlzLmFzdEdlbmVyaWMoYXN0LCByZXRBcnIpO1xuICAgIHJldEFyci5wdXNoKCcpJyk7XG4gICAgdGhpcy5wb3BTdGF0ZSgnY2FzdGluZy10by1pbnRlZ2VyJyk7XG4gICAgcmV0dXJuIHJldEFycjtcbiAgfVxuXG4gIGNhc3RWYWx1ZVRvRmxvYXQoYXN0LCByZXRBcnIpIHtcbiAgICB0aGlzLnB1c2hTdGF0ZSgnY2FzdGluZy10by1mbG9hdCcpO1xuICAgIHJldEFyci5wdXNoKCdmbG9hdCgnKTtcbiAgICB0aGlzLmFzdEdlbmVyaWMoYXN0LCByZXRBcnIpO1xuICAgIHJldEFyci5wdXNoKCcpJyk7XG4gICAgdGhpcy5wb3BTdGF0ZSgnY2FzdGluZy10by1mbG9hdCcpO1xuICAgIHJldHVybiByZXRBcnI7XG4gIH1cblxuICBhc3RJZGVudGlmaWVyRXhwcmVzc2lvbihpZHROb2RlLCByZXRBcnIpIHtcbiAgICBpZiAoaWR0Tm9kZS50eXBlICE9PSAnSWRlbnRpZmllcicpIHtcbiAgICAgIHRocm93IHRoaXMuYXN0RXJyb3JPdXRwdXQoJ0lkZW50aWZpZXJFeHByZXNzaW9uIC0gbm90IGFuIElkZW50aWZpZXInLCBpZHROb2RlKTtcbiAgICB9XG5cbiAgICBjb25zdCB0eXBlID0gdGhpcy5nZXRUeXBlKGlkdE5vZGUpO1xuXG4gICAgY29uc3QgbmFtZSA9IHV0aWxzLnNhbml0aXplTmFtZShpZHROb2RlLm5hbWUpO1xuICAgIGlmIChpZHROb2RlLm5hbWUgPT09ICdJbmZpbml0eScpIHtcbiAgICAgIHJldEFyci5wdXNoKCczLjQwMjgyMzQ2NmUrMzgnKTtcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdCb29sZWFuJykge1xuICAgICAgaWYgKHRoaXMuYXJndW1lbnROYW1lcy5pbmRleE9mKG5hbWUpID4gLTEpIHtcbiAgICAgICAgcmV0QXJyLnB1c2goYGJvb2wodXNlcl8ke25hbWV9KWApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0QXJyLnB1c2goYHVzZXJfJHtuYW1lfWApO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZXRBcnIucHVzaChgdXNlcl8ke25hbWV9YCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJldEFycjtcbiAgfVxuXG4gIGFzdEZvclN0YXRlbWVudChmb3JOb2RlLCByZXRBcnIpIHtcbiAgICBpZiAoZm9yTm9kZS50eXBlICE9PSAnRm9yU3RhdGVtZW50Jykge1xuICAgICAgdGhyb3cgdGhpcy5hc3RFcnJvck91dHB1dCgnSW52YWxpZCBmb3Igc3RhdGVtZW50JywgZm9yTm9kZSk7XG4gICAgfVxuXG4gICAgY29uc3QgaW5pdEFyciA9IFtdO1xuICAgIGNvbnN0IHRlc3RBcnIgPSBbXTtcbiAgICBjb25zdCB1cGRhdGVBcnIgPSBbXTtcbiAgICBjb25zdCBib2R5QXJyID0gW107XG4gICAgbGV0IGlzU2FmZSA9IG51bGw7XG5cbiAgICBpZiAoZm9yTm9kZS5pbml0KSB7XG4gICAgICBjb25zdCB7IGRlY2xhcmF0aW9ucyB9ID0gZm9yTm9kZS5pbml0O1xuICAgICAgaWYgKGRlY2xhcmF0aW9ucy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGlzU2FmZSA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgdGhpcy5hc3RHZW5lcmljKGZvck5vZGUuaW5pdCwgaW5pdEFycik7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRlY2xhcmF0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoZGVjbGFyYXRpb25zW2ldLmluaXQgJiYgZGVjbGFyYXRpb25zW2ldLmluaXQudHlwZSAhPT0gJ0xpdGVyYWwnKSB7XG4gICAgICAgICAgaXNTYWZlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaXNTYWZlID0gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKGZvck5vZGUudGVzdCkge1xuICAgICAgdGhpcy5hc3RHZW5lcmljKGZvck5vZGUudGVzdCwgdGVzdEFycik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlzU2FmZSA9IGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChmb3JOb2RlLnVwZGF0ZSkge1xuICAgICAgdGhpcy5hc3RHZW5lcmljKGZvck5vZGUudXBkYXRlLCB1cGRhdGVBcnIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpc1NhZmUgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoZm9yTm9kZS5ib2R5KSB7XG4gICAgICB0aGlzLnB1c2hTdGF0ZSgnbG9vcC1ib2R5Jyk7XG4gICAgICB0aGlzLmFzdEdlbmVyaWMoZm9yTm9kZS5ib2R5LCBib2R5QXJyKTtcbiAgICAgIHRoaXMucG9wU3RhdGUoJ2xvb3AtYm9keScpO1xuICAgIH1cblxuICAgIGlmIChpc1NhZmUgPT09IG51bGwpIHtcbiAgICAgIGlzU2FmZSA9IHRoaXMuaXNTYWZlKGZvck5vZGUuaW5pdCkgJiYgdGhpcy5pc1NhZmUoZm9yTm9kZS50ZXN0KTtcbiAgICB9XG5cbiAgICBpZiAoaXNTYWZlKSB7XG4gICAgICBjb25zdCBpbml0U3RyaW5nID0gaW5pdEFyci5qb2luKCcnKTtcbiAgICAgIGNvbnN0IGluaXROZWVkc1NlbWlDb2xvbiA9IGluaXRTdHJpbmdbaW5pdFN0cmluZy5sZW5ndGggLSAxXSAhPT0gJzsnO1xuICAgICAgcmV0QXJyLnB1c2goYGZvciAoJHtpbml0U3RyaW5nfSR7aW5pdE5lZWRzU2VtaUNvbG9uID8gJzsnIDogJyd9JHt0ZXN0QXJyLmpvaW4oJycpfTske3VwZGF0ZUFyci5qb2luKCcnKX0pe1xcbmApO1xuICAgICAgcmV0QXJyLnB1c2goYm9keUFyci5qb2luKCcnKSk7XG4gICAgICByZXRBcnIucHVzaCgnfVxcbicpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBpVmFyaWFibGVOYW1lID0gdGhpcy5nZXRJbnRlcm5hbFZhcmlhYmxlTmFtZSgnc2FmZUknKTtcbiAgICAgIGlmIChpbml0QXJyLmxlbmd0aCA+IDApIHtcbiAgICAgICAgcmV0QXJyLnB1c2goaW5pdEFyci5qb2luKCcnKSwgJ1xcbicpO1xuICAgICAgfVxuICAgICAgcmV0QXJyLnB1c2goYGZvciAoaW50ICR7aVZhcmlhYmxlTmFtZX09MDske2lWYXJpYWJsZU5hbWV9PExPT1BfTUFYOyR7aVZhcmlhYmxlTmFtZX0rKyl7XFxuYCk7XG4gICAgICBpZiAodGVzdEFyci5sZW5ndGggPiAwKSB7XG4gICAgICAgIHJldEFyci5wdXNoKGBpZiAoISR7dGVzdEFyci5qb2luKCcnKX0pIGJyZWFrO1xcbmApO1xuICAgICAgfVxuICAgICAgcmV0QXJyLnB1c2goYm9keUFyci5qb2luKCcnKSk7XG4gICAgICByZXRBcnIucHVzaChgXFxuJHt1cGRhdGVBcnIuam9pbignJyl9O2ApO1xuICAgICAgcmV0QXJyLnB1c2goJ31cXG4nKTtcbiAgICB9XG4gICAgcmV0dXJuIHJldEFycjtcbiAgfVxuXG4gIGFzdFdoaWxlU3RhdGVtZW50KHdoaWxlTm9kZSwgcmV0QXJyKSB7XG4gICAgaWYgKHdoaWxlTm9kZS50eXBlICE9PSAnV2hpbGVTdGF0ZW1lbnQnKSB7XG4gICAgICB0aHJvdyB0aGlzLmFzdEVycm9yT3V0cHV0KCdJbnZhbGlkIHdoaWxlIHN0YXRlbWVudCcsIHdoaWxlTm9kZSk7XG4gICAgfVxuXG4gICAgY29uc3QgaVZhcmlhYmxlTmFtZSA9IHRoaXMuZ2V0SW50ZXJuYWxWYXJpYWJsZU5hbWUoJ3NhZmVJJyk7XG4gICAgcmV0QXJyLnB1c2goYGZvciAoaW50ICR7aVZhcmlhYmxlTmFtZX09MDske2lWYXJpYWJsZU5hbWV9PExPT1BfTUFYOyR7aVZhcmlhYmxlTmFtZX0rKyl7XFxuYCk7XG4gICAgcmV0QXJyLnB1c2goJ2lmICghJyk7XG4gICAgdGhpcy5hc3RHZW5lcmljKHdoaWxlTm9kZS50ZXN0LCByZXRBcnIpO1xuICAgIHJldEFyci5wdXNoKCcpIGJyZWFrO1xcbicpO1xuICAgIHRoaXMuYXN0R2VuZXJpYyh3aGlsZU5vZGUuYm9keSwgcmV0QXJyKTtcbiAgICByZXRBcnIucHVzaCgnfVxcbicpO1xuXG4gICAgcmV0dXJuIHJldEFycjtcbiAgfVxuXG4gIGFzdERvV2hpbGVTdGF0ZW1lbnQoZG9XaGlsZU5vZGUsIHJldEFycikge1xuICAgIGlmIChkb1doaWxlTm9kZS50eXBlICE9PSAnRG9XaGlsZVN0YXRlbWVudCcpIHtcbiAgICAgIHRocm93IHRoaXMuYXN0RXJyb3JPdXRwdXQoJ0ludmFsaWQgd2hpbGUgc3RhdGVtZW50JywgZG9XaGlsZU5vZGUpO1xuICAgIH1cblxuICAgIGNvbnN0IGlWYXJpYWJsZU5hbWUgPSB0aGlzLmdldEludGVybmFsVmFyaWFibGVOYW1lKCdzYWZlSScpO1xuICAgIHJldEFyci5wdXNoKGBmb3IgKGludCAke2lWYXJpYWJsZU5hbWV9PTA7JHtpVmFyaWFibGVOYW1lfTxMT09QX01BWDske2lWYXJpYWJsZU5hbWV9Kyspe1xcbmApO1xuICAgIHRoaXMuYXN0R2VuZXJpYyhkb1doaWxlTm9kZS5ib2R5LCByZXRBcnIpO1xuICAgIHJldEFyci5wdXNoKCdpZiAoIScpO1xuICAgIHRoaXMuYXN0R2VuZXJpYyhkb1doaWxlTm9kZS50ZXN0LCByZXRBcnIpO1xuICAgIHJldEFyci5wdXNoKCcpIGJyZWFrO1xcbicpO1xuICAgIHJldEFyci5wdXNoKCd9XFxuJyk7XG5cbiAgICByZXR1cm4gcmV0QXJyO1xuICB9XG5cblxuICBhc3RBc3NpZ25tZW50RXhwcmVzc2lvbihhc3NOb2RlLCByZXRBcnIpIHtcbiAgICBpZiAoYXNzTm9kZS5vcGVyYXRvciA9PT0gJyU9Jykge1xuICAgICAgdGhpcy5hc3RHZW5lcmljKGFzc05vZGUubGVmdCwgcmV0QXJyKTtcbiAgICAgIHJldEFyci5wdXNoKCc9Jyk7XG4gICAgICByZXRBcnIucHVzaCgnbW9kKCcpO1xuICAgICAgdGhpcy5hc3RHZW5lcmljKGFzc05vZGUubGVmdCwgcmV0QXJyKTtcbiAgICAgIHJldEFyci5wdXNoKCcsJyk7XG4gICAgICB0aGlzLmFzdEdlbmVyaWMoYXNzTm9kZS5yaWdodCwgcmV0QXJyKTtcbiAgICAgIHJldEFyci5wdXNoKCcpJyk7XG4gICAgfSBlbHNlIGlmIChhc3NOb2RlLm9wZXJhdG9yID09PSAnKio9Jykge1xuICAgICAgdGhpcy5hc3RHZW5lcmljKGFzc05vZGUubGVmdCwgcmV0QXJyKTtcbiAgICAgIHJldEFyci5wdXNoKCc9Jyk7XG4gICAgICByZXRBcnIucHVzaCgncG93KCcpO1xuICAgICAgdGhpcy5hc3RHZW5lcmljKGFzc05vZGUubGVmdCwgcmV0QXJyKTtcbiAgICAgIHJldEFyci5wdXNoKCcsJyk7XG4gICAgICB0aGlzLmFzdEdlbmVyaWMoYXNzTm9kZS5yaWdodCwgcmV0QXJyKTtcbiAgICAgIHJldEFyci5wdXNoKCcpJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGxlZnRUeXBlID0gdGhpcy5nZXRUeXBlKGFzc05vZGUubGVmdCk7XG4gICAgICBjb25zdCByaWdodFR5cGUgPSB0aGlzLmdldFR5cGUoYXNzTm9kZS5yaWdodCk7XG4gICAgICB0aGlzLmFzdEdlbmVyaWMoYXNzTm9kZS5sZWZ0LCByZXRBcnIpO1xuICAgICAgcmV0QXJyLnB1c2goYXNzTm9kZS5vcGVyYXRvcik7XG4gICAgICBpZiAobGVmdFR5cGUgIT09ICdJbnRlZ2VyJyAmJiByaWdodFR5cGUgPT09ICdJbnRlZ2VyJykge1xuICAgICAgICByZXRBcnIucHVzaCgnZmxvYXQoJyk7XG4gICAgICAgIHRoaXMuYXN0R2VuZXJpYyhhc3NOb2RlLnJpZ2h0LCByZXRBcnIpO1xuICAgICAgICByZXRBcnIucHVzaCgnKScpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5hc3RHZW5lcmljKGFzc05vZGUucmlnaHQsIHJldEFycik7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmV0QXJyO1xuICAgIH1cbiAgfVxuXG4gIGFzdEJsb2NrU3RhdGVtZW50KGJOb2RlLCByZXRBcnIpIHtcbiAgICBpZiAodGhpcy5pc1N0YXRlKCdsb29wLWJvZHknKSkge1xuICAgICAgdGhpcy5wdXNoU3RhdGUoJ2Jsb2NrLWJvZHknKTsgXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJOb2RlLmJvZHkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy5hc3RHZW5lcmljKGJOb2RlLmJvZHlbaV0sIHJldEFycik7XG4gICAgICB9XG4gICAgICB0aGlzLnBvcFN0YXRlKCdibG9jay1ib2R5Jyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldEFyci5wdXNoKCd7XFxuJyk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJOb2RlLmJvZHkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy5hc3RHZW5lcmljKGJOb2RlLmJvZHlbaV0sIHJldEFycik7XG4gICAgICB9XG4gICAgICByZXRBcnIucHVzaCgnfVxcbicpO1xuICAgIH1cbiAgICByZXR1cm4gcmV0QXJyO1xuICB9XG5cbiAgYXN0VmFyaWFibGVEZWNsYXJhdGlvbih2YXJEZWNOb2RlLCByZXRBcnIpIHtcbiAgICBjb25zdCBkZWNsYXJhdGlvbnMgPSB2YXJEZWNOb2RlLmRlY2xhcmF0aW9ucztcbiAgICBpZiAoIWRlY2xhcmF0aW9ucyB8fCAhZGVjbGFyYXRpb25zWzBdIHx8ICFkZWNsYXJhdGlvbnNbMF0uaW5pdCkge1xuICAgICAgdGhyb3cgdGhpcy5hc3RFcnJvck91dHB1dCgnVW5leHBlY3RlZCBleHByZXNzaW9uJywgdmFyRGVjTm9kZSk7XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIGxldCBsYXN0VHlwZSA9IG51bGw7XG4gICAgY29uc3QgZGVjbGFyYXRpb25TZXRzID0gW107XG4gICAgbGV0IGRlY2xhcmF0aW9uU2V0ID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkZWNsYXJhdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGRlY2xhcmF0aW9uID0gZGVjbGFyYXRpb25zW2ldO1xuICAgICAgY29uc3QgaW5pdCA9IGRlY2xhcmF0aW9uLmluaXQ7XG4gICAgICBjb25zdCBpbmZvID0gdGhpcy5nZXREZWNsYXJhdGlvbihkZWNsYXJhdGlvbi5pZCk7XG4gICAgICBjb25zdCBhY3R1YWxUeXBlID0gdGhpcy5nZXRUeXBlKGRlY2xhcmF0aW9uLmluaXQpO1xuICAgICAgbGV0IHR5cGUgPSBhY3R1YWxUeXBlO1xuICAgICAgaWYgKHR5cGUgPT09ICdMaXRlcmFsSW50ZWdlcicpIHtcbiAgICAgICAgaWYgKGluZm8uc3VnZ2VzdGVkVHlwZSA9PT0gJ0ludGVnZXInKSB7XG4gICAgICAgICAgdHlwZSA9ICdJbnRlZ2VyJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0eXBlID0gJ051bWJlcic7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IG1hcmt1cFR5cGUgPSB0eXBlTWFwW3R5cGVdO1xuICAgICAgaWYgKCFtYXJrdXBUeXBlKSB7XG4gICAgICAgIHRocm93IHRoaXMuYXN0RXJyb3JPdXRwdXQoYE1hcmt1cCB0eXBlICR7IHR5cGUgfSBub3QgaGFuZGxlZGAsIHZhckRlY05vZGUpO1xuICAgICAgfVxuICAgICAgY29uc3QgZGVjbGFyYXRpb25SZXN1bHQgPSBbXTtcbiAgICAgIGlmIChhY3R1YWxUeXBlID09PSAnSW50ZWdlcicgJiYgdHlwZSA9PT0gJ0ludGVnZXInKSB7XG4gICAgICAgIGluZm8udmFsdWVUeXBlID0gJ051bWJlcic7XG4gICAgICAgIGlmIChpID09PSAwIHx8IGxhc3RUeXBlID09PSBudWxsKSB7XG4gICAgICAgICAgZGVjbGFyYXRpb25SZXN1bHQucHVzaCgnZmxvYXQgJyk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZSAhPT0gbGFzdFR5cGUpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuaGFuZGxlZCBkZWNsYXJhdGlvbicpO1xuICAgICAgICB9XG4gICAgICAgIGxhc3RUeXBlID0gdHlwZTtcbiAgICAgICAgZGVjbGFyYXRpb25SZXN1bHQucHVzaChgdXNlcl8ke3V0aWxzLnNhbml0aXplTmFtZShkZWNsYXJhdGlvbi5pZC5uYW1lKX09YCk7XG4gICAgICAgIGRlY2xhcmF0aW9uUmVzdWx0LnB1c2goJ2Zsb2F0KCcpO1xuICAgICAgICB0aGlzLmFzdEdlbmVyaWMoaW5pdCwgZGVjbGFyYXRpb25SZXN1bHQpO1xuICAgICAgICBkZWNsYXJhdGlvblJlc3VsdC5wdXNoKCcpJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbmZvLnZhbHVlVHlwZSA9IHR5cGU7XG4gICAgICAgIGlmIChpID09PSAwIHx8IGxhc3RUeXBlID09PSBudWxsKSB7XG4gICAgICAgICAgZGVjbGFyYXRpb25SZXN1bHQucHVzaChgJHttYXJrdXBUeXBlfSBgKTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlICE9PSBsYXN0VHlwZSkge1xuICAgICAgICAgIGRlY2xhcmF0aW9uU2V0cy5wdXNoKGRlY2xhcmF0aW9uU2V0LmpvaW4oJywnKSk7XG4gICAgICAgICAgZGVjbGFyYXRpb25TZXQgPSBbXTtcbiAgICAgICAgICBkZWNsYXJhdGlvblJlc3VsdC5wdXNoKGAke21hcmt1cFR5cGV9IGApO1xuICAgICAgICB9XG4gICAgICAgIGxhc3RUeXBlID0gdHlwZTtcbiAgICAgICAgZGVjbGFyYXRpb25SZXN1bHQucHVzaChgdXNlcl8ke3V0aWxzLnNhbml0aXplTmFtZShkZWNsYXJhdGlvbi5pZC5uYW1lKX09YCk7XG4gICAgICAgIGlmIChhY3R1YWxUeXBlID09PSAnTnVtYmVyJyAmJiB0eXBlID09PSAnSW50ZWdlcicpIHtcbiAgICAgICAgICBpZiAoaW5pdC5sZWZ0ICYmIGluaXQubGVmdC50eXBlID09PSAnTGl0ZXJhbCcpIHtcbiAgICAgICAgICAgIHRoaXMuYXN0R2VuZXJpYyhpbml0LCBkZWNsYXJhdGlvblJlc3VsdCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRlY2xhcmF0aW9uUmVzdWx0LnB1c2goJ2ludCgnKTtcbiAgICAgICAgICAgIHRoaXMuYXN0R2VuZXJpYyhpbml0LCBkZWNsYXJhdGlvblJlc3VsdCk7XG4gICAgICAgICAgICBkZWNsYXJhdGlvblJlc3VsdC5wdXNoKCcpJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGFjdHVhbFR5cGUgPT09ICdMaXRlcmFsSW50ZWdlcicgJiYgdHlwZSA9PT0gJ0ludGVnZXInKSB7XG4gICAgICAgICAgdGhpcy5jYXN0TGl0ZXJhbFRvSW50ZWdlcihpbml0LCBkZWNsYXJhdGlvblJlc3VsdCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5hc3RHZW5lcmljKGluaXQsIGRlY2xhcmF0aW9uUmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZGVjbGFyYXRpb25TZXQucHVzaChkZWNsYXJhdGlvblJlc3VsdC5qb2luKCcnKSk7XG4gICAgfVxuXG4gICAgaWYgKGRlY2xhcmF0aW9uU2V0Lmxlbmd0aCA+IDApIHtcbiAgICAgIGRlY2xhcmF0aW9uU2V0cy5wdXNoKGRlY2xhcmF0aW9uU2V0LmpvaW4oJywnKSk7XG4gICAgfVxuXG4gICAgcmVzdWx0LnB1c2goZGVjbGFyYXRpb25TZXRzLmpvaW4oJzsnKSk7XG5cbiAgICByZXRBcnIucHVzaChyZXN1bHQuam9pbignJykpO1xuICAgIHJldEFyci5wdXNoKCc7Jyk7XG4gICAgcmV0dXJuIHJldEFycjtcbiAgfVxuXG4gIGFzdElmU3RhdGVtZW50KGlmTm9kZSwgcmV0QXJyKSB7XG4gICAgcmV0QXJyLnB1c2goJ2lmICgnKTtcbiAgICB0aGlzLmFzdEdlbmVyaWMoaWZOb2RlLnRlc3QsIHJldEFycik7XG4gICAgcmV0QXJyLnB1c2goJyknKTtcbiAgICBpZiAoaWZOb2RlLmNvbnNlcXVlbnQudHlwZSA9PT0gJ0Jsb2NrU3RhdGVtZW50Jykge1xuICAgICAgdGhpcy5hc3RHZW5lcmljKGlmTm9kZS5jb25zZXF1ZW50LCByZXRBcnIpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXRBcnIucHVzaCgnIHtcXG4nKTtcbiAgICAgIHRoaXMuYXN0R2VuZXJpYyhpZk5vZGUuY29uc2VxdWVudCwgcmV0QXJyKTtcbiAgICAgIHJldEFyci5wdXNoKCdcXG59XFxuJyk7XG4gICAgfVxuXG4gICAgaWYgKGlmTm9kZS5hbHRlcm5hdGUpIHtcbiAgICAgIHJldEFyci5wdXNoKCdlbHNlICcpO1xuICAgICAgaWYgKGlmTm9kZS5hbHRlcm5hdGUudHlwZSA9PT0gJ0Jsb2NrU3RhdGVtZW50JyB8fCBpZk5vZGUuYWx0ZXJuYXRlLnR5cGUgPT09ICdJZlN0YXRlbWVudCcpIHtcbiAgICAgICAgdGhpcy5hc3RHZW5lcmljKGlmTm9kZS5hbHRlcm5hdGUsIHJldEFycik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXRBcnIucHVzaCgnIHtcXG4nKTtcbiAgICAgICAgdGhpcy5hc3RHZW5lcmljKGlmTm9kZS5hbHRlcm5hdGUsIHJldEFycik7XG4gICAgICAgIHJldEFyci5wdXNoKCdcXG59XFxuJyk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXRBcnI7XG4gIH1cblxuICBhc3RTd2l0Y2hTdGF0ZW1lbnQoYXN0LCByZXRBcnIpIHtcbiAgICBpZiAoYXN0LnR5cGUgIT09ICdTd2l0Y2hTdGF0ZW1lbnQnKSB7XG4gICAgICB0aHJvdyB0aGlzLmFzdEVycm9yT3V0cHV0KCdJbnZhbGlkIHN3aXRjaCBzdGF0ZW1lbnQnLCBhc3QpO1xuICAgIH1cbiAgICBjb25zdCB7IGRpc2NyaW1pbmFudCwgY2FzZXMgfSA9IGFzdDtcbiAgICBjb25zdCB0eXBlID0gdGhpcy5nZXRUeXBlKGRpc2NyaW1pbmFudCk7XG4gICAgY29uc3QgdmFyTmFtZSA9IGBzd2l0Y2hEaXNjcmltaW5hbnQke3RoaXMuYXN0S2V5KGFzdCwgJ18nKX1gO1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSAnRmxvYXQnOlxuICAgICAgY2FzZSAnTnVtYmVyJzpcbiAgICAgICAgcmV0QXJyLnB1c2goYGZsb2F0ICR7dmFyTmFtZX0gPSBgKTtcbiAgICAgICAgdGhpcy5hc3RHZW5lcmljKGRpc2NyaW1pbmFudCwgcmV0QXJyKTtcbiAgICAgICAgcmV0QXJyLnB1c2goJztcXG4nKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdJbnRlZ2VyJzpcbiAgICAgICAgcmV0QXJyLnB1c2goYGludCAke3Zhck5hbWV9ID0gYCk7XG4gICAgICAgIHRoaXMuYXN0R2VuZXJpYyhkaXNjcmltaW5hbnQsIHJldEFycik7XG4gICAgICAgIHJldEFyci5wdXNoKCc7XFxuJyk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBpZiAoY2FzZXMubGVuZ3RoID09PSAxICYmICFjYXNlc1swXS50ZXN0KSB7XG4gICAgICB0aGlzLmFzdEdlbmVyaWMoY2FzZXNbMF0uY29uc2VxdWVudCwgcmV0QXJyKTtcbiAgICAgIHJldHVybiByZXRBcnI7XG4gICAgfVxuXG4gICAgbGV0IGZhbGxpbmdUaHJvdWdoID0gZmFsc2U7XG4gICAgbGV0IGRlZmF1bHRSZXN1bHQgPSBbXTtcbiAgICBsZXQgbW92aW5nRGVmYXVsdFRvRW5kID0gZmFsc2U7XG4gICAgbGV0IHBhc3RGaXJzdElmID0gZmFsc2U7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjYXNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKCFjYXNlc1tpXS50ZXN0KSB7XG4gICAgICAgIGlmIChjYXNlcy5sZW5ndGggPiBpICsgMSkge1xuICAgICAgICAgIG1vdmluZ0RlZmF1bHRUb0VuZCA9IHRydWU7XG4gICAgICAgICAgdGhpcy5hc3RHZW5lcmljKGNhc2VzW2ldLmNvbnNlcXVlbnQsIGRlZmF1bHRSZXN1bHQpO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldEFyci5wdXNoKCcgZWxzZSB7XFxuJyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChpID09PSAwIHx8ICFwYXN0Rmlyc3RJZikge1xuICAgICAgICAgIHBhc3RGaXJzdElmID0gdHJ1ZTtcbiAgICAgICAgICByZXRBcnIucHVzaChgaWYgKCR7dmFyTmFtZX0gPT0gYCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKGZhbGxpbmdUaHJvdWdoKSB7XG4gICAgICAgICAgICByZXRBcnIucHVzaChgJHt2YXJOYW1lfSA9PSBgKTtcbiAgICAgICAgICAgIGZhbGxpbmdUaHJvdWdoID0gZmFsc2U7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldEFyci5wdXNoKGAgZWxzZSBpZiAoJHt2YXJOYW1lfSA9PSBgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGUgPT09ICdJbnRlZ2VyJykge1xuICAgICAgICAgIGNvbnN0IHRlc3RUeXBlID0gdGhpcy5nZXRUeXBlKGNhc2VzW2ldLnRlc3QpO1xuICAgICAgICAgIHN3aXRjaCAodGVzdFR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ051bWJlcic6XG4gICAgICAgICAgICBjYXNlICdGbG9hdCc6XG4gICAgICAgICAgICAgIHRoaXMuY2FzdFZhbHVlVG9JbnRlZ2VyKGNhc2VzW2ldLnRlc3QsIHJldEFycik7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnTGl0ZXJhbEludGVnZXInOlxuICAgICAgICAgICAgICB0aGlzLmNhc3RMaXRlcmFsVG9JbnRlZ2VyKGNhc2VzW2ldLnRlc3QsIHJldEFycik7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAnRmxvYXQnKSB7XG4gICAgICAgICAgY29uc3QgdGVzdFR5cGUgPSB0aGlzLmdldFR5cGUoY2FzZXNbaV0udGVzdCk7XG4gICAgICAgICAgc3dpdGNoICh0ZXN0VHlwZSkge1xuICAgICAgICAgICAgY2FzZSAnTGl0ZXJhbEludGVnZXInOlxuICAgICAgICAgICAgICB0aGlzLmNhc3RMaXRlcmFsVG9GbG9hdChjYXNlc1tpXS50ZXN0LCByZXRBcnIpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ0ludGVnZXInOlxuICAgICAgICAgICAgICB0aGlzLmNhc3RWYWx1ZVRvRmxvYXQoY2FzZXNbaV0udGVzdCwgcmV0QXJyKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndW5oYW5sZGVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFjYXNlc1tpXS5jb25zZXF1ZW50IHx8IGNhc2VzW2ldLmNvbnNlcXVlbnQubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgZmFsbGluZ1Rocm91Z2ggPSB0cnVlO1xuICAgICAgICAgIHJldEFyci5wdXNoKCcgfHwgJyk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0QXJyLnB1c2goYCkge1xcbmApO1xuICAgICAgfVxuICAgICAgdGhpcy5hc3RHZW5lcmljKGNhc2VzW2ldLmNvbnNlcXVlbnQsIHJldEFycik7XG4gICAgICByZXRBcnIucHVzaCgnXFxufScpO1xuICAgIH1cbiAgICBpZiAobW92aW5nRGVmYXVsdFRvRW5kKSB7XG4gICAgICByZXRBcnIucHVzaCgnIGVsc2UgeycpO1xuICAgICAgcmV0QXJyLnB1c2goZGVmYXVsdFJlc3VsdC5qb2luKCcnKSk7XG4gICAgICByZXRBcnIucHVzaCgnfScpO1xuICAgIH1cbiAgICByZXR1cm4gcmV0QXJyO1xuICB9XG5cbiAgYXN0VGhpc0V4cHJlc3Npb24odE5vZGUsIHJldEFycikge1xuICAgIHJldEFyci5wdXNoKCd0aGlzJyk7XG4gICAgcmV0dXJuIHJldEFycjtcbiAgfVxuXG4gIGFzdE1lbWJlckV4cHJlc3Npb24obU5vZGUsIHJldEFycikge1xuICAgIGNvbnN0IHtcbiAgICAgIHByb3BlcnR5LFxuICAgICAgbmFtZSxcbiAgICAgIHNpZ25hdHVyZSxcbiAgICAgIG9yaWdpbixcbiAgICAgIHR5cGUsXG4gICAgICB4UHJvcGVydHksXG4gICAgICB5UHJvcGVydHksXG4gICAgICB6UHJvcGVydHlcbiAgICB9ID0gdGhpcy5nZXRNZW1iZXJFeHByZXNzaW9uRGV0YWlscyhtTm9kZSk7XG4gICAgc3dpdGNoIChzaWduYXR1cmUpIHtcbiAgICAgIGNhc2UgJ3ZhbHVlLnRocmVhZC52YWx1ZSc6XG4gICAgICBjYXNlICd0aGlzLnRocmVhZC52YWx1ZSc6XG4gICAgICAgIGlmIChuYW1lICE9PSAneCcgJiYgbmFtZSAhPT0gJ3knICYmIG5hbWUgIT09ICd6Jykge1xuICAgICAgICAgIHRocm93IHRoaXMuYXN0RXJyb3JPdXRwdXQoJ1VuZXhwZWN0ZWQgZXhwcmVzc2lvbiwgZXhwZWN0ZWQgYHRoaXMudGhyZWFkLnhgLCBgdGhpcy50aHJlYWQueWAsIG9yIGB0aGlzLnRocmVhZC56YCcsIG1Ob2RlKTtcbiAgICAgICAgfVxuICAgICAgICByZXRBcnIucHVzaChgdGhyZWFkSWQuJHtuYW1lfWApO1xuICAgICAgICByZXR1cm4gcmV0QXJyO1xuICAgICAgY2FzZSAndGhpcy5vdXRwdXQudmFsdWUnOlxuICAgICAgICBpZiAodGhpcy5keW5hbWljT3V0cHV0KSB7XG4gICAgICAgICAgc3dpdGNoIChuYW1lKSB7XG4gICAgICAgICAgICBjYXNlICd4JzpcbiAgICAgICAgICAgICAgaWYgKHRoaXMuaXNTdGF0ZSgnY2FzdGluZy10by1mbG9hdCcpKSB7XG4gICAgICAgICAgICAgICAgcmV0QXJyLnB1c2goJ2Zsb2F0KHVPdXRwdXREaW0ueCknKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXRBcnIucHVzaCgndU91dHB1dERpbS54Jyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICd5JzpcbiAgICAgICAgICAgICAgaWYgKHRoaXMuaXNTdGF0ZSgnY2FzdGluZy10by1mbG9hdCcpKSB7XG4gICAgICAgICAgICAgICAgcmV0QXJyLnB1c2goJ2Zsb2F0KHVPdXRwdXREaW0ueSknKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXRBcnIucHVzaCgndU91dHB1dERpbS55Jyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICd6JzpcbiAgICAgICAgICAgICAgaWYgKHRoaXMuaXNTdGF0ZSgnY2FzdGluZy10by1mbG9hdCcpKSB7XG4gICAgICAgICAgICAgICAgcmV0QXJyLnB1c2goJ2Zsb2F0KHVPdXRwdXREaW0ueiknKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXRBcnIucHVzaCgndU91dHB1dERpbS56Jyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICB0aHJvdyB0aGlzLmFzdEVycm9yT3V0cHV0KCdVbmV4cGVjdGVkIGV4cHJlc3Npb24nLCBtTm9kZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN3aXRjaCAobmFtZSkge1xuICAgICAgICAgICAgY2FzZSAneCc6XG4gICAgICAgICAgICAgIGlmICh0aGlzLmlzU3RhdGUoJ2Nhc3RpbmctdG8taW50ZWdlcicpKSB7XG4gICAgICAgICAgICAgICAgcmV0QXJyLnB1c2godGhpcy5vdXRwdXRbMF0pO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldEFyci5wdXNoKHRoaXMub3V0cHV0WzBdLCAnLjAnKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3knOlxuICAgICAgICAgICAgICBpZiAodGhpcy5pc1N0YXRlKCdjYXN0aW5nLXRvLWludGVnZXInKSkge1xuICAgICAgICAgICAgICAgIHJldEFyci5wdXNoKHRoaXMub3V0cHV0WzFdKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXRBcnIucHVzaCh0aGlzLm91dHB1dFsxXSwgJy4wJyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICd6JzpcbiAgICAgICAgICAgICAgaWYgKHRoaXMuaXNTdGF0ZSgnY2FzdGluZy10by1pbnRlZ2VyJykpIHtcbiAgICAgICAgICAgICAgICByZXRBcnIucHVzaCh0aGlzLm91dHB1dFsyXSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0QXJyLnB1c2godGhpcy5vdXRwdXRbMl0sICcuMCcpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgdGhyb3cgdGhpcy5hc3RFcnJvck91dHB1dCgnVW5leHBlY3RlZCBleHByZXNzaW9uJywgbU5vZGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmV0QXJyO1xuICAgICAgY2FzZSAndmFsdWUnOlxuICAgICAgICB0aHJvdyB0aGlzLmFzdEVycm9yT3V0cHV0KCdVbmV4cGVjdGVkIGV4cHJlc3Npb24nLCBtTm9kZSk7XG4gICAgICBjYXNlICd2YWx1ZVtdJzpcbiAgICAgIGNhc2UgJ3ZhbHVlW11bXSc6XG4gICAgICBjYXNlICd2YWx1ZVtdW11bXSc6XG4gICAgICBjYXNlICd2YWx1ZVtdW11bXVtdJzpcbiAgICAgIGNhc2UgJ3ZhbHVlLnZhbHVlJzpcbiAgICAgICAgaWYgKG9yaWdpbiA9PT0gJ01hdGgnKSB7XG4gICAgICAgICAgcmV0QXJyLnB1c2goTWF0aFtuYW1lXSk7XG4gICAgICAgICAgcmV0dXJuIHJldEFycjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjbGVhbk5hbWUgPSB1dGlscy5zYW5pdGl6ZU5hbWUobmFtZSk7XG4gICAgICAgIHN3aXRjaCAocHJvcGVydHkpIHtcbiAgICAgICAgICBjYXNlICdyJzpcbiAgICAgICAgICAgIHJldEFyci5wdXNoKGB1c2VyXyR7IGNsZWFuTmFtZSB9LnJgKTtcbiAgICAgICAgICAgIHJldHVybiByZXRBcnI7XG4gICAgICAgICAgY2FzZSAnZyc6XG4gICAgICAgICAgICByZXRBcnIucHVzaChgdXNlcl8keyBjbGVhbk5hbWUgfS5nYCk7XG4gICAgICAgICAgICByZXR1cm4gcmV0QXJyO1xuICAgICAgICAgIGNhc2UgJ2InOlxuICAgICAgICAgICAgcmV0QXJyLnB1c2goYHVzZXJfJHsgY2xlYW5OYW1lIH0uYmApO1xuICAgICAgICAgICAgcmV0dXJuIHJldEFycjtcbiAgICAgICAgICBjYXNlICdhJzpcbiAgICAgICAgICAgIHJldEFyci5wdXNoKGB1c2VyXyR7IGNsZWFuTmFtZSB9LmFgKTtcbiAgICAgICAgICAgIHJldHVybiByZXRBcnI7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICd0aGlzLmNvbnN0YW50cy52YWx1ZSc6XG4gICAgICAgIGlmICh0eXBlb2YgeFByb3BlcnR5ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgICAgY2FzZSAnQXJyYXkoMiknOlxuICAgICAgICAgICAgY2FzZSAnQXJyYXkoMyknOlxuICAgICAgICAgICAgY2FzZSAnQXJyYXkoNCknOlxuICAgICAgICAgICAgICByZXRBcnIucHVzaChgY29uc3RhbnRzXyR7IHV0aWxzLnNhbml0aXplTmFtZShuYW1lKSB9YCk7XG4gICAgICAgICAgICAgIHJldHVybiByZXRBcnI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ3RoaXMuY29uc3RhbnRzLnZhbHVlW10nOlxuICAgICAgICBjYXNlICd0aGlzLmNvbnN0YW50cy52YWx1ZVtdW10nOlxuICAgICAgICBjYXNlICd0aGlzLmNvbnN0YW50cy52YWx1ZVtdW11bXSc6XG4gICAgICAgIGNhc2UgJ3RoaXMuY29uc3RhbnRzLnZhbHVlW11bXVtdW10nOlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdmbigpW10nOlxuICAgICAgICAgIHRoaXMuYXN0Q2FsbEV4cHJlc3Npb24obU5vZGUub2JqZWN0LCByZXRBcnIpO1xuICAgICAgICAgIHJldEFyci5wdXNoKCdbJyk7XG4gICAgICAgICAgcmV0QXJyLnB1c2godGhpcy5tZW1iZXJFeHByZXNzaW9uUHJvcGVydHlNYXJrdXAocHJvcGVydHkpKTtcbiAgICAgICAgICByZXRBcnIucHVzaCgnXScpO1xuICAgICAgICAgIHJldHVybiByZXRBcnI7XG4gICAgICAgIGNhc2UgJ2ZuKClbXVtdJzpcbiAgICAgICAgICB0aGlzLmFzdENhbGxFeHByZXNzaW9uKG1Ob2RlLm9iamVjdC5vYmplY3QsIHJldEFycik7XG4gICAgICAgICAgcmV0QXJyLnB1c2goJ1snKTtcbiAgICAgICAgICByZXRBcnIucHVzaCh0aGlzLm1lbWJlckV4cHJlc3Npb25Qcm9wZXJ0eU1hcmt1cChtTm9kZS5vYmplY3QucHJvcGVydHkpKTtcbiAgICAgICAgICByZXRBcnIucHVzaCgnXScpO1xuICAgICAgICAgIHJldEFyci5wdXNoKCdbJyk7XG4gICAgICAgICAgcmV0QXJyLnB1c2godGhpcy5tZW1iZXJFeHByZXNzaW9uUHJvcGVydHlNYXJrdXAobU5vZGUucHJvcGVydHkpKTtcbiAgICAgICAgICByZXRBcnIucHVzaCgnXScpO1xuICAgICAgICAgIHJldHVybiByZXRBcnI7XG4gICAgICAgIGNhc2UgJ1tdW10nOlxuICAgICAgICAgIHRoaXMuYXN0QXJyYXlFeHByZXNzaW9uKG1Ob2RlLm9iamVjdCwgcmV0QXJyKTtcbiAgICAgICAgICByZXRBcnIucHVzaCgnWycpO1xuICAgICAgICAgIHJldEFyci5wdXNoKHRoaXMubWVtYmVyRXhwcmVzc2lvblByb3BlcnR5TWFya3VwKHByb3BlcnR5KSk7XG4gICAgICAgICAgcmV0QXJyLnB1c2goJ10nKTtcbiAgICAgICAgICByZXR1cm4gcmV0QXJyO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRocm93IHRoaXMuYXN0RXJyb3JPdXRwdXQoJ1VuZXhwZWN0ZWQgZXhwcmVzc2lvbicsIG1Ob2RlKTtcbiAgICB9XG5cbiAgICBpZiAobU5vZGUuY29tcHV0ZWQgPT09IGZhbHNlKSB7XG4gICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSAnTnVtYmVyJzpcbiAgICAgICAgY2FzZSAnSW50ZWdlcic6XG4gICAgICAgIGNhc2UgJ0Zsb2F0JzpcbiAgICAgICAgY2FzZSAnQm9vbGVhbic6XG4gICAgICAgICAgcmV0QXJyLnB1c2goYCR7b3JpZ2lufV8ke3V0aWxzLnNhbml0aXplTmFtZShuYW1lKX1gKTtcbiAgICAgICAgICByZXR1cm4gcmV0QXJyO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IG1hcmt1cE5hbWUgPSBgJHtvcmlnaW59XyR7dXRpbHMuc2FuaXRpemVOYW1lKG5hbWUpfWA7XG5cbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgJ0FycmF5KDIpJzpcbiAgICAgIGNhc2UgJ0FycmF5KDMpJzpcbiAgICAgIGNhc2UgJ0FycmF5KDQpJzpcbiAgICAgICAgdGhpcy5hc3RHZW5lcmljKG1Ob2RlLm9iamVjdCwgcmV0QXJyKTtcbiAgICAgICAgcmV0QXJyLnB1c2goJ1snKTtcbiAgICAgICAgcmV0QXJyLnB1c2godGhpcy5tZW1iZXJFeHByZXNzaW9uUHJvcGVydHlNYXJrdXAoeFByb3BlcnR5KSk7XG4gICAgICAgIHJldEFyci5wdXNoKCddJyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnSFRNTEltYWdlQXJyYXknOlxuICAgICAgICByZXRBcnIucHVzaChgZ2V0SW1hZ2UzRCgkeyBtYXJrdXBOYW1lIH0sICR7IG1hcmt1cE5hbWUgfVNpemUsICR7IG1hcmt1cE5hbWUgfURpbSwgYCk7XG4gICAgICAgIHRoaXMubWVtYmVyRXhwcmVzc2lvblhZWih4UHJvcGVydHksIHlQcm9wZXJ0eSwgelByb3BlcnR5LCByZXRBcnIpO1xuICAgICAgICByZXRBcnIucHVzaCgnKScpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ0FycmF5VGV4dHVyZSgxKSc6XG4gICAgICAgIHJldEFyci5wdXNoKGBnZXRGbG9hdEZyb21TYW1wbGVyMkQoJHsgbWFya3VwTmFtZSB9LCAkeyBtYXJrdXBOYW1lIH1TaXplLCAkeyBtYXJrdXBOYW1lIH1EaW0sIGApO1xuICAgICAgICB0aGlzLm1lbWJlckV4cHJlc3Npb25YWVooeFByb3BlcnR5LCB5UHJvcGVydHksIHpQcm9wZXJ0eSwgcmV0QXJyKTtcbiAgICAgICAgcmV0QXJyLnB1c2goJyknKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdBcnJheTFEKDIpJzpcbiAgICAgIGNhc2UgJ0FycmF5MkQoMiknOlxuICAgICAgY2FzZSAnQXJyYXkzRCgyKSc6XG4gICAgICAgIHJldEFyci5wdXNoKGBnZXRNZW1vcnlPcHRpbWl6ZWRWZWMyKCR7IG1hcmt1cE5hbWUgfSwgJHsgbWFya3VwTmFtZSB9U2l6ZSwgJHsgbWFya3VwTmFtZSB9RGltLCBgKTtcbiAgICAgICAgdGhpcy5tZW1iZXJFeHByZXNzaW9uWFlaKHhQcm9wZXJ0eSwgeVByb3BlcnR5LCB6UHJvcGVydHksIHJldEFycik7XG4gICAgICAgIHJldEFyci5wdXNoKCcpJyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnQXJyYXlUZXh0dXJlKDIpJzpcbiAgICAgICAgcmV0QXJyLnB1c2goYGdldFZlYzJGcm9tU2FtcGxlcjJEKCR7IG1hcmt1cE5hbWUgfSwgJHsgbWFya3VwTmFtZSB9U2l6ZSwgJHsgbWFya3VwTmFtZSB9RGltLCBgKTtcbiAgICAgICAgdGhpcy5tZW1iZXJFeHByZXNzaW9uWFlaKHhQcm9wZXJ0eSwgeVByb3BlcnR5LCB6UHJvcGVydHksIHJldEFycik7XG4gICAgICAgIHJldEFyci5wdXNoKCcpJyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnQXJyYXkxRCgzKSc6XG4gICAgICBjYXNlICdBcnJheTJEKDMpJzpcbiAgICAgIGNhc2UgJ0FycmF5M0QoMyknOlxuICAgICAgICByZXRBcnIucHVzaChgZ2V0TWVtb3J5T3B0aW1pemVkVmVjMygkeyBtYXJrdXBOYW1lIH0sICR7IG1hcmt1cE5hbWUgfVNpemUsICR7IG1hcmt1cE5hbWUgfURpbSwgYCk7XG4gICAgICAgIHRoaXMubWVtYmVyRXhwcmVzc2lvblhZWih4UHJvcGVydHksIHlQcm9wZXJ0eSwgelByb3BlcnR5LCByZXRBcnIpO1xuICAgICAgICByZXRBcnIucHVzaCgnKScpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ0FycmF5VGV4dHVyZSgzKSc6XG4gICAgICAgIHJldEFyci5wdXNoKGBnZXRWZWMzRnJvbVNhbXBsZXIyRCgkeyBtYXJrdXBOYW1lIH0sICR7IG1hcmt1cE5hbWUgfVNpemUsICR7IG1hcmt1cE5hbWUgfURpbSwgYCk7XG4gICAgICAgIHRoaXMubWVtYmVyRXhwcmVzc2lvblhZWih4UHJvcGVydHksIHlQcm9wZXJ0eSwgelByb3BlcnR5LCByZXRBcnIpO1xuICAgICAgICByZXRBcnIucHVzaCgnKScpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ0FycmF5MUQoNCknOlxuICAgICAgY2FzZSAnQXJyYXkyRCg0KSc6XG4gICAgICBjYXNlICdBcnJheTNEKDQpJzpcbiAgICAgICAgcmV0QXJyLnB1c2goYGdldE1lbW9yeU9wdGltaXplZFZlYzQoJHsgbWFya3VwTmFtZSB9LCAkeyBtYXJrdXBOYW1lIH1TaXplLCAkeyBtYXJrdXBOYW1lIH1EaW0sIGApO1xuICAgICAgICB0aGlzLm1lbWJlckV4cHJlc3Npb25YWVooeFByb3BlcnR5LCB5UHJvcGVydHksIHpQcm9wZXJ0eSwgcmV0QXJyKTtcbiAgICAgICAgcmV0QXJyLnB1c2goJyknKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdBcnJheVRleHR1cmUoNCknOlxuICAgICAgY2FzZSAnSFRNTENhbnZhcyc6XG4gICAgICBjYXNlICdIVE1MSW1hZ2UnOlxuICAgICAgY2FzZSAnSFRNTFZpZGVvJzpcbiAgICAgICAgcmV0QXJyLnB1c2goYGdldFZlYzRGcm9tU2FtcGxlcjJEKCR7IG1hcmt1cE5hbWUgfSwgJHsgbWFya3VwTmFtZSB9U2l6ZSwgJHsgbWFya3VwTmFtZSB9RGltLCBgKTtcbiAgICAgICAgdGhpcy5tZW1iZXJFeHByZXNzaW9uWFlaKHhQcm9wZXJ0eSwgeVByb3BlcnR5LCB6UHJvcGVydHksIHJldEFycik7XG4gICAgICAgIHJldEFyci5wdXNoKCcpJyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnTnVtYmVyVGV4dHVyZSc6XG4gICAgICBjYXNlICdBcnJheSc6XG4gICAgICBjYXNlICdBcnJheTJEJzpcbiAgICAgIGNhc2UgJ0FycmF5M0QnOlxuICAgICAgY2FzZSAnQXJyYXk0RCc6XG4gICAgICBjYXNlICdJbnB1dCc6XG4gICAgICBjYXNlICdOdW1iZXInOlxuICAgICAgY2FzZSAnRmxvYXQnOlxuICAgICAgY2FzZSAnSW50ZWdlcic6XG4gICAgICAgIGlmICh0aGlzLnByZWNpc2lvbiA9PT0gJ3NpbmdsZScpIHtcbiAgICAgICAgICByZXRBcnIucHVzaChgZ2V0TWVtb3J5T3B0aW1pemVkMzIoJHttYXJrdXBOYW1lfSwgJHttYXJrdXBOYW1lfVNpemUsICR7bWFya3VwTmFtZX1EaW0sIGApO1xuICAgICAgICAgIHRoaXMubWVtYmVyRXhwcmVzc2lvblhZWih4UHJvcGVydHksIHlQcm9wZXJ0eSwgelByb3BlcnR5LCByZXRBcnIpO1xuICAgICAgICAgIHJldEFyci5wdXNoKCcpJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc3QgYml0UmF0aW8gPSAob3JpZ2luID09PSAndXNlcicgP1xuICAgICAgICAgICAgdGhpcy5sb29rdXBGdW5jdGlvbkFyZ3VtZW50Qml0UmF0aW8odGhpcy5uYW1lLCBuYW1lKSA6XG4gICAgICAgICAgICB0aGlzLmNvbnN0YW50Qml0UmF0aW9zW25hbWVdXG4gICAgICAgICAgKTtcbiAgICAgICAgICBzd2l0Y2ggKGJpdFJhdGlvKSB7XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgIHJldEFyci5wdXNoKGBnZXQ4KCR7bWFya3VwTmFtZX0sICR7bWFya3VwTmFtZX1TaXplLCAke21hcmt1cE5hbWV9RGltLCBgKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgIHJldEFyci5wdXNoKGBnZXQxNigke21hcmt1cE5hbWV9LCAke21hcmt1cE5hbWV9U2l6ZSwgJHttYXJrdXBOYW1lfURpbSwgYCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICByZXRBcnIucHVzaChgZ2V0MzIoJHttYXJrdXBOYW1lfSwgJHttYXJrdXBOYW1lfVNpemUsICR7bWFya3VwTmFtZX1EaW0sIGApO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgdW5oYW5kbGVkIGJpdCByYXRpbyBvZiAke2JpdFJhdGlvfWApO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLm1lbWJlckV4cHJlc3Npb25YWVooeFByb3BlcnR5LCB5UHJvcGVydHksIHpQcm9wZXJ0eSwgcmV0QXJyKTtcbiAgICAgICAgICByZXRBcnIucHVzaCgnKScpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnTWVtb3J5T3B0aW1pemVkTnVtYmVyVGV4dHVyZSc6XG4gICAgICAgIHJldEFyci5wdXNoKGBnZXRNZW1vcnlPcHRpbWl6ZWQzMigkeyBtYXJrdXBOYW1lIH0sICR7IG1hcmt1cE5hbWUgfVNpemUsICR7IG1hcmt1cE5hbWUgfURpbSwgYCk7XG4gICAgICAgIHRoaXMubWVtYmVyRXhwcmVzc2lvblhZWih4UHJvcGVydHksIHlQcm9wZXJ0eSwgelByb3BlcnR5LCByZXRBcnIpO1xuICAgICAgICByZXRBcnIucHVzaCgnKScpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ01hdHJpeCgyKSc6XG4gICAgICBjYXNlICdNYXRyaXgoMyknOlxuICAgICAgY2FzZSAnTWF0cml4KDQpJzpcbiAgICAgICAgcmV0QXJyLnB1c2goYCR7bWFya3VwTmFtZX1bJHt0aGlzLm1lbWJlckV4cHJlc3Npb25Qcm9wZXJ0eU1hcmt1cCh5UHJvcGVydHkpfV1gKTtcbiAgICAgICAgaWYgKHlQcm9wZXJ0eSkge1xuICAgICAgICAgIHJldEFyci5wdXNoKGBbJHt0aGlzLm1lbWJlckV4cHJlc3Npb25Qcm9wZXJ0eU1hcmt1cCh4UHJvcGVydHkpfV1gKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgdW5oYW5kbGVkIG1lbWJlciBleHByZXNzaW9uIFwiJHsgdHlwZSB9XCJgKTtcbiAgICB9XG4gICAgcmV0dXJuIHJldEFycjtcbiAgfVxuXG4gIGFzdENhbGxFeHByZXNzaW9uKGFzdCwgcmV0QXJyKSB7XG4gICAgaWYgKCFhc3QuY2FsbGVlKSB7XG4gICAgICB0aHJvdyB0aGlzLmFzdEVycm9yT3V0cHV0KCdVbmtub3duIENhbGxFeHByZXNzaW9uJywgYXN0KTtcbiAgICB9XG5cbiAgICBsZXQgZnVuY3Rpb25OYW1lID0gbnVsbDtcbiAgICBjb25zdCBpc01hdGhGdW5jdGlvbiA9IHRoaXMuaXNBc3RNYXRoRnVuY3Rpb24oYXN0KTtcblxuICAgIGlmIChpc01hdGhGdW5jdGlvbiB8fCAoYXN0LmNhbGxlZS5vYmplY3QgJiYgYXN0LmNhbGxlZS5vYmplY3QudHlwZSA9PT0gJ1RoaXNFeHByZXNzaW9uJykpIHtcbiAgICAgIGZ1bmN0aW9uTmFtZSA9IGFzdC5jYWxsZWUucHJvcGVydHkubmFtZTtcbiAgICB9XG4gICAgZWxzZSBpZiAoYXN0LmNhbGxlZS50eXBlID09PSAnU2VxdWVuY2VFeHByZXNzaW9uJyAmJiBhc3QuY2FsbGVlLmV4cHJlc3Npb25zWzBdLnR5cGUgPT09ICdMaXRlcmFsJyAmJiAhaXNOYU4oYXN0LmNhbGxlZS5leHByZXNzaW9uc1swXS5yYXcpKSB7XG4gICAgICBmdW5jdGlvbk5hbWUgPSBhc3QuY2FsbGVlLmV4cHJlc3Npb25zWzFdLnByb3BlcnR5Lm5hbWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZ1bmN0aW9uTmFtZSA9IGFzdC5jYWxsZWUubmFtZTtcbiAgICB9XG5cbiAgICBpZiAoIWZ1bmN0aW9uTmFtZSkge1xuICAgICAgdGhyb3cgdGhpcy5hc3RFcnJvck91dHB1dChgVW5oYW5kbGVkIGZ1bmN0aW9uLCBjb3VsZG4ndCBmaW5kIG5hbWVgLCBhc3QpO1xuICAgIH1cblxuICAgIHN3aXRjaCAoZnVuY3Rpb25OYW1lKSB7XG4gICAgICBjYXNlICdwb3cnOlxuICAgICAgICBmdW5jdGlvbk5hbWUgPSAnX3Bvdyc7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAncm91bmQnOlxuICAgICAgICBmdW5jdGlvbk5hbWUgPSAnX3JvdW5kJztcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuY2FsbGVkRnVuY3Rpb25zLmluZGV4T2YoZnVuY3Rpb25OYW1lKSA8IDApIHtcbiAgICAgIHRoaXMuY2FsbGVkRnVuY3Rpb25zLnB1c2goZnVuY3Rpb25OYW1lKTtcbiAgICB9XG5cbiAgICBpZiAoZnVuY3Rpb25OYW1lID09PSAncmFuZG9tJyAmJiB0aGlzLnBsdWdpbnMgJiYgdGhpcy5wbHVnaW5zLmxlbmd0aCA+IDApIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5wbHVnaW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHBsdWdpbiA9IHRoaXMucGx1Z2luc1tpXTtcbiAgICAgICAgaWYgKHBsdWdpbi5mdW5jdGlvbk1hdGNoID09PSAnTWF0aC5yYW5kb20oKScgJiYgcGx1Z2luLmZ1bmN0aW9uUmVwbGFjZSkge1xuICAgICAgICAgIHJldEFyci5wdXNoKHBsdWdpbi5mdW5jdGlvblJlcGxhY2UpO1xuICAgICAgICAgIHJldHVybiByZXRBcnI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5vbkZ1bmN0aW9uQ2FsbCkge1xuICAgICAgdGhpcy5vbkZ1bmN0aW9uQ2FsbCh0aGlzLm5hbWUsIGZ1bmN0aW9uTmFtZSwgYXN0LmFyZ3VtZW50cyk7XG4gICAgfVxuXG4gICAgcmV0QXJyLnB1c2goZnVuY3Rpb25OYW1lKTtcblxuICAgIHJldEFyci5wdXNoKCcoJyk7XG5cbiAgICBpZiAoaXNNYXRoRnVuY3Rpb24pIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXN0LmFyZ3VtZW50cy5sZW5ndGg7ICsraSkge1xuICAgICAgICBjb25zdCBhcmd1bWVudCA9IGFzdC5hcmd1bWVudHNbaV07XG4gICAgICAgIGNvbnN0IGFyZ3VtZW50VHlwZSA9IHRoaXMuZ2V0VHlwZShhcmd1bWVudCk7XG4gICAgICAgIGlmIChpID4gMCkge1xuICAgICAgICAgIHJldEFyci5wdXNoKCcsICcpO1xuICAgICAgICB9XG5cbiAgICAgICAgc3dpdGNoIChhcmd1bWVudFR5cGUpIHtcbiAgICAgICAgICBjYXNlICdJbnRlZ2VyJzpcbiAgICAgICAgICAgIHRoaXMuY2FzdFZhbHVlVG9GbG9hdChhcmd1bWVudCwgcmV0QXJyKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aGlzLmFzdEdlbmVyaWMoYXJndW1lbnQsIHJldEFycik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCB0YXJnZXRUeXBlcyA9IHRoaXMubG9va3VwRnVuY3Rpb25Bcmd1bWVudFR5cGVzKGZ1bmN0aW9uTmFtZSkgfHwgW107XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFzdC5hcmd1bWVudHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY29uc3QgYXJndW1lbnQgPSBhc3QuYXJndW1lbnRzW2ldO1xuICAgICAgICBsZXQgdGFyZ2V0VHlwZSA9IHRhcmdldFR5cGVzW2ldO1xuICAgICAgICBpZiAoaSA+IDApIHtcbiAgICAgICAgICByZXRBcnIucHVzaCgnLCAnKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhcmd1bWVudFR5cGUgPSB0aGlzLmdldFR5cGUoYXJndW1lbnQpO1xuICAgICAgICBpZiAoIXRhcmdldFR5cGUpIHtcbiAgICAgICAgICB0aGlzLnRyaWdnZXJJbXBseUFyZ3VtZW50VHlwZShmdW5jdGlvbk5hbWUsIGksIGFyZ3VtZW50VHlwZSwgdGhpcyk7XG4gICAgICAgICAgdGFyZ2V0VHlwZSA9IGFyZ3VtZW50VHlwZTtcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKGFyZ3VtZW50VHlwZSkge1xuICAgICAgICAgIGNhc2UgJ0Jvb2xlYW4nOlxuICAgICAgICAgICAgdGhpcy5hc3RHZW5lcmljKGFyZ3VtZW50LCByZXRBcnIpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgY2FzZSAnTnVtYmVyJzpcbiAgICAgICAgICBjYXNlICdGbG9hdCc6XG4gICAgICAgICAgICBpZiAodGFyZ2V0VHlwZSA9PT0gJ0ludGVnZXInKSB7XG4gICAgICAgICAgICAgIHJldEFyci5wdXNoKCdpbnQoJyk7XG4gICAgICAgICAgICAgIHRoaXMuYXN0R2VuZXJpYyhhcmd1bWVudCwgcmV0QXJyKTtcbiAgICAgICAgICAgICAgcmV0QXJyLnB1c2goJyknKTtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRhcmdldFR5cGUgPT09ICdOdW1iZXInIHx8IHRhcmdldFR5cGUgPT09ICdGbG9hdCcpIHtcbiAgICAgICAgICAgICAgdGhpcy5hc3RHZW5lcmljKGFyZ3VtZW50LCByZXRBcnIpO1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGFyZ2V0VHlwZSA9PT0gJ0xpdGVyYWxJbnRlZ2VyJykge1xuICAgICAgICAgICAgICB0aGlzLmNhc3RMaXRlcmFsVG9GbG9hdChhcmd1bWVudCwgcmV0QXJyKTtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdJbnRlZ2VyJzpcbiAgICAgICAgICAgIGlmICh0YXJnZXRUeXBlID09PSAnTnVtYmVyJyB8fCB0YXJnZXRUeXBlID09PSAnRmxvYXQnKSB7XG4gICAgICAgICAgICAgIHJldEFyci5wdXNoKCdmbG9hdCgnKTtcbiAgICAgICAgICAgICAgdGhpcy5hc3RHZW5lcmljKGFyZ3VtZW50LCByZXRBcnIpO1xuICAgICAgICAgICAgICByZXRBcnIucHVzaCgnKScpO1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGFyZ2V0VHlwZSA9PT0gJ0ludGVnZXInKSB7XG4gICAgICAgICAgICAgIHRoaXMuYXN0R2VuZXJpYyhhcmd1bWVudCwgcmV0QXJyKTtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdMaXRlcmFsSW50ZWdlcic6XG4gICAgICAgICAgICBpZiAodGFyZ2V0VHlwZSA9PT0gJ0ludGVnZXInKSB7XG4gICAgICAgICAgICAgIHRoaXMuY2FzdExpdGVyYWxUb0ludGVnZXIoYXJndW1lbnQsIHJldEFycik7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0YXJnZXRUeXBlID09PSAnTnVtYmVyJyB8fCB0YXJnZXRUeXBlID09PSAnRmxvYXQnKSB7XG4gICAgICAgICAgICAgIHRoaXMuY2FzdExpdGVyYWxUb0Zsb2F0KGFyZ3VtZW50LCByZXRBcnIpO1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGFyZ2V0VHlwZSA9PT0gJ0xpdGVyYWxJbnRlZ2VyJykge1xuICAgICAgICAgICAgICB0aGlzLmFzdEdlbmVyaWMoYXJndW1lbnQsIHJldEFycik7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnQXJyYXkoMiknOlxuICAgICAgICAgIGNhc2UgJ0FycmF5KDMpJzpcbiAgICAgICAgICBjYXNlICdBcnJheSg0KSc6XG4gICAgICAgICAgICBpZiAodGFyZ2V0VHlwZSA9PT0gYXJndW1lbnRUeXBlKSB7XG4gICAgICAgICAgICAgIGlmIChhcmd1bWVudC50eXBlID09PSAnSWRlbnRpZmllcicpIHtcbiAgICAgICAgICAgICAgICByZXRBcnIucHVzaChgdXNlcl8ke3V0aWxzLnNhbml0aXplTmFtZShhcmd1bWVudC5uYW1lKX1gKTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChhcmd1bWVudC50eXBlID09PSAnQXJyYXlFeHByZXNzaW9uJyB8fCBhcmd1bWVudC50eXBlID09PSAnTWVtYmVyRXhwcmVzc2lvbicgfHwgYXJndW1lbnQudHlwZSA9PT0gJ0NhbGxFeHByZXNzaW9uJykge1xuICAgICAgICAgICAgICAgIHRoaXMuYXN0R2VuZXJpYyhhcmd1bWVudCwgcmV0QXJyKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyB0aGlzLmFzdEVycm9yT3V0cHV0KGBVbmhhbmRsZWQgYXJndW1lbnQgdHlwZSAkeyBhcmd1bWVudC50eXBlIH1gLCBhc3QpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnSFRNTENhbnZhcyc6XG4gICAgICAgICAgY2FzZSAnSFRNTEltYWdlJzpcbiAgICAgICAgICBjYXNlICdIVE1MSW1hZ2VBcnJheSc6XG4gICAgICAgICAgY2FzZSAnSFRNTFZpZGVvJzpcbiAgICAgICAgICBjYXNlICdBcnJheVRleHR1cmUoMSknOlxuICAgICAgICAgIGNhc2UgJ0FycmF5VGV4dHVyZSgyKSc6XG4gICAgICAgICAgY2FzZSAnQXJyYXlUZXh0dXJlKDMpJzpcbiAgICAgICAgICBjYXNlICdBcnJheVRleHR1cmUoNCknOlxuICAgICAgICAgIGNhc2UgJ0FycmF5JzpcbiAgICAgICAgICBjYXNlICdJbnB1dCc6XG4gICAgICAgICAgICBpZiAodGFyZ2V0VHlwZSA9PT0gYXJndW1lbnRUeXBlKSB7XG4gICAgICAgICAgICAgIGlmIChhcmd1bWVudC50eXBlICE9PSAnSWRlbnRpZmllcicpIHRocm93IHRoaXMuYXN0RXJyb3JPdXRwdXQoYFVuaGFuZGxlZCBhcmd1bWVudCB0eXBlICR7IGFyZ3VtZW50LnR5cGUgfWAsIGFzdCk7XG4gICAgICAgICAgICAgIHRoaXMudHJpZ2dlckltcGx5QXJndW1lbnRCaXRSYXRpbyh0aGlzLm5hbWUsIGFyZ3VtZW50Lm5hbWUsIGZ1bmN0aW9uTmFtZSwgaSk7XG4gICAgICAgICAgICAgIGNvbnN0IG5hbWUgPSB1dGlscy5zYW5pdGl6ZU5hbWUoYXJndW1lbnQubmFtZSk7XG4gICAgICAgICAgICAgIHJldEFyci5wdXNoKGB1c2VyXyR7bmFtZX0sdXNlcl8ke25hbWV9U2l6ZSx1c2VyXyR7bmFtZX1EaW1gKTtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyB0aGlzLmFzdEVycm9yT3V0cHV0KGBVbmhhbmRsZWQgYXJndW1lbnQgY29tYmluYXRpb24gb2YgJHsgYXJndW1lbnRUeXBlIH0gYW5kICR7IHRhcmdldFR5cGUgfSBmb3IgYXJndW1lbnQgbmFtZWQgXCIkeyBhcmd1bWVudC5uYW1lIH1cImAsIGFzdCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldEFyci5wdXNoKCcpJyk7XG5cbiAgICByZXR1cm4gcmV0QXJyO1xuICB9XG5cbiAgYXN0QXJyYXlFeHByZXNzaW9uKGFyck5vZGUsIHJldEFycikge1xuICAgIGNvbnN0IHJldHVyblR5cGUgPSB0aGlzLmdldFR5cGUoYXJyTm9kZSk7XG5cbiAgICBjb25zdCBhcnJMZW4gPSBhcnJOb2RlLmVsZW1lbnRzLmxlbmd0aDtcblxuICAgIHN3aXRjaCAocmV0dXJuVHlwZSkge1xuICAgICAgY2FzZSAnTWF0cml4KDIpJzpcbiAgICAgIGNhc2UgJ01hdHJpeCgzKSc6XG4gICAgICBjYXNlICdNYXRyaXgoNCknOlxuICAgICAgICByZXRBcnIucHVzaChgbWF0JHthcnJMZW59KGApO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldEFyci5wdXNoKGB2ZWMke2Fyckxlbn0oYCk7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyTGVuOyArK2kpIHtcbiAgICAgIGlmIChpID4gMCkge1xuICAgICAgICByZXRBcnIucHVzaCgnLCAnKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHN1Yk5vZGUgPSBhcnJOb2RlLmVsZW1lbnRzW2ldO1xuICAgICAgdGhpcy5hc3RHZW5lcmljKHN1Yk5vZGUsIHJldEFycilcbiAgICB9XG4gICAgcmV0QXJyLnB1c2goJyknKTtcblxuICAgIHJldHVybiByZXRBcnI7XG4gIH1cblxuICBtZW1iZXJFeHByZXNzaW9uWFlaKHgsIHksIHosIHJldEFycikge1xuICAgIGlmICh6KSB7XG4gICAgICByZXRBcnIucHVzaCh0aGlzLm1lbWJlckV4cHJlc3Npb25Qcm9wZXJ0eU1hcmt1cCh6KSwgJywgJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldEFyci5wdXNoKCcwLCAnKTtcbiAgICB9XG4gICAgaWYgKHkpIHtcbiAgICAgIHJldEFyci5wdXNoKHRoaXMubWVtYmVyRXhwcmVzc2lvblByb3BlcnR5TWFya3VwKHkpLCAnLCAnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0QXJyLnB1c2goJzAsICcpO1xuICAgIH1cbiAgICByZXRBcnIucHVzaCh0aGlzLm1lbWJlckV4cHJlc3Npb25Qcm9wZXJ0eU1hcmt1cCh4KSk7XG4gICAgcmV0dXJuIHJldEFycjtcbiAgfVxuXG4gIG1lbWJlckV4cHJlc3Npb25Qcm9wZXJ0eU1hcmt1cChwcm9wZXJ0eSkge1xuICAgIGlmICghcHJvcGVydHkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignUHJvcGVydHkgbm90IHNldCcpO1xuICAgIH1cbiAgICBjb25zdCB0eXBlID0gdGhpcy5nZXRUeXBlKHByb3BlcnR5KTtcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgJ051bWJlcic6XG4gICAgICBjYXNlICdGbG9hdCc6XG4gICAgICAgIHRoaXMuY2FzdFZhbHVlVG9JbnRlZ2VyKHByb3BlcnR5LCByZXN1bHQpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ0xpdGVyYWxJbnRlZ2VyJzpcbiAgICAgICAgdGhpcy5jYXN0TGl0ZXJhbFRvSW50ZWdlcihwcm9wZXJ0eSwgcmVzdWx0KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aGlzLmFzdEdlbmVyaWMocHJvcGVydHksIHJlc3VsdCk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQuam9pbignJyk7XG4gIH1cbn1cblxuY29uc3QgdHlwZU1hcCA9IHtcbiAgJ0FycmF5JzogJ3NhbXBsZXIyRCcsXG4gICdBcnJheSgyKSc6ICd2ZWMyJyxcbiAgJ0FycmF5KDMpJzogJ3ZlYzMnLFxuICAnQXJyYXkoNCknOiAndmVjNCcsXG4gICdNYXRyaXgoMiknOiAnbWF0MicsXG4gICdNYXRyaXgoMyknOiAnbWF0MycsXG4gICdNYXRyaXgoNCknOiAnbWF0NCcsXG4gICdBcnJheTJEJzogJ3NhbXBsZXIyRCcsXG4gICdBcnJheTNEJzogJ3NhbXBsZXIyRCcsXG4gICdCb29sZWFuJzogJ2Jvb2wnLFxuICAnRmxvYXQnOiAnZmxvYXQnLFxuICAnSW5wdXQnOiAnc2FtcGxlcjJEJyxcbiAgJ0ludGVnZXInOiAnaW50JyxcbiAgJ051bWJlcic6ICdmbG9hdCcsXG4gICdMaXRlcmFsSW50ZWdlcic6ICdmbG9hdCcsXG4gICdOdW1iZXJUZXh0dXJlJzogJ3NhbXBsZXIyRCcsXG4gICdNZW1vcnlPcHRpbWl6ZWROdW1iZXJUZXh0dXJlJzogJ3NhbXBsZXIyRCcsXG4gICdBcnJheVRleHR1cmUoMSknOiAnc2FtcGxlcjJEJyxcbiAgJ0FycmF5VGV4dHVyZSgyKSc6ICdzYW1wbGVyMkQnLFxuICAnQXJyYXlUZXh0dXJlKDMpJzogJ3NhbXBsZXIyRCcsXG4gICdBcnJheVRleHR1cmUoNCknOiAnc2FtcGxlcjJEJyxcbiAgJ0hUTUxWaWRlbyc6ICdzYW1wbGVyMkQnLFxuICAnSFRNTENhbnZhcyc6ICdzYW1wbGVyMkQnLFxuICAnSFRNTEltYWdlJzogJ3NhbXBsZXIyRCcsXG4gICdIVE1MSW1hZ2VBcnJheSc6ICdzYW1wbGVyMkRBcnJheScsXG59O1xuXG5jb25zdCBvcGVyYXRvck1hcCA9IHtcbiAgJz09PSc6ICc9PScsXG4gICchPT0nOiAnIT0nXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgV2ViR0xGdW5jdGlvbk5vZGVcbn07XG59LHtcIi4uLy4uL3V0aWxzXCI6MTE0LFwiLi4vZnVuY3Rpb24tbm9kZVwiOjEwfV0sMzk6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuY29uc3QgeyBXZWJHTEtlcm5lbFZhbHVlQm9vbGVhbiB9ID0gcmVxdWlyZSgnLi9rZXJuZWwtdmFsdWUvYm9vbGVhbicpO1xuY29uc3QgeyBXZWJHTEtlcm5lbFZhbHVlRmxvYXQgfSA9IHJlcXVpcmUoJy4va2VybmVsLXZhbHVlL2Zsb2F0Jyk7XG5jb25zdCB7IFdlYkdMS2VybmVsVmFsdWVJbnRlZ2VyIH0gPSByZXF1aXJlKCcuL2tlcm5lbC12YWx1ZS9pbnRlZ2VyJyk7XG5cbmNvbnN0IHsgV2ViR0xLZXJuZWxWYWx1ZUhUTUxJbWFnZSB9ID0gcmVxdWlyZSgnLi9rZXJuZWwtdmFsdWUvaHRtbC1pbWFnZScpO1xuY29uc3QgeyBXZWJHTEtlcm5lbFZhbHVlRHluYW1pY0hUTUxJbWFnZSB9ID0gcmVxdWlyZSgnLi9rZXJuZWwtdmFsdWUvZHluYW1pYy1odG1sLWltYWdlJyk7XG5cbmNvbnN0IHsgV2ViR0xLZXJuZWxWYWx1ZUhUTUxWaWRlbyB9ID0gcmVxdWlyZSgnLi9rZXJuZWwtdmFsdWUvaHRtbC12aWRlbycpO1xuY29uc3QgeyBXZWJHTEtlcm5lbFZhbHVlRHluYW1pY0hUTUxWaWRlbyB9ID0gcmVxdWlyZSgnLi9rZXJuZWwtdmFsdWUvZHluYW1pYy1odG1sLXZpZGVvJyk7XG5cbmNvbnN0IHsgV2ViR0xLZXJuZWxWYWx1ZVNpbmdsZUlucHV0IH0gPSByZXF1aXJlKCcuL2tlcm5lbC12YWx1ZS9zaW5nbGUtaW5wdXQnKTtcbmNvbnN0IHsgV2ViR0xLZXJuZWxWYWx1ZUR5bmFtaWNTaW5nbGVJbnB1dCB9ID0gcmVxdWlyZSgnLi9rZXJuZWwtdmFsdWUvZHluYW1pYy1zaW5nbGUtaW5wdXQnKTtcblxuY29uc3QgeyBXZWJHTEtlcm5lbFZhbHVlVW5zaWduZWRJbnB1dCB9ID0gcmVxdWlyZSgnLi9rZXJuZWwtdmFsdWUvdW5zaWduZWQtaW5wdXQnKTtcbmNvbnN0IHsgV2ViR0xLZXJuZWxWYWx1ZUR5bmFtaWNVbnNpZ25lZElucHV0IH0gPSByZXF1aXJlKCcuL2tlcm5lbC12YWx1ZS9keW5hbWljLXVuc2lnbmVkLWlucHV0Jyk7XG5cbmNvbnN0IHsgV2ViR0xLZXJuZWxWYWx1ZU1lbW9yeU9wdGltaXplZE51bWJlclRleHR1cmUgfSA9IHJlcXVpcmUoJy4va2VybmVsLXZhbHVlL21lbW9yeS1vcHRpbWl6ZWQtbnVtYmVyLXRleHR1cmUnKTtcbmNvbnN0IHsgV2ViR0xLZXJuZWxWYWx1ZUR5bmFtaWNNZW1vcnlPcHRpbWl6ZWROdW1iZXJUZXh0dXJlIH0gPSByZXF1aXJlKCcuL2tlcm5lbC12YWx1ZS9keW5hbWljLW1lbW9yeS1vcHRpbWl6ZWQtbnVtYmVyLXRleHR1cmUnKTtcblxuY29uc3QgeyBXZWJHTEtlcm5lbFZhbHVlTnVtYmVyVGV4dHVyZSB9ID0gcmVxdWlyZSgnLi9rZXJuZWwtdmFsdWUvbnVtYmVyLXRleHR1cmUnKTtcbmNvbnN0IHsgV2ViR0xLZXJuZWxWYWx1ZUR5bmFtaWNOdW1iZXJUZXh0dXJlIH0gPSByZXF1aXJlKCcuL2tlcm5lbC12YWx1ZS9keW5hbWljLW51bWJlci10ZXh0dXJlJyk7XG5cbmNvbnN0IHsgV2ViR0xLZXJuZWxWYWx1ZVNpbmdsZUFycmF5IH0gPSByZXF1aXJlKCcuL2tlcm5lbC12YWx1ZS9zaW5nbGUtYXJyYXknKTtcbmNvbnN0IHsgV2ViR0xLZXJuZWxWYWx1ZUR5bmFtaWNTaW5nbGVBcnJheSB9ID0gcmVxdWlyZSgnLi9rZXJuZWwtdmFsdWUvZHluYW1pYy1zaW5nbGUtYXJyYXknKTtcblxuY29uc3QgeyBXZWJHTEtlcm5lbFZhbHVlU2luZ2xlQXJyYXkxREkgfSA9IHJlcXVpcmUoJy4va2VybmVsLXZhbHVlL3NpbmdsZS1hcnJheTFkLWknKTtcbmNvbnN0IHsgV2ViR0xLZXJuZWxWYWx1ZUR5bmFtaWNTaW5nbGVBcnJheTFESSB9ID0gcmVxdWlyZSgnLi9rZXJuZWwtdmFsdWUvZHluYW1pYy1zaW5nbGUtYXJyYXkxZC1pJyk7XG5cbmNvbnN0IHsgV2ViR0xLZXJuZWxWYWx1ZVNpbmdsZUFycmF5MkRJIH0gPSByZXF1aXJlKCcuL2tlcm5lbC12YWx1ZS9zaW5nbGUtYXJyYXkyZC1pJyk7XG5jb25zdCB7IFdlYkdMS2VybmVsVmFsdWVEeW5hbWljU2luZ2xlQXJyYXkyREkgfSA9IHJlcXVpcmUoJy4va2VybmVsLXZhbHVlL2R5bmFtaWMtc2luZ2xlLWFycmF5MmQtaScpO1xuXG5jb25zdCB7IFdlYkdMS2VybmVsVmFsdWVTaW5nbGVBcnJheTNESSB9ID0gcmVxdWlyZSgnLi9rZXJuZWwtdmFsdWUvc2luZ2xlLWFycmF5M2QtaScpO1xuY29uc3QgeyBXZWJHTEtlcm5lbFZhbHVlRHluYW1pY1NpbmdsZUFycmF5M0RJIH0gPSByZXF1aXJlKCcuL2tlcm5lbC12YWx1ZS9keW5hbWljLXNpbmdsZS1hcnJheTNkLWknKTtcblxuY29uc3QgeyBXZWJHTEtlcm5lbFZhbHVlU2luZ2xlQXJyYXkyIH0gPSByZXF1aXJlKCcuL2tlcm5lbC12YWx1ZS9zaW5nbGUtYXJyYXkyJyk7XG5jb25zdCB7IFdlYkdMS2VybmVsVmFsdWVTaW5nbGVBcnJheTMgfSA9IHJlcXVpcmUoJy4va2VybmVsLXZhbHVlL3NpbmdsZS1hcnJheTMnKTtcbmNvbnN0IHsgV2ViR0xLZXJuZWxWYWx1ZVNpbmdsZUFycmF5NCB9ID0gcmVxdWlyZSgnLi9rZXJuZWwtdmFsdWUvc2luZ2xlLWFycmF5NCcpO1xuXG5jb25zdCB7IFdlYkdMS2VybmVsVmFsdWVVbnNpZ25lZEFycmF5IH0gPSByZXF1aXJlKCcuL2tlcm5lbC12YWx1ZS91bnNpZ25lZC1hcnJheScpO1xuY29uc3QgeyBXZWJHTEtlcm5lbFZhbHVlRHluYW1pY1Vuc2lnbmVkQXJyYXkgfSA9IHJlcXVpcmUoJy4va2VybmVsLXZhbHVlL2R5bmFtaWMtdW5zaWduZWQtYXJyYXknKTtcblxuY29uc3Qga2VybmVsVmFsdWVNYXBzID0ge1xuICB1bnNpZ25lZDoge1xuICAgIGR5bmFtaWM6IHtcbiAgICAgICdCb29sZWFuJzogV2ViR0xLZXJuZWxWYWx1ZUJvb2xlYW4sXG4gICAgICAnSW50ZWdlcic6IFdlYkdMS2VybmVsVmFsdWVJbnRlZ2VyLFxuICAgICAgJ0Zsb2F0JzogV2ViR0xLZXJuZWxWYWx1ZUZsb2F0LFxuICAgICAgJ0FycmF5JzogV2ViR0xLZXJuZWxWYWx1ZUR5bmFtaWNVbnNpZ25lZEFycmF5LFxuICAgICAgJ0FycmF5KDIpJzogZmFsc2UsXG4gICAgICAnQXJyYXkoMyknOiBmYWxzZSxcbiAgICAgICdBcnJheSg0KSc6IGZhbHNlLFxuICAgICAgJ0FycmF5MUQoMiknOiBmYWxzZSxcbiAgICAgICdBcnJheTFEKDMpJzogZmFsc2UsXG4gICAgICAnQXJyYXkxRCg0KSc6IGZhbHNlLFxuICAgICAgJ0FycmF5MkQoMiknOiBmYWxzZSxcbiAgICAgICdBcnJheTJEKDMpJzogZmFsc2UsXG4gICAgICAnQXJyYXkyRCg0KSc6IGZhbHNlLFxuICAgICAgJ0FycmF5M0QoMiknOiBmYWxzZSxcbiAgICAgICdBcnJheTNEKDMpJzogZmFsc2UsXG4gICAgICAnQXJyYXkzRCg0KSc6IGZhbHNlLFxuICAgICAgJ0lucHV0JzogV2ViR0xLZXJuZWxWYWx1ZUR5bmFtaWNVbnNpZ25lZElucHV0LFxuICAgICAgJ051bWJlclRleHR1cmUnOiBXZWJHTEtlcm5lbFZhbHVlRHluYW1pY051bWJlclRleHR1cmUsXG4gICAgICAnQXJyYXlUZXh0dXJlKDEpJzogV2ViR0xLZXJuZWxWYWx1ZUR5bmFtaWNOdW1iZXJUZXh0dXJlLFxuICAgICAgJ0FycmF5VGV4dHVyZSgyKSc6IFdlYkdMS2VybmVsVmFsdWVEeW5hbWljTnVtYmVyVGV4dHVyZSxcbiAgICAgICdBcnJheVRleHR1cmUoMyknOiBXZWJHTEtlcm5lbFZhbHVlRHluYW1pY051bWJlclRleHR1cmUsXG4gICAgICAnQXJyYXlUZXh0dXJlKDQpJzogV2ViR0xLZXJuZWxWYWx1ZUR5bmFtaWNOdW1iZXJUZXh0dXJlLFxuICAgICAgJ01lbW9yeU9wdGltaXplZE51bWJlclRleHR1cmUnOiBXZWJHTEtlcm5lbFZhbHVlRHluYW1pY01lbW9yeU9wdGltaXplZE51bWJlclRleHR1cmUsXG4gICAgICAnSFRNTENhbnZhcyc6IFdlYkdMS2VybmVsVmFsdWVEeW5hbWljSFRNTEltYWdlLFxuICAgICAgJ0hUTUxJbWFnZSc6IFdlYkdMS2VybmVsVmFsdWVEeW5hbWljSFRNTEltYWdlLFxuICAgICAgJ0hUTUxJbWFnZUFycmF5JzogZmFsc2UsXG4gICAgICAnSFRNTFZpZGVvJzogV2ViR0xLZXJuZWxWYWx1ZUR5bmFtaWNIVE1MVmlkZW8sXG4gICAgfSxcbiAgICBzdGF0aWM6IHtcbiAgICAgICdCb29sZWFuJzogV2ViR0xLZXJuZWxWYWx1ZUJvb2xlYW4sXG4gICAgICAnRmxvYXQnOiBXZWJHTEtlcm5lbFZhbHVlRmxvYXQsXG4gICAgICAnSW50ZWdlcic6IFdlYkdMS2VybmVsVmFsdWVJbnRlZ2VyLFxuICAgICAgJ0FycmF5JzogV2ViR0xLZXJuZWxWYWx1ZVVuc2lnbmVkQXJyYXksXG4gICAgICAnQXJyYXkoMiknOiBmYWxzZSxcbiAgICAgICdBcnJheSgzKSc6IGZhbHNlLFxuICAgICAgJ0FycmF5KDQpJzogZmFsc2UsXG4gICAgICAnQXJyYXkxRCgyKSc6IGZhbHNlLFxuICAgICAgJ0FycmF5MUQoMyknOiBmYWxzZSxcbiAgICAgICdBcnJheTFEKDQpJzogZmFsc2UsXG4gICAgICAnQXJyYXkyRCgyKSc6IGZhbHNlLFxuICAgICAgJ0FycmF5MkQoMyknOiBmYWxzZSxcbiAgICAgICdBcnJheTJEKDQpJzogZmFsc2UsXG4gICAgICAnQXJyYXkzRCgyKSc6IGZhbHNlLFxuICAgICAgJ0FycmF5M0QoMyknOiBmYWxzZSxcbiAgICAgICdBcnJheTNEKDQpJzogZmFsc2UsXG4gICAgICAnSW5wdXQnOiBXZWJHTEtlcm5lbFZhbHVlVW5zaWduZWRJbnB1dCxcbiAgICAgICdOdW1iZXJUZXh0dXJlJzogV2ViR0xLZXJuZWxWYWx1ZU51bWJlclRleHR1cmUsXG4gICAgICAnQXJyYXlUZXh0dXJlKDEpJzogV2ViR0xLZXJuZWxWYWx1ZU51bWJlclRleHR1cmUsXG4gICAgICAnQXJyYXlUZXh0dXJlKDIpJzogV2ViR0xLZXJuZWxWYWx1ZU51bWJlclRleHR1cmUsXG4gICAgICAnQXJyYXlUZXh0dXJlKDMpJzogV2ViR0xLZXJuZWxWYWx1ZU51bWJlclRleHR1cmUsXG4gICAgICAnQXJyYXlUZXh0dXJlKDQpJzogV2ViR0xLZXJuZWxWYWx1ZU51bWJlclRleHR1cmUsXG4gICAgICAnTWVtb3J5T3B0aW1pemVkTnVtYmVyVGV4dHVyZSc6IFdlYkdMS2VybmVsVmFsdWVNZW1vcnlPcHRpbWl6ZWROdW1iZXJUZXh0dXJlLFxuICAgICAgJ0hUTUxDYW52YXMnOiBXZWJHTEtlcm5lbFZhbHVlSFRNTEltYWdlLFxuICAgICAgJ0hUTUxJbWFnZSc6IFdlYkdMS2VybmVsVmFsdWVIVE1MSW1hZ2UsXG4gICAgICAnSFRNTEltYWdlQXJyYXknOiBmYWxzZSxcbiAgICAgICdIVE1MVmlkZW8nOiBXZWJHTEtlcm5lbFZhbHVlSFRNTFZpZGVvLFxuICAgIH1cbiAgfSxcbiAgc2luZ2xlOiB7XG4gICAgZHluYW1pYzoge1xuICAgICAgJ0Jvb2xlYW4nOiBXZWJHTEtlcm5lbFZhbHVlQm9vbGVhbixcbiAgICAgICdJbnRlZ2VyJzogV2ViR0xLZXJuZWxWYWx1ZUludGVnZXIsXG4gICAgICAnRmxvYXQnOiBXZWJHTEtlcm5lbFZhbHVlRmxvYXQsXG4gICAgICAnQXJyYXknOiBXZWJHTEtlcm5lbFZhbHVlRHluYW1pY1NpbmdsZUFycmF5LFxuICAgICAgJ0FycmF5KDIpJzogV2ViR0xLZXJuZWxWYWx1ZVNpbmdsZUFycmF5MixcbiAgICAgICdBcnJheSgzKSc6IFdlYkdMS2VybmVsVmFsdWVTaW5nbGVBcnJheTMsXG4gICAgICAnQXJyYXkoNCknOiBXZWJHTEtlcm5lbFZhbHVlU2luZ2xlQXJyYXk0LFxuICAgICAgJ0FycmF5MUQoMiknOiBXZWJHTEtlcm5lbFZhbHVlRHluYW1pY1NpbmdsZUFycmF5MURJLFxuICAgICAgJ0FycmF5MUQoMyknOiBXZWJHTEtlcm5lbFZhbHVlRHluYW1pY1NpbmdsZUFycmF5MURJLFxuICAgICAgJ0FycmF5MUQoNCknOiBXZWJHTEtlcm5lbFZhbHVlRHluYW1pY1NpbmdsZUFycmF5MURJLFxuICAgICAgJ0FycmF5MkQoMiknOiBXZWJHTEtlcm5lbFZhbHVlRHluYW1pY1NpbmdsZUFycmF5MkRJLFxuICAgICAgJ0FycmF5MkQoMyknOiBXZWJHTEtlcm5lbFZhbHVlRHluYW1pY1NpbmdsZUFycmF5MkRJLFxuICAgICAgJ0FycmF5MkQoNCknOiBXZWJHTEtlcm5lbFZhbHVlRHluYW1pY1NpbmdsZUFycmF5MkRJLFxuICAgICAgJ0FycmF5M0QoMiknOiBXZWJHTEtlcm5lbFZhbHVlRHluYW1pY1NpbmdsZUFycmF5M0RJLFxuICAgICAgJ0FycmF5M0QoMyknOiBXZWJHTEtlcm5lbFZhbHVlRHluYW1pY1NpbmdsZUFycmF5M0RJLFxuICAgICAgJ0FycmF5M0QoNCknOiBXZWJHTEtlcm5lbFZhbHVlRHluYW1pY1NpbmdsZUFycmF5M0RJLFxuICAgICAgJ0lucHV0JzogV2ViR0xLZXJuZWxWYWx1ZUR5bmFtaWNTaW5nbGVJbnB1dCxcbiAgICAgICdOdW1iZXJUZXh0dXJlJzogV2ViR0xLZXJuZWxWYWx1ZUR5bmFtaWNOdW1iZXJUZXh0dXJlLFxuICAgICAgJ0FycmF5VGV4dHVyZSgxKSc6IFdlYkdMS2VybmVsVmFsdWVEeW5hbWljTnVtYmVyVGV4dHVyZSxcbiAgICAgICdBcnJheVRleHR1cmUoMiknOiBXZWJHTEtlcm5lbFZhbHVlRHluYW1pY051bWJlclRleHR1cmUsXG4gICAgICAnQXJyYXlUZXh0dXJlKDMpJzogV2ViR0xLZXJuZWxWYWx1ZUR5bmFtaWNOdW1iZXJUZXh0dXJlLFxuICAgICAgJ0FycmF5VGV4dHVyZSg0KSc6IFdlYkdMS2VybmVsVmFsdWVEeW5hbWljTnVtYmVyVGV4dHVyZSxcbiAgICAgICdNZW1vcnlPcHRpbWl6ZWROdW1iZXJUZXh0dXJlJzogV2ViR0xLZXJuZWxWYWx1ZUR5bmFtaWNNZW1vcnlPcHRpbWl6ZWROdW1iZXJUZXh0dXJlLFxuICAgICAgJ0hUTUxDYW52YXMnOiBXZWJHTEtlcm5lbFZhbHVlRHluYW1pY0hUTUxJbWFnZSxcbiAgICAgICdIVE1MSW1hZ2UnOiBXZWJHTEtlcm5lbFZhbHVlRHluYW1pY0hUTUxJbWFnZSxcbiAgICAgICdIVE1MSW1hZ2VBcnJheSc6IGZhbHNlLFxuICAgICAgJ0hUTUxWaWRlbyc6IFdlYkdMS2VybmVsVmFsdWVEeW5hbWljSFRNTFZpZGVvLFxuICAgIH0sXG4gICAgc3RhdGljOiB7XG4gICAgICAnQm9vbGVhbic6IFdlYkdMS2VybmVsVmFsdWVCb29sZWFuLFxuICAgICAgJ0Zsb2F0JzogV2ViR0xLZXJuZWxWYWx1ZUZsb2F0LFxuICAgICAgJ0ludGVnZXInOiBXZWJHTEtlcm5lbFZhbHVlSW50ZWdlcixcbiAgICAgICdBcnJheSc6IFdlYkdMS2VybmVsVmFsdWVTaW5nbGVBcnJheSxcbiAgICAgICdBcnJheSgyKSc6IFdlYkdMS2VybmVsVmFsdWVTaW5nbGVBcnJheTIsXG4gICAgICAnQXJyYXkoMyknOiBXZWJHTEtlcm5lbFZhbHVlU2luZ2xlQXJyYXkzLFxuICAgICAgJ0FycmF5KDQpJzogV2ViR0xLZXJuZWxWYWx1ZVNpbmdsZUFycmF5NCxcbiAgICAgICdBcnJheTFEKDIpJzogV2ViR0xLZXJuZWxWYWx1ZVNpbmdsZUFycmF5MURJLFxuICAgICAgJ0FycmF5MUQoMyknOiBXZWJHTEtlcm5lbFZhbHVlU2luZ2xlQXJyYXkxREksXG4gICAgICAnQXJyYXkxRCg0KSc6IFdlYkdMS2VybmVsVmFsdWVTaW5nbGVBcnJheTFESSxcbiAgICAgICdBcnJheTJEKDIpJzogV2ViR0xLZXJuZWxWYWx1ZVNpbmdsZUFycmF5MkRJLFxuICAgICAgJ0FycmF5MkQoMyknOiBXZWJHTEtlcm5lbFZhbHVlU2luZ2xlQXJyYXkyREksXG4gICAgICAnQXJyYXkyRCg0KSc6IFdlYkdMS2VybmVsVmFsdWVTaW5nbGVBcnJheTJESSxcbiAgICAgICdBcnJheTNEKDIpJzogV2ViR0xLZXJuZWxWYWx1ZVNpbmdsZUFycmF5M0RJLFxuICAgICAgJ0FycmF5M0QoMyknOiBXZWJHTEtlcm5lbFZhbHVlU2luZ2xlQXJyYXkzREksXG4gICAgICAnQXJyYXkzRCg0KSc6IFdlYkdMS2VybmVsVmFsdWVTaW5nbGVBcnJheTNESSxcbiAgICAgICdJbnB1dCc6IFdlYkdMS2VybmVsVmFsdWVTaW5nbGVJbnB1dCxcbiAgICAgICdOdW1iZXJUZXh0dXJlJzogV2ViR0xLZXJuZWxWYWx1ZU51bWJlclRleHR1cmUsXG4gICAgICAnQXJyYXlUZXh0dXJlKDEpJzogV2ViR0xLZXJuZWxWYWx1ZU51bWJlclRleHR1cmUsXG4gICAgICAnQXJyYXlUZXh0dXJlKDIpJzogV2ViR0xLZXJuZWxWYWx1ZU51bWJlclRleHR1cmUsXG4gICAgICAnQXJyYXlUZXh0dXJlKDMpJzogV2ViR0xLZXJuZWxWYWx1ZU51bWJlclRleHR1cmUsXG4gICAgICAnQXJyYXlUZXh0dXJlKDQpJzogV2ViR0xLZXJuZWxWYWx1ZU51bWJlclRleHR1cmUsXG4gICAgICAnTWVtb3J5T3B0aW1pemVkTnVtYmVyVGV4dHVyZSc6IFdlYkdMS2VybmVsVmFsdWVNZW1vcnlPcHRpbWl6ZWROdW1iZXJUZXh0dXJlLFxuICAgICAgJ0hUTUxDYW52YXMnOiBXZWJHTEtlcm5lbFZhbHVlSFRNTEltYWdlLFxuICAgICAgJ0hUTUxJbWFnZSc6IFdlYkdMS2VybmVsVmFsdWVIVE1MSW1hZ2UsXG4gICAgICAnSFRNTEltYWdlQXJyYXknOiBmYWxzZSxcbiAgICAgICdIVE1MVmlkZW8nOiBXZWJHTEtlcm5lbFZhbHVlSFRNTFZpZGVvLFxuICAgIH1cbiAgfSxcbn07XG5cbmZ1bmN0aW9uIGxvb2t1cEtlcm5lbFZhbHVlVHlwZSh0eXBlLCBkeW5hbWljLCBwcmVjaXNpb24sIHZhbHVlKSB7XG4gIGlmICghdHlwZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigndHlwZSBtaXNzaW5nJyk7XG4gIH1cbiAgaWYgKCFkeW5hbWljKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdkeW5hbWljIG1pc3NpbmcnKTtcbiAgfVxuICBpZiAoIXByZWNpc2lvbikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJlY2lzaW9uIG1pc3NpbmcnKTtcbiAgfVxuICBpZiAodmFsdWUudHlwZSkge1xuICAgIHR5cGUgPSB2YWx1ZS50eXBlO1xuICB9XG4gIGNvbnN0IHR5cGVzID0ga2VybmVsVmFsdWVNYXBzW3ByZWNpc2lvbl1bZHluYW1pY107XG4gIGlmICh0eXBlc1t0eXBlXSA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfSBlbHNlIGlmICh0eXBlc1t0eXBlXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBDb3VsZCBub3QgZmluZCBhIEtlcm5lbFZhbHVlIGZvciAkeyB0eXBlIH1gKTtcbiAgfVxuICByZXR1cm4gdHlwZXNbdHlwZV07XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBsb29rdXBLZXJuZWxWYWx1ZVR5cGUsXG4gIGtlcm5lbFZhbHVlTWFwcyxcbn07XG59LHtcIi4va2VybmVsLXZhbHVlL2Jvb2xlYW5cIjo0MSxcIi4va2VybmVsLXZhbHVlL2R5bmFtaWMtaHRtbC1pbWFnZVwiOjQyLFwiLi9rZXJuZWwtdmFsdWUvZHluYW1pYy1odG1sLXZpZGVvXCI6NDMsXCIuL2tlcm5lbC12YWx1ZS9keW5hbWljLW1lbW9yeS1vcHRpbWl6ZWQtbnVtYmVyLXRleHR1cmVcIjo0NCxcIi4va2VybmVsLXZhbHVlL2R5bmFtaWMtbnVtYmVyLXRleHR1cmVcIjo0NSxcIi4va2VybmVsLXZhbHVlL2R5bmFtaWMtc2luZ2xlLWFycmF5XCI6NDYsXCIuL2tlcm5lbC12YWx1ZS9keW5hbWljLXNpbmdsZS1hcnJheTFkLWlcIjo0NyxcIi4va2VybmVsLXZhbHVlL2R5bmFtaWMtc2luZ2xlLWFycmF5MmQtaVwiOjQ4LFwiLi9rZXJuZWwtdmFsdWUvZHluYW1pYy1zaW5nbGUtYXJyYXkzZC1pXCI6NDksXCIuL2tlcm5lbC12YWx1ZS9keW5hbWljLXNpbmdsZS1pbnB1dFwiOjUwLFwiLi9rZXJuZWwtdmFsdWUvZHluYW1pYy11bnNpZ25lZC1hcnJheVwiOjUxLFwiLi9rZXJuZWwtdmFsdWUvZHluYW1pYy11bnNpZ25lZC1pbnB1dFwiOjUyLFwiLi9rZXJuZWwtdmFsdWUvZmxvYXRcIjo1MyxcIi4va2VybmVsLXZhbHVlL2h0bWwtaW1hZ2VcIjo1NCxcIi4va2VybmVsLXZhbHVlL2h0bWwtdmlkZW9cIjo1NSxcIi4va2VybmVsLXZhbHVlL2ludGVnZXJcIjo1NyxcIi4va2VybmVsLXZhbHVlL21lbW9yeS1vcHRpbWl6ZWQtbnVtYmVyLXRleHR1cmVcIjo1OCxcIi4va2VybmVsLXZhbHVlL251bWJlci10ZXh0dXJlXCI6NTksXCIuL2tlcm5lbC12YWx1ZS9zaW5nbGUtYXJyYXlcIjo2MCxcIi4va2VybmVsLXZhbHVlL3NpbmdsZS1hcnJheTFkLWlcIjo2MSxcIi4va2VybmVsLXZhbHVlL3NpbmdsZS1hcnJheTJcIjo2MixcIi4va2VybmVsLXZhbHVlL3NpbmdsZS1hcnJheTJkLWlcIjo2MyxcIi4va2VybmVsLXZhbHVlL3NpbmdsZS1hcnJheTNcIjo2NCxcIi4va2VybmVsLXZhbHVlL3NpbmdsZS1hcnJheTNkLWlcIjo2NSxcIi4va2VybmVsLXZhbHVlL3NpbmdsZS1hcnJheTRcIjo2NixcIi4va2VybmVsLXZhbHVlL3NpbmdsZS1pbnB1dFwiOjY3LFwiLi9rZXJuZWwtdmFsdWUvdW5zaWduZWQtYXJyYXlcIjo2OCxcIi4va2VybmVsLXZhbHVlL3Vuc2lnbmVkLWlucHV0XCI6Njl9XSw0MDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5jb25zdCB7IFdlYkdMS2VybmVsVmFsdWUgfSA9IHJlcXVpcmUoJy4vaW5kZXgnKTtcbmNvbnN0IHsgSW5wdXQgfSA9IHJlcXVpcmUoJy4uLy4uLy4uL2lucHV0Jyk7XG5cbmNsYXNzIFdlYkdMS2VybmVsQXJyYXkgZXh0ZW5kcyBXZWJHTEtlcm5lbFZhbHVlIHtcbiAgY2hlY2tTaXplKHdpZHRoLCBoZWlnaHQpIHtcbiAgICBpZiAoIXRoaXMua2VybmVsLnZhbGlkYXRlKSByZXR1cm47XG4gICAgY29uc3QgeyBtYXhUZXh0dXJlU2l6ZSB9ID0gdGhpcy5rZXJuZWwuY29uc3RydWN0b3IuZmVhdHVyZXM7XG4gICAgaWYgKHdpZHRoID4gbWF4VGV4dHVyZVNpemUgfHwgaGVpZ2h0ID4gbWF4VGV4dHVyZVNpemUpIHtcbiAgICAgIGlmICh3aWR0aCA+IGhlaWdodCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEFyZ3VtZW50IHRleHR1cmUgd2lkdGggb2YgJHt3aWR0aH0gbGFyZ2VyIHRoYW4gbWF4aW11bSBzaXplIG9mICR7bWF4VGV4dHVyZVNpemV9IGZvciB5b3VyIEdQVWApO1xuICAgICAgfSBlbHNlIGlmICh3aWR0aCA8IGhlaWdodCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEFyZ3VtZW50IHRleHR1cmUgaGVpZ2h0IG9mICR7aGVpZ2h0fSBsYXJnZXIgdGhhbiBtYXhpbXVtIHNpemUgb2YgJHttYXhUZXh0dXJlU2l6ZX0gZm9yIHlvdXIgR1BVYCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEFyZ3VtZW50IHRleHR1cmUgaGVpZ2h0IGFuZCB3aWR0aCBvZiAke2hlaWdodH0gbGFyZ2VyIHRoYW4gbWF4aW11bSBzaXplIG9mICR7bWF4VGV4dHVyZVNpemV9IGZvciB5b3VyIEdQVWApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHNldHVwKCkge1xuICAgIHRoaXMucmVxdWVzdFRleHR1cmUoKTtcbiAgICB0aGlzLnNldHVwVGV4dHVyZSgpO1xuICAgIHRoaXMuZGVmaW5lVGV4dHVyZSgpO1xuICB9XG5cbiAgcmVxdWVzdFRleHR1cmUoKSB7XG4gICAgdGhpcy50ZXh0dXJlID0gdGhpcy5vblJlcXVlc3RUZXh0dXJlKCk7XG4gIH1cblxuICBkZWZpbmVUZXh0dXJlKCkge1xuICAgIGNvbnN0IHsgY29udGV4dDogZ2wgfSA9IHRoaXM7XG4gICAgZ2wuYWN0aXZlVGV4dHVyZSh0aGlzLmNvbnRleHRIYW5kbGUpO1xuICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRoaXMudGV4dHVyZSk7XG4gICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfUywgZ2wuQ0xBTVBfVE9fRURHRSk7XG4gICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfVCwgZ2wuQ0xBTVBfVE9fRURHRSk7XG4gICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01JTl9GSUxURVIsIGdsLk5FQVJFU1QpO1xuICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCBnbC5ORUFSRVNUKTtcbiAgfVxuXG4gIHNldHVwVGV4dHVyZSgpIHtcbiAgICB0aGlzLmNvbnRleHRIYW5kbGUgPSB0aGlzLm9uUmVxdWVzdENvbnRleHRIYW5kbGUoKTtcbiAgICB0aGlzLmluZGV4ID0gdGhpcy5vblJlcXVlc3RJbmRleCgpO1xuICAgIHRoaXMuZGltZW5zaW9uc0lkID0gdGhpcy5pZCArICdEaW0nO1xuICAgIHRoaXMuc2l6ZUlkID0gdGhpcy5pZCArICdTaXplJztcbiAgfVxuXG4gIGdldEJpdFJhdGlvKHZhbHVlKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWVbMF0pKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRCaXRSYXRpbyh2YWx1ZVswXSk7XG4gICAgfSBlbHNlIGlmICh2YWx1ZS5jb25zdHJ1Y3RvciA9PT0gSW5wdXQpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldEJpdFJhdGlvKHZhbHVlLnZhbHVlKTtcbiAgICB9XG4gICAgc3dpdGNoICh2YWx1ZS5jb25zdHJ1Y3Rvcikge1xuICAgICAgY2FzZSBVaW50OENsYW1wZWRBcnJheTpcbiAgICAgIGNhc2UgVWludDhBcnJheTpcbiAgICAgIGNhc2UgSW50OEFycmF5OlxuICAgICAgICByZXR1cm4gMTtcbiAgICAgIGNhc2UgVWludDE2QXJyYXk6XG4gICAgICBjYXNlIEludDE2QXJyYXk6XG4gICAgICAgIHJldHVybiAyO1xuICAgICAgY2FzZSBGbG9hdDMyQXJyYXk6XG4gICAgICBjYXNlIEludDMyQXJyYXk6XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gNDtcbiAgICB9XG4gIH1cblxuICBkZXN0cm95KCkge1xuICAgIGlmICh0aGlzLnByZXZBcmcpIHtcbiAgICAgIHRoaXMucHJldkFyZy5kZWxldGUoKTtcbiAgICB9XG4gICAgdGhpcy5jb250ZXh0LmRlbGV0ZVRleHR1cmUodGhpcy50ZXh0dXJlKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgV2ViR0xLZXJuZWxBcnJheVxufTtcbn0se1wiLi4vLi4vLi4vaW5wdXRcIjoxMTAsXCIuL2luZGV4XCI6NTZ9XSw0MTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5jb25zdCB7IHV0aWxzIH0gPSByZXF1aXJlKCcuLi8uLi8uLi91dGlscycpO1xuY29uc3QgeyBXZWJHTEtlcm5lbFZhbHVlIH0gPSByZXF1aXJlKCcuL2luZGV4Jyk7XG5cbmNsYXNzIFdlYkdMS2VybmVsVmFsdWVCb29sZWFuIGV4dGVuZHMgV2ViR0xLZXJuZWxWYWx1ZSB7XG4gIGNvbnN0cnVjdG9yKHZhbHVlLCBzZXR0aW5ncykge1xuICAgIHN1cGVyKHZhbHVlLCBzZXR0aW5ncyk7XG4gICAgdGhpcy51cGxvYWRWYWx1ZSA9IHZhbHVlO1xuICB9XG4gIGdldFNvdXJjZSh2YWx1ZSkge1xuICAgIGlmICh0aGlzLm9yaWdpbiA9PT0gJ2NvbnN0YW50cycpIHtcbiAgICAgIHJldHVybiBgY29uc3QgYm9vbCAke3RoaXMuaWR9ID0gJHt2YWx1ZX07XFxuYDtcbiAgICB9XG4gICAgcmV0dXJuIGB1bmlmb3JtIGJvb2wgJHt0aGlzLmlkfTtcXG5gO1xuICB9XG5cbiAgZ2V0U3RyaW5nVmFsdWVIYW5kbGVyKCkge1xuICAgIHJldHVybiBgY29uc3QgdXBsb2FkVmFsdWVfJHt0aGlzLm5hbWV9ID0gJHt0aGlzLnZhck5hbWV9O1xcbmA7XG4gIH1cblxuICB1cGRhdGVWYWx1ZSh2YWx1ZSkge1xuICAgIGlmICh0aGlzLm9yaWdpbiA9PT0gJ2NvbnN0YW50cycpIHJldHVybjtcbiAgICB0aGlzLmtlcm5lbC5zZXRVbmlmb3JtMWkodGhpcy5pZCwgdGhpcy51cGxvYWRWYWx1ZSA9IHZhbHVlKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgV2ViR0xLZXJuZWxWYWx1ZUJvb2xlYW5cbn07XG59LHtcIi4uLy4uLy4uL3V0aWxzXCI6MTE0LFwiLi9pbmRleFwiOjU2fV0sNDI6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuY29uc3QgeyB1dGlscyB9ID0gcmVxdWlyZSgnLi4vLi4vLi4vdXRpbHMnKTtcbmNvbnN0IHsgV2ViR0xLZXJuZWxWYWx1ZUhUTUxJbWFnZSB9ID0gcmVxdWlyZSgnLi9odG1sLWltYWdlJyk7XG5cbmNsYXNzIFdlYkdMS2VybmVsVmFsdWVEeW5hbWljSFRNTEltYWdlIGV4dGVuZHMgV2ViR0xLZXJuZWxWYWx1ZUhUTUxJbWFnZSB7XG4gIGdldFNvdXJjZSgpIHtcbiAgICByZXR1cm4gdXRpbHMubGluZXNUb1N0cmluZyhbXG4gICAgICBgdW5pZm9ybSBzYW1wbGVyMkQgJHt0aGlzLmlkfWAsXG4gICAgICBgdW5pZm9ybSBpdmVjMiAke3RoaXMuc2l6ZUlkfWAsXG4gICAgICBgdW5pZm9ybSBpdmVjMyAke3RoaXMuZGltZW5zaW9uc0lkfWAsXG4gICAgXSk7XG4gIH1cblxuICB1cGRhdGVWYWx1ZSh2YWx1ZSkge1xuICAgIGNvbnN0IHsgd2lkdGgsIGhlaWdodCB9ID0gdmFsdWU7XG4gICAgdGhpcy5jaGVja1NpemUod2lkdGgsIGhlaWdodCk7XG4gICAgdGhpcy5kaW1lbnNpb25zID0gW3dpZHRoLCBoZWlnaHQsIDFdO1xuICAgIHRoaXMudGV4dHVyZVNpemUgPSBbd2lkdGgsIGhlaWdodF07XG4gICAgdGhpcy5rZXJuZWwuc2V0VW5pZm9ybTNpdih0aGlzLmRpbWVuc2lvbnNJZCwgdGhpcy5kaW1lbnNpb25zKTtcbiAgICB0aGlzLmtlcm5lbC5zZXRVbmlmb3JtMml2KHRoaXMuc2l6ZUlkLCB0aGlzLnRleHR1cmVTaXplKTtcbiAgICBzdXBlci51cGRhdGVWYWx1ZSh2YWx1ZSk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIFdlYkdMS2VybmVsVmFsdWVEeW5hbWljSFRNTEltYWdlXG59O1xufSx7XCIuLi8uLi8uLi91dGlsc1wiOjExNCxcIi4vaHRtbC1pbWFnZVwiOjU0fV0sNDM6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuY29uc3QgeyBXZWJHTEtlcm5lbFZhbHVlRHluYW1pY0hUTUxJbWFnZSB9ID0gcmVxdWlyZSgnLi9keW5hbWljLWh0bWwtaW1hZ2UnKTtcblxuY2xhc3MgV2ViR0xLZXJuZWxWYWx1ZUR5bmFtaWNIVE1MVmlkZW8gZXh0ZW5kcyBXZWJHTEtlcm5lbFZhbHVlRHluYW1pY0hUTUxJbWFnZSB7fVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgV2ViR0xLZXJuZWxWYWx1ZUR5bmFtaWNIVE1MVmlkZW9cbn07XG59LHtcIi4vZHluYW1pYy1odG1sLWltYWdlXCI6NDJ9XSw0NDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5jb25zdCB7IHV0aWxzIH0gPSByZXF1aXJlKCcuLi8uLi8uLi91dGlscycpO1xuY29uc3QgeyBXZWJHTEtlcm5lbFZhbHVlTWVtb3J5T3B0aW1pemVkTnVtYmVyVGV4dHVyZSB9ID0gcmVxdWlyZSgnLi9tZW1vcnktb3B0aW1pemVkLW51bWJlci10ZXh0dXJlJyk7XG5cbmNsYXNzIFdlYkdMS2VybmVsVmFsdWVEeW5hbWljTWVtb3J5T3B0aW1pemVkTnVtYmVyVGV4dHVyZSBleHRlbmRzIFdlYkdMS2VybmVsVmFsdWVNZW1vcnlPcHRpbWl6ZWROdW1iZXJUZXh0dXJlIHtcbiAgZ2V0U291cmNlKCkge1xuICAgIHJldHVybiB1dGlscy5saW5lc1RvU3RyaW5nKFtcbiAgICAgIGB1bmlmb3JtIHNhbXBsZXIyRCAke3RoaXMuaWR9YCxcbiAgICAgIGB1bmlmb3JtIGl2ZWMyICR7dGhpcy5zaXplSWR9YCxcbiAgICAgIGB1bmlmb3JtIGl2ZWMzICR7dGhpcy5kaW1lbnNpb25zSWR9YCxcbiAgICBdKTtcbiAgfVxuXG4gIHVwZGF0ZVZhbHVlKGlucHV0VGV4dHVyZSkge1xuICAgIHRoaXMuZGltZW5zaW9ucyA9IGlucHV0VGV4dHVyZS5kaW1lbnNpb25zO1xuICAgIHRoaXMuY2hlY2tTaXplKGlucHV0VGV4dHVyZS5zaXplWzBdLCBpbnB1dFRleHR1cmUuc2l6ZVsxXSk7XG4gICAgdGhpcy50ZXh0dXJlU2l6ZSA9IGlucHV0VGV4dHVyZS5zaXplO1xuICAgIHRoaXMua2VybmVsLnNldFVuaWZvcm0zaXYodGhpcy5kaW1lbnNpb25zSWQsIHRoaXMuZGltZW5zaW9ucyk7XG4gICAgdGhpcy5rZXJuZWwuc2V0VW5pZm9ybTJpdih0aGlzLnNpemVJZCwgdGhpcy50ZXh0dXJlU2l6ZSk7XG4gICAgc3VwZXIudXBkYXRlVmFsdWUoaW5wdXRUZXh0dXJlKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgV2ViR0xLZXJuZWxWYWx1ZUR5bmFtaWNNZW1vcnlPcHRpbWl6ZWROdW1iZXJUZXh0dXJlXG59O1xufSx7XCIuLi8uLi8uLi91dGlsc1wiOjExNCxcIi4vbWVtb3J5LW9wdGltaXplZC1udW1iZXItdGV4dHVyZVwiOjU4fV0sNDU6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuY29uc3QgeyB1dGlscyB9ID0gcmVxdWlyZSgnLi4vLi4vLi4vdXRpbHMnKTtcbmNvbnN0IHsgV2ViR0xLZXJuZWxWYWx1ZU51bWJlclRleHR1cmUgfSA9IHJlcXVpcmUoJy4vbnVtYmVyLXRleHR1cmUnKTtcblxuY2xhc3MgV2ViR0xLZXJuZWxWYWx1ZUR5bmFtaWNOdW1iZXJUZXh0dXJlIGV4dGVuZHMgV2ViR0xLZXJuZWxWYWx1ZU51bWJlclRleHR1cmUge1xuICBnZXRTb3VyY2UoKSB7XG4gICAgcmV0dXJuIHV0aWxzLmxpbmVzVG9TdHJpbmcoW1xuICAgICAgYHVuaWZvcm0gc2FtcGxlcjJEICR7dGhpcy5pZH1gLFxuICAgICAgYHVuaWZvcm0gaXZlYzIgJHt0aGlzLnNpemVJZH1gLFxuICAgICAgYHVuaWZvcm0gaXZlYzMgJHt0aGlzLmRpbWVuc2lvbnNJZH1gLFxuICAgIF0pO1xuICB9XG5cbiAgdXBkYXRlVmFsdWUodmFsdWUpIHtcbiAgICB0aGlzLmRpbWVuc2lvbnMgPSB2YWx1ZS5kaW1lbnNpb25zO1xuICAgIHRoaXMuY2hlY2tTaXplKHZhbHVlLnNpemVbMF0sIHZhbHVlLnNpemVbMV0pO1xuICAgIHRoaXMudGV4dHVyZVNpemUgPSB2YWx1ZS5zaXplO1xuICAgIHRoaXMua2VybmVsLnNldFVuaWZvcm0zaXYodGhpcy5kaW1lbnNpb25zSWQsIHRoaXMuZGltZW5zaW9ucyk7XG4gICAgdGhpcy5rZXJuZWwuc2V0VW5pZm9ybTJpdih0aGlzLnNpemVJZCwgdGhpcy50ZXh0dXJlU2l6ZSk7XG4gICAgc3VwZXIudXBkYXRlVmFsdWUodmFsdWUpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBXZWJHTEtlcm5lbFZhbHVlRHluYW1pY051bWJlclRleHR1cmVcbn07XG59LHtcIi4uLy4uLy4uL3V0aWxzXCI6MTE0LFwiLi9udW1iZXItdGV4dHVyZVwiOjU5fV0sNDY6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuY29uc3QgeyB1dGlscyB9ID0gcmVxdWlyZSgnLi4vLi4vLi4vdXRpbHMnKTtcbmNvbnN0IHsgV2ViR0xLZXJuZWxWYWx1ZVNpbmdsZUFycmF5IH0gPSByZXF1aXJlKCcuL3NpbmdsZS1hcnJheScpO1xuXG5jbGFzcyBXZWJHTEtlcm5lbFZhbHVlRHluYW1pY1NpbmdsZUFycmF5IGV4dGVuZHMgV2ViR0xLZXJuZWxWYWx1ZVNpbmdsZUFycmF5IHtcbiAgZ2V0U291cmNlKCkge1xuICAgIHJldHVybiB1dGlscy5saW5lc1RvU3RyaW5nKFtcbiAgICAgIGB1bmlmb3JtIHNhbXBsZXIyRCAke3RoaXMuaWR9YCxcbiAgICAgIGB1bmlmb3JtIGl2ZWMyICR7dGhpcy5zaXplSWR9YCxcbiAgICAgIGB1bmlmb3JtIGl2ZWMzICR7dGhpcy5kaW1lbnNpb25zSWR9YCxcbiAgICBdKTtcbiAgfVxuXG4gIHVwZGF0ZVZhbHVlKHZhbHVlKSB7XG4gICAgdGhpcy5kaW1lbnNpb25zID0gdXRpbHMuZ2V0RGltZW5zaW9ucyh2YWx1ZSwgdHJ1ZSk7XG4gICAgdGhpcy50ZXh0dXJlU2l6ZSA9IHV0aWxzLmdldE1lbW9yeU9wdGltaXplZEZsb2F0VGV4dHVyZVNpemUodGhpcy5kaW1lbnNpb25zLCB0aGlzLmJpdFJhdGlvKTtcbiAgICB0aGlzLnVwbG9hZEFycmF5TGVuZ3RoID0gdGhpcy50ZXh0dXJlU2l6ZVswXSAqIHRoaXMudGV4dHVyZVNpemVbMV0gKiB0aGlzLmJpdFJhdGlvO1xuICAgIHRoaXMuY2hlY2tTaXplKHRoaXMudGV4dHVyZVNpemVbMF0sIHRoaXMudGV4dHVyZVNpemVbMV0pO1xuICAgIHRoaXMudXBsb2FkVmFsdWUgPSBuZXcgRmxvYXQzMkFycmF5KHRoaXMudXBsb2FkQXJyYXlMZW5ndGgpO1xuICAgIHRoaXMua2VybmVsLnNldFVuaWZvcm0zaXYodGhpcy5kaW1lbnNpb25zSWQsIHRoaXMuZGltZW5zaW9ucyk7XG4gICAgdGhpcy5rZXJuZWwuc2V0VW5pZm9ybTJpdih0aGlzLnNpemVJZCwgdGhpcy50ZXh0dXJlU2l6ZSk7XG4gICAgc3VwZXIudXBkYXRlVmFsdWUodmFsdWUpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBXZWJHTEtlcm5lbFZhbHVlRHluYW1pY1NpbmdsZUFycmF5XG59O1xufSx7XCIuLi8uLi8uLi91dGlsc1wiOjExNCxcIi4vc2luZ2xlLWFycmF5XCI6NjB9XSw0NzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5jb25zdCB7IHV0aWxzIH0gPSByZXF1aXJlKCcuLi8uLi8uLi91dGlscycpO1xuY29uc3QgeyBXZWJHTEtlcm5lbFZhbHVlU2luZ2xlQXJyYXkxREkgfSA9IHJlcXVpcmUoJy4vc2luZ2xlLWFycmF5MWQtaScpO1xuXG5jbGFzcyBXZWJHTEtlcm5lbFZhbHVlRHluYW1pY1NpbmdsZUFycmF5MURJIGV4dGVuZHMgV2ViR0xLZXJuZWxWYWx1ZVNpbmdsZUFycmF5MURJIHtcbiAgZ2V0U291cmNlKCkge1xuICAgIHJldHVybiB1dGlscy5saW5lc1RvU3RyaW5nKFtcbiAgICAgIGB1bmlmb3JtIHNhbXBsZXIyRCAke3RoaXMuaWR9YCxcbiAgICAgIGB1bmlmb3JtIGl2ZWMyICR7dGhpcy5zaXplSWR9YCxcbiAgICAgIGB1bmlmb3JtIGl2ZWMzICR7dGhpcy5kaW1lbnNpb25zSWR9YCxcbiAgICBdKTtcbiAgfVxuXG4gIHVwZGF0ZVZhbHVlKHZhbHVlKSB7XG4gICAgdGhpcy5zZXRTaGFwZSh2YWx1ZSk7XG4gICAgdGhpcy5rZXJuZWwuc2V0VW5pZm9ybTNpdih0aGlzLmRpbWVuc2lvbnNJZCwgdGhpcy5kaW1lbnNpb25zKTtcbiAgICB0aGlzLmtlcm5lbC5zZXRVbmlmb3JtMml2KHRoaXMuc2l6ZUlkLCB0aGlzLnRleHR1cmVTaXplKTtcbiAgICBzdXBlci51cGRhdGVWYWx1ZSh2YWx1ZSk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIFdlYkdMS2VybmVsVmFsdWVEeW5hbWljU2luZ2xlQXJyYXkxRElcbn07XG59LHtcIi4uLy4uLy4uL3V0aWxzXCI6MTE0LFwiLi9zaW5nbGUtYXJyYXkxZC1pXCI6NjF9XSw0ODpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5jb25zdCB7IHV0aWxzIH0gPSByZXF1aXJlKCcuLi8uLi8uLi91dGlscycpO1xuY29uc3QgeyBXZWJHTEtlcm5lbFZhbHVlU2luZ2xlQXJyYXkyREkgfSA9IHJlcXVpcmUoJy4vc2luZ2xlLWFycmF5MmQtaScpO1xuXG5jbGFzcyBXZWJHTEtlcm5lbFZhbHVlRHluYW1pY1NpbmdsZUFycmF5MkRJIGV4dGVuZHMgV2ViR0xLZXJuZWxWYWx1ZVNpbmdsZUFycmF5MkRJIHtcbiAgZ2V0U291cmNlKCkge1xuICAgIHJldHVybiB1dGlscy5saW5lc1RvU3RyaW5nKFtcbiAgICAgIGB1bmlmb3JtIHNhbXBsZXIyRCAke3RoaXMuaWR9YCxcbiAgICAgIGB1bmlmb3JtIGl2ZWMyICR7dGhpcy5zaXplSWR9YCxcbiAgICAgIGB1bmlmb3JtIGl2ZWMzICR7dGhpcy5kaW1lbnNpb25zSWR9YCxcbiAgICBdKTtcbiAgfVxuXG4gIHVwZGF0ZVZhbHVlKHZhbHVlKSB7XG4gICAgdGhpcy5zZXRTaGFwZSh2YWx1ZSk7XG4gICAgdGhpcy5rZXJuZWwuc2V0VW5pZm9ybTNpdih0aGlzLmRpbWVuc2lvbnNJZCwgdGhpcy5kaW1lbnNpb25zKTtcbiAgICB0aGlzLmtlcm5lbC5zZXRVbmlmb3JtMml2KHRoaXMuc2l6ZUlkLCB0aGlzLnRleHR1cmVTaXplKTtcbiAgICBzdXBlci51cGRhdGVWYWx1ZSh2YWx1ZSk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIFdlYkdMS2VybmVsVmFsdWVEeW5hbWljU2luZ2xlQXJyYXkyRElcbn07XG59LHtcIi4uLy4uLy4uL3V0aWxzXCI6MTE0LFwiLi9zaW5nbGUtYXJyYXkyZC1pXCI6NjN9XSw0OTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5jb25zdCB7IHV0aWxzIH0gPSByZXF1aXJlKCcuLi8uLi8uLi91dGlscycpO1xuY29uc3QgeyBXZWJHTEtlcm5lbFZhbHVlU2luZ2xlQXJyYXkzREkgfSA9IHJlcXVpcmUoJy4vc2luZ2xlLWFycmF5M2QtaScpO1xuXG5jbGFzcyBXZWJHTEtlcm5lbFZhbHVlRHluYW1pY1NpbmdsZUFycmF5M0RJIGV4dGVuZHMgV2ViR0xLZXJuZWxWYWx1ZVNpbmdsZUFycmF5M0RJIHtcbiAgZ2V0U291cmNlKCkge1xuICAgIHJldHVybiB1dGlscy5saW5lc1RvU3RyaW5nKFtcbiAgICAgIGB1bmlmb3JtIHNhbXBsZXIyRCAke3RoaXMuaWR9YCxcbiAgICAgIGB1bmlmb3JtIGl2ZWMyICR7dGhpcy5zaXplSWR9YCxcbiAgICAgIGB1bmlmb3JtIGl2ZWMzICR7dGhpcy5kaW1lbnNpb25zSWR9YCxcbiAgICBdKTtcbiAgfVxuXG4gIHVwZGF0ZVZhbHVlKHZhbHVlKSB7XG4gICAgdGhpcy5zZXRTaGFwZSh2YWx1ZSk7XG4gICAgdGhpcy5rZXJuZWwuc2V0VW5pZm9ybTNpdih0aGlzLmRpbWVuc2lvbnNJZCwgdGhpcy5kaW1lbnNpb25zKTtcbiAgICB0aGlzLmtlcm5lbC5zZXRVbmlmb3JtMml2KHRoaXMuc2l6ZUlkLCB0aGlzLnRleHR1cmVTaXplKTtcbiAgICBzdXBlci51cGRhdGVWYWx1ZSh2YWx1ZSk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIFdlYkdMS2VybmVsVmFsdWVEeW5hbWljU2luZ2xlQXJyYXkzRElcbn07XG59LHtcIi4uLy4uLy4uL3V0aWxzXCI6MTE0LFwiLi9zaW5nbGUtYXJyYXkzZC1pXCI6NjV9XSw1MDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5jb25zdCB7IHV0aWxzIH0gPSByZXF1aXJlKCcuLi8uLi8uLi91dGlscycpO1xuY29uc3QgeyBXZWJHTEtlcm5lbFZhbHVlU2luZ2xlSW5wdXQgfSA9IHJlcXVpcmUoJy4vc2luZ2xlLWlucHV0Jyk7XG5cbmNsYXNzIFdlYkdMS2VybmVsVmFsdWVEeW5hbWljU2luZ2xlSW5wdXQgZXh0ZW5kcyBXZWJHTEtlcm5lbFZhbHVlU2luZ2xlSW5wdXQge1xuICBnZXRTb3VyY2UoKSB7XG4gICAgcmV0dXJuIHV0aWxzLmxpbmVzVG9TdHJpbmcoW1xuICAgICAgYHVuaWZvcm0gc2FtcGxlcjJEICR7dGhpcy5pZH1gLFxuICAgICAgYHVuaWZvcm0gaXZlYzIgJHt0aGlzLnNpemVJZH1gLFxuICAgICAgYHVuaWZvcm0gaXZlYzMgJHt0aGlzLmRpbWVuc2lvbnNJZH1gLFxuICAgIF0pO1xuICB9XG5cbiAgdXBkYXRlVmFsdWUodmFsdWUpIHtcbiAgICBsZXQgW3csIGgsIGRdID0gdmFsdWUuc2l6ZTtcbiAgICB0aGlzLmRpbWVuc2lvbnMgPSBuZXcgSW50MzJBcnJheShbdyB8fCAxLCBoIHx8IDEsIGQgfHwgMV0pO1xuICAgIHRoaXMudGV4dHVyZVNpemUgPSB1dGlscy5nZXRNZW1vcnlPcHRpbWl6ZWRGbG9hdFRleHR1cmVTaXplKHRoaXMuZGltZW5zaW9ucywgdGhpcy5iaXRSYXRpbyk7XG4gICAgdGhpcy51cGxvYWRBcnJheUxlbmd0aCA9IHRoaXMudGV4dHVyZVNpemVbMF0gKiB0aGlzLnRleHR1cmVTaXplWzFdICogdGhpcy5iaXRSYXRpbztcbiAgICB0aGlzLmNoZWNrU2l6ZSh0aGlzLnRleHR1cmVTaXplWzBdLCB0aGlzLnRleHR1cmVTaXplWzFdKTtcbiAgICB0aGlzLnVwbG9hZFZhbHVlID0gbmV3IEZsb2F0MzJBcnJheSh0aGlzLnVwbG9hZEFycmF5TGVuZ3RoKTtcbiAgICB0aGlzLmtlcm5lbC5zZXRVbmlmb3JtM2l2KHRoaXMuZGltZW5zaW9uc0lkLCB0aGlzLmRpbWVuc2lvbnMpO1xuICAgIHRoaXMua2VybmVsLnNldFVuaWZvcm0yaXYodGhpcy5zaXplSWQsIHRoaXMudGV4dHVyZVNpemUpO1xuICAgIHN1cGVyLnVwZGF0ZVZhbHVlKHZhbHVlKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgV2ViR0xLZXJuZWxWYWx1ZUR5bmFtaWNTaW5nbGVJbnB1dFxufTtcbn0se1wiLi4vLi4vLi4vdXRpbHNcIjoxMTQsXCIuL3NpbmdsZS1pbnB1dFwiOjY3fV0sNTE6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuY29uc3QgeyB1dGlscyB9ID0gcmVxdWlyZSgnLi4vLi4vLi4vdXRpbHMnKTtcbmNvbnN0IHsgV2ViR0xLZXJuZWxWYWx1ZVVuc2lnbmVkQXJyYXkgfSA9IHJlcXVpcmUoJy4vdW5zaWduZWQtYXJyYXknKTtcblxuY2xhc3MgV2ViR0xLZXJuZWxWYWx1ZUR5bmFtaWNVbnNpZ25lZEFycmF5IGV4dGVuZHMgV2ViR0xLZXJuZWxWYWx1ZVVuc2lnbmVkQXJyYXkge1xuICBnZXRTb3VyY2UoKSB7XG4gICAgcmV0dXJuIHV0aWxzLmxpbmVzVG9TdHJpbmcoW1xuICAgICAgYHVuaWZvcm0gc2FtcGxlcjJEICR7dGhpcy5pZH1gLFxuICAgICAgYHVuaWZvcm0gaXZlYzIgJHt0aGlzLnNpemVJZH1gLFxuICAgICAgYHVuaWZvcm0gaXZlYzMgJHt0aGlzLmRpbWVuc2lvbnNJZH1gLFxuICAgIF0pO1xuICB9XG5cbiAgdXBkYXRlVmFsdWUodmFsdWUpIHtcbiAgICB0aGlzLmRpbWVuc2lvbnMgPSB1dGlscy5nZXREaW1lbnNpb25zKHZhbHVlLCB0cnVlKTtcbiAgICB0aGlzLnRleHR1cmVTaXplID0gdXRpbHMuZ2V0TWVtb3J5T3B0aW1pemVkUGFja2VkVGV4dHVyZVNpemUodGhpcy5kaW1lbnNpb25zLCB0aGlzLmJpdFJhdGlvKTtcbiAgICB0aGlzLnVwbG9hZEFycmF5TGVuZ3RoID0gdGhpcy50ZXh0dXJlU2l6ZVswXSAqIHRoaXMudGV4dHVyZVNpemVbMV0gKiAoNCAvIHRoaXMuYml0UmF0aW8pO1xuICAgIHRoaXMuY2hlY2tTaXplKHRoaXMudGV4dHVyZVNpemVbMF0sIHRoaXMudGV4dHVyZVNpemVbMV0pO1xuICAgIGNvbnN0IFR5cGUgPSB0aGlzLmdldFRyYW5zZmVyQXJyYXlUeXBlKHZhbHVlKTtcbiAgICB0aGlzLnByZVVwbG9hZFZhbHVlID0gbmV3IFR5cGUodGhpcy51cGxvYWRBcnJheUxlbmd0aCk7XG4gICAgdGhpcy51cGxvYWRWYWx1ZSA9IG5ldyBVaW50OEFycmF5KHRoaXMucHJlVXBsb2FkVmFsdWUuYnVmZmVyKTtcbiAgICB0aGlzLmtlcm5lbC5zZXRVbmlmb3JtM2l2KHRoaXMuZGltZW5zaW9uc0lkLCB0aGlzLmRpbWVuc2lvbnMpO1xuICAgIHRoaXMua2VybmVsLnNldFVuaWZvcm0yaXYodGhpcy5zaXplSWQsIHRoaXMudGV4dHVyZVNpemUpO1xuICAgIHN1cGVyLnVwZGF0ZVZhbHVlKHZhbHVlKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgV2ViR0xLZXJuZWxWYWx1ZUR5bmFtaWNVbnNpZ25lZEFycmF5XG59O1xufSx7XCIuLi8uLi8uLi91dGlsc1wiOjExNCxcIi4vdW5zaWduZWQtYXJyYXlcIjo2OH1dLDUyOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbmNvbnN0IHsgdXRpbHMgfSA9IHJlcXVpcmUoJy4uLy4uLy4uL3V0aWxzJyk7XG5jb25zdCB7IFdlYkdMS2VybmVsVmFsdWVVbnNpZ25lZElucHV0IH0gPSByZXF1aXJlKCcuL3Vuc2lnbmVkLWlucHV0Jyk7XG5cbmNsYXNzIFdlYkdMS2VybmVsVmFsdWVEeW5hbWljVW5zaWduZWRJbnB1dCBleHRlbmRzIFdlYkdMS2VybmVsVmFsdWVVbnNpZ25lZElucHV0IHtcbiAgZ2V0U291cmNlKCkge1xuICAgIHJldHVybiB1dGlscy5saW5lc1RvU3RyaW5nKFtcbiAgICAgIGB1bmlmb3JtIHNhbXBsZXIyRCAke3RoaXMuaWR9YCxcbiAgICAgIGB1bmlmb3JtIGl2ZWMyICR7dGhpcy5zaXplSWR9YCxcbiAgICAgIGB1bmlmb3JtIGl2ZWMzICR7dGhpcy5kaW1lbnNpb25zSWR9YCxcbiAgICBdKTtcbiAgfVxuXG4gIHVwZGF0ZVZhbHVlKHZhbHVlKSB7XG4gICAgbGV0IFt3LCBoLCBkXSA9IHZhbHVlLnNpemU7XG4gICAgdGhpcy5kaW1lbnNpb25zID0gbmV3IEludDMyQXJyYXkoW3cgfHwgMSwgaCB8fCAxLCBkIHx8IDFdKTtcbiAgICB0aGlzLnRleHR1cmVTaXplID0gdXRpbHMuZ2V0TWVtb3J5T3B0aW1pemVkUGFja2VkVGV4dHVyZVNpemUodGhpcy5kaW1lbnNpb25zLCB0aGlzLmJpdFJhdGlvKTtcbiAgICB0aGlzLnVwbG9hZEFycmF5TGVuZ3RoID0gdGhpcy50ZXh0dXJlU2l6ZVswXSAqIHRoaXMudGV4dHVyZVNpemVbMV0gKiAoNCAvIHRoaXMuYml0UmF0aW8pO1xuICAgIHRoaXMuY2hlY2tTaXplKHRoaXMudGV4dHVyZVNpemVbMF0sIHRoaXMudGV4dHVyZVNpemVbMV0pO1xuICAgIGNvbnN0IFR5cGUgPSB0aGlzLmdldFRyYW5zZmVyQXJyYXlUeXBlKHZhbHVlLnZhbHVlKTtcbiAgICB0aGlzLnByZVVwbG9hZFZhbHVlID0gbmV3IFR5cGUodGhpcy51cGxvYWRBcnJheUxlbmd0aCk7XG4gICAgdGhpcy51cGxvYWRWYWx1ZSA9IG5ldyBVaW50OEFycmF5KHRoaXMucHJlVXBsb2FkVmFsdWUuYnVmZmVyKTtcbiAgICB0aGlzLmtlcm5lbC5zZXRVbmlmb3JtM2l2KHRoaXMuZGltZW5zaW9uc0lkLCB0aGlzLmRpbWVuc2lvbnMpO1xuICAgIHRoaXMua2VybmVsLnNldFVuaWZvcm0yaXYodGhpcy5zaXplSWQsIHRoaXMudGV4dHVyZVNpemUpO1xuICAgIHN1cGVyLnVwZGF0ZVZhbHVlKHZhbHVlKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgV2ViR0xLZXJuZWxWYWx1ZUR5bmFtaWNVbnNpZ25lZElucHV0XG59O1xufSx7XCIuLi8uLi8uLi91dGlsc1wiOjExNCxcIi4vdW5zaWduZWQtaW5wdXRcIjo2OX1dLDUzOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbmNvbnN0IHsgdXRpbHMgfSA9IHJlcXVpcmUoJy4uLy4uLy4uL3V0aWxzJyk7XG5jb25zdCB7IFdlYkdMS2VybmVsVmFsdWUgfSA9IHJlcXVpcmUoJy4vaW5kZXgnKTtcblxuY2xhc3MgV2ViR0xLZXJuZWxWYWx1ZUZsb2F0IGV4dGVuZHMgV2ViR0xLZXJuZWxWYWx1ZSB7XG4gIGNvbnN0cnVjdG9yKHZhbHVlLCBzZXR0aW5ncykge1xuICAgIHN1cGVyKHZhbHVlLCBzZXR0aW5ncyk7XG4gICAgdGhpcy51cGxvYWRWYWx1ZSA9IHZhbHVlO1xuICB9XG4gIGdldFN0cmluZ1ZhbHVlSGFuZGxlcigpIHtcbiAgICByZXR1cm4gYGNvbnN0IHVwbG9hZFZhbHVlXyR7dGhpcy5uYW1lfSA9ICR7dGhpcy52YXJOYW1lfTtcXG5gO1xuICB9XG4gIGdldFNvdXJjZSh2YWx1ZSkge1xuICAgIGlmICh0aGlzLm9yaWdpbiA9PT0gJ2NvbnN0YW50cycpIHtcbiAgICAgIGlmIChOdW1iZXIuaXNJbnRlZ2VyKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gYGNvbnN0IGZsb2F0ICR7dGhpcy5pZH0gPSAke3ZhbHVlfS4wO1xcbmA7XG4gICAgICB9XG4gICAgICByZXR1cm4gYGNvbnN0IGZsb2F0ICR7dGhpcy5pZH0gPSAke3ZhbHVlfTtcXG5gO1xuICAgIH1cbiAgICByZXR1cm4gYHVuaWZvcm0gZmxvYXQgJHt0aGlzLmlkfTtcXG5gO1xuICB9XG5cbiAgdXBkYXRlVmFsdWUodmFsdWUpIHtcbiAgICBpZiAodGhpcy5vcmlnaW4gPT09ICdjb25zdGFudHMnKSByZXR1cm47XG4gICAgdGhpcy5rZXJuZWwuc2V0VW5pZm9ybTFmKHRoaXMuaWQsIHRoaXMudXBsb2FkVmFsdWUgPSB2YWx1ZSk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIFdlYkdMS2VybmVsVmFsdWVGbG9hdFxufTtcbn0se1wiLi4vLi4vLi4vdXRpbHNcIjoxMTQsXCIuL2luZGV4XCI6NTZ9XSw1NDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5jb25zdCB7IHV0aWxzIH0gPSByZXF1aXJlKCcuLi8uLi8uLi91dGlscycpO1xuY29uc3QgeyBXZWJHTEtlcm5lbEFycmF5IH0gPSByZXF1aXJlKCcuL2FycmF5Jyk7XG5cbmNsYXNzIFdlYkdMS2VybmVsVmFsdWVIVE1MSW1hZ2UgZXh0ZW5kcyBXZWJHTEtlcm5lbEFycmF5IHtcbiAgY29uc3RydWN0b3IodmFsdWUsIHNldHRpbmdzKSB7XG4gICAgc3VwZXIodmFsdWUsIHNldHRpbmdzKTtcbiAgICBjb25zdCB7IHdpZHRoLCBoZWlnaHQgfSA9IHZhbHVlO1xuICAgIHRoaXMuY2hlY2tTaXplKHdpZHRoLCBoZWlnaHQpO1xuICAgIHRoaXMuZGltZW5zaW9ucyA9IFt3aWR0aCwgaGVpZ2h0LCAxXTtcbiAgICB0aGlzLnRleHR1cmVTaXplID0gW3dpZHRoLCBoZWlnaHRdO1xuICAgIHRoaXMudXBsb2FkVmFsdWUgPSB2YWx1ZTtcbiAgfVxuXG4gIGdldFN0cmluZ1ZhbHVlSGFuZGxlcigpIHtcbiAgICByZXR1cm4gYGNvbnN0IHVwbG9hZFZhbHVlXyR7dGhpcy5uYW1lfSA9ICR7dGhpcy52YXJOYW1lfTtcXG5gO1xuICB9XG5cbiAgZ2V0U291cmNlKCkge1xuICAgIHJldHVybiB1dGlscy5saW5lc1RvU3RyaW5nKFtcbiAgICAgIGB1bmlmb3JtIHNhbXBsZXIyRCAke3RoaXMuaWR9YCxcbiAgICAgIGBpdmVjMiAke3RoaXMuc2l6ZUlkfSA9IGl2ZWMyKCR7dGhpcy50ZXh0dXJlU2l6ZVswXX0sICR7dGhpcy50ZXh0dXJlU2l6ZVsxXX0pYCxcbiAgICAgIGBpdmVjMyAke3RoaXMuZGltZW5zaW9uc0lkfSA9IGl2ZWMzKCR7dGhpcy5kaW1lbnNpb25zWzBdfSwgJHt0aGlzLmRpbWVuc2lvbnNbMV19LCAke3RoaXMuZGltZW5zaW9uc1syXX0pYCxcbiAgICBdKTtcbiAgfVxuXG4gIHVwZGF0ZVZhbHVlKGlucHV0SW1hZ2UpIHtcbiAgICBpZiAoaW5wdXRJbWFnZS5jb25zdHJ1Y3RvciAhPT0gdGhpcy5pbml0aWFsVmFsdWVDb25zdHJ1Y3Rvcikge1xuICAgICAgdGhpcy5vblVwZGF0ZVZhbHVlTWlzbWF0Y2goaW5wdXRJbWFnZS5jb25zdHJ1Y3Rvcik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHsgY29udGV4dDogZ2wgfSA9IHRoaXM7XG4gICAgZ2wuYWN0aXZlVGV4dHVyZSh0aGlzLmNvbnRleHRIYW5kbGUpO1xuICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRoaXMudGV4dHVyZSk7XG4gICAgZ2wucGl4ZWxTdG9yZWkoZ2wuVU5QQUNLX0ZMSVBfWV9XRUJHTCwgdHJ1ZSk7XG4gICAgZ2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCBnbC5SR0JBLCBnbC5SR0JBLCBnbC5VTlNJR05FRF9CWVRFLCB0aGlzLnVwbG9hZFZhbHVlID0gaW5wdXRJbWFnZSk7XG4gICAgdGhpcy5rZXJuZWwuc2V0VW5pZm9ybTFpKHRoaXMuaWQsIHRoaXMuaW5kZXgpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBXZWJHTEtlcm5lbFZhbHVlSFRNTEltYWdlXG59O1xufSx7XCIuLi8uLi8uLi91dGlsc1wiOjExNCxcIi4vYXJyYXlcIjo0MH1dLDU1OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbmNvbnN0IHsgV2ViR0xLZXJuZWxWYWx1ZUhUTUxJbWFnZSB9ID0gcmVxdWlyZSgnLi9odG1sLWltYWdlJyk7XG5cbmNsYXNzIFdlYkdMS2VybmVsVmFsdWVIVE1MVmlkZW8gZXh0ZW5kcyBXZWJHTEtlcm5lbFZhbHVlSFRNTEltYWdlIHt9XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBXZWJHTEtlcm5lbFZhbHVlSFRNTFZpZGVvXG59O1xufSx7XCIuL2h0bWwtaW1hZ2VcIjo1NH1dLDU2OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbmNvbnN0IHsgdXRpbHMgfSA9IHJlcXVpcmUoJy4uLy4uLy4uL3V0aWxzJyk7XG5jb25zdCB7IEtlcm5lbFZhbHVlIH0gPSByZXF1aXJlKCcuLi8uLi9rZXJuZWwtdmFsdWUnKTtcblxuY2xhc3MgV2ViR0xLZXJuZWxWYWx1ZSBleHRlbmRzIEtlcm5lbFZhbHVlIHtcbiAgY29uc3RydWN0b3IodmFsdWUsIHNldHRpbmdzKSB7XG4gICAgc3VwZXIodmFsdWUsIHNldHRpbmdzKTtcbiAgICB0aGlzLmRpbWVuc2lvbnNJZCA9IG51bGw7XG4gICAgdGhpcy5zaXplSWQgPSBudWxsO1xuICAgIHRoaXMuaW5pdGlhbFZhbHVlQ29uc3RydWN0b3IgPSB2YWx1ZS5jb25zdHJ1Y3RvcjtcbiAgICB0aGlzLm9uUmVxdWVzdFRleHR1cmUgPSBzZXR0aW5ncy5vblJlcXVlc3RUZXh0dXJlO1xuICAgIHRoaXMub25SZXF1ZXN0SW5kZXggPSBzZXR0aW5ncy5vblJlcXVlc3RJbmRleDtcbiAgICB0aGlzLnVwbG9hZFZhbHVlID0gbnVsbDtcbiAgICB0aGlzLnRleHR1cmVTaXplID0gbnVsbDtcbiAgICB0aGlzLmJpdFJhdGlvID0gbnVsbDtcbiAgICB0aGlzLnByZXZBcmcgPSBudWxsO1xuICB9XG5cbiAgZ2V0IGlkKCkge1xuICAgIHJldHVybiBgJHt0aGlzLm9yaWdpbn1fJHt1dGlscy5zYW5pdGl6ZU5hbWUodGhpcy5uYW1lKX1gO1xuICB9XG5cbiAgc2V0dXAoKSB7fVxuXG4gIGdldFRyYW5zZmVyQXJyYXlUeXBlKHZhbHVlKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWVbMF0pKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRUcmFuc2ZlckFycmF5VHlwZSh2YWx1ZVswXSk7XG4gICAgfVxuICAgIHN3aXRjaCAodmFsdWUuY29uc3RydWN0b3IpIHtcbiAgICAgIGNhc2UgQXJyYXk6XG4gICAgICBjYXNlIEludDMyQXJyYXk6XG4gICAgICBjYXNlIEludDE2QXJyYXk6XG4gICAgICBjYXNlIEludDhBcnJheTpcbiAgICAgICAgcmV0dXJuIEZsb2F0MzJBcnJheTtcbiAgICAgIGNhc2UgVWludDhDbGFtcGVkQXJyYXk6XG4gICAgICBjYXNlIFVpbnQ4QXJyYXk6XG4gICAgICBjYXNlIFVpbnQxNkFycmF5OlxuICAgICAgY2FzZSBVaW50MzJBcnJheTpcbiAgICAgIGNhc2UgRmxvYXQzMkFycmF5OlxuICAgICAgY2FzZSBGbG9hdDY0QXJyYXk6XG4gICAgICAgIHJldHVybiB2YWx1ZS5jb25zdHJ1Y3RvcjtcbiAgICB9XG4gICAgY29uc29sZS53YXJuKCdVbmZhbWlsaWFyIGNvbnN0cnVjdG9yIHR5cGUuICBXaWxsIGdvIGFoZWFkIGFuZCB1c2UsIGJ1dCBsaWtsZXkgdGhpcyBtYXkgcmVzdWx0IGluIGEgdHJhbnNmZXIgb2YgemVyb3MnKTtcbiAgICByZXR1cm4gdmFsdWUuY29uc3RydWN0b3I7XG4gIH1cblxuICBnZXRTdHJpbmdWYWx1ZUhhbmRsZXIoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBcImdldFN0cmluZ1ZhbHVlSGFuZGxlclwiIG5vdCBpbXBsZW1lbnRlZCBvbiAke3RoaXMuY29uc3RydWN0b3IubmFtZX1gKTtcbiAgfVxuXG4gIGdldFZhcmlhYmxlUHJlY2lzaW9uU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLmtlcm5lbC5nZXRWYXJpYWJsZVByZWNpc2lvblN0cmluZyh0aGlzLnRleHR1cmVTaXplIHx8IHVuZGVmaW5lZCwgdGhpcy50YWN0aWMgfHwgdW5kZWZpbmVkKTtcbiAgfVxuXG4gIGRlc3Ryb3koKSB7fVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgV2ViR0xLZXJuZWxWYWx1ZVxufTtcbn0se1wiLi4vLi4vLi4vdXRpbHNcIjoxMTQsXCIuLi8uLi9rZXJuZWwtdmFsdWVcIjozNX1dLDU3OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbmNvbnN0IHsgdXRpbHMgfSA9IHJlcXVpcmUoJy4uLy4uLy4uL3V0aWxzJyk7XG5jb25zdCB7IFdlYkdMS2VybmVsVmFsdWUgfSA9IHJlcXVpcmUoJy4vaW5kZXgnKTtcblxuY2xhc3MgV2ViR0xLZXJuZWxWYWx1ZUludGVnZXIgZXh0ZW5kcyBXZWJHTEtlcm5lbFZhbHVlIHtcbiAgY29uc3RydWN0b3IodmFsdWUsIHNldHRpbmdzKSB7XG4gICAgc3VwZXIodmFsdWUsIHNldHRpbmdzKTtcbiAgICB0aGlzLnVwbG9hZFZhbHVlID0gdmFsdWU7XG4gIH1cbiAgZ2V0U3RyaW5nVmFsdWVIYW5kbGVyKCkge1xuICAgIHJldHVybiBgY29uc3QgdXBsb2FkVmFsdWVfJHt0aGlzLm5hbWV9ID0gJHt0aGlzLnZhck5hbWV9O1xcbmA7XG4gIH1cbiAgZ2V0U291cmNlKHZhbHVlKSB7XG4gICAgaWYgKHRoaXMub3JpZ2luID09PSAnY29uc3RhbnRzJykge1xuICAgICAgcmV0dXJuIGBjb25zdCBpbnQgJHt0aGlzLmlkfSA9ICR7IHBhcnNlSW50KHZhbHVlKSB9O1xcbmA7XG4gICAgfVxuICAgIHJldHVybiBgdW5pZm9ybSBpbnQgJHt0aGlzLmlkfTtcXG5gO1xuICB9XG5cbiAgdXBkYXRlVmFsdWUodmFsdWUpIHtcbiAgICBpZiAodGhpcy5vcmlnaW4gPT09ICdjb25zdGFudHMnKSByZXR1cm47XG4gICAgdGhpcy5rZXJuZWwuc2V0VW5pZm9ybTFpKHRoaXMuaWQsIHRoaXMudXBsb2FkVmFsdWUgPSB2YWx1ZSk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIFdlYkdMS2VybmVsVmFsdWVJbnRlZ2VyXG59O1xufSx7XCIuLi8uLi8uLi91dGlsc1wiOjExNCxcIi4vaW5kZXhcIjo1Nn1dLDU4OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbmNvbnN0IHsgdXRpbHMgfSA9IHJlcXVpcmUoJy4uLy4uLy4uL3V0aWxzJyk7XG5jb25zdCB7IFdlYkdMS2VybmVsQXJyYXkgfSA9IHJlcXVpcmUoJy4vYXJyYXknKTtcblxuY29uc3Qgc2FtZUVycm9yID0gYFNvdXJjZSBhbmQgZGVzdGluYXRpb24gdGV4dHVyZXMgYXJlIHRoZSBzYW1lLiAgVXNlIGltbXV0YWJsZSA9IHRydWUgYW5kIG1hbnVhbGx5IGNsZWFudXAga2VybmVsIG91dHB1dCB0ZXh0dXJlIG1lbW9yeSB3aXRoIHRleHR1cmUuZGVsZXRlKClgO1xuXG5jbGFzcyBXZWJHTEtlcm5lbFZhbHVlTWVtb3J5T3B0aW1pemVkTnVtYmVyVGV4dHVyZSBleHRlbmRzIFdlYkdMS2VybmVsQXJyYXkge1xuICBjb25zdHJ1Y3Rvcih2YWx1ZSwgc2V0dGluZ3MpIHtcbiAgICBzdXBlcih2YWx1ZSwgc2V0dGluZ3MpO1xuICAgIGNvbnN0IFt3aWR0aCwgaGVpZ2h0XSA9IHZhbHVlLnNpemU7XG4gICAgdGhpcy5jaGVja1NpemUod2lkdGgsIGhlaWdodCk7XG4gICAgdGhpcy5kaW1lbnNpb25zID0gdmFsdWUuZGltZW5zaW9ucztcbiAgICB0aGlzLnRleHR1cmVTaXplID0gdmFsdWUuc2l6ZTtcbiAgICB0aGlzLnVwbG9hZFZhbHVlID0gdmFsdWUudGV4dHVyZTtcbiAgICB0aGlzLmZvcmNlVXBsb2FkRWFjaFJ1biA9IHRydWU7XG4gIH1cblxuICBzZXR1cCgpIHtcbiAgICB0aGlzLnNldHVwVGV4dHVyZSgpO1xuICB9XG5cbiAgZ2V0U3RyaW5nVmFsdWVIYW5kbGVyKCkge1xuICAgIHJldHVybiBgY29uc3QgdXBsb2FkVmFsdWVfJHt0aGlzLm5hbWV9ID0gJHt0aGlzLnZhck5hbWV9LnRleHR1cmU7XFxuYDtcbiAgfVxuXG4gIGdldFNvdXJjZSgpIHtcbiAgICByZXR1cm4gdXRpbHMubGluZXNUb1N0cmluZyhbXG4gICAgICBgdW5pZm9ybSBzYW1wbGVyMkQgJHt0aGlzLmlkfWAsXG4gICAgICBgaXZlYzIgJHt0aGlzLnNpemVJZH0gPSBpdmVjMigke3RoaXMudGV4dHVyZVNpemVbMF19LCAke3RoaXMudGV4dHVyZVNpemVbMV19KWAsXG4gICAgICBgaXZlYzMgJHt0aGlzLmRpbWVuc2lvbnNJZH0gPSBpdmVjMygke3RoaXMuZGltZW5zaW9uc1swXX0sICR7dGhpcy5kaW1lbnNpb25zWzFdfSwgJHt0aGlzLmRpbWVuc2lvbnNbMl19KWAsXG4gICAgXSk7XG4gIH1cblxuICB1cGRhdGVWYWx1ZShpbnB1dFRleHR1cmUpIHtcbiAgICBpZiAoaW5wdXRUZXh0dXJlLmNvbnN0cnVjdG9yICE9PSB0aGlzLmluaXRpYWxWYWx1ZUNvbnN0cnVjdG9yKSB7XG4gICAgICB0aGlzLm9uVXBkYXRlVmFsdWVNaXNtYXRjaChpbnB1dFRleHR1cmUuY29uc3RydWN0b3IpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5jaGVja0NvbnRleHQgJiYgaW5wdXRUZXh0dXJlLmNvbnRleHQgIT09IHRoaXMuY29udGV4dCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBWYWx1ZSAke3RoaXMubmFtZX0gKCR7dGhpcy50eXBlfSkgbXVzdCBiZSBmcm9tIHNhbWUgY29udGV4dGApO1xuICAgIH1cblxuICAgIGNvbnN0IHsga2VybmVsLCBjb250ZXh0OiBnbCB9ID0gdGhpcztcbiAgICBpZiAoa2VybmVsLnBpcGVsaW5lKSB7XG4gICAgICBpZiAoa2VybmVsLmltbXV0YWJsZSkge1xuICAgICAgICBrZXJuZWwudXBkYXRlVGV4dHVyZUFyZ3VtZW50UmVmcyh0aGlzLCBpbnB1dFRleHR1cmUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGtlcm5lbC50ZXh0dXJlICYmIGtlcm5lbC50ZXh0dXJlLnRleHR1cmUgPT09IGlucHV0VGV4dHVyZS50ZXh0dXJlKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHNhbWVFcnJvcik7XG4gICAgICAgIH0gZWxzZSBpZiAoa2VybmVsLm1hcHBlZFRleHR1cmVzKSB7XG4gICAgICAgICAgY29uc3QgeyBtYXBwZWRUZXh0dXJlcyB9ID0ga2VybmVsO1xuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWFwcGVkVGV4dHVyZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChtYXBwZWRUZXh0dXJlc1tpXS50ZXh0dXJlID09PSBpbnB1dFRleHR1cmUudGV4dHVyZSkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3Ioc2FtZUVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBnbC5hY3RpdmVUZXh0dXJlKHRoaXMuY29udGV4dEhhbmRsZSk7XG4gICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGhpcy51cGxvYWRWYWx1ZSA9IGlucHV0VGV4dHVyZS50ZXh0dXJlKTtcbiAgICB0aGlzLmtlcm5lbC5zZXRVbmlmb3JtMWkodGhpcy5pZCwgdGhpcy5pbmRleCk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIFdlYkdMS2VybmVsVmFsdWVNZW1vcnlPcHRpbWl6ZWROdW1iZXJUZXh0dXJlLFxuICBzYW1lRXJyb3Jcbn07XG5cbn0se1wiLi4vLi4vLi4vdXRpbHNcIjoxMTQsXCIuL2FycmF5XCI6NDB9XSw1OTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5jb25zdCB7IHV0aWxzIH0gPSByZXF1aXJlKCcuLi8uLi8uLi91dGlscycpO1xuY29uc3QgeyBXZWJHTEtlcm5lbEFycmF5IH0gPSByZXF1aXJlKCcuL2FycmF5Jyk7XG5jb25zdCB7IHNhbWVFcnJvciB9ID0gcmVxdWlyZSgnLi9tZW1vcnktb3B0aW1pemVkLW51bWJlci10ZXh0dXJlJyk7XG5cbmNsYXNzIFdlYkdMS2VybmVsVmFsdWVOdW1iZXJUZXh0dXJlIGV4dGVuZHMgV2ViR0xLZXJuZWxBcnJheSB7XG4gIGNvbnN0cnVjdG9yKHZhbHVlLCBzZXR0aW5ncykge1xuICAgIHN1cGVyKHZhbHVlLCBzZXR0aW5ncyk7XG4gICAgY29uc3QgW3dpZHRoLCBoZWlnaHRdID0gdmFsdWUuc2l6ZTtcbiAgICB0aGlzLmNoZWNrU2l6ZSh3aWR0aCwgaGVpZ2h0KTtcbiAgICBjb25zdCB7IHNpemU6IHRleHR1cmVTaXplLCBkaW1lbnNpb25zIH0gPSB2YWx1ZTtcbiAgICB0aGlzLmJpdFJhdGlvID0gdGhpcy5nZXRCaXRSYXRpbyh2YWx1ZSk7XG4gICAgdGhpcy5kaW1lbnNpb25zID0gZGltZW5zaW9ucztcbiAgICB0aGlzLnRleHR1cmVTaXplID0gdGV4dHVyZVNpemU7XG4gICAgdGhpcy51cGxvYWRWYWx1ZSA9IHZhbHVlLnRleHR1cmU7XG4gICAgdGhpcy5mb3JjZVVwbG9hZEVhY2hSdW4gPSB0cnVlO1xuICB9XG5cbiAgc2V0dXAoKSB7XG4gICAgdGhpcy5zZXR1cFRleHR1cmUoKTtcbiAgfVxuXG4gIGdldFN0cmluZ1ZhbHVlSGFuZGxlcigpIHtcbiAgICByZXR1cm4gYGNvbnN0IHVwbG9hZFZhbHVlXyR7dGhpcy5uYW1lfSA9ICR7dGhpcy52YXJOYW1lfS50ZXh0dXJlO1xcbmA7XG4gIH1cblxuICBnZXRTb3VyY2UoKSB7XG4gICAgcmV0dXJuIHV0aWxzLmxpbmVzVG9TdHJpbmcoW1xuICAgICAgYHVuaWZvcm0gc2FtcGxlcjJEICR7dGhpcy5pZH1gLFxuICAgICAgYGl2ZWMyICR7dGhpcy5zaXplSWR9ID0gaXZlYzIoJHt0aGlzLnRleHR1cmVTaXplWzBdfSwgJHt0aGlzLnRleHR1cmVTaXplWzFdfSlgLFxuICAgICAgYGl2ZWMzICR7dGhpcy5kaW1lbnNpb25zSWR9ID0gaXZlYzMoJHt0aGlzLmRpbWVuc2lvbnNbMF19LCAke3RoaXMuZGltZW5zaW9uc1sxXX0sICR7dGhpcy5kaW1lbnNpb25zWzJdfSlgLFxuICAgIF0pO1xuICB9XG5cbiAgdXBkYXRlVmFsdWUoaW5wdXRUZXh0dXJlKSB7XG4gICAgaWYgKGlucHV0VGV4dHVyZS5jb25zdHJ1Y3RvciAhPT0gdGhpcy5pbml0aWFsVmFsdWVDb25zdHJ1Y3Rvcikge1xuICAgICAgdGhpcy5vblVwZGF0ZVZhbHVlTWlzbWF0Y2goaW5wdXRUZXh0dXJlLmNvbnN0cnVjdG9yKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuY2hlY2tDb250ZXh0ICYmIGlucHV0VGV4dHVyZS5jb250ZXh0ICE9PSB0aGlzLmNvbnRleHQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVmFsdWUgJHt0aGlzLm5hbWV9ICgke3RoaXMudHlwZX0pIG11c3QgYmUgZnJvbSBzYW1lIGNvbnRleHRgKTtcbiAgICB9XG5cbiAgICBjb25zdCB7IGtlcm5lbCwgY29udGV4dDogZ2wgfSA9IHRoaXM7XG4gICAgaWYgKGtlcm5lbC5waXBlbGluZSkge1xuICAgICAgaWYgKGtlcm5lbC5pbW11dGFibGUpIHtcbiAgICAgICAga2VybmVsLnVwZGF0ZVRleHR1cmVBcmd1bWVudFJlZnModGhpcywgaW5wdXRUZXh0dXJlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChrZXJuZWwudGV4dHVyZSAmJiBrZXJuZWwudGV4dHVyZS50ZXh0dXJlID09PSBpbnB1dFRleHR1cmUudGV4dHVyZSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihzYW1lRXJyb3IpO1xuICAgICAgICB9IGVsc2UgaWYgKGtlcm5lbC5tYXBwZWRUZXh0dXJlcykge1xuICAgICAgICAgIGNvbnN0IHsgbWFwcGVkVGV4dHVyZXMgfSA9IGtlcm5lbDtcbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1hcHBlZFRleHR1cmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAobWFwcGVkVGV4dHVyZXNbaV0udGV4dHVyZSA9PT0gaW5wdXRUZXh0dXJlLnRleHR1cmUpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHNhbWVFcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgZ2wuYWN0aXZlVGV4dHVyZSh0aGlzLmNvbnRleHRIYW5kbGUpO1xuICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRoaXMudXBsb2FkVmFsdWUgPSBpbnB1dFRleHR1cmUudGV4dHVyZSk7XG4gICAgdGhpcy5rZXJuZWwuc2V0VW5pZm9ybTFpKHRoaXMuaWQsIHRoaXMuaW5kZXgpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBXZWJHTEtlcm5lbFZhbHVlTnVtYmVyVGV4dHVyZVxufTtcblxufSx7XCIuLi8uLi8uLi91dGlsc1wiOjExNCxcIi4vYXJyYXlcIjo0MCxcIi4vbWVtb3J5LW9wdGltaXplZC1udW1iZXItdGV4dHVyZVwiOjU4fV0sNjA6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuY29uc3QgeyB1dGlscyB9ID0gcmVxdWlyZSgnLi4vLi4vLi4vdXRpbHMnKTtcbmNvbnN0IHsgV2ViR0xLZXJuZWxBcnJheSB9ID0gcmVxdWlyZSgnLi9hcnJheScpO1xuXG5jbGFzcyBXZWJHTEtlcm5lbFZhbHVlU2luZ2xlQXJyYXkgZXh0ZW5kcyBXZWJHTEtlcm5lbEFycmF5IHtcbiAgY29uc3RydWN0b3IodmFsdWUsIHNldHRpbmdzKSB7XG4gICAgc3VwZXIodmFsdWUsIHNldHRpbmdzKTtcbiAgICB0aGlzLmJpdFJhdGlvID0gNDtcbiAgICB0aGlzLmRpbWVuc2lvbnMgPSB1dGlscy5nZXREaW1lbnNpb25zKHZhbHVlLCB0cnVlKTtcbiAgICB0aGlzLnRleHR1cmVTaXplID0gdXRpbHMuZ2V0TWVtb3J5T3B0aW1pemVkRmxvYXRUZXh0dXJlU2l6ZSh0aGlzLmRpbWVuc2lvbnMsIHRoaXMuYml0UmF0aW8pO1xuICAgIHRoaXMudXBsb2FkQXJyYXlMZW5ndGggPSB0aGlzLnRleHR1cmVTaXplWzBdICogdGhpcy50ZXh0dXJlU2l6ZVsxXSAqIHRoaXMuYml0UmF0aW87XG4gICAgdGhpcy5jaGVja1NpemUodGhpcy50ZXh0dXJlU2l6ZVswXSwgdGhpcy50ZXh0dXJlU2l6ZVsxXSk7XG4gICAgdGhpcy51cGxvYWRWYWx1ZSA9IG5ldyBGbG9hdDMyQXJyYXkodGhpcy51cGxvYWRBcnJheUxlbmd0aCk7XG4gIH1cblxuICBnZXRTdHJpbmdWYWx1ZUhhbmRsZXIoKSB7XG4gICAgcmV0dXJuIHV0aWxzLmxpbmVzVG9TdHJpbmcoW1xuICAgICAgYGNvbnN0IHVwbG9hZFZhbHVlXyR7dGhpcy5uYW1lfSA9IG5ldyBGbG9hdDMyQXJyYXkoJHt0aGlzLnVwbG9hZEFycmF5TGVuZ3RofSlgLFxuICAgICAgYGZsYXR0ZW5Ubygke3RoaXMudmFyTmFtZX0sIHVwbG9hZFZhbHVlXyR7dGhpcy5uYW1lfSlgLFxuICAgIF0pO1xuICB9XG5cbiAgZ2V0U291cmNlKCkge1xuICAgIHJldHVybiB1dGlscy5saW5lc1RvU3RyaW5nKFtcbiAgICAgIGB1bmlmb3JtIHNhbXBsZXIyRCAke3RoaXMuaWR9YCxcbiAgICAgIGBpdmVjMiAke3RoaXMuc2l6ZUlkfSA9IGl2ZWMyKCR7dGhpcy50ZXh0dXJlU2l6ZVswXX0sICR7dGhpcy50ZXh0dXJlU2l6ZVsxXX0pYCxcbiAgICAgIGBpdmVjMyAke3RoaXMuZGltZW5zaW9uc0lkfSA9IGl2ZWMzKCR7dGhpcy5kaW1lbnNpb25zWzBdfSwgJHt0aGlzLmRpbWVuc2lvbnNbMV19LCAke3RoaXMuZGltZW5zaW9uc1syXX0pYCxcbiAgICBdKTtcbiAgfVxuXG4gIHVwZGF0ZVZhbHVlKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlLmNvbnN0cnVjdG9yICE9PSB0aGlzLmluaXRpYWxWYWx1ZUNvbnN0cnVjdG9yKSB7XG4gICAgICB0aGlzLm9uVXBkYXRlVmFsdWVNaXNtYXRjaCh2YWx1ZS5jb25zdHJ1Y3Rvcik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHsgY29udGV4dDogZ2wgfSA9IHRoaXM7XG4gICAgdXRpbHMuZmxhdHRlblRvKHZhbHVlLCB0aGlzLnVwbG9hZFZhbHVlKTtcbiAgICBnbC5hY3RpdmVUZXh0dXJlKHRoaXMuY29udGV4dEhhbmRsZSk7XG4gICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGhpcy50ZXh0dXJlKTtcbiAgICBnbC5waXhlbFN0b3JlaShnbC5VTlBBQ0tfRkxJUF9ZX1dFQkdMLCBmYWxzZSk7XG4gICAgZ2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCBnbC5SR0JBLCB0aGlzLnRleHR1cmVTaXplWzBdLCB0aGlzLnRleHR1cmVTaXplWzFdLCAwLCBnbC5SR0JBLCBnbC5GTE9BVCwgdGhpcy51cGxvYWRWYWx1ZSk7XG4gICAgdGhpcy5rZXJuZWwuc2V0VW5pZm9ybTFpKHRoaXMuaWQsIHRoaXMuaW5kZXgpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBXZWJHTEtlcm5lbFZhbHVlU2luZ2xlQXJyYXlcbn07XG59LHtcIi4uLy4uLy4uL3V0aWxzXCI6MTE0LFwiLi9hcnJheVwiOjQwfV0sNjE6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuY29uc3QgeyB1dGlscyB9ID0gcmVxdWlyZSgnLi4vLi4vLi4vdXRpbHMnKTtcbmNvbnN0IHsgV2ViR0xLZXJuZWxBcnJheSB9ID0gcmVxdWlyZSgnLi9hcnJheScpO1xuXG5jbGFzcyBXZWJHTEtlcm5lbFZhbHVlU2luZ2xlQXJyYXkxREkgZXh0ZW5kcyBXZWJHTEtlcm5lbEFycmF5IHtcbiAgY29uc3RydWN0b3IodmFsdWUsIHNldHRpbmdzKSB7XG4gICAgc3VwZXIodmFsdWUsIHNldHRpbmdzKTtcbiAgICB0aGlzLmJpdFJhdGlvID0gNDtcbiAgICB0aGlzLnNldFNoYXBlKHZhbHVlKTtcbiAgfVxuXG4gIHNldFNoYXBlKHZhbHVlKSB7XG4gICAgY29uc3QgdmFsdWVEaW1lbnNpb25zID0gdXRpbHMuZ2V0RGltZW5zaW9ucyh2YWx1ZSwgdHJ1ZSk7XG4gICAgdGhpcy50ZXh0dXJlU2l6ZSA9IHV0aWxzLmdldE1lbW9yeU9wdGltaXplZEZsb2F0VGV4dHVyZVNpemUodmFsdWVEaW1lbnNpb25zLCB0aGlzLmJpdFJhdGlvKTtcbiAgICB0aGlzLmRpbWVuc2lvbnMgPSBuZXcgSW50MzJBcnJheShbdmFsdWVEaW1lbnNpb25zWzFdLCAxLCAxXSk7XG4gICAgdGhpcy51cGxvYWRBcnJheUxlbmd0aCA9IHRoaXMudGV4dHVyZVNpemVbMF0gKiB0aGlzLnRleHR1cmVTaXplWzFdICogdGhpcy5iaXRSYXRpbztcbiAgICB0aGlzLmNoZWNrU2l6ZSh0aGlzLnRleHR1cmVTaXplWzBdLCB0aGlzLnRleHR1cmVTaXplWzFdKTtcbiAgICB0aGlzLnVwbG9hZFZhbHVlID0gbmV3IEZsb2F0MzJBcnJheSh0aGlzLnVwbG9hZEFycmF5TGVuZ3RoKTtcbiAgfVxuXG4gIGdldFN0cmluZ1ZhbHVlSGFuZGxlcigpIHtcbiAgICByZXR1cm4gdXRpbHMubGluZXNUb1N0cmluZyhbXG4gICAgICBgY29uc3QgdXBsb2FkVmFsdWVfJHt0aGlzLm5hbWV9ID0gbmV3IEZsb2F0MzJBcnJheSgke3RoaXMudXBsb2FkQXJyYXlMZW5ndGh9KWAsXG4gICAgICBgZmxhdHRlblRvKCR7dGhpcy52YXJOYW1lfSwgdXBsb2FkVmFsdWVfJHt0aGlzLm5hbWV9KWAsXG4gICAgXSk7XG4gIH1cblxuICBnZXRTb3VyY2UoKSB7XG4gICAgcmV0dXJuIHV0aWxzLmxpbmVzVG9TdHJpbmcoW1xuICAgICAgYHVuaWZvcm0gc2FtcGxlcjJEICR7dGhpcy5pZH1gLFxuICAgICAgYGl2ZWMyICR7dGhpcy5zaXplSWR9ID0gaXZlYzIoJHt0aGlzLnRleHR1cmVTaXplWzBdfSwgJHt0aGlzLnRleHR1cmVTaXplWzFdfSlgLFxuICAgICAgYGl2ZWMzICR7dGhpcy5kaW1lbnNpb25zSWR9ID0gaXZlYzMoJHt0aGlzLmRpbWVuc2lvbnNbMF19LCAke3RoaXMuZGltZW5zaW9uc1sxXX0sICR7dGhpcy5kaW1lbnNpb25zWzJdfSlgLFxuICAgIF0pO1xuICB9XG5cbiAgdXBkYXRlVmFsdWUodmFsdWUpIHtcbiAgICBpZiAodmFsdWUuY29uc3RydWN0b3IgIT09IHRoaXMuaW5pdGlhbFZhbHVlQ29uc3RydWN0b3IpIHtcbiAgICAgIHRoaXMub25VcGRhdGVWYWx1ZU1pc21hdGNoKHZhbHVlLmNvbnN0cnVjdG9yKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgeyBjb250ZXh0OiBnbCB9ID0gdGhpcztcbiAgICB1dGlscy5mbGF0dGVuMmRBcnJheVRvKHZhbHVlLCB0aGlzLnVwbG9hZFZhbHVlKTtcbiAgICBnbC5hY3RpdmVUZXh0dXJlKHRoaXMuY29udGV4dEhhbmRsZSk7XG4gICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGhpcy50ZXh0dXJlKTtcbiAgICBnbC5waXhlbFN0b3JlaShnbC5VTlBBQ0tfRkxJUF9ZX1dFQkdMLCBmYWxzZSk7XG4gICAgZ2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCBnbC5SR0JBLCB0aGlzLnRleHR1cmVTaXplWzBdLCB0aGlzLnRleHR1cmVTaXplWzFdLCAwLCBnbC5SR0JBLCBnbC5GTE9BVCwgdGhpcy51cGxvYWRWYWx1ZSk7XG4gICAgdGhpcy5rZXJuZWwuc2V0VW5pZm9ybTFpKHRoaXMuaWQsIHRoaXMuaW5kZXgpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBXZWJHTEtlcm5lbFZhbHVlU2luZ2xlQXJyYXkxRElcbn07XG59LHtcIi4uLy4uLy4uL3V0aWxzXCI6MTE0LFwiLi9hcnJheVwiOjQwfV0sNjI6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuY29uc3QgeyB1dGlscyB9ID0gcmVxdWlyZSgnLi4vLi4vLi4vdXRpbHMnKTtcbmNvbnN0IHsgV2ViR0xLZXJuZWxWYWx1ZSB9ID0gcmVxdWlyZSgnLi9pbmRleCcpO1xuXG5jbGFzcyBXZWJHTEtlcm5lbFZhbHVlU2luZ2xlQXJyYXkyIGV4dGVuZHMgV2ViR0xLZXJuZWxWYWx1ZSB7XG4gIGNvbnN0cnVjdG9yKHZhbHVlLCBzZXR0aW5ncykge1xuICAgIHN1cGVyKHZhbHVlLCBzZXR0aW5ncyk7XG4gICAgdGhpcy51cGxvYWRWYWx1ZSA9IHZhbHVlO1xuICB9XG4gIGdldFNvdXJjZSh2YWx1ZSkge1xuICAgIGlmICh0aGlzLm9yaWdpbiA9PT0gJ2NvbnN0YW50cycpIHtcbiAgICAgIHJldHVybiBgY29uc3QgdmVjMiAke3RoaXMuaWR9ID0gdmVjMigke3ZhbHVlWzBdfSwke3ZhbHVlWzFdfSk7XFxuYDtcbiAgICB9XG4gICAgcmV0dXJuIGB1bmlmb3JtIHZlYzIgJHt0aGlzLmlkfTtcXG5gO1xuICB9XG5cbiAgZ2V0U3RyaW5nVmFsdWVIYW5kbGVyKCkge1xuICAgIGlmICh0aGlzLm9yaWdpbiA9PT0gJ2NvbnN0YW50cycpIHJldHVybiAnJztcbiAgICByZXR1cm4gYGNvbnN0IHVwbG9hZFZhbHVlXyR7dGhpcy5uYW1lfSA9ICR7dGhpcy52YXJOYW1lfTtcXG5gO1xuICB9XG5cbiAgdXBkYXRlVmFsdWUodmFsdWUpIHtcbiAgICBpZiAodGhpcy5vcmlnaW4gPT09ICdjb25zdGFudHMnKSByZXR1cm47XG4gICAgdGhpcy5rZXJuZWwuc2V0VW5pZm9ybTJmdih0aGlzLmlkLCB0aGlzLnVwbG9hZFZhbHVlID0gdmFsdWUpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBXZWJHTEtlcm5lbFZhbHVlU2luZ2xlQXJyYXkyXG59O1xufSx7XCIuLi8uLi8uLi91dGlsc1wiOjExNCxcIi4vaW5kZXhcIjo1Nn1dLDYzOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbmNvbnN0IHsgdXRpbHMgfSA9IHJlcXVpcmUoJy4uLy4uLy4uL3V0aWxzJyk7XG5jb25zdCB7IFdlYkdMS2VybmVsQXJyYXkgfSA9IHJlcXVpcmUoJy4vYXJyYXknKTtcblxuY2xhc3MgV2ViR0xLZXJuZWxWYWx1ZVNpbmdsZUFycmF5MkRJIGV4dGVuZHMgV2ViR0xLZXJuZWxBcnJheSB7XG4gIGNvbnN0cnVjdG9yKHZhbHVlLCBzZXR0aW5ncykge1xuICAgIHN1cGVyKHZhbHVlLCBzZXR0aW5ncyk7XG4gICAgdGhpcy5iaXRSYXRpbyA9IDQ7XG4gICAgdGhpcy5zZXRTaGFwZSh2YWx1ZSk7XG4gIH1cblxuICBzZXRTaGFwZSh2YWx1ZSkge1xuICAgIGNvbnN0IHZhbHVlRGltZW5zaW9ucyA9IHV0aWxzLmdldERpbWVuc2lvbnModmFsdWUsIHRydWUpO1xuICAgIHRoaXMudGV4dHVyZVNpemUgPSB1dGlscy5nZXRNZW1vcnlPcHRpbWl6ZWRGbG9hdFRleHR1cmVTaXplKHZhbHVlRGltZW5zaW9ucywgdGhpcy5iaXRSYXRpbyk7XG4gICAgdGhpcy5kaW1lbnNpb25zID0gbmV3IEludDMyQXJyYXkoW3ZhbHVlRGltZW5zaW9uc1sxXSwgdmFsdWVEaW1lbnNpb25zWzJdLCAxXSk7XG4gICAgdGhpcy51cGxvYWRBcnJheUxlbmd0aCA9IHRoaXMudGV4dHVyZVNpemVbMF0gKiB0aGlzLnRleHR1cmVTaXplWzFdICogdGhpcy5iaXRSYXRpbztcbiAgICB0aGlzLmNoZWNrU2l6ZSh0aGlzLnRleHR1cmVTaXplWzBdLCB0aGlzLnRleHR1cmVTaXplWzFdKTtcbiAgICB0aGlzLnVwbG9hZFZhbHVlID0gbmV3IEZsb2F0MzJBcnJheSh0aGlzLnVwbG9hZEFycmF5TGVuZ3RoKTtcbiAgfVxuXG4gIGdldFN0cmluZ1ZhbHVlSGFuZGxlcigpIHtcbiAgICByZXR1cm4gdXRpbHMubGluZXNUb1N0cmluZyhbXG4gICAgICBgY29uc3QgdXBsb2FkVmFsdWVfJHt0aGlzLm5hbWV9ID0gbmV3IEZsb2F0MzJBcnJheSgke3RoaXMudXBsb2FkQXJyYXlMZW5ndGh9KWAsXG4gICAgICBgZmxhdHRlblRvKCR7dGhpcy52YXJOYW1lfSwgdXBsb2FkVmFsdWVfJHt0aGlzLm5hbWV9KWAsXG4gICAgXSk7XG4gIH1cblxuICBnZXRTb3VyY2UoKSB7XG4gICAgcmV0dXJuIHV0aWxzLmxpbmVzVG9TdHJpbmcoW1xuICAgICAgYHVuaWZvcm0gc2FtcGxlcjJEICR7dGhpcy5pZH1gLFxuICAgICAgYGl2ZWMyICR7dGhpcy5zaXplSWR9ID0gaXZlYzIoJHt0aGlzLnRleHR1cmVTaXplWzBdfSwgJHt0aGlzLnRleHR1cmVTaXplWzFdfSlgLFxuICAgICAgYGl2ZWMzICR7dGhpcy5kaW1lbnNpb25zSWR9ID0gaXZlYzMoJHt0aGlzLmRpbWVuc2lvbnNbMF19LCAke3RoaXMuZGltZW5zaW9uc1sxXX0sICR7dGhpcy5kaW1lbnNpb25zWzJdfSlgLFxuICAgIF0pO1xuICB9XG5cbiAgdXBkYXRlVmFsdWUodmFsdWUpIHtcbiAgICBpZiAodmFsdWUuY29uc3RydWN0b3IgIT09IHRoaXMuaW5pdGlhbFZhbHVlQ29uc3RydWN0b3IpIHtcbiAgICAgIHRoaXMub25VcGRhdGVWYWx1ZU1pc21hdGNoKHZhbHVlLmNvbnN0cnVjdG9yKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgeyBjb250ZXh0OiBnbCB9ID0gdGhpcztcbiAgICB1dGlscy5mbGF0dGVuM2RBcnJheVRvKHZhbHVlLCB0aGlzLnVwbG9hZFZhbHVlKTtcbiAgICBnbC5hY3RpdmVUZXh0dXJlKHRoaXMuY29udGV4dEhhbmRsZSk7XG4gICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGhpcy50ZXh0dXJlKTtcbiAgICBnbC5waXhlbFN0b3JlaShnbC5VTlBBQ0tfRkxJUF9ZX1dFQkdMLCBmYWxzZSk7XG4gICAgZ2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCBnbC5SR0JBLCB0aGlzLnRleHR1cmVTaXplWzBdLCB0aGlzLnRleHR1cmVTaXplWzFdLCAwLCBnbC5SR0JBLCBnbC5GTE9BVCwgdGhpcy51cGxvYWRWYWx1ZSk7XG4gICAgdGhpcy5rZXJuZWwuc2V0VW5pZm9ybTFpKHRoaXMuaWQsIHRoaXMuaW5kZXgpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBXZWJHTEtlcm5lbFZhbHVlU2luZ2xlQXJyYXkyRElcbn07XG59LHtcIi4uLy4uLy4uL3V0aWxzXCI6MTE0LFwiLi9hcnJheVwiOjQwfV0sNjQ6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuY29uc3QgeyB1dGlscyB9ID0gcmVxdWlyZSgnLi4vLi4vLi4vdXRpbHMnKTtcbmNvbnN0IHsgV2ViR0xLZXJuZWxWYWx1ZSB9ID0gcmVxdWlyZSgnLi9pbmRleCcpO1xuXG5jbGFzcyBXZWJHTEtlcm5lbFZhbHVlU2luZ2xlQXJyYXkzIGV4dGVuZHMgV2ViR0xLZXJuZWxWYWx1ZSB7XG4gIGNvbnN0cnVjdG9yKHZhbHVlLCBzZXR0aW5ncykge1xuICAgIHN1cGVyKHZhbHVlLCBzZXR0aW5ncyk7XG4gICAgdGhpcy51cGxvYWRWYWx1ZSA9IHZhbHVlO1xuICB9XG4gIGdldFNvdXJjZSh2YWx1ZSkge1xuICAgIGlmICh0aGlzLm9yaWdpbiA9PT0gJ2NvbnN0YW50cycpIHtcbiAgICAgIHJldHVybiBgY29uc3QgdmVjMyAke3RoaXMuaWR9ID0gdmVjMygke3ZhbHVlWzBdfSwke3ZhbHVlWzFdfSwke3ZhbHVlWzJdfSk7XFxuYDtcbiAgICB9XG4gICAgcmV0dXJuIGB1bmlmb3JtIHZlYzMgJHt0aGlzLmlkfTtcXG5gO1xuICB9XG5cbiAgZ2V0U3RyaW5nVmFsdWVIYW5kbGVyKCkge1xuICAgIGlmICh0aGlzLm9yaWdpbiA9PT0gJ2NvbnN0YW50cycpIHJldHVybiAnJztcbiAgICByZXR1cm4gYGNvbnN0IHVwbG9hZFZhbHVlXyR7dGhpcy5uYW1lfSA9ICR7dGhpcy52YXJOYW1lfTtcXG5gO1xuICB9XG5cbiAgdXBkYXRlVmFsdWUodmFsdWUpIHtcbiAgICBpZiAodGhpcy5vcmlnaW4gPT09ICdjb25zdGFudHMnKSByZXR1cm47XG4gICAgdGhpcy5rZXJuZWwuc2V0VW5pZm9ybTNmdih0aGlzLmlkLCB0aGlzLnVwbG9hZFZhbHVlID0gdmFsdWUpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBXZWJHTEtlcm5lbFZhbHVlU2luZ2xlQXJyYXkzXG59O1xufSx7XCIuLi8uLi8uLi91dGlsc1wiOjExNCxcIi4vaW5kZXhcIjo1Nn1dLDY1OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbmNvbnN0IHsgdXRpbHMgfSA9IHJlcXVpcmUoJy4uLy4uLy4uL3V0aWxzJyk7XG5jb25zdCB7IFdlYkdMS2VybmVsQXJyYXkgfSA9IHJlcXVpcmUoJy4vYXJyYXknKTtcblxuY2xhc3MgV2ViR0xLZXJuZWxWYWx1ZVNpbmdsZUFycmF5M0RJIGV4dGVuZHMgV2ViR0xLZXJuZWxBcnJheSB7XG4gIGNvbnN0cnVjdG9yKHZhbHVlLCBzZXR0aW5ncykge1xuICAgIHN1cGVyKHZhbHVlLCBzZXR0aW5ncyk7XG4gICAgdGhpcy5iaXRSYXRpbyA9IDQ7XG4gICAgdGhpcy5zZXRTaGFwZSh2YWx1ZSk7XG4gIH1cblxuICBzZXRTaGFwZSh2YWx1ZSkge1xuICAgIGNvbnN0IHZhbHVlRGltZW5zaW9ucyA9IHV0aWxzLmdldERpbWVuc2lvbnModmFsdWUsIHRydWUpO1xuICAgIHRoaXMudGV4dHVyZVNpemUgPSB1dGlscy5nZXRNZW1vcnlPcHRpbWl6ZWRGbG9hdFRleHR1cmVTaXplKHZhbHVlRGltZW5zaW9ucywgdGhpcy5iaXRSYXRpbyk7XG4gICAgdGhpcy5kaW1lbnNpb25zID0gbmV3IEludDMyQXJyYXkoW3ZhbHVlRGltZW5zaW9uc1sxXSwgdmFsdWVEaW1lbnNpb25zWzJdLCB2YWx1ZURpbWVuc2lvbnNbM11dKTtcbiAgICB0aGlzLnVwbG9hZEFycmF5TGVuZ3RoID0gdGhpcy50ZXh0dXJlU2l6ZVswXSAqIHRoaXMudGV4dHVyZVNpemVbMV0gKiB0aGlzLmJpdFJhdGlvO1xuICAgIHRoaXMuY2hlY2tTaXplKHRoaXMudGV4dHVyZVNpemVbMF0sIHRoaXMudGV4dHVyZVNpemVbMV0pO1xuICAgIHRoaXMudXBsb2FkVmFsdWUgPSBuZXcgRmxvYXQzMkFycmF5KHRoaXMudXBsb2FkQXJyYXlMZW5ndGgpO1xuICB9XG5cbiAgZ2V0U3RyaW5nVmFsdWVIYW5kbGVyKCkge1xuICAgIHJldHVybiB1dGlscy5saW5lc1RvU3RyaW5nKFtcbiAgICAgIGBjb25zdCB1cGxvYWRWYWx1ZV8ke3RoaXMubmFtZX0gPSBuZXcgRmxvYXQzMkFycmF5KCR7dGhpcy51cGxvYWRBcnJheUxlbmd0aH0pYCxcbiAgICAgIGBmbGF0dGVuVG8oJHt0aGlzLnZhck5hbWV9LCB1cGxvYWRWYWx1ZV8ke3RoaXMubmFtZX0pYCxcbiAgICBdKTtcbiAgfVxuXG4gIGdldFNvdXJjZSgpIHtcbiAgICByZXR1cm4gdXRpbHMubGluZXNUb1N0cmluZyhbXG4gICAgICBgdW5pZm9ybSBzYW1wbGVyMkQgJHt0aGlzLmlkfWAsXG4gICAgICBgaXZlYzIgJHt0aGlzLnNpemVJZH0gPSBpdmVjMigke3RoaXMudGV4dHVyZVNpemVbMF19LCAke3RoaXMudGV4dHVyZVNpemVbMV19KWAsXG4gICAgICBgaXZlYzMgJHt0aGlzLmRpbWVuc2lvbnNJZH0gPSBpdmVjMygke3RoaXMuZGltZW5zaW9uc1swXX0sICR7dGhpcy5kaW1lbnNpb25zWzFdfSwgJHt0aGlzLmRpbWVuc2lvbnNbMl19KWAsXG4gICAgXSk7XG4gIH1cblxuICB1cGRhdGVWYWx1ZSh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZS5jb25zdHJ1Y3RvciAhPT0gdGhpcy5pbml0aWFsVmFsdWVDb25zdHJ1Y3Rvcikge1xuICAgICAgdGhpcy5vblVwZGF0ZVZhbHVlTWlzbWF0Y2godmFsdWUuY29uc3RydWN0b3IpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7IGNvbnRleHQ6IGdsIH0gPSB0aGlzO1xuICAgIHV0aWxzLmZsYXR0ZW40ZEFycmF5VG8odmFsdWUsIHRoaXMudXBsb2FkVmFsdWUpO1xuICAgIGdsLmFjdGl2ZVRleHR1cmUodGhpcy5jb250ZXh0SGFuZGxlKTtcbiAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0aGlzLnRleHR1cmUpO1xuICAgIGdsLnBpeGVsU3RvcmVpKGdsLlVOUEFDS19GTElQX1lfV0VCR0wsIGZhbHNlKTtcbiAgICBnbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIGdsLlJHQkEsIHRoaXMudGV4dHVyZVNpemVbMF0sIHRoaXMudGV4dHVyZVNpemVbMV0sIDAsIGdsLlJHQkEsIGdsLkZMT0FULCB0aGlzLnVwbG9hZFZhbHVlKTtcbiAgICB0aGlzLmtlcm5lbC5zZXRVbmlmb3JtMWkodGhpcy5pZCwgdGhpcy5pbmRleCk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIFdlYkdMS2VybmVsVmFsdWVTaW5nbGVBcnJheTNESVxufTtcbn0se1wiLi4vLi4vLi4vdXRpbHNcIjoxMTQsXCIuL2FycmF5XCI6NDB9XSw2NjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5jb25zdCB7IHV0aWxzIH0gPSByZXF1aXJlKCcuLi8uLi8uLi91dGlscycpO1xuY29uc3QgeyBXZWJHTEtlcm5lbFZhbHVlIH0gPSByZXF1aXJlKCcuL2luZGV4Jyk7XG5cbmNsYXNzIFdlYkdMS2VybmVsVmFsdWVTaW5nbGVBcnJheTQgZXh0ZW5kcyBXZWJHTEtlcm5lbFZhbHVlIHtcbiAgY29uc3RydWN0b3IodmFsdWUsIHNldHRpbmdzKSB7XG4gICAgc3VwZXIodmFsdWUsIHNldHRpbmdzKTtcbiAgICB0aGlzLnVwbG9hZFZhbHVlID0gdmFsdWU7XG4gIH1cbiAgZ2V0U291cmNlKHZhbHVlKSB7XG4gICAgaWYgKHRoaXMub3JpZ2luID09PSAnY29uc3RhbnRzJykge1xuICAgICAgcmV0dXJuIGBjb25zdCB2ZWM0ICR7dGhpcy5pZH0gPSB2ZWM0KCR7dmFsdWVbMF19LCR7dmFsdWVbMV19LCR7dmFsdWVbMl19LCR7dmFsdWVbM119KTtcXG5gO1xuICAgIH1cbiAgICByZXR1cm4gYHVuaWZvcm0gdmVjNCAke3RoaXMuaWR9O1xcbmA7XG4gIH1cblxuICBnZXRTdHJpbmdWYWx1ZUhhbmRsZXIoKSB7XG4gICAgaWYgKHRoaXMub3JpZ2luID09PSAnY29uc3RhbnRzJykgcmV0dXJuICcnO1xuICAgIHJldHVybiBgY29uc3QgdXBsb2FkVmFsdWVfJHt0aGlzLm5hbWV9ID0gJHt0aGlzLnZhck5hbWV9O1xcbmA7XG4gIH1cblxuICB1cGRhdGVWYWx1ZSh2YWx1ZSkge1xuICAgIGlmICh0aGlzLm9yaWdpbiA9PT0gJ2NvbnN0YW50cycpIHJldHVybjtcbiAgICB0aGlzLmtlcm5lbC5zZXRVbmlmb3JtNGZ2KHRoaXMuaWQsIHRoaXMudXBsb2FkVmFsdWUgPSB2YWx1ZSk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIFdlYkdMS2VybmVsVmFsdWVTaW5nbGVBcnJheTRcbn07XG59LHtcIi4uLy4uLy4uL3V0aWxzXCI6MTE0LFwiLi9pbmRleFwiOjU2fV0sNjc6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuY29uc3QgeyB1dGlscyB9ID0gcmVxdWlyZSgnLi4vLi4vLi4vdXRpbHMnKTtcbmNvbnN0IHsgV2ViR0xLZXJuZWxBcnJheSB9ID0gcmVxdWlyZSgnLi9hcnJheScpO1xuXG5jbGFzcyBXZWJHTEtlcm5lbFZhbHVlU2luZ2xlSW5wdXQgZXh0ZW5kcyBXZWJHTEtlcm5lbEFycmF5IHtcbiAgY29uc3RydWN0b3IodmFsdWUsIHNldHRpbmdzKSB7XG4gICAgc3VwZXIodmFsdWUsIHNldHRpbmdzKTtcbiAgICB0aGlzLmJpdFJhdGlvID0gNDtcbiAgICBsZXQgW3csIGgsIGRdID0gdmFsdWUuc2l6ZTtcbiAgICB0aGlzLmRpbWVuc2lvbnMgPSBuZXcgSW50MzJBcnJheShbdyB8fCAxLCBoIHx8IDEsIGQgfHwgMV0pO1xuICAgIHRoaXMudGV4dHVyZVNpemUgPSB1dGlscy5nZXRNZW1vcnlPcHRpbWl6ZWRGbG9hdFRleHR1cmVTaXplKHRoaXMuZGltZW5zaW9ucywgdGhpcy5iaXRSYXRpbyk7XG4gICAgdGhpcy51cGxvYWRBcnJheUxlbmd0aCA9IHRoaXMudGV4dHVyZVNpemVbMF0gKiB0aGlzLnRleHR1cmVTaXplWzFdICogdGhpcy5iaXRSYXRpbztcbiAgICB0aGlzLmNoZWNrU2l6ZSh0aGlzLnRleHR1cmVTaXplWzBdLCB0aGlzLnRleHR1cmVTaXplWzFdKTtcbiAgICB0aGlzLnVwbG9hZFZhbHVlID0gbmV3IEZsb2F0MzJBcnJheSh0aGlzLnVwbG9hZEFycmF5TGVuZ3RoKTtcbiAgfVxuXG4gIGdldFN0cmluZ1ZhbHVlSGFuZGxlcigpIHtcbiAgICByZXR1cm4gdXRpbHMubGluZXNUb1N0cmluZyhbXG4gICAgICBgY29uc3QgdXBsb2FkVmFsdWVfJHt0aGlzLm5hbWV9ID0gbmV3IEZsb2F0MzJBcnJheSgke3RoaXMudXBsb2FkQXJyYXlMZW5ndGh9KWAsXG4gICAgICBgZmxhdHRlblRvKCR7dGhpcy52YXJOYW1lfS52YWx1ZSwgdXBsb2FkVmFsdWVfJHt0aGlzLm5hbWV9KWAsXG4gICAgXSk7XG4gIH1cblxuICBnZXRTb3VyY2UoKSB7XG4gICAgcmV0dXJuIHV0aWxzLmxpbmVzVG9TdHJpbmcoW1xuICAgICAgYHVuaWZvcm0gc2FtcGxlcjJEICR7dGhpcy5pZH1gLFxuICAgICAgYGl2ZWMyICR7dGhpcy5zaXplSWR9ID0gaXZlYzIoJHt0aGlzLnRleHR1cmVTaXplWzBdfSwgJHt0aGlzLnRleHR1cmVTaXplWzFdfSlgLFxuICAgICAgYGl2ZWMzICR7dGhpcy5kaW1lbnNpb25zSWR9ID0gaXZlYzMoJHt0aGlzLmRpbWVuc2lvbnNbMF19LCAke3RoaXMuZGltZW5zaW9uc1sxXX0sICR7dGhpcy5kaW1lbnNpb25zWzJdfSlgLFxuICAgIF0pO1xuICB9XG5cbiAgdXBkYXRlVmFsdWUoaW5wdXQpIHtcbiAgICBpZiAoaW5wdXQuY29uc3RydWN0b3IgIT09IHRoaXMuaW5pdGlhbFZhbHVlQ29uc3RydWN0b3IpIHtcbiAgICAgIHRoaXMub25VcGRhdGVWYWx1ZU1pc21hdGNoKGlucHV0LmNvbnN0cnVjdG9yKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgeyBjb250ZXh0OiBnbCB9ID0gdGhpcztcbiAgICB1dGlscy5mbGF0dGVuVG8oaW5wdXQudmFsdWUsIHRoaXMudXBsb2FkVmFsdWUpO1xuICAgIGdsLmFjdGl2ZVRleHR1cmUodGhpcy5jb250ZXh0SGFuZGxlKTtcbiAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0aGlzLnRleHR1cmUpO1xuICAgIGdsLnBpeGVsU3RvcmVpKGdsLlVOUEFDS19GTElQX1lfV0VCR0wsIGZhbHNlKTtcbiAgICBnbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIGdsLlJHQkEsIHRoaXMudGV4dHVyZVNpemVbMF0sIHRoaXMudGV4dHVyZVNpemVbMV0sIDAsIGdsLlJHQkEsIGdsLkZMT0FULCB0aGlzLnVwbG9hZFZhbHVlKTtcbiAgICB0aGlzLmtlcm5lbC5zZXRVbmlmb3JtMWkodGhpcy5pZCwgdGhpcy5pbmRleCk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIFdlYkdMS2VybmVsVmFsdWVTaW5nbGVJbnB1dFxufTtcbn0se1wiLi4vLi4vLi4vdXRpbHNcIjoxMTQsXCIuL2FycmF5XCI6NDB9XSw2ODpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5jb25zdCB7IHV0aWxzIH0gPSByZXF1aXJlKCcuLi8uLi8uLi91dGlscycpO1xuY29uc3QgeyBXZWJHTEtlcm5lbEFycmF5IH0gPSByZXF1aXJlKCcuL2FycmF5Jyk7XG5cbmNsYXNzIFdlYkdMS2VybmVsVmFsdWVVbnNpZ25lZEFycmF5IGV4dGVuZHMgV2ViR0xLZXJuZWxBcnJheSB7XG4gIGNvbnN0cnVjdG9yKHZhbHVlLCBzZXR0aW5ncykge1xuICAgIHN1cGVyKHZhbHVlLCBzZXR0aW5ncyk7XG4gICAgdGhpcy5iaXRSYXRpbyA9IHRoaXMuZ2V0Qml0UmF0aW8odmFsdWUpO1xuICAgIHRoaXMuZGltZW5zaW9ucyA9IHV0aWxzLmdldERpbWVuc2lvbnModmFsdWUsIHRydWUpO1xuICAgIHRoaXMudGV4dHVyZVNpemUgPSB1dGlscy5nZXRNZW1vcnlPcHRpbWl6ZWRQYWNrZWRUZXh0dXJlU2l6ZSh0aGlzLmRpbWVuc2lvbnMsIHRoaXMuYml0UmF0aW8pO1xuICAgIHRoaXMudXBsb2FkQXJyYXlMZW5ndGggPSB0aGlzLnRleHR1cmVTaXplWzBdICogdGhpcy50ZXh0dXJlU2l6ZVsxXSAqICg0IC8gdGhpcy5iaXRSYXRpbyk7XG4gICAgdGhpcy5jaGVja1NpemUodGhpcy50ZXh0dXJlU2l6ZVswXSwgdGhpcy50ZXh0dXJlU2l6ZVsxXSk7XG4gICAgdGhpcy5UcmFuc2VyQXJyYXlUeXBlID0gdGhpcy5nZXRUcmFuc2ZlckFycmF5VHlwZSh2YWx1ZSk7XG4gICAgdGhpcy5wcmVVcGxvYWRWYWx1ZSA9IG5ldyB0aGlzLlRyYW5zZXJBcnJheVR5cGUodGhpcy51cGxvYWRBcnJheUxlbmd0aCk7XG4gICAgdGhpcy51cGxvYWRWYWx1ZSA9IG5ldyBVaW50OEFycmF5KHRoaXMucHJlVXBsb2FkVmFsdWUuYnVmZmVyKTtcbiAgfVxuXG4gIGdldFN0cmluZ1ZhbHVlSGFuZGxlcigpIHtcbiAgICByZXR1cm4gdXRpbHMubGluZXNUb1N0cmluZyhbXG4gICAgICBgY29uc3QgcHJlVXBsb2FkVmFsdWVfJHt0aGlzLm5hbWV9ID0gbmV3ICR7dGhpcy5UcmFuc2VyQXJyYXlUeXBlLm5hbWV9KCR7dGhpcy51cGxvYWRBcnJheUxlbmd0aH0pYCxcbiAgICAgIGBjb25zdCB1cGxvYWRWYWx1ZV8ke3RoaXMubmFtZX0gPSBuZXcgVWludDhBcnJheShwcmVVcGxvYWRWYWx1ZV8ke3RoaXMubmFtZX0uYnVmZmVyKWAsXG4gICAgICBgZmxhdHRlblRvKCR7dGhpcy52YXJOYW1lfSwgcHJlVXBsb2FkVmFsdWVfJHt0aGlzLm5hbWV9KWAsXG4gICAgXSk7XG4gIH1cblxuICBnZXRTb3VyY2UoKSB7XG4gICAgcmV0dXJuIHV0aWxzLmxpbmVzVG9TdHJpbmcoW1xuICAgICAgYHVuaWZvcm0gc2FtcGxlcjJEICR7dGhpcy5pZH1gLFxuICAgICAgYGl2ZWMyICR7dGhpcy5zaXplSWR9ID0gaXZlYzIoJHt0aGlzLnRleHR1cmVTaXplWzBdfSwgJHt0aGlzLnRleHR1cmVTaXplWzFdfSlgLFxuICAgICAgYGl2ZWMzICR7dGhpcy5kaW1lbnNpb25zSWR9ID0gaXZlYzMoJHt0aGlzLmRpbWVuc2lvbnNbMF19LCAke3RoaXMuZGltZW5zaW9uc1sxXX0sICR7dGhpcy5kaW1lbnNpb25zWzJdfSlgLFxuICAgIF0pO1xuICB9XG5cbiAgdXBkYXRlVmFsdWUodmFsdWUpIHtcbiAgICBpZiAodmFsdWUuY29uc3RydWN0b3IgIT09IHRoaXMuaW5pdGlhbFZhbHVlQ29uc3RydWN0b3IpIHtcbiAgICAgIHRoaXMub25VcGRhdGVWYWx1ZU1pc21hdGNoKHZhbHVlLmNvbnN0cnVjdG9yKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgeyBjb250ZXh0OiBnbCB9ID0gdGhpcztcbiAgICB1dGlscy5mbGF0dGVuVG8odmFsdWUsIHRoaXMucHJlVXBsb2FkVmFsdWUpO1xuICAgIGdsLmFjdGl2ZVRleHR1cmUodGhpcy5jb250ZXh0SGFuZGxlKTtcbiAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0aGlzLnRleHR1cmUpO1xuICAgIGdsLnBpeGVsU3RvcmVpKGdsLlVOUEFDS19GTElQX1lfV0VCR0wsIGZhbHNlKTtcbiAgICBnbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIGdsLlJHQkEsIHRoaXMudGV4dHVyZVNpemVbMF0sIHRoaXMudGV4dHVyZVNpemVbMV0sIDAsIGdsLlJHQkEsIGdsLlVOU0lHTkVEX0JZVEUsIHRoaXMudXBsb2FkVmFsdWUpO1xuICAgIHRoaXMua2VybmVsLnNldFVuaWZvcm0xaSh0aGlzLmlkLCB0aGlzLmluZGV4KTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgV2ViR0xLZXJuZWxWYWx1ZVVuc2lnbmVkQXJyYXlcbn07XG59LHtcIi4uLy4uLy4uL3V0aWxzXCI6MTE0LFwiLi9hcnJheVwiOjQwfV0sNjk6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuY29uc3QgeyB1dGlscyB9ID0gcmVxdWlyZSgnLi4vLi4vLi4vdXRpbHMnKTtcbmNvbnN0IHsgV2ViR0xLZXJuZWxBcnJheSB9ID0gcmVxdWlyZSgnLi9hcnJheScpO1xuXG5jbGFzcyBXZWJHTEtlcm5lbFZhbHVlVW5zaWduZWRJbnB1dCBleHRlbmRzIFdlYkdMS2VybmVsQXJyYXkge1xuICBjb25zdHJ1Y3Rvcih2YWx1ZSwgc2V0dGluZ3MpIHtcbiAgICBzdXBlcih2YWx1ZSwgc2V0dGluZ3MpO1xuICAgIHRoaXMuYml0UmF0aW8gPSB0aGlzLmdldEJpdFJhdGlvKHZhbHVlKTtcbiAgICBjb25zdCBbdywgaCwgZF0gPSB2YWx1ZS5zaXplO1xuICAgIHRoaXMuZGltZW5zaW9ucyA9IG5ldyBJbnQzMkFycmF5KFt3IHx8IDEsIGggfHwgMSwgZCB8fCAxXSk7XG4gICAgdGhpcy50ZXh0dXJlU2l6ZSA9IHV0aWxzLmdldE1lbW9yeU9wdGltaXplZFBhY2tlZFRleHR1cmVTaXplKHRoaXMuZGltZW5zaW9ucywgdGhpcy5iaXRSYXRpbyk7XG4gICAgdGhpcy51cGxvYWRBcnJheUxlbmd0aCA9IHRoaXMudGV4dHVyZVNpemVbMF0gKiB0aGlzLnRleHR1cmVTaXplWzFdICogKDQgLyB0aGlzLmJpdFJhdGlvKTtcbiAgICB0aGlzLmNoZWNrU2l6ZSh0aGlzLnRleHR1cmVTaXplWzBdLCB0aGlzLnRleHR1cmVTaXplWzFdKTtcbiAgICB0aGlzLlRyYW5zZXJBcnJheVR5cGUgPSB0aGlzLmdldFRyYW5zZmVyQXJyYXlUeXBlKHZhbHVlLnZhbHVlKTtcbiAgICB0aGlzLnByZVVwbG9hZFZhbHVlID0gbmV3IHRoaXMuVHJhbnNlckFycmF5VHlwZSh0aGlzLnVwbG9hZEFycmF5TGVuZ3RoKTtcbiAgICB0aGlzLnVwbG9hZFZhbHVlID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5wcmVVcGxvYWRWYWx1ZS5idWZmZXIpO1xuICB9XG5cbiAgZ2V0U3RyaW5nVmFsdWVIYW5kbGVyKCkge1xuICAgIHJldHVybiB1dGlscy5saW5lc1RvU3RyaW5nKFtcbiAgICAgIGBjb25zdCBwcmVVcGxvYWRWYWx1ZV8ke3RoaXMubmFtZX0gPSBuZXcgJHt0aGlzLlRyYW5zZXJBcnJheVR5cGUubmFtZX0oJHt0aGlzLnVwbG9hZEFycmF5TGVuZ3RofSlgLFxuICAgICAgYGNvbnN0IHVwbG9hZFZhbHVlXyR7dGhpcy5uYW1lfSA9IG5ldyBVaW50OEFycmF5KHByZVVwbG9hZFZhbHVlXyR7dGhpcy5uYW1lfS5idWZmZXIpYCxcbiAgICAgIGBmbGF0dGVuVG8oJHt0aGlzLnZhck5hbWV9LnZhbHVlLCBwcmVVcGxvYWRWYWx1ZV8ke3RoaXMubmFtZX0pYCxcbiAgICBdKTtcbiAgfVxuXG4gIGdldFNvdXJjZSgpIHtcbiAgICByZXR1cm4gdXRpbHMubGluZXNUb1N0cmluZyhbXG4gICAgICBgdW5pZm9ybSBzYW1wbGVyMkQgJHt0aGlzLmlkfWAsXG4gICAgICBgaXZlYzIgJHt0aGlzLnNpemVJZH0gPSBpdmVjMigke3RoaXMudGV4dHVyZVNpemVbMF19LCAke3RoaXMudGV4dHVyZVNpemVbMV19KWAsXG4gICAgICBgaXZlYzMgJHt0aGlzLmRpbWVuc2lvbnNJZH0gPSBpdmVjMygke3RoaXMuZGltZW5zaW9uc1swXX0sICR7dGhpcy5kaW1lbnNpb25zWzFdfSwgJHt0aGlzLmRpbWVuc2lvbnNbMl19KWAsXG4gICAgXSk7XG4gIH1cblxuICB1cGRhdGVWYWx1ZShpbnB1dCkge1xuICAgIGlmIChpbnB1dC5jb25zdHJ1Y3RvciAhPT0gdGhpcy5pbml0aWFsVmFsdWVDb25zdHJ1Y3Rvcikge1xuICAgICAgdGhpcy5vblVwZGF0ZVZhbHVlTWlzbWF0Y2godmFsdWUuY29uc3RydWN0b3IpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7IGNvbnRleHQ6IGdsIH0gPSB0aGlzO1xuICAgIHV0aWxzLmZsYXR0ZW5UbyhpbnB1dC52YWx1ZSwgdGhpcy5wcmVVcGxvYWRWYWx1ZSk7XG4gICAgZ2wuYWN0aXZlVGV4dHVyZSh0aGlzLmNvbnRleHRIYW5kbGUpO1xuICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRoaXMudGV4dHVyZSk7XG4gICAgZ2wucGl4ZWxTdG9yZWkoZ2wuVU5QQUNLX0ZMSVBfWV9XRUJHTCwgZmFsc2UpO1xuICAgIGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgZ2wuUkdCQSwgdGhpcy50ZXh0dXJlU2l6ZVswXSwgdGhpcy50ZXh0dXJlU2l6ZVsxXSwgMCwgZ2wuUkdCQSwgZ2wuVU5TSUdORURfQllURSwgdGhpcy51cGxvYWRWYWx1ZSk7XG4gICAgdGhpcy5rZXJuZWwuc2V0VW5pZm9ybTFpKHRoaXMuaWQsIHRoaXMuaW5kZXgpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBXZWJHTEtlcm5lbFZhbHVlVW5zaWduZWRJbnB1dFxufTtcbn0se1wiLi4vLi4vLi4vdXRpbHNcIjoxMTQsXCIuL2FycmF5XCI6NDB9XSw3MDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5jb25zdCB7IEdMS2VybmVsIH0gPSByZXF1aXJlKCcuLi9nbC9rZXJuZWwnKTtcbmNvbnN0IHsgRnVuY3Rpb25CdWlsZGVyIH0gPSByZXF1aXJlKCcuLi9mdW5jdGlvbi1idWlsZGVyJyk7XG5jb25zdCB7IFdlYkdMRnVuY3Rpb25Ob2RlIH0gPSByZXF1aXJlKCcuL2Z1bmN0aW9uLW5vZGUnKTtcbmNvbnN0IHsgdXRpbHMgfSA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzJyk7XG5jb25zdCBtcnVkID0gcmVxdWlyZSgnLi4vLi4vcGx1Z2lucy9tYXRoLXJhbmRvbS11bmlmb3JtbHktZGlzdHJpYnV0ZWQnKTtcbmNvbnN0IHsgZnJhZ21lbnRTaGFkZXIgfSA9IHJlcXVpcmUoJy4vZnJhZ21lbnQtc2hhZGVyJyk7XG5jb25zdCB7IHZlcnRleFNoYWRlciB9ID0gcmVxdWlyZSgnLi92ZXJ0ZXgtc2hhZGVyJyk7XG5jb25zdCB7IGdsS2VybmVsU3RyaW5nIH0gPSByZXF1aXJlKCcuLi9nbC9rZXJuZWwtc3RyaW5nJyk7XG5jb25zdCB7IGxvb2t1cEtlcm5lbFZhbHVlVHlwZSB9ID0gcmVxdWlyZSgnLi9rZXJuZWwtdmFsdWUtbWFwcycpO1xuXG5sZXQgaXNTdXBwb3J0ZWQgPSBudWxsO1xubGV0IHRlc3RDYW52YXMgPSBudWxsO1xubGV0IHRlc3RDb250ZXh0ID0gbnVsbDtcbmxldCB0ZXN0RXh0ZW5zaW9ucyA9IG51bGw7XG5sZXQgZmVhdHVyZXMgPSBudWxsO1xuXG5jb25zdCBwbHVnaW5zID0gW21ydWRdO1xuY29uc3QgY2FudmFzZXMgPSBbXTtcbmNvbnN0IG1heFRleFNpemVzID0ge307XG5cblxuY2xhc3MgV2ViR0xLZXJuZWwgZXh0ZW5kcyBHTEtlcm5lbCB7XG4gIHN0YXRpYyBnZXQgaXNTdXBwb3J0ZWQoKSB7XG4gICAgaWYgKGlzU3VwcG9ydGVkICE9PSBudWxsKSB7XG4gICAgICByZXR1cm4gaXNTdXBwb3J0ZWQ7XG4gICAgfVxuICAgIHRoaXMuc2V0dXBGZWF0dXJlQ2hlY2tzKCk7XG4gICAgaXNTdXBwb3J0ZWQgPSB0aGlzLmlzQ29udGV4dE1hdGNoKHRlc3RDb250ZXh0KTtcbiAgICByZXR1cm4gaXNTdXBwb3J0ZWQ7XG4gIH1cblxuICBzdGF0aWMgc2V0dXBGZWF0dXJlQ2hlY2tzKCkge1xuICAgIGlmICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0ZXN0Q2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgT2Zmc2NyZWVuQ2FudmFzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgdGVzdENhbnZhcyA9IG5ldyBPZmZzY3JlZW5DYW52YXMoMCwgMCk7XG4gICAgfVxuICAgIGlmICghdGVzdENhbnZhcykgcmV0dXJuO1xuICAgIHRlc3RDb250ZXh0ID0gdGVzdENhbnZhcy5nZXRDb250ZXh0KCd3ZWJnbCcpIHx8IHRlc3RDYW52YXMuZ2V0Q29udGV4dCgnZXhwZXJpbWVudGFsLXdlYmdsJyk7XG4gICAgaWYgKCF0ZXN0Q29udGV4dCB8fCAhdGVzdENvbnRleHQuZ2V0RXh0ZW5zaW9uKSByZXR1cm47XG4gICAgdGVzdEV4dGVuc2lvbnMgPSB7XG4gICAgICBPRVNfdGV4dHVyZV9mbG9hdDogdGVzdENvbnRleHQuZ2V0RXh0ZW5zaW9uKCdPRVNfdGV4dHVyZV9mbG9hdCcpLFxuICAgICAgT0VTX3RleHR1cmVfZmxvYXRfbGluZWFyOiB0ZXN0Q29udGV4dC5nZXRFeHRlbnNpb24oJ09FU190ZXh0dXJlX2Zsb2F0X2xpbmVhcicpLFxuICAgICAgT0VTX2VsZW1lbnRfaW5kZXhfdWludDogdGVzdENvbnRleHQuZ2V0RXh0ZW5zaW9uKCdPRVNfZWxlbWVudF9pbmRleF91aW50JyksXG4gICAgICBXRUJHTF9kcmF3X2J1ZmZlcnM6IHRlc3RDb250ZXh0LmdldEV4dGVuc2lvbignV0VCR0xfZHJhd19idWZmZXJzJyksXG4gICAgfTtcbiAgICBmZWF0dXJlcyA9IHRoaXMuZ2V0RmVhdHVyZXMoKTtcbiAgfVxuXG4gIHN0YXRpYyBpc0NvbnRleHRNYXRjaChjb250ZXh0KSB7XG4gICAgaWYgKHR5cGVvZiBXZWJHTFJlbmRlcmluZ0NvbnRleHQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICByZXR1cm4gY29udGV4dCBpbnN0YW5jZW9mIFdlYkdMUmVuZGVyaW5nQ29udGV4dDtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgc3RhdGljIGdldElzVGV4dHVyZUZsb2F0KCkge1xuICAgIHJldHVybiBCb29sZWFuKHRlc3RFeHRlbnNpb25zLk9FU190ZXh0dXJlX2Zsb2F0KTtcbiAgfVxuXG4gIHN0YXRpYyBnZXRJc0RyYXdCdWZmZXJzKCkge1xuICAgIHJldHVybiBCb29sZWFuKHRlc3RFeHRlbnNpb25zLldFQkdMX2RyYXdfYnVmZmVycyk7XG4gIH1cblxuICBzdGF0aWMgZ2V0Q2hhbm5lbENvdW50KCkge1xuICAgIHJldHVybiB0ZXN0RXh0ZW5zaW9ucy5XRUJHTF9kcmF3X2J1ZmZlcnMgP1xuICAgICAgdGVzdENvbnRleHQuZ2V0UGFyYW1ldGVyKHRlc3RFeHRlbnNpb25zLldFQkdMX2RyYXdfYnVmZmVycy5NQVhfRFJBV19CVUZGRVJTX1dFQkdMKSA6XG4gICAgICAxO1xuICB9XG5cbiAgc3RhdGljIGdldE1heFRleHR1cmVTaXplKCkge1xuICAgIHJldHVybiB0ZXN0Q29udGV4dC5nZXRQYXJhbWV0ZXIodGVzdENvbnRleHQuTUFYX1RFWFRVUkVfU0laRSk7XG4gIH1cblxuICBzdGF0aWMgbG9va3VwS2VybmVsVmFsdWVUeXBlKHR5cGUsIGR5bmFtaWMsIHByZWNpc2lvbiwgdmFsdWUpIHtcbiAgICByZXR1cm4gbG9va3VwS2VybmVsVmFsdWVUeXBlKHR5cGUsIGR5bmFtaWMsIHByZWNpc2lvbiwgdmFsdWUpO1xuICB9XG5cbiAgc3RhdGljIGdldCB0ZXN0Q2FudmFzKCkge1xuICAgIHJldHVybiB0ZXN0Q2FudmFzO1xuICB9XG5cbiAgc3RhdGljIGdldCB0ZXN0Q29udGV4dCgpIHtcbiAgICByZXR1cm4gdGVzdENvbnRleHQ7XG4gIH1cblxuICBzdGF0aWMgZ2V0IGZlYXR1cmVzKCkge1xuICAgIHJldHVybiBmZWF0dXJlcztcbiAgfVxuXG4gIHN0YXRpYyBnZXQgZnJhZ21lbnRTaGFkZXIoKSB7XG4gICAgcmV0dXJuIGZyYWdtZW50U2hhZGVyO1xuICB9XG5cbiAgc3RhdGljIGdldCB2ZXJ0ZXhTaGFkZXIoKSB7XG4gICAgcmV0dXJuIHZlcnRleFNoYWRlcjtcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKHNvdXJjZSwgc2V0dGluZ3MpIHtcbiAgICBzdXBlcihzb3VyY2UsIHNldHRpbmdzKTtcbiAgICB0aGlzLnByb2dyYW0gPSBudWxsO1xuICAgIHRoaXMucGlwZWxpbmUgPSBzZXR0aW5ncy5waXBlbGluZTtcbiAgICB0aGlzLmVuZGlhbm5lc3MgPSB1dGlscy5zeXN0ZW1FbmRpYW5uZXNzKCk7XG4gICAgdGhpcy5leHRlbnNpb25zID0ge307XG4gICAgdGhpcy5hcmd1bWVudFRleHR1cmVDb3VudCA9IDA7XG4gICAgdGhpcy5jb25zdGFudFRleHR1cmVDb3VudCA9IDA7XG4gICAgdGhpcy5mcmFnU2hhZGVyID0gbnVsbDtcbiAgICB0aGlzLnZlcnRTaGFkZXIgPSBudWxsO1xuICAgIHRoaXMuZHJhd0J1ZmZlcnNNYXAgPSBudWxsO1xuXG4gICAgdGhpcy5tYXhUZXhTaXplID0gbnVsbDtcbiAgICB0aGlzLm9uUmVxdWVzdFN3aXRjaEtlcm5lbCA9IG51bGw7XG5cbiAgICB0aGlzLnRleHR1cmUgPSBudWxsO1xuICAgIHRoaXMubWFwcGVkVGV4dHVyZXMgPSBudWxsO1xuICAgIHRoaXMubWVyZ2VTZXR0aW5ncyhzb3VyY2Uuc2V0dGluZ3MgfHwgc2V0dGluZ3MpO1xuXG4gICAgdGhpcy50aHJlYWREaW0gPSBudWxsO1xuICAgIHRoaXMuZnJhbWVidWZmZXIgPSBudWxsO1xuICAgIHRoaXMuYnVmZmVyID0gbnVsbDtcblxuICAgIHRoaXMudGV4dHVyZUNhY2hlID0gW107XG4gICAgdGhpcy5wcm9ncmFtVW5pZm9ybUxvY2F0aW9uQ2FjaGUgPSB7fTtcbiAgICB0aGlzLnVuaWZvcm0xZkNhY2hlID0ge307XG4gICAgdGhpcy51bmlmb3JtMWlDYWNoZSA9IHt9O1xuICAgIHRoaXMudW5pZm9ybTJmQ2FjaGUgPSB7fTtcbiAgICB0aGlzLnVuaWZvcm0yZnZDYWNoZSA9IHt9O1xuICAgIHRoaXMudW5pZm9ybTJpdkNhY2hlID0ge307XG4gICAgdGhpcy51bmlmb3JtM2Z2Q2FjaGUgPSB7fTtcbiAgICB0aGlzLnVuaWZvcm0zaXZDYWNoZSA9IHt9O1xuICAgIHRoaXMudW5pZm9ybTRmdkNhY2hlID0ge307XG4gICAgdGhpcy51bmlmb3JtNGl2Q2FjaGUgPSB7fTtcbiAgfVxuXG4gIGluaXRDYW52YXMoKSB7XG4gICAgaWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGNvbnN0IGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgICAgY2FudmFzLndpZHRoID0gMjtcbiAgICAgIGNhbnZhcy5oZWlnaHQgPSAyO1xuICAgICAgcmV0dXJuIGNhbnZhcztcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBPZmZzY3JlZW5DYW52YXMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICByZXR1cm4gbmV3IE9mZnNjcmVlbkNhbnZhcygwLCAwKTtcbiAgICB9XG4gIH1cblxuICBpbml0Q29udGV4dCgpIHtcbiAgICBjb25zdCBzZXR0aW5ncyA9IHtcbiAgICAgIGFscGhhOiBmYWxzZSxcbiAgICAgIGRlcHRoOiBmYWxzZSxcbiAgICAgIGFudGlhbGlhczogZmFsc2VcbiAgICB9O1xuICAgIHJldHVybiB0aGlzLmNhbnZhcy5nZXRDb250ZXh0KCd3ZWJnbCcsIHNldHRpbmdzKSB8fCB0aGlzLmNhbnZhcy5nZXRDb250ZXh0KCdleHBlcmltZW50YWwtd2ViZ2wnLCBzZXR0aW5ncyk7XG4gIH1cblxuICBpbml0UGx1Z2lucyhzZXR0aW5ncykge1xuICAgIGNvbnN0IHBsdWdpbnNUb1VzZSA9IFtdO1xuICAgIGNvbnN0IHsgc291cmNlIH0gPSB0aGlzO1xuICAgIGlmICh0eXBlb2Ygc291cmNlID09PSAnc3RyaW5nJykge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwbHVnaW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHBsdWdpbiA9IHBsdWdpbnNbaV07XG4gICAgICAgIGlmIChzb3VyY2UubWF0Y2gocGx1Z2luLmZ1bmN0aW9uTWF0Y2gpKSB7XG4gICAgICAgICAgcGx1Z2luc1RvVXNlLnB1c2gocGx1Z2luKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIHNvdXJjZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGlmIChzZXR0aW5ncy5wbHVnaW5OYW1lcykgeyBcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwbHVnaW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgY29uc3QgcGx1Z2luID0gcGx1Z2luc1tpXTtcbiAgICAgICAgICBjb25zdCB1c2VQbHVnaW4gPSBzZXR0aW5ncy5wbHVnaW5OYW1lcy5zb21lKHBsdWdpbk5hbWUgPT4gcGx1Z2luTmFtZSA9PT0gcGx1Z2luLm5hbWUpO1xuICAgICAgICAgIGlmICh1c2VQbHVnaW4pIHtcbiAgICAgICAgICAgIHBsdWdpbnNUb1VzZS5wdXNoKHBsdWdpbik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwbHVnaW5zVG9Vc2U7XG4gIH1cblxuICBpbml0RXh0ZW5zaW9ucygpIHtcbiAgICB0aGlzLmV4dGVuc2lvbnMgPSB7XG4gICAgICBPRVNfdGV4dHVyZV9mbG9hdDogdGhpcy5jb250ZXh0LmdldEV4dGVuc2lvbignT0VTX3RleHR1cmVfZmxvYXQnKSxcbiAgICAgIE9FU190ZXh0dXJlX2Zsb2F0X2xpbmVhcjogdGhpcy5jb250ZXh0LmdldEV4dGVuc2lvbignT0VTX3RleHR1cmVfZmxvYXRfbGluZWFyJyksXG4gICAgICBPRVNfZWxlbWVudF9pbmRleF91aW50OiB0aGlzLmNvbnRleHQuZ2V0RXh0ZW5zaW9uKCdPRVNfZWxlbWVudF9pbmRleF91aW50JyksXG4gICAgICBXRUJHTF9kcmF3X2J1ZmZlcnM6IHRoaXMuY29udGV4dC5nZXRFeHRlbnNpb24oJ1dFQkdMX2RyYXdfYnVmZmVycycpLFxuICAgICAgV0VCR0xfY29sb3JfYnVmZmVyX2Zsb2F0OiB0aGlzLmNvbnRleHQuZ2V0RXh0ZW5zaW9uKCdXRUJHTF9jb2xvcl9idWZmZXJfZmxvYXQnKSxcbiAgICB9O1xuICB9XG5cbiAgdmFsaWRhdGVTZXR0aW5ncyhhcmdzKSB7XG4gICAgaWYgKCF0aGlzLnZhbGlkYXRlKSB7XG4gICAgICB0aGlzLnRleFNpemUgPSB1dGlscy5nZXRLZXJuZWxUZXh0dXJlU2l6ZSh7XG4gICAgICAgIG9wdGltaXplRmxvYXRNZW1vcnk6IHRoaXMub3B0aW1pemVGbG9hdE1lbW9yeSxcbiAgICAgICAgcHJlY2lzaW9uOiB0aGlzLnByZWNpc2lvbixcbiAgICAgIH0sIHRoaXMub3V0cHV0KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCB7IGZlYXR1cmVzIH0gPSB0aGlzLmNvbnN0cnVjdG9yO1xuXG4gICAgaWYgKHRoaXMub3B0aW1pemVGbG9hdE1lbW9yeSA9PT0gdHJ1ZSAmJiAhZmVhdHVyZXMuaXNUZXh0dXJlRmxvYXQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRmxvYXQgdGV4dHVyZXMgYXJlIG5vdCBzdXBwb3J0ZWQnKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMucHJlY2lzaW9uID09PSAnc2luZ2xlJyAmJiAhZmVhdHVyZXMuaXNGbG9hdFJlYWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignU2luZ2xlIHByZWNpc2lvbiBub3Qgc3VwcG9ydGVkJyk7XG4gICAgfSBlbHNlIGlmICghdGhpcy5ncmFwaGljYWwgJiYgdGhpcy5wcmVjaXNpb24gPT09IG51bGwgJiYgZmVhdHVyZXMuaXNUZXh0dXJlRmxvYXQpIHtcbiAgICAgIHRoaXMucHJlY2lzaW9uID0gZmVhdHVyZXMuaXNGbG9hdFJlYWQgPyAnc2luZ2xlJyA6ICd1bnNpZ25lZCc7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuc3ViS2VybmVscyAmJiB0aGlzLnN1Yktlcm5lbHMubGVuZ3RoID4gMCAmJiAhdGhpcy5leHRlbnNpb25zLldFQkdMX2RyYXdfYnVmZmVycykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdjb3VsZCBub3QgaW5zdGFudGlhdGUgZHJhdyBidWZmZXJzIGV4dGVuc2lvbicpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmZpeEludGVnZXJEaXZpc2lvbkFjY3VyYWN5ID09PSBudWxsKSB7XG4gICAgICB0aGlzLmZpeEludGVnZXJEaXZpc2lvbkFjY3VyYWN5ID0gIWZlYXR1cmVzLmlzSW50ZWdlckRpdmlzaW9uQWNjdXJhdGU7XG4gICAgfSBlbHNlIGlmICh0aGlzLmZpeEludGVnZXJEaXZpc2lvbkFjY3VyYWN5ICYmIGZlYXR1cmVzLmlzSW50ZWdlckRpdmlzaW9uQWNjdXJhdGUpIHtcbiAgICAgIHRoaXMuZml4SW50ZWdlckRpdmlzaW9uQWNjdXJhY3kgPSBmYWxzZTtcbiAgICB9XG5cbiAgICB0aGlzLmNoZWNrT3V0cHV0KCk7XG5cbiAgICBpZiAoIXRoaXMub3V0cHV0IHx8IHRoaXMub3V0cHV0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgaWYgKGFyZ3MubGVuZ3RoICE9PSAxKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQXV0byBvdXRwdXQgb25seSBzdXBwb3J0ZWQgZm9yIGtlcm5lbHMgd2l0aCBvbmx5IG9uZSBpbnB1dCcpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBhcmdUeXBlID0gdXRpbHMuZ2V0VmFyaWFibGVUeXBlKGFyZ3NbMF0sIHRoaXMuc3RyaWN0SW50ZWdlcnMpO1xuICAgICAgc3dpdGNoIChhcmdUeXBlKSB7XG4gICAgICAgIGNhc2UgJ0FycmF5JzpcbiAgICAgICAgICB0aGlzLm91dHB1dCA9IHV0aWxzLmdldERpbWVuc2lvbnMoYXJnVHlwZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ051bWJlclRleHR1cmUnOlxuICAgICAgICBjYXNlICdNZW1vcnlPcHRpbWl6ZWROdW1iZXJUZXh0dXJlJzpcbiAgICAgICAgY2FzZSAnQXJyYXlUZXh0dXJlKDEpJzpcbiAgICAgICAgY2FzZSAnQXJyYXlUZXh0dXJlKDIpJzpcbiAgICAgICAgY2FzZSAnQXJyYXlUZXh0dXJlKDMpJzpcbiAgICAgICAgY2FzZSAnQXJyYXlUZXh0dXJlKDQpJzpcbiAgICAgICAgICB0aGlzLm91dHB1dCA9IGFyZ3NbMF0ub3V0cHV0O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQXV0byBvdXRwdXQgbm90IHN1cHBvcnRlZCBmb3IgaW5wdXQgdHlwZTogJyArIGFyZ1R5cGUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLmdyYXBoaWNhbCkge1xuICAgICAgaWYgKHRoaXMub3V0cHV0Lmxlbmd0aCAhPT0gMikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ091dHB1dCBtdXN0IGhhdmUgMiBkaW1lbnNpb25zIG9uIGdyYXBoaWNhbCBtb2RlJyk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnByZWNpc2lvbiA9PT0gJ3ByZWNpc2lvbicpIHtcbiAgICAgICAgdGhpcy5wcmVjaXNpb24gPSAndW5zaWduZWQnO1xuICAgICAgICBjb25zb2xlLndhcm4oJ0Nhbm5vdCB1c2UgZ3JhcGhpY2FsIG1vZGUgYW5kIHNpbmdsZSBwcmVjaXNpb24gYXQgdGhlIHNhbWUgdGltZScpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnRleFNpemUgPSB1dGlscy5jbG9uZSh0aGlzLm91dHB1dCk7XG4gICAgICByZXR1cm47XG4gICAgfSBlbHNlIGlmICh0aGlzLnByZWNpc2lvbiA9PT0gbnVsbCAmJiBmZWF0dXJlcy5pc1RleHR1cmVGbG9hdCkge1xuICAgICAgdGhpcy5wcmVjaXNpb24gPSAnc2luZ2xlJztcbiAgICB9XG5cbiAgICB0aGlzLnRleFNpemUgPSB1dGlscy5nZXRLZXJuZWxUZXh0dXJlU2l6ZSh7XG4gICAgICBvcHRpbWl6ZUZsb2F0TWVtb3J5OiB0aGlzLm9wdGltaXplRmxvYXRNZW1vcnksXG4gICAgICBwcmVjaXNpb246IHRoaXMucHJlY2lzaW9uLFxuICAgIH0sIHRoaXMub3V0cHV0KTtcblxuICAgIHRoaXMuY2hlY2tUZXh0dXJlU2l6ZSgpO1xuICB9XG5cbiAgdXBkYXRlTWF4VGV4U2l6ZSgpIHtcbiAgICBjb25zdCB7IHRleFNpemUsIGNhbnZhcyB9ID0gdGhpcztcbiAgICBpZiAodGhpcy5tYXhUZXhTaXplID09PSBudWxsKSB7XG4gICAgICBsZXQgY2FudmFzSW5kZXggPSBjYW52YXNlcy5pbmRleE9mKGNhbnZhcyk7XG4gICAgICBpZiAoY2FudmFzSW5kZXggPT09IC0xKSB7XG4gICAgICAgIGNhbnZhc0luZGV4ID0gY2FudmFzZXMubGVuZ3RoO1xuICAgICAgICBjYW52YXNlcy5wdXNoKGNhbnZhcyk7XG4gICAgICAgIG1heFRleFNpemVzW2NhbnZhc0luZGV4XSA9IFt0ZXhTaXplWzBdLCB0ZXhTaXplWzFdXTtcbiAgICAgIH1cbiAgICAgIHRoaXMubWF4VGV4U2l6ZSA9IG1heFRleFNpemVzW2NhbnZhc0luZGV4XTtcbiAgICB9XG4gICAgaWYgKHRoaXMubWF4VGV4U2l6ZVswXSA8IHRleFNpemVbMF0pIHtcbiAgICAgIHRoaXMubWF4VGV4U2l6ZVswXSA9IHRleFNpemVbMF07XG4gICAgfVxuICAgIGlmICh0aGlzLm1heFRleFNpemVbMV0gPCB0ZXhTaXplWzFdKSB7XG4gICAgICB0aGlzLm1heFRleFNpemVbMV0gPSB0ZXhTaXplWzFdO1xuICAgIH1cbiAgfVxuXG4gIHNldHVwQXJndW1lbnRzKGFyZ3MpIHtcbiAgICB0aGlzLmtlcm5lbEFyZ3VtZW50cyA9IFtdO1xuICAgIHRoaXMuYXJndW1lbnRUZXh0dXJlQ291bnQgPSAwO1xuICAgIGNvbnN0IG5lZWRzQXJndW1lbnRUeXBlcyA9IHRoaXMuYXJndW1lbnRUeXBlcyA9PT0gbnVsbDtcbiAgICBpZiAobmVlZHNBcmd1bWVudFR5cGVzKSB7XG4gICAgICB0aGlzLmFyZ3VtZW50VHlwZXMgPSBbXTtcbiAgICB9XG4gICAgdGhpcy5hcmd1bWVudFNpemVzID0gW107XG4gICAgdGhpcy5hcmd1bWVudEJpdFJhdGlvcyA9IFtdO1xuXG4gICAgaWYgKGFyZ3MubGVuZ3RoIDwgdGhpcy5hcmd1bWVudE5hbWVzLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdub3QgZW5vdWdoIGFyZ3VtZW50cyBmb3Iga2VybmVsJyk7XG4gICAgfSBlbHNlIGlmIChhcmdzLmxlbmd0aCA+IHRoaXMuYXJndW1lbnROYW1lcy5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigndG9vIG1hbnkgYXJndW1lbnRzIGZvciBrZXJuZWwnKTtcbiAgICB9XG5cbiAgICBjb25zdCB7IGNvbnRleHQ6IGdsIH0gPSB0aGlzO1xuICAgIGxldCB0ZXh0dXJlSW5kZXhlcyA9IDA7XG5cbiAgICBjb25zdCBvblJlcXVlc3RUZXh0dXJlID0gKCkgPT4ge1xuICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlVGV4dHVyZSgpO1xuICAgIH07XG4gICAgY29uc3Qgb25SZXF1ZXN0SW5kZXggPSAoKSA9PiB7XG4gICAgICByZXR1cm4gdGhpcy5jb25zdGFudFRleHR1cmVDb3VudCArIHRleHR1cmVJbmRleGVzKys7XG4gICAgfTtcbiAgICBjb25zdCBvblVwZGF0ZVZhbHVlTWlzbWF0Y2ggPSAoY29uc3RydWN0b3IpID0+IHtcbiAgICAgIHRoaXMuc3dpdGNoS2VybmVscyh7XG4gICAgICAgIHR5cGU6ICdhcmd1bWVudE1pc21hdGNoJyxcbiAgICAgICAgbmVlZGVkOiBjb25zdHJ1Y3RvclxuICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCBvblJlcXVlc3RDb250ZXh0SGFuZGxlID0gKCkgPT4ge1xuICAgICAgcmV0dXJuIGdsLlRFWFRVUkUwICsgdGhpcy5jb25zdGFudFRleHR1cmVDb3VudCArIHRoaXMuYXJndW1lbnRUZXh0dXJlQ291bnQrKztcbiAgICB9O1xuXG4gICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IGFyZ3MubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICBjb25zdCB2YWx1ZSA9IGFyZ3NbaW5kZXhdO1xuICAgICAgY29uc3QgbmFtZSA9IHRoaXMuYXJndW1lbnROYW1lc1tpbmRleF07XG4gICAgICBsZXQgdHlwZTtcbiAgICAgIGlmIChuZWVkc0FyZ3VtZW50VHlwZXMpIHtcbiAgICAgICAgdHlwZSA9IHV0aWxzLmdldFZhcmlhYmxlVHlwZSh2YWx1ZSwgdGhpcy5zdHJpY3RJbnRlZ2Vycyk7XG4gICAgICAgIHRoaXMuYXJndW1lbnRUeXBlcy5wdXNoKHR5cGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHlwZSA9IHRoaXMuYXJndW1lbnRUeXBlc1tpbmRleF07XG4gICAgICB9XG4gICAgICBjb25zdCBLZXJuZWxWYWx1ZSA9IHRoaXMuY29uc3RydWN0b3IubG9va3VwS2VybmVsVmFsdWVUeXBlKHR5cGUsIHRoaXMuZHluYW1pY0FyZ3VtZW50cyA/ICdkeW5hbWljJyA6ICdzdGF0aWMnLCB0aGlzLnByZWNpc2lvbiwgYXJnc1tpbmRleF0pO1xuICAgICAgaWYgKEtlcm5lbFZhbHVlID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlcXVlc3RGYWxsYmFjayhhcmdzKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGtlcm5lbEFyZ3VtZW50ID0gbmV3IEtlcm5lbFZhbHVlKHZhbHVlLCB7XG4gICAgICAgIG5hbWUsXG4gICAgICAgIHR5cGUsXG4gICAgICAgIHRhY3RpYzogdGhpcy50YWN0aWMsXG4gICAgICAgIG9yaWdpbjogJ3VzZXInLFxuICAgICAgICBjb250ZXh0OiBnbCxcbiAgICAgICAgY2hlY2tDb250ZXh0OiB0aGlzLmNoZWNrQ29udGV4dCxcbiAgICAgICAga2VybmVsOiB0aGlzLFxuICAgICAgICBzdHJpY3RJbnRlZ2VyczogdGhpcy5zdHJpY3RJbnRlZ2VycyxcbiAgICAgICAgb25SZXF1ZXN0VGV4dHVyZSxcbiAgICAgICAgb25SZXF1ZXN0SW5kZXgsXG4gICAgICAgIG9uVXBkYXRlVmFsdWVNaXNtYXRjaCxcbiAgICAgICAgb25SZXF1ZXN0Q29udGV4dEhhbmRsZSxcbiAgICAgIH0pO1xuICAgICAgdGhpcy5rZXJuZWxBcmd1bWVudHMucHVzaChrZXJuZWxBcmd1bWVudCk7XG4gICAgICBrZXJuZWxBcmd1bWVudC5zZXR1cCgpO1xuICAgICAgdGhpcy5hcmd1bWVudFNpemVzLnB1c2goa2VybmVsQXJndW1lbnQudGV4dHVyZVNpemUpO1xuICAgICAgdGhpcy5hcmd1bWVudEJpdFJhdGlvc1tpbmRleF0gPSBrZXJuZWxBcmd1bWVudC5iaXRSYXRpbztcbiAgICB9XG4gIH1cblxuICBjcmVhdGVUZXh0dXJlKCkge1xuICAgIGNvbnN0IHRleHR1cmUgPSB0aGlzLmNvbnRleHQuY3JlYXRlVGV4dHVyZSgpO1xuICAgIHRoaXMudGV4dHVyZUNhY2hlLnB1c2godGV4dHVyZSk7XG4gICAgcmV0dXJuIHRleHR1cmU7XG4gIH1cblxuICBzZXR1cENvbnN0YW50cyhhcmdzKSB7XG4gICAgY29uc3QgeyBjb250ZXh0OiBnbCB9ID0gdGhpcztcbiAgICB0aGlzLmtlcm5lbENvbnN0YW50cyA9IFtdO1xuICAgIHRoaXMuZm9yY2VVcGxvYWRLZXJuZWxDb25zdGFudHMgPSBbXTtcbiAgICBsZXQgbmVlZHNDb25zdGFudFR5cGVzID0gdGhpcy5jb25zdGFudFR5cGVzID09PSBudWxsO1xuICAgIGlmIChuZWVkc0NvbnN0YW50VHlwZXMpIHtcbiAgICAgIHRoaXMuY29uc3RhbnRUeXBlcyA9IHt9O1xuICAgIH1cbiAgICB0aGlzLmNvbnN0YW50Qml0UmF0aW9zID0ge307XG4gICAgbGV0IHRleHR1cmVJbmRleGVzID0gMDtcbiAgICBmb3IgKGNvbnN0IG5hbWUgaW4gdGhpcy5jb25zdGFudHMpIHtcbiAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5jb25zdGFudHNbbmFtZV07XG4gICAgICBsZXQgdHlwZTtcbiAgICAgIGlmIChuZWVkc0NvbnN0YW50VHlwZXMpIHtcbiAgICAgICAgdHlwZSA9IHV0aWxzLmdldFZhcmlhYmxlVHlwZSh2YWx1ZSwgdGhpcy5zdHJpY3RJbnRlZ2Vycyk7XG4gICAgICAgIHRoaXMuY29uc3RhbnRUeXBlc1tuYW1lXSA9IHR5cGU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0eXBlID0gdGhpcy5jb25zdGFudFR5cGVzW25hbWVdO1xuICAgICAgfVxuICAgICAgY29uc3QgS2VybmVsVmFsdWUgPSB0aGlzLmNvbnN0cnVjdG9yLmxvb2t1cEtlcm5lbFZhbHVlVHlwZSh0eXBlLCAnc3RhdGljJywgdGhpcy5wcmVjaXNpb24sIHZhbHVlKTtcbiAgICAgIGlmIChLZXJuZWxWYWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXF1ZXN0RmFsbGJhY2soYXJncyk7XG4gICAgICB9XG4gICAgICBjb25zdCBrZXJuZWxWYWx1ZSA9IG5ldyBLZXJuZWxWYWx1ZSh2YWx1ZSwge1xuICAgICAgICBuYW1lLFxuICAgICAgICB0eXBlLFxuICAgICAgICB0YWN0aWM6IHRoaXMudGFjdGljLFxuICAgICAgICBvcmlnaW46ICdjb25zdGFudHMnLFxuICAgICAgICBjb250ZXh0OiB0aGlzLmNvbnRleHQsXG4gICAgICAgIGNoZWNrQ29udGV4dDogdGhpcy5jaGVja0NvbnRleHQsXG4gICAgICAgIGtlcm5lbDogdGhpcyxcbiAgICAgICAgc3RyaWN0SW50ZWdlcnM6IHRoaXMuc3RyaWN0SW50ZWdlcnMsXG4gICAgICAgIG9uUmVxdWVzdFRleHR1cmU6ICgpID0+IHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVUZXh0dXJlKCk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uUmVxdWVzdEluZGV4OiAoKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIHRleHR1cmVJbmRleGVzKys7XG4gICAgICAgIH0sXG4gICAgICAgIG9uUmVxdWVzdENvbnRleHRIYW5kbGU6ICgpID0+IHtcbiAgICAgICAgICByZXR1cm4gZ2wuVEVYVFVSRTAgKyB0aGlzLmNvbnN0YW50VGV4dHVyZUNvdW50Kys7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgdGhpcy5jb25zdGFudEJpdFJhdGlvc1tuYW1lXSA9IGtlcm5lbFZhbHVlLmJpdFJhdGlvO1xuICAgICAgdGhpcy5rZXJuZWxDb25zdGFudHMucHVzaChrZXJuZWxWYWx1ZSk7XG4gICAgICBrZXJuZWxWYWx1ZS5zZXR1cCgpO1xuICAgICAgaWYgKGtlcm5lbFZhbHVlLmZvcmNlVXBsb2FkRWFjaFJ1bikge1xuICAgICAgICB0aGlzLmZvcmNlVXBsb2FkS2VybmVsQ29uc3RhbnRzLnB1c2goa2VybmVsVmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGJ1aWxkKCkge1xuICAgIGlmICh0aGlzLmJ1aWx0KSByZXR1cm47XG4gICAgdGhpcy5pbml0RXh0ZW5zaW9ucygpO1xuICAgIHRoaXMudmFsaWRhdGVTZXR0aW5ncyhhcmd1bWVudHMpO1xuICAgIHRoaXMuc2V0dXBDb25zdGFudHMoYXJndW1lbnRzKTtcbiAgICBpZiAodGhpcy5mYWxsYmFja1JlcXVlc3RlZCkgcmV0dXJuO1xuICAgIHRoaXMuc2V0dXBBcmd1bWVudHMoYXJndW1lbnRzKTtcbiAgICBpZiAodGhpcy5mYWxsYmFja1JlcXVlc3RlZCkgcmV0dXJuO1xuICAgIHRoaXMudXBkYXRlTWF4VGV4U2l6ZSgpO1xuICAgIHRoaXMudHJhbnNsYXRlU291cmNlKCk7XG4gICAgY29uc3QgZmFpbHVyZVJlc3VsdCA9IHRoaXMucGlja1JlbmRlclN0cmF0ZWd5KGFyZ3VtZW50cyk7XG4gICAgaWYgKGZhaWx1cmVSZXN1bHQpIHtcbiAgICAgIHJldHVybiBmYWlsdXJlUmVzdWx0O1xuICAgIH1cbiAgICBjb25zdCB7IHRleFNpemUsIGNvbnRleHQ6IGdsLCBjYW52YXMgfSA9IHRoaXM7XG4gICAgZ2wuZW5hYmxlKGdsLlNDSVNTT1JfVEVTVCk7XG4gICAgaWYgKHRoaXMucGlwZWxpbmUgJiYgdGhpcy5wcmVjaXNpb24gPT09ICdzaW5nbGUnKSB7XG4gICAgICBnbC52aWV3cG9ydCgwLCAwLCB0aGlzLm1heFRleFNpemVbMF0sIHRoaXMubWF4VGV4U2l6ZVsxXSk7XG4gICAgICBjYW52YXMud2lkdGggPSB0aGlzLm1heFRleFNpemVbMF07XG4gICAgICBjYW52YXMuaGVpZ2h0ID0gdGhpcy5tYXhUZXhTaXplWzFdO1xuICAgIH0gZWxzZSB7XG4gICAgICBnbC52aWV3cG9ydCgwLCAwLCB0aGlzLm1heFRleFNpemVbMF0sIHRoaXMubWF4VGV4U2l6ZVsxXSk7XG4gICAgICBjYW52YXMud2lkdGggPSB0aGlzLm1heFRleFNpemVbMF07XG4gICAgICBjYW52YXMuaGVpZ2h0ID0gdGhpcy5tYXhUZXhTaXplWzFdO1xuICAgIH1cbiAgICBjb25zdCB0aHJlYWREaW0gPSB0aGlzLnRocmVhZERpbSA9IEFycmF5LmZyb20odGhpcy5vdXRwdXQpO1xuICAgIHdoaWxlICh0aHJlYWREaW0ubGVuZ3RoIDwgMykge1xuICAgICAgdGhyZWFkRGltLnB1c2goMSk7XG4gICAgfVxuXG4gICAgY29uc3QgY29tcGlsZWRWZXJ0ZXhTaGFkZXIgPSB0aGlzLmdldFZlcnRleFNoYWRlcihhcmd1bWVudHMpO1xuICAgIGNvbnN0IHZlcnRTaGFkZXIgPSBnbC5jcmVhdGVTaGFkZXIoZ2wuVkVSVEVYX1NIQURFUik7XG4gICAgZ2wuc2hhZGVyU291cmNlKHZlcnRTaGFkZXIsIGNvbXBpbGVkVmVydGV4U2hhZGVyKTtcbiAgICBnbC5jb21waWxlU2hhZGVyKHZlcnRTaGFkZXIpO1xuICAgIHRoaXMudmVydFNoYWRlciA9IHZlcnRTaGFkZXI7XG5cbiAgICBjb25zdCBjb21waWxlZEZyYWdtZW50U2hhZGVyID0gdGhpcy5nZXRGcmFnbWVudFNoYWRlcihhcmd1bWVudHMpO1xuICAgIGNvbnN0IGZyYWdTaGFkZXIgPSBnbC5jcmVhdGVTaGFkZXIoZ2wuRlJBR01FTlRfU0hBREVSKTtcbiAgICBnbC5zaGFkZXJTb3VyY2UoZnJhZ1NoYWRlciwgY29tcGlsZWRGcmFnbWVudFNoYWRlcik7XG4gICAgZ2wuY29tcGlsZVNoYWRlcihmcmFnU2hhZGVyKTtcbiAgICB0aGlzLmZyYWdTaGFkZXIgPSBmcmFnU2hhZGVyO1xuXG4gICAgaWYgKHRoaXMuZGVidWcpIHtcbiAgICAgIGNvbnNvbGUubG9nKCdHTFNMIFNoYWRlciBPdXRwdXQ6Jyk7XG4gICAgICBjb25zb2xlLmxvZyhjb21waWxlZEZyYWdtZW50U2hhZGVyKTtcbiAgICB9XG5cbiAgICBpZiAoIWdsLmdldFNoYWRlclBhcmFtZXRlcih2ZXJ0U2hhZGVyLCBnbC5DT01QSUxFX1NUQVRVUykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRXJyb3IgY29tcGlsaW5nIHZlcnRleCBzaGFkZXI6ICcgKyBnbC5nZXRTaGFkZXJJbmZvTG9nKHZlcnRTaGFkZXIpKTtcbiAgICB9XG4gICAgaWYgKCFnbC5nZXRTaGFkZXJQYXJhbWV0ZXIoZnJhZ1NoYWRlciwgZ2wuQ09NUElMRV9TVEFUVVMpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Vycm9yIGNvbXBpbGluZyBmcmFnbWVudCBzaGFkZXI6ICcgKyBnbC5nZXRTaGFkZXJJbmZvTG9nKGZyYWdTaGFkZXIpKTtcbiAgICB9XG5cbiAgICBjb25zdCBwcm9ncmFtID0gdGhpcy5wcm9ncmFtID0gZ2wuY3JlYXRlUHJvZ3JhbSgpO1xuICAgIGdsLmF0dGFjaFNoYWRlcihwcm9ncmFtLCB2ZXJ0U2hhZGVyKTtcbiAgICBnbC5hdHRhY2hTaGFkZXIocHJvZ3JhbSwgZnJhZ1NoYWRlcik7XG4gICAgZ2wubGlua1Byb2dyYW0ocHJvZ3JhbSk7XG4gICAgdGhpcy5mcmFtZWJ1ZmZlciA9IGdsLmNyZWF0ZUZyYW1lYnVmZmVyKCk7XG4gICAgdGhpcy5mcmFtZWJ1ZmZlci53aWR0aCA9IHRleFNpemVbMF07XG4gICAgdGhpcy5mcmFtZWJ1ZmZlci5oZWlnaHQgPSB0ZXhTaXplWzFdO1xuICAgIHRoaXMucmF3VmFsdWVGcmFtZWJ1ZmZlcnMgPSB7fTtcblxuICAgIGNvbnN0IHZlcnRpY2VzID0gbmV3IEZsb2F0MzJBcnJheShbLTEsIC0xLFxuICAgICAgMSwgLTEsIC0xLCAxLFxuICAgICAgMSwgMVxuICAgIF0pO1xuICAgIGNvbnN0IHRleENvb3JkcyA9IG5ldyBGbG9hdDMyQXJyYXkoW1xuICAgICAgMCwgMCxcbiAgICAgIDEsIDAsXG4gICAgICAwLCAxLFxuICAgICAgMSwgMVxuICAgIF0pO1xuXG4gICAgY29uc3QgdGV4Q29vcmRPZmZzZXQgPSB2ZXJ0aWNlcy5ieXRlTGVuZ3RoO1xuXG4gICAgbGV0IGJ1ZmZlciA9IHRoaXMuYnVmZmVyO1xuICAgIGlmICghYnVmZmVyKSB7XG4gICAgICBidWZmZXIgPSB0aGlzLmJ1ZmZlciA9IGdsLmNyZWF0ZUJ1ZmZlcigpO1xuICAgICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIGJ1ZmZlcik7XG4gICAgICBnbC5idWZmZXJEYXRhKGdsLkFSUkFZX0JVRkZFUiwgdmVydGljZXMuYnl0ZUxlbmd0aCArIHRleENvb3Jkcy5ieXRlTGVuZ3RoLCBnbC5TVEFUSUNfRFJBVyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCBidWZmZXIpO1xuICAgIH1cblxuICAgIGdsLmJ1ZmZlclN1YkRhdGEoZ2wuQVJSQVlfQlVGRkVSLCAwLCB2ZXJ0aWNlcyk7XG4gICAgZ2wuYnVmZmVyU3ViRGF0YShnbC5BUlJBWV9CVUZGRVIsIHRleENvb3JkT2Zmc2V0LCB0ZXhDb29yZHMpO1xuXG4gICAgY29uc3QgYVBvc0xvYyA9IGdsLmdldEF0dHJpYkxvY2F0aW9uKHRoaXMucHJvZ3JhbSwgJ2FQb3MnKTtcbiAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShhUG9zTG9jKTtcbiAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKGFQb3NMb2MsIDIsIGdsLkZMT0FULCBmYWxzZSwgMCwgMCk7XG4gICAgY29uc3QgYVRleENvb3JkTG9jID0gZ2wuZ2V0QXR0cmliTG9jYXRpb24odGhpcy5wcm9ncmFtLCAnYVRleENvb3JkJyk7XG4gICAgZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkoYVRleENvb3JkTG9jKTtcbiAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKGFUZXhDb29yZExvYywgMiwgZ2wuRkxPQVQsIGZhbHNlLCAwLCB0ZXhDb29yZE9mZnNldCk7XG4gICAgZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCB0aGlzLmZyYW1lYnVmZmVyKTtcblxuICAgIGxldCBpID0gMDtcbiAgICBnbC51c2VQcm9ncmFtKHRoaXMucHJvZ3JhbSk7XG4gICAgZm9yIChsZXQgcCBpbiB0aGlzLmNvbnN0YW50cykge1xuICAgICAgdGhpcy5rZXJuZWxDb25zdGFudHNbaSsrXS51cGRhdGVWYWx1ZSh0aGlzLmNvbnN0YW50c1twXSk7XG4gICAgfVxuXG4gICAgdGhpcy5fc2V0dXBPdXRwdXRUZXh0dXJlKCk7XG4gICAgaWYgKFxuICAgICAgdGhpcy5zdWJLZXJuZWxzICE9PSBudWxsICYmXG4gICAgICB0aGlzLnN1Yktlcm5lbHMubGVuZ3RoID4gMFxuICAgICkge1xuICAgICAgdGhpcy5fbWFwcGVkVGV4dHVyZVN3aXRjaGVkID0ge307XG4gICAgICB0aGlzLl9zZXR1cFN1Yk91dHB1dFRleHR1cmVzKCk7XG4gICAgfVxuICAgIHRoaXMuYnVpbGRTaWduYXR1cmUoYXJndW1lbnRzKTtcbiAgICB0aGlzLmJ1aWx0ID0gdHJ1ZTtcbiAgfVxuXG4gIHRyYW5zbGF0ZVNvdXJjZSgpIHtcbiAgICBjb25zdCBmdW5jdGlvbkJ1aWxkZXIgPSBGdW5jdGlvbkJ1aWxkZXIuZnJvbUtlcm5lbCh0aGlzLCBXZWJHTEZ1bmN0aW9uTm9kZSwge1xuICAgICAgZml4SW50ZWdlckRpdmlzaW9uQWNjdXJhY3k6IHRoaXMuZml4SW50ZWdlckRpdmlzaW9uQWNjdXJhY3lcbiAgICB9KTtcbiAgICB0aGlzLnRyYW5zbGF0ZWRTb3VyY2UgPSBmdW5jdGlvbkJ1aWxkZXIuZ2V0UHJvdG90eXBlU3RyaW5nKCdrZXJuZWwnKTtcbiAgICB0aGlzLnNldHVwUmV0dXJuVHlwZXMoZnVuY3Rpb25CdWlsZGVyKTtcbiAgfVxuXG4gIHNldHVwUmV0dXJuVHlwZXMoZnVuY3Rpb25CdWlsZGVyKSB7XG4gICAgaWYgKCF0aGlzLmdyYXBoaWNhbCAmJiAhdGhpcy5yZXR1cm5UeXBlKSB7XG4gICAgICB0aGlzLnJldHVyblR5cGUgPSBmdW5jdGlvbkJ1aWxkZXIuZ2V0S2VybmVsUmVzdWx0VHlwZSgpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnN1Yktlcm5lbHMgJiYgdGhpcy5zdWJLZXJuZWxzLmxlbmd0aCA+IDApIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5zdWJLZXJuZWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHN1Yktlcm5lbCA9IHRoaXMuc3ViS2VybmVsc1tpXTtcbiAgICAgICAgaWYgKCFzdWJLZXJuZWwucmV0dXJuVHlwZSkge1xuICAgICAgICAgIHN1Yktlcm5lbC5yZXR1cm5UeXBlID0gZnVuY3Rpb25CdWlsZGVyLmdldFN1Yktlcm5lbFJlc3VsdFR5cGUoaSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBydW4oKSB7XG4gICAgY29uc3QgeyBrZXJuZWxBcmd1bWVudHMsIHRleFNpemUsIGZvcmNlVXBsb2FkS2VybmVsQ29uc3RhbnRzLCBjb250ZXh0OiBnbCB9ID0gdGhpcztcblxuICAgIGdsLnVzZVByb2dyYW0odGhpcy5wcm9ncmFtKTtcbiAgICBnbC5zY2lzc29yKDAsIDAsIHRleFNpemVbMF0sIHRleFNpemVbMV0pO1xuICAgIGlmICh0aGlzLmR5bmFtaWNPdXRwdXQpIHtcbiAgICAgIHRoaXMuc2V0VW5pZm9ybTNpdigndU91dHB1dERpbScsIG5ldyBJbnQzMkFycmF5KHRoaXMudGhyZWFkRGltKSk7XG4gICAgICB0aGlzLnNldFVuaWZvcm0yaXYoJ3VUZXhTaXplJywgdGV4U2l6ZSk7XG4gICAgfVxuXG4gICAgdGhpcy5zZXRVbmlmb3JtMmYoJ3JhdGlvJywgdGV4U2l6ZVswXSAvIHRoaXMubWF4VGV4U2l6ZVswXSwgdGV4U2l6ZVsxXSAvIHRoaXMubWF4VGV4U2l6ZVsxXSk7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZvcmNlVXBsb2FkS2VybmVsQ29uc3RhbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBjb25zdGFudCA9IGZvcmNlVXBsb2FkS2VybmVsQ29uc3RhbnRzW2ldO1xuICAgICAgY29uc3RhbnQudXBkYXRlVmFsdWUodGhpcy5jb25zdGFudHNbY29uc3RhbnQubmFtZV0pO1xuICAgICAgaWYgKHRoaXMuc3dpdGNoaW5nS2VybmVscykgcmV0dXJuO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGtlcm5lbEFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAga2VybmVsQXJndW1lbnRzW2ldLnVwZGF0ZVZhbHVlKGFyZ3VtZW50c1tpXSk7XG4gICAgICBpZiAodGhpcy5zd2l0Y2hpbmdLZXJuZWxzKSByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHRoaXMucGx1Z2lucykge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnBsdWdpbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgcGx1Z2luID0gdGhpcy5wbHVnaW5zW2ldO1xuICAgICAgICBpZiAocGx1Z2luLm9uQmVmb3JlUnVuKSB7XG4gICAgICAgICAgcGx1Z2luLm9uQmVmb3JlUnVuKHRoaXMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuZ3JhcGhpY2FsKSB7XG4gICAgICBpZiAodGhpcy5waXBlbGluZSkge1xuICAgICAgICBnbC5iaW5kUmVuZGVyYnVmZmVyKGdsLlJFTkRFUkJVRkZFUiwgbnVsbCk7XG4gICAgICAgIGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgdGhpcy5mcmFtZWJ1ZmZlcik7XG4gICAgICAgIGlmICh0aGlzLmltbXV0YWJsZSkge1xuICAgICAgICAgIHRoaXMuX3JlcGxhY2VPdXRwdXRUZXh0dXJlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZ2wuZHJhd0FycmF5cyhnbC5UUklBTkdMRV9TVFJJUCwgMCwgNCk7XG4gICAgICAgIHJldHVybiB0aGlzLmltbXV0YWJsZSA/IHRoaXMudGV4dHVyZS5jbG9uZSgpIDogdGhpcy50ZXh0dXJlO1xuICAgICAgfVxuICAgICAgZ2wuYmluZFJlbmRlcmJ1ZmZlcihnbC5SRU5ERVJCVUZGRVIsIG51bGwpO1xuICAgICAgZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCBudWxsKTtcbiAgICAgIGdsLmRyYXdBcnJheXMoZ2wuVFJJQU5HTEVfU1RSSVAsIDAsIDQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgdGhpcy5mcmFtZWJ1ZmZlcik7XG4gICAgaWYgKHRoaXMuaW1tdXRhYmxlKSB7XG4gICAgICB0aGlzLl9yZXBsYWNlT3V0cHV0VGV4dHVyZSgpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnN1Yktlcm5lbHMgIT09IG51bGwpIHtcbiAgICAgIGlmICh0aGlzLmltbXV0YWJsZSkge1xuICAgICAgICB0aGlzLl9yZXBsYWNlU3ViT3V0cHV0VGV4dHVyZXMoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZHJhd0J1ZmZlcnMoKTtcbiAgICB9XG5cbiAgICBnbC5kcmF3QXJyYXlzKGdsLlRSSUFOR0xFX1NUUklQLCAwLCA0KTtcbiAgfVxuXG4gIGRyYXdCdWZmZXJzKCkge1xuICAgIHRoaXMuZXh0ZW5zaW9ucy5XRUJHTF9kcmF3X2J1ZmZlcnMuZHJhd0J1ZmZlcnNXRUJHTCh0aGlzLmRyYXdCdWZmZXJzTWFwKTtcbiAgfVxuXG4gIGdldEludGVybmFsRm9ybWF0KCkge1xuICAgIHJldHVybiB0aGlzLmNvbnRleHQuUkdCQTtcbiAgfVxuICBnZXRUZXh0dXJlRm9ybWF0KCkge1xuICAgIGNvbnN0IHsgY29udGV4dDogZ2wgfSA9IHRoaXM7XG4gICAgc3dpdGNoICh0aGlzLmdldEludGVybmFsRm9ybWF0KCkpIHtcbiAgICAgIGNhc2UgZ2wuUkdCQTpcbiAgICAgICAgcmV0dXJuIGdsLlJHQkE7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gaW50ZXJuYWwgZm9ybWF0Jyk7XG4gICAgfVxuICB9XG5cbiAgX3JlcGxhY2VPdXRwdXRUZXh0dXJlKCkge1xuICAgIGlmICh0aGlzLnRleHR1cmUuYmVmb3JlTXV0YXRlKCkgfHwgdGhpcy5fdGV4dHVyZVN3aXRjaGVkKSB7XG4gICAgICBjb25zdCBnbCA9IHRoaXMuY29udGV4dDtcbiAgICAgIGdsLmZyYW1lYnVmZmVyVGV4dHVyZTJEKGdsLkZSQU1FQlVGRkVSLCBnbC5DT0xPUl9BVFRBQ0hNRU5UMCwgZ2wuVEVYVFVSRV8yRCwgdGhpcy50ZXh0dXJlLnRleHR1cmUsIDApO1xuICAgICAgdGhpcy5fdGV4dHVyZVN3aXRjaGVkID0gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgX3NldHVwT3V0cHV0VGV4dHVyZSgpIHtcbiAgICBjb25zdCBnbCA9IHRoaXMuY29udGV4dDtcbiAgICBjb25zdCB0ZXhTaXplID0gdGhpcy50ZXhTaXplO1xuICAgIGlmICh0aGlzLnRleHR1cmUpIHtcbiAgICAgIGdsLmZyYW1lYnVmZmVyVGV4dHVyZTJEKGdsLkZSQU1FQlVGRkVSLCBnbC5DT0xPUl9BVFRBQ0hNRU5UMCwgZ2wuVEVYVFVSRV8yRCwgdGhpcy50ZXh0dXJlLnRleHR1cmUsIDApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB0ZXh0dXJlID0gdGhpcy5jcmVhdGVUZXh0dXJlKCk7XG4gICAgZ2wuYWN0aXZlVGV4dHVyZShnbC5URVhUVVJFMCArIHRoaXMuY29uc3RhbnRUZXh0dXJlQ291bnQgKyB0aGlzLmFyZ3VtZW50VGV4dHVyZUNvdW50KTtcbiAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0ZXh0dXJlKTtcbiAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9TLCBnbC5DTEFNUF9UT19FREdFKTtcbiAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9ULCBnbC5DTEFNUF9UT19FREdFKTtcbiAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgZ2wuTkVBUkVTVCk7XG4gICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01BR19GSUxURVIsIGdsLk5FQVJFU1QpO1xuICAgIGNvbnN0IGZvcm1hdCA9IHRoaXMuZ2V0SW50ZXJuYWxGb3JtYXQoKTtcbiAgICBpZiAodGhpcy5wcmVjaXNpb24gPT09ICdzaW5nbGUnKSB7XG4gICAgICBnbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIGZvcm1hdCwgdGV4U2l6ZVswXSwgdGV4U2l6ZVsxXSwgMCwgZ2wuUkdCQSwgZ2wuRkxPQVQsIG51bGwpO1xuICAgIH0gZWxzZSB7XG4gICAgICBnbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIGZvcm1hdCwgdGV4U2l6ZVswXSwgdGV4U2l6ZVsxXSwgMCwgZm9ybWF0LCBnbC5VTlNJR05FRF9CWVRFLCBudWxsKTtcbiAgICB9XG4gICAgZ2wuZnJhbWVidWZmZXJUZXh0dXJlMkQoZ2wuRlJBTUVCVUZGRVIsIGdsLkNPTE9SX0FUVEFDSE1FTlQwLCBnbC5URVhUVVJFXzJELCB0ZXh0dXJlLCAwKTtcbiAgICB0aGlzLnRleHR1cmUgPSBuZXcgdGhpcy5UZXh0dXJlQ29uc3RydWN0b3Ioe1xuICAgICAgdGV4dHVyZSxcbiAgICAgIHNpemU6IHRleFNpemUsXG4gICAgICBkaW1lbnNpb25zOiB0aGlzLnRocmVhZERpbSxcbiAgICAgIG91dHB1dDogdGhpcy5vdXRwdXQsXG4gICAgICBjb250ZXh0OiB0aGlzLmNvbnRleHQsXG4gICAgICBpbnRlcm5hbEZvcm1hdDogdGhpcy5nZXRJbnRlcm5hbEZvcm1hdCgpLFxuICAgICAgdGV4dHVyZUZvcm1hdDogdGhpcy5nZXRUZXh0dXJlRm9ybWF0KCksXG4gICAgICBrZXJuZWw6IHRoaXMsXG4gICAgfSk7XG4gIH1cblxuICBfcmVwbGFjZVN1Yk91dHB1dFRleHR1cmVzKCkge1xuICAgIGNvbnN0IGdsID0gdGhpcy5jb250ZXh0O1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5tYXBwZWRUZXh0dXJlcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgbWFwcGVkVGV4dHVyZSA9IHRoaXMubWFwcGVkVGV4dHVyZXNbaV07XG4gICAgICBpZiAobWFwcGVkVGV4dHVyZS5iZWZvcmVNdXRhdGUoKSB8fCB0aGlzLl9tYXBwZWRUZXh0dXJlU3dpdGNoZWRbaV0pIHtcbiAgICAgICAgZ2wuZnJhbWVidWZmZXJUZXh0dXJlMkQoZ2wuRlJBTUVCVUZGRVIsIGdsLkNPTE9SX0FUVEFDSE1FTlQwICsgaSArIDEsIGdsLlRFWFRVUkVfMkQsIG1hcHBlZFRleHR1cmUudGV4dHVyZSwgMCk7XG4gICAgICAgIHRoaXMuX21hcHBlZFRleHR1cmVTd2l0Y2hlZFtpXSA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIF9zZXR1cFN1Yk91dHB1dFRleHR1cmVzKCkge1xuICAgIGNvbnN0IGdsID0gdGhpcy5jb250ZXh0O1xuICAgIGlmICh0aGlzLm1hcHBlZFRleHR1cmVzKSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuc3ViS2VybmVscy5sZW5ndGg7IGkrKykge1xuICAgICAgICBnbC5mcmFtZWJ1ZmZlclRleHR1cmUyRChnbC5GUkFNRUJVRkZFUiwgZ2wuQ09MT1JfQVRUQUNITUVOVDAgKyBpICsgMSwgZ2wuVEVYVFVSRV8yRCwgdGhpcy5tYXBwZWRUZXh0dXJlc1tpXS50ZXh0dXJlLCAwKTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgdGV4U2l6ZSA9IHRoaXMudGV4U2l6ZTtcbiAgICB0aGlzLmRyYXdCdWZmZXJzTWFwID0gW2dsLkNPTE9SX0FUVEFDSE1FTlQwXTtcbiAgICB0aGlzLm1hcHBlZFRleHR1cmVzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnN1Yktlcm5lbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHRleHR1cmUgPSB0aGlzLmNyZWF0ZVRleHR1cmUoKTtcbiAgICAgIHRoaXMuZHJhd0J1ZmZlcnNNYXAucHVzaChnbC5DT0xPUl9BVFRBQ0hNRU5UMCArIGkgKyAxKTtcbiAgICAgIGdsLmFjdGl2ZVRleHR1cmUoZ2wuVEVYVFVSRTAgKyB0aGlzLmNvbnN0YW50VGV4dHVyZUNvdW50ICsgdGhpcy5hcmd1bWVudFRleHR1cmVDb3VudCArIGkpO1xuICAgICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGV4dHVyZSk7XG4gICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9TLCBnbC5DTEFNUF9UT19FREdFKTtcbiAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1QsIGdsLkNMQU1QX1RPX0VER0UpO1xuICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01JTl9GSUxURVIsIGdsLk5FQVJFU1QpO1xuICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01BR19GSUxURVIsIGdsLk5FQVJFU1QpO1xuICAgICAgaWYgKHRoaXMucHJlY2lzaW9uID09PSAnc2luZ2xlJykge1xuICAgICAgICBnbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIGdsLlJHQkEsIHRleFNpemVbMF0sIHRleFNpemVbMV0sIDAsIGdsLlJHQkEsIGdsLkZMT0FULCBudWxsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgZ2wuUkdCQSwgdGV4U2l6ZVswXSwgdGV4U2l6ZVsxXSwgMCwgZ2wuUkdCQSwgZ2wuVU5TSUdORURfQllURSwgbnVsbCk7XG4gICAgICB9XG4gICAgICBnbC5mcmFtZWJ1ZmZlclRleHR1cmUyRChnbC5GUkFNRUJVRkZFUiwgZ2wuQ09MT1JfQVRUQUNITUVOVDAgKyBpICsgMSwgZ2wuVEVYVFVSRV8yRCwgdGV4dHVyZSwgMCk7XG5cbiAgICAgIHRoaXMubWFwcGVkVGV4dHVyZXMucHVzaChuZXcgdGhpcy5UZXh0dXJlQ29uc3RydWN0b3Ioe1xuICAgICAgICB0ZXh0dXJlLFxuICAgICAgICBzaXplOiB0ZXhTaXplLFxuICAgICAgICBkaW1lbnNpb25zOiB0aGlzLnRocmVhZERpbSxcbiAgICAgICAgb3V0cHV0OiB0aGlzLm91dHB1dCxcbiAgICAgICAgY29udGV4dDogdGhpcy5jb250ZXh0LFxuICAgICAgICBpbnRlcm5hbEZvcm1hdDogdGhpcy5nZXRJbnRlcm5hbEZvcm1hdCgpLFxuICAgICAgICB0ZXh0dXJlRm9ybWF0OiB0aGlzLmdldFRleHR1cmVGb3JtYXQoKSxcbiAgICAgICAga2VybmVsOiB0aGlzLFxuICAgICAgfSkpO1xuICAgIH1cbiAgfVxuXG4gIHNldFVuaWZvcm0xZihuYW1lLCB2YWx1ZSkge1xuICAgIGlmICh0aGlzLnVuaWZvcm0xZkNhY2hlLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICBjb25zdCBjYWNoZSA9IHRoaXMudW5pZm9ybTFmQ2FjaGVbbmFtZV07XG4gICAgICBpZiAodmFsdWUgPT09IGNhY2hlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy51bmlmb3JtMWZDYWNoZVtuYW1lXSA9IHZhbHVlO1xuICAgIGNvbnN0IGxvYyA9IHRoaXMuZ2V0VW5pZm9ybUxvY2F0aW9uKG5hbWUpO1xuICAgIHRoaXMuY29udGV4dC51bmlmb3JtMWYobG9jLCB2YWx1ZSk7XG4gIH1cblxuICBzZXRVbmlmb3JtMWkobmFtZSwgdmFsdWUpIHtcbiAgICBpZiAodGhpcy51bmlmb3JtMWlDYWNoZS5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgY29uc3QgY2FjaGUgPSB0aGlzLnVuaWZvcm0xaUNhY2hlW25hbWVdO1xuICAgICAgaWYgKHZhbHVlID09PSBjYWNoZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMudW5pZm9ybTFpQ2FjaGVbbmFtZV0gPSB2YWx1ZTtcbiAgICBjb25zdCBsb2MgPSB0aGlzLmdldFVuaWZvcm1Mb2NhdGlvbihuYW1lKTtcbiAgICB0aGlzLmNvbnRleHQudW5pZm9ybTFpKGxvYywgdmFsdWUpO1xuICB9XG5cbiAgc2V0VW5pZm9ybTJmKG5hbWUsIHZhbHVlMSwgdmFsdWUyKSB7XG4gICAgaWYgKHRoaXMudW5pZm9ybTJmQ2FjaGUuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgIGNvbnN0IGNhY2hlID0gdGhpcy51bmlmb3JtMmZDYWNoZVtuYW1lXTtcbiAgICAgIGlmIChcbiAgICAgICAgdmFsdWUxID09PSBjYWNoZVswXSAmJlxuICAgICAgICB2YWx1ZTIgPT09IGNhY2hlWzFdXG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLnVuaWZvcm0yZkNhY2hlW25hbWVdID0gW3ZhbHVlMSwgdmFsdWUyXTtcbiAgICBjb25zdCBsb2MgPSB0aGlzLmdldFVuaWZvcm1Mb2NhdGlvbihuYW1lKTtcbiAgICB0aGlzLmNvbnRleHQudW5pZm9ybTJmKGxvYywgdmFsdWUxLCB2YWx1ZTIpO1xuICB9XG5cbiAgc2V0VW5pZm9ybTJmdihuYW1lLCB2YWx1ZSkge1xuICAgIGlmICh0aGlzLnVuaWZvcm0yZnZDYWNoZS5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgY29uc3QgY2FjaGUgPSB0aGlzLnVuaWZvcm0yZnZDYWNoZVtuYW1lXTtcbiAgICAgIGlmIChcbiAgICAgICAgdmFsdWVbMF0gPT09IGNhY2hlWzBdICYmXG4gICAgICAgIHZhbHVlWzFdID09PSBjYWNoZVsxXVxuICAgICAgKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy51bmlmb3JtMmZ2Q2FjaGVbbmFtZV0gPSB2YWx1ZTtcbiAgICBjb25zdCBsb2MgPSB0aGlzLmdldFVuaWZvcm1Mb2NhdGlvbihuYW1lKTtcbiAgICB0aGlzLmNvbnRleHQudW5pZm9ybTJmdihsb2MsIHZhbHVlKTtcbiAgfVxuXG4gIHNldFVuaWZvcm0yaXYobmFtZSwgdmFsdWUpIHtcbiAgICBpZiAodGhpcy51bmlmb3JtMml2Q2FjaGUuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgIGNvbnN0IGNhY2hlID0gdGhpcy51bmlmb3JtMml2Q2FjaGVbbmFtZV07XG4gICAgICBpZiAoXG4gICAgICAgIHZhbHVlWzBdID09PSBjYWNoZVswXSAmJlxuICAgICAgICB2YWx1ZVsxXSA9PT0gY2FjaGVbMV1cbiAgICAgICkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMudW5pZm9ybTJpdkNhY2hlW25hbWVdID0gdmFsdWU7XG4gICAgY29uc3QgbG9jID0gdGhpcy5nZXRVbmlmb3JtTG9jYXRpb24obmFtZSk7XG4gICAgdGhpcy5jb250ZXh0LnVuaWZvcm0yaXYobG9jLCB2YWx1ZSk7XG4gIH1cblxuICBzZXRVbmlmb3JtM2Z2KG5hbWUsIHZhbHVlKSB7XG4gICAgaWYgKHRoaXMudW5pZm9ybTNmdkNhY2hlLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICBjb25zdCBjYWNoZSA9IHRoaXMudW5pZm9ybTNmdkNhY2hlW25hbWVdO1xuICAgICAgaWYgKFxuICAgICAgICB2YWx1ZVswXSA9PT0gY2FjaGVbMF0gJiZcbiAgICAgICAgdmFsdWVbMV0gPT09IGNhY2hlWzFdICYmXG4gICAgICAgIHZhbHVlWzJdID09PSBjYWNoZVsyXVxuICAgICAgKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy51bmlmb3JtM2Z2Q2FjaGVbbmFtZV0gPSB2YWx1ZTtcbiAgICBjb25zdCBsb2MgPSB0aGlzLmdldFVuaWZvcm1Mb2NhdGlvbihuYW1lKTtcbiAgICB0aGlzLmNvbnRleHQudW5pZm9ybTNmdihsb2MsIHZhbHVlKTtcbiAgfVxuXG4gIHNldFVuaWZvcm0zaXYobmFtZSwgdmFsdWUpIHtcbiAgICBpZiAodGhpcy51bmlmb3JtM2l2Q2FjaGUuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgIGNvbnN0IGNhY2hlID0gdGhpcy51bmlmb3JtM2l2Q2FjaGVbbmFtZV07XG4gICAgICBpZiAoXG4gICAgICAgIHZhbHVlWzBdID09PSBjYWNoZVswXSAmJlxuICAgICAgICB2YWx1ZVsxXSA9PT0gY2FjaGVbMV0gJiZcbiAgICAgICAgdmFsdWVbMl0gPT09IGNhY2hlWzJdXG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLnVuaWZvcm0zaXZDYWNoZVtuYW1lXSA9IHZhbHVlO1xuICAgIGNvbnN0IGxvYyA9IHRoaXMuZ2V0VW5pZm9ybUxvY2F0aW9uKG5hbWUpO1xuICAgIHRoaXMuY29udGV4dC51bmlmb3JtM2l2KGxvYywgdmFsdWUpO1xuICB9XG5cbiAgc2V0VW5pZm9ybTRmdihuYW1lLCB2YWx1ZSkge1xuICAgIGlmICh0aGlzLnVuaWZvcm00ZnZDYWNoZS5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgY29uc3QgY2FjaGUgPSB0aGlzLnVuaWZvcm00ZnZDYWNoZVtuYW1lXTtcbiAgICAgIGlmIChcbiAgICAgICAgdmFsdWVbMF0gPT09IGNhY2hlWzBdICYmXG4gICAgICAgIHZhbHVlWzFdID09PSBjYWNoZVsxXSAmJlxuICAgICAgICB2YWx1ZVsyXSA9PT0gY2FjaGVbMl0gJiZcbiAgICAgICAgdmFsdWVbM10gPT09IGNhY2hlWzNdXG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLnVuaWZvcm00ZnZDYWNoZVtuYW1lXSA9IHZhbHVlO1xuICAgIGNvbnN0IGxvYyA9IHRoaXMuZ2V0VW5pZm9ybUxvY2F0aW9uKG5hbWUpO1xuICAgIHRoaXMuY29udGV4dC51bmlmb3JtNGZ2KGxvYywgdmFsdWUpO1xuICB9XG5cbiAgc2V0VW5pZm9ybTRpdihuYW1lLCB2YWx1ZSkge1xuICAgIGlmICh0aGlzLnVuaWZvcm00aXZDYWNoZS5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgY29uc3QgY2FjaGUgPSB0aGlzLnVuaWZvcm00aXZDYWNoZVtuYW1lXTtcbiAgICAgIGlmIChcbiAgICAgICAgdmFsdWVbMF0gPT09IGNhY2hlWzBdICYmXG4gICAgICAgIHZhbHVlWzFdID09PSBjYWNoZVsxXSAmJlxuICAgICAgICB2YWx1ZVsyXSA9PT0gY2FjaGVbMl0gJiZcbiAgICAgICAgdmFsdWVbM10gPT09IGNhY2hlWzNdXG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLnVuaWZvcm00aXZDYWNoZVtuYW1lXSA9IHZhbHVlO1xuICAgIGNvbnN0IGxvYyA9IHRoaXMuZ2V0VW5pZm9ybUxvY2F0aW9uKG5hbWUpO1xuICAgIHRoaXMuY29udGV4dC51bmlmb3JtNGl2KGxvYywgdmFsdWUpO1xuICB9XG5cbiAgZ2V0VW5pZm9ybUxvY2F0aW9uKG5hbWUpIHtcbiAgICBpZiAodGhpcy5wcm9ncmFtVW5pZm9ybUxvY2F0aW9uQ2FjaGUuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgIHJldHVybiB0aGlzLnByb2dyYW1Vbmlmb3JtTG9jYXRpb25DYWNoZVtuYW1lXTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMucHJvZ3JhbVVuaWZvcm1Mb2NhdGlvbkNhY2hlW25hbWVdID0gdGhpcy5jb250ZXh0LmdldFVuaWZvcm1Mb2NhdGlvbih0aGlzLnByb2dyYW0sIG5hbWUpO1xuICB9XG5cbiAgX2dldEZyYWdTaGFkZXJBcnRpZmFjdE1hcChhcmdzKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIEhFQURFUjogdGhpcy5fZ2V0SGVhZGVyU3RyaW5nKCksXG4gICAgICBMT09QX01BWDogdGhpcy5fZ2V0TG9vcE1heFN0cmluZygpLFxuICAgICAgUExVR0lOUzogdGhpcy5fZ2V0UGx1Z2luc1N0cmluZygpLFxuICAgICAgQ09OU1RBTlRTOiB0aGlzLl9nZXRDb25zdGFudHNTdHJpbmcoKSxcbiAgICAgIERFQ09ERTMyX0VORElBTk5FU1M6IHRoaXMuX2dldERlY29kZTMyRW5kaWFubmVzc1N0cmluZygpLFxuICAgICAgRU5DT0RFMzJfRU5ESUFOTkVTUzogdGhpcy5fZ2V0RW5jb2RlMzJFbmRpYW5uZXNzU3RyaW5nKCksXG4gICAgICBESVZJREVfV0lUSF9JTlRFR0VSX0NIRUNLOiB0aGlzLl9nZXREaXZpZGVXaXRoSW50ZWdlckNoZWNrU3RyaW5nKCksXG4gICAgICBJTkpFQ1RFRF9OQVRJVkU6IHRoaXMuX2dldEluamVjdGVkTmF0aXZlKCksXG4gICAgICBNQUlOX0NPTlNUQU5UUzogdGhpcy5fZ2V0TWFpbkNvbnN0YW50c1N0cmluZygpLFxuICAgICAgTUFJTl9BUkdVTUVOVFM6IHRoaXMuX2dldE1haW5Bcmd1bWVudHNTdHJpbmcoYXJncyksXG4gICAgICBLRVJORUw6IHRoaXMuZ2V0S2VybmVsU3RyaW5nKCksXG4gICAgICBNQUlOX1JFU1VMVDogdGhpcy5nZXRNYWluUmVzdWx0U3RyaW5nKCksXG4gICAgICBGTE9BVF9UQUNUSUNfREVDTEFSQVRJT046IHRoaXMuZ2V0RmxvYXRUYWN0aWNEZWNsYXJhdGlvbigpLFxuICAgICAgSU5UX1RBQ1RJQ19ERUNMQVJBVElPTjogdGhpcy5nZXRJbnRUYWN0aWNEZWNsYXJhdGlvbigpLFxuICAgICAgU0FNUExFUl8yRF9UQUNUSUNfREVDTEFSQVRJT046IHRoaXMuZ2V0U2FtcGxlcjJEVGFjdGljRGVjbGFyYXRpb24oKSxcbiAgICAgIFNBTVBMRVJfMkRfQVJSQVlfVEFDVElDX0RFQ0xBUkFUSU9OOiB0aGlzLmdldFNhbXBsZXIyREFycmF5VGFjdGljRGVjbGFyYXRpb24oKSxcbiAgICB9O1xuICB9XG5cbiAgX2dldFZlcnRTaGFkZXJBcnRpZmFjdE1hcChhcmdzKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIEZMT0FUX1RBQ1RJQ19ERUNMQVJBVElPTjogdGhpcy5nZXRGbG9hdFRhY3RpY0RlY2xhcmF0aW9uKCksXG4gICAgICBJTlRfVEFDVElDX0RFQ0xBUkFUSU9OOiB0aGlzLmdldEludFRhY3RpY0RlY2xhcmF0aW9uKCksXG4gICAgICBTQU1QTEVSXzJEX1RBQ1RJQ19ERUNMQVJBVElPTjogdGhpcy5nZXRTYW1wbGVyMkRUYWN0aWNEZWNsYXJhdGlvbigpLFxuICAgICAgU0FNUExFUl8yRF9BUlJBWV9UQUNUSUNfREVDTEFSQVRJT046IHRoaXMuZ2V0U2FtcGxlcjJEQXJyYXlUYWN0aWNEZWNsYXJhdGlvbigpLFxuICAgIH07XG4gIH1cblxuICBfZ2V0SGVhZGVyU3RyaW5nKCkge1xuICAgIHJldHVybiAoXG4gICAgICB0aGlzLnN1Yktlcm5lbHMgIT09IG51bGwgP1xuICAgICAgJyNleHRlbnNpb24gR0xfRVhUX2RyYXdfYnVmZmVycyA6IHJlcXVpcmVcXG4nIDpcbiAgICAgICcnXG4gICAgKTtcbiAgfVxuXG4gIF9nZXRMb29wTWF4U3RyaW5nKCkge1xuICAgIHJldHVybiAoXG4gICAgICB0aGlzLmxvb3BNYXhJdGVyYXRpb25zID9cbiAgICAgIGAgJHtwYXJzZUludCh0aGlzLmxvb3BNYXhJdGVyYXRpb25zKX07XFxuYCA6XG4gICAgICAnIDEwMDA7XFxuJ1xuICAgICk7XG4gIH1cblxuICBfZ2V0UGx1Z2luc1N0cmluZygpIHtcbiAgICBpZiAoIXRoaXMucGx1Z2lucykgcmV0dXJuICdcXG4nO1xuICAgIHJldHVybiB0aGlzLnBsdWdpbnMubWFwKHBsdWdpbiA9PiBwbHVnaW4uc291cmNlICYmIHRoaXMuc291cmNlLm1hdGNoKHBsdWdpbi5mdW5jdGlvbk1hdGNoKSA/IHBsdWdpbi5zb3VyY2UgOiAnJykuam9pbignXFxuJyk7XG4gIH1cblxuICBfZ2V0Q29uc3RhbnRzU3RyaW5nKCkge1xuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIGNvbnN0IHsgdGhyZWFkRGltLCB0ZXhTaXplIH0gPSB0aGlzO1xuICAgIGlmICh0aGlzLmR5bmFtaWNPdXRwdXQpIHtcbiAgICAgIHJlc3VsdC5wdXNoKFxuICAgICAgICAndW5pZm9ybSBpdmVjMyB1T3V0cHV0RGltJyxcbiAgICAgICAgJ3VuaWZvcm0gaXZlYzIgdVRleFNpemUnXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQucHVzaChcbiAgICAgICAgYGl2ZWMzIHVPdXRwdXREaW0gPSBpdmVjMygke3RocmVhZERpbVswXX0sICR7dGhyZWFkRGltWzFdfSwgJHt0aHJlYWREaW1bMl19KWAsXG4gICAgICAgIGBpdmVjMiB1VGV4U2l6ZSA9IGl2ZWMyKCR7dGV4U2l6ZVswXX0sICR7dGV4U2l6ZVsxXX0pYFxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHV0aWxzLmxpbmVzVG9TdHJpbmcocmVzdWx0KTtcbiAgfVxuXG4gIF9nZXRUZXh0dXJlQ29vcmRpbmF0ZSgpIHtcbiAgICBjb25zdCBzdWJLZXJuZWxzID0gdGhpcy5zdWJLZXJuZWxzO1xuICAgIGlmIChzdWJLZXJuZWxzID09PSBudWxsIHx8IHN1Yktlcm5lbHMubGVuZ3RoIDwgMSkge1xuICAgICAgcmV0dXJuICd2YXJ5aW5nIHZlYzIgdlRleENvb3JkO1xcbic7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAnb3V0IHZlYzIgdlRleENvb3JkO1xcbic7XG4gICAgfVxuICB9XG5cbiAgX2dldERlY29kZTMyRW5kaWFubmVzc1N0cmluZygpIHtcbiAgICByZXR1cm4gKFxuICAgICAgdGhpcy5lbmRpYW5uZXNzID09PSAnTEUnID9cbiAgICAgICcnIDpcbiAgICAgICcgIHRleGVsLnJnYmEgPSB0ZXhlbC5hYmdyO1xcbidcbiAgICApO1xuICB9XG5cbiAgX2dldEVuY29kZTMyRW5kaWFubmVzc1N0cmluZygpIHtcbiAgICByZXR1cm4gKFxuICAgICAgdGhpcy5lbmRpYW5uZXNzID09PSAnTEUnID9cbiAgICAgICcnIDpcbiAgICAgICcgIHRleGVsLnJnYmEgPSB0ZXhlbC5hYmdyO1xcbidcbiAgICApO1xuICB9XG5cbiAgX2dldERpdmlkZVdpdGhJbnRlZ2VyQ2hlY2tTdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuZml4SW50ZWdlckRpdmlzaW9uQWNjdXJhY3kgP1xuICAgICAgYGZsb2F0IGRpdldpdGhJbnRDaGVjayhmbG9hdCB4LCBmbG9hdCB5KSB7XG4gIGlmIChmbG9vcih4KSA9PSB4ICYmIGZsb29yKHkpID09IHkgJiYgaW50ZWdlck1vZCh4LCB5KSA9PSAwLjApIHtcbiAgICByZXR1cm4gZmxvYXQoaW50KHgpIC8gaW50KHkpKTtcbiAgfVxuICByZXR1cm4geCAvIHk7XG59XG5cbmZsb2F0IGludGVnZXJDb3JyZWN0aW9uTW9kdWxvKGZsb2F0IG51bWJlciwgZmxvYXQgZGl2aXNvcikge1xuICBpZiAobnVtYmVyIDwgMC4wKSB7XG4gICAgbnVtYmVyID0gYWJzKG51bWJlcik7XG4gICAgaWYgKGRpdmlzb3IgPCAwLjApIHtcbiAgICAgIGRpdmlzb3IgPSBhYnMoZGl2aXNvcik7XG4gICAgfVxuICAgIHJldHVybiAtKG51bWJlciAtIChkaXZpc29yICogZmxvb3IoZGl2V2l0aEludENoZWNrKG51bWJlciwgZGl2aXNvcikpKSk7XG4gIH1cbiAgaWYgKGRpdmlzb3IgPCAwLjApIHtcbiAgICBkaXZpc29yID0gYWJzKGRpdmlzb3IpO1xuICB9XG4gIHJldHVybiBudW1iZXIgLSAoZGl2aXNvciAqIGZsb29yKGRpdldpdGhJbnRDaGVjayhudW1iZXIsIGRpdmlzb3IpKSk7XG59YCA6XG4gICAgICAnJztcbiAgfVxuXG4gIF9nZXRNYWluQXJndW1lbnRzU3RyaW5nKGFyZ3MpIHtcbiAgICBjb25zdCByZXN1bHRzID0gW107XG4gICAgY29uc3QgeyBhcmd1bWVudE5hbWVzIH0gPSB0aGlzO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJndW1lbnROYW1lcy5sZW5ndGg7IGkrKykge1xuICAgICAgcmVzdWx0cy5wdXNoKHRoaXMua2VybmVsQXJndW1lbnRzW2ldLmdldFNvdXJjZShhcmdzW2ldKSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHRzLmpvaW4oJycpO1xuICB9XG5cbiAgX2dldEluamVjdGVkTmF0aXZlKCkge1xuICAgIHJldHVybiB0aGlzLmluamVjdGVkTmF0aXZlIHx8ICcnO1xuICB9XG5cbiAgX2dldE1haW5Db25zdGFudHNTdHJpbmcoKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgY29uc3QgeyBjb25zdGFudHMgfSA9IHRoaXM7XG4gICAgaWYgKGNvbnN0YW50cykge1xuICAgICAgbGV0IGkgPSAwO1xuICAgICAgZm9yIChjb25zdCBuYW1lIGluIGNvbnN0YW50cykge1xuICAgICAgICBpZiAoIXRoaXMuY29uc3RhbnRzLmhhc093blByb3BlcnR5KG5hbWUpKSBjb250aW51ZTtcbiAgICAgICAgcmVzdWx0LnB1c2godGhpcy5rZXJuZWxDb25zdGFudHNbaSsrXS5nZXRTb3VyY2UodGhpcy5jb25zdGFudHNbbmFtZV0pKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdC5qb2luKCcnKTtcbiAgfVxuXG4gIGdldFJhd1ZhbHVlRnJhbWVidWZmZXIod2lkdGgsIGhlaWdodCkge1xuICAgIGlmICghdGhpcy5yYXdWYWx1ZUZyYW1lYnVmZmVyc1t3aWR0aF0pIHtcbiAgICAgIHRoaXMucmF3VmFsdWVGcmFtZWJ1ZmZlcnNbd2lkdGhdID0ge307XG4gICAgfVxuICAgIGlmICghdGhpcy5yYXdWYWx1ZUZyYW1lYnVmZmVyc1t3aWR0aF1baGVpZ2h0XSkge1xuICAgICAgY29uc3QgZnJhbWVidWZmZXIgPSB0aGlzLmNvbnRleHQuY3JlYXRlRnJhbWVidWZmZXIoKTtcbiAgICAgIGZyYW1lYnVmZmVyLndpZHRoID0gd2lkdGg7XG4gICAgICBmcmFtZWJ1ZmZlci5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICB0aGlzLnJhd1ZhbHVlRnJhbWVidWZmZXJzW3dpZHRoXVtoZWlnaHRdID0gZnJhbWVidWZmZXI7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnJhd1ZhbHVlRnJhbWVidWZmZXJzW3dpZHRoXVtoZWlnaHRdO1xuICB9XG5cbiAgZ2V0S2VybmVsUmVzdWx0RGVjbGFyYXRpb24oKSB7XG4gICAgc3dpdGNoICh0aGlzLnJldHVyblR5cGUpIHtcbiAgICAgIGNhc2UgJ0FycmF5KDIpJzpcbiAgICAgICAgcmV0dXJuICd2ZWMyIGtlcm5lbFJlc3VsdCc7XG4gICAgICBjYXNlICdBcnJheSgzKSc6XG4gICAgICAgIHJldHVybiAndmVjMyBrZXJuZWxSZXN1bHQnO1xuICAgICAgY2FzZSAnQXJyYXkoNCknOlxuICAgICAgICByZXR1cm4gJ3ZlYzQga2VybmVsUmVzdWx0JztcbiAgICAgIGNhc2UgJ0xpdGVyYWxJbnRlZ2VyJzpcbiAgICAgIGNhc2UgJ0Zsb2F0JzpcbiAgICAgIGNhc2UgJ051bWJlcic6XG4gICAgICBjYXNlICdJbnRlZ2VyJzpcbiAgICAgICAgcmV0dXJuICdmbG9hdCBrZXJuZWxSZXN1bHQnO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKHRoaXMuZ3JhcGhpY2FsKSB7XG4gICAgICAgICAgcmV0dXJuICdmbG9hdCBrZXJuZWxSZXN1bHQnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgdW5yZWNvZ25pemVkIG91dHB1dCB0eXBlIFwiJHsgdGhpcy5yZXR1cm5UeXBlIH1cImApO1xuICAgICAgICB9XG4gICAgfVxuICB9XG4gIGdldEtlcm5lbFN0cmluZygpIHtcbiAgICBjb25zdCByZXN1bHQgPSBbdGhpcy5nZXRLZXJuZWxSZXN1bHREZWNsYXJhdGlvbigpXTtcbiAgICBjb25zdCB7IHN1Yktlcm5lbHMgfSA9IHRoaXM7XG4gICAgaWYgKHN1Yktlcm5lbHMgIT09IG51bGwpIHtcbiAgICAgIHN3aXRjaCAodGhpcy5yZXR1cm5UeXBlKSB7XG4gICAgICAgIGNhc2UgJ051bWJlcic6XG4gICAgICAgIGNhc2UgJ0Zsb2F0JzpcbiAgICAgICAgY2FzZSAnSW50ZWdlcic6XG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdWJLZXJuZWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBzdWJLZXJuZWwgPSBzdWJLZXJuZWxzW2ldO1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goXG4gICAgICAgICAgICAgIHN1Yktlcm5lbC5yZXR1cm5UeXBlID09PSAnSW50ZWdlcicgP1xuICAgICAgICAgICAgICBgaW50IHN1Yktlcm5lbFJlc3VsdF8keyBzdWJLZXJuZWwubmFtZSB9ID0gMGAgOlxuICAgICAgICAgICAgICBgZmxvYXQgc3ViS2VybmVsUmVzdWx0XyR7IHN1Yktlcm5lbC5uYW1lIH0gPSAwLjBgXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnQXJyYXkoMiknOlxuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3ViS2VybmVscy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goXG4gICAgICAgICAgICAgIGB2ZWMyIHN1Yktlcm5lbFJlc3VsdF8keyBzdWJLZXJuZWxzW2ldLm5hbWUgfWBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdBcnJheSgzKSc6XG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdWJLZXJuZWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChcbiAgICAgICAgICAgICAgYHZlYzMgc3ViS2VybmVsUmVzdWx0XyR7IHN1Yktlcm5lbHNbaV0ubmFtZSB9YFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ0FycmF5KDQpJzpcbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN1Yktlcm5lbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKFxuICAgICAgICAgICAgICBgdmVjNCBzdWJLZXJuZWxSZXN1bHRfJHsgc3ViS2VybmVsc1tpXS5uYW1lIH1gXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdXRpbHMubGluZXNUb1N0cmluZyhyZXN1bHQpICsgdGhpcy50cmFuc2xhdGVkU291cmNlO1xuICB9XG5cbiAgZ2V0TWFpblJlc3VsdEdyYXBoaWNhbCgpIHtcbiAgICByZXR1cm4gdXRpbHMubGluZXNUb1N0cmluZyhbXG4gICAgICAnICB0aHJlYWRJZCA9IGluZGV4VG8zRChpbmRleCwgdU91dHB1dERpbSknLFxuICAgICAgJyAga2VybmVsKCknLFxuICAgICAgJyAgZ2xfRnJhZ0NvbG9yID0gYWN0dWFsQ29sb3InLFxuICAgIF0pO1xuICB9XG5cbiAgZ2V0TWFpblJlc3VsdFBhY2tlZFBpeGVscygpIHtcbiAgICBzd2l0Y2ggKHRoaXMucmV0dXJuVHlwZSkge1xuICAgICAgY2FzZSAnTGl0ZXJhbEludGVnZXInOlxuICAgICAgY2FzZSAnTnVtYmVyJzpcbiAgICAgIGNhc2UgJ0ludGVnZXInOlxuICAgICAgY2FzZSAnRmxvYXQnOlxuICAgICAgICByZXR1cm4gdGhpcy5nZXRNYWluUmVzdWx0S2VybmVsUGFja2VkUGl4ZWxzKCkgK1xuICAgICAgICAgIHRoaXMuZ2V0TWFpblJlc3VsdFN1Yktlcm5lbFBhY2tlZFBpeGVscygpO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBwYWNrZWQgb3V0cHV0IG9ubHkgdXNhYmxlIHdpdGggTnVtYmVycywgXCIke3RoaXMucmV0dXJuVHlwZX1cIiBzcGVjaWZpZWRgKTtcbiAgICB9XG4gIH1cblxuICBnZXRNYWluUmVzdWx0S2VybmVsUGFja2VkUGl4ZWxzKCkge1xuICAgIHJldHVybiB1dGlscy5saW5lc1RvU3RyaW5nKFtcbiAgICAgICcgIHRocmVhZElkID0gaW5kZXhUbzNEKGluZGV4LCB1T3V0cHV0RGltKScsXG4gICAgICAnICBrZXJuZWwoKScsXG4gICAgICBgICBnbF9GcmFnRGF0YVswXSA9ICR7dGhpcy51c2VMZWdhY3lFbmNvZGVyID8gJ2xlZ2FjeUVuY29kZTMyJyA6ICdlbmNvZGUzMid9KGtlcm5lbFJlc3VsdClgXG4gICAgXSk7XG4gIH1cblxuICBnZXRNYWluUmVzdWx0U3ViS2VybmVsUGFja2VkUGl4ZWxzKCkge1xuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIGlmICghdGhpcy5zdWJLZXJuZWxzKSByZXR1cm4gJyc7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnN1Yktlcm5lbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHN1Yktlcm5lbCA9IHRoaXMuc3ViS2VybmVsc1tpXTtcbiAgICAgIGlmIChzdWJLZXJuZWwucmV0dXJuVHlwZSA9PT0gJ0ludGVnZXInKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKFxuICAgICAgICAgIGAgIGdsX0ZyYWdEYXRhWyR7aSArIDF9XSA9ICR7dGhpcy51c2VMZWdhY3lFbmNvZGVyID8gJ2xlZ2FjeUVuY29kZTMyJyA6ICdlbmNvZGUzMid9KGZsb2F0KHN1Yktlcm5lbFJlc3VsdF8ke3RoaXMuc3ViS2VybmVsc1tpXS5uYW1lfSkpYFxuICAgICAgICApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0LnB1c2goXG4gICAgICAgICAgYCAgZ2xfRnJhZ0RhdGFbJHtpICsgMX1dID0gJHt0aGlzLnVzZUxlZ2FjeUVuY29kZXIgPyAnbGVnYWN5RW5jb2RlMzInIDogJ2VuY29kZTMyJ30oc3ViS2VybmVsUmVzdWx0XyR7dGhpcy5zdWJLZXJuZWxzW2ldLm5hbWV9KWBcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHV0aWxzLmxpbmVzVG9TdHJpbmcocmVzdWx0KTtcbiAgfVxuXG4gIGdldE1haW5SZXN1bHRNZW1vcnlPcHRpbWl6ZWRGbG9hdHMoKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gW1xuICAgICAgJyAgaW5kZXggKj0gNCcsXG4gICAgXTtcblxuICAgIHN3aXRjaCAodGhpcy5yZXR1cm5UeXBlKSB7XG4gICAgICBjYXNlICdOdW1iZXInOlxuICAgICAgY2FzZSAnSW50ZWdlcic6XG4gICAgICBjYXNlICdGbG9hdCc6XG4gICAgICAgIGNvbnN0IGNoYW5uZWxzID0gWydyJywgJ2cnLCAnYicsICdhJ107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hhbm5lbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBjb25zdCBjaGFubmVsID0gY2hhbm5lbHNbaV07XG4gICAgICAgICAgdGhpcy5nZXRNYWluUmVzdWx0S2VybmVsTWVtb3J5T3B0aW1pemVkRmxvYXRzKHJlc3VsdCwgY2hhbm5lbCk7XG4gICAgICAgICAgdGhpcy5nZXRNYWluUmVzdWx0U3ViS2VybmVsTWVtb3J5T3B0aW1pemVkRmxvYXRzKHJlc3VsdCwgY2hhbm5lbCk7XG4gICAgICAgICAgaWYgKGkgKyAxIDwgY2hhbm5lbHMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaCgnICBpbmRleCArPSAxJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBvcHRpbWl6ZWQgb3V0cHV0IG9ubHkgdXNhYmxlIHdpdGggTnVtYmVycywgJHt0aGlzLnJldHVyblR5cGV9IHNwZWNpZmllZGApO1xuICAgIH1cblxuICAgIHJldHVybiB1dGlscy5saW5lc1RvU3RyaW5nKHJlc3VsdCk7XG4gIH1cblxuICBnZXRNYWluUmVzdWx0S2VybmVsTWVtb3J5T3B0aW1pemVkRmxvYXRzKHJlc3VsdCwgY2hhbm5lbCkge1xuICAgIHJlc3VsdC5wdXNoKFxuICAgICAgJyAgdGhyZWFkSWQgPSBpbmRleFRvM0QoaW5kZXgsIHVPdXRwdXREaW0pJyxcbiAgICAgICcgIGtlcm5lbCgpJyxcbiAgICAgIGAgIGdsX0ZyYWdEYXRhWzBdLiR7Y2hhbm5lbH0gPSBrZXJuZWxSZXN1bHRgXG4gICAgKTtcbiAgfVxuXG4gIGdldE1haW5SZXN1bHRTdWJLZXJuZWxNZW1vcnlPcHRpbWl6ZWRGbG9hdHMocmVzdWx0LCBjaGFubmVsKSB7XG4gICAgaWYgKCF0aGlzLnN1Yktlcm5lbHMpIHJldHVybiByZXN1bHQ7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnN1Yktlcm5lbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHN1Yktlcm5lbCA9IHRoaXMuc3ViS2VybmVsc1tpXTtcbiAgICAgIGlmIChzdWJLZXJuZWwucmV0dXJuVHlwZSA9PT0gJ0ludGVnZXInKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKFxuICAgICAgICAgIGAgIGdsX0ZyYWdEYXRhWyR7aSArIDF9XS4ke2NoYW5uZWx9ID0gZmxvYXQoc3ViS2VybmVsUmVzdWx0XyR7dGhpcy5zdWJLZXJuZWxzW2ldLm5hbWV9KWBcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKFxuICAgICAgICAgIGAgIGdsX0ZyYWdEYXRhWyR7aSArIDF9XS4ke2NoYW5uZWx9ID0gc3ViS2VybmVsUmVzdWx0XyR7dGhpcy5zdWJLZXJuZWxzW2ldLm5hbWV9YFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGdldE1haW5SZXN1bHRLZXJuZWxOdW1iZXJUZXh0dXJlKCkge1xuICAgIHJldHVybiBbXG4gICAgICAnICB0aHJlYWRJZCA9IGluZGV4VG8zRChpbmRleCwgdU91dHB1dERpbSknLFxuICAgICAgJyAga2VybmVsKCknLFxuICAgICAgJyAgZ2xfRnJhZ0RhdGFbMF1bMF0gPSBrZXJuZWxSZXN1bHQnLFxuICAgIF07XG4gIH1cblxuICBnZXRNYWluUmVzdWx0U3ViS2VybmVsTnVtYmVyVGV4dHVyZSgpIHtcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICBpZiAoIXRoaXMuc3ViS2VybmVscykgcmV0dXJuIHJlc3VsdDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuc3ViS2VybmVscy5sZW5ndGg7ICsraSkge1xuICAgICAgY29uc3Qgc3ViS2VybmVsID0gdGhpcy5zdWJLZXJuZWxzW2ldO1xuICAgICAgaWYgKHN1Yktlcm5lbC5yZXR1cm5UeXBlID09PSAnSW50ZWdlcicpIHtcbiAgICAgICAgcmVzdWx0LnB1c2goXG4gICAgICAgICAgYCAgZ2xfRnJhZ0RhdGFbJHtpICsgMX1dWzBdID0gZmxvYXQoc3ViS2VybmVsUmVzdWx0XyR7c3ViS2VybmVsLm5hbWV9KWBcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKFxuICAgICAgICAgIGAgIGdsX0ZyYWdEYXRhWyR7aSArIDF9XVswXSA9IHN1Yktlcm5lbFJlc3VsdF8ke3N1Yktlcm5lbC5uYW1lfWBcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGdldE1haW5SZXN1bHRLZXJuZWxBcnJheTJUZXh0dXJlKCkge1xuICAgIHJldHVybiBbXG4gICAgICAnICB0aHJlYWRJZCA9IGluZGV4VG8zRChpbmRleCwgdU91dHB1dERpbSknLFxuICAgICAgJyAga2VybmVsKCknLFxuICAgICAgJyAgZ2xfRnJhZ0RhdGFbMF1bMF0gPSBrZXJuZWxSZXN1bHRbMF0nLFxuICAgICAgJyAgZ2xfRnJhZ0RhdGFbMF1bMV0gPSBrZXJuZWxSZXN1bHRbMV0nLFxuICAgIF07XG4gIH1cblxuICBnZXRNYWluUmVzdWx0U3ViS2VybmVsQXJyYXkyVGV4dHVyZSgpIHtcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICBpZiAoIXRoaXMuc3ViS2VybmVscykgcmV0dXJuIHJlc3VsdDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuc3ViS2VybmVscy5sZW5ndGg7ICsraSkge1xuICAgICAgcmVzdWx0LnB1c2goXG4gICAgICAgIGAgIGdsX0ZyYWdEYXRhWyR7aSArIDF9XVswXSA9IHN1Yktlcm5lbFJlc3VsdF8ke3RoaXMuc3ViS2VybmVsc1tpXS5uYW1lfVswXWAsXG4gICAgICAgIGAgIGdsX0ZyYWdEYXRhWyR7aSArIDF9XVsxXSA9IHN1Yktlcm5lbFJlc3VsdF8ke3RoaXMuc3ViS2VybmVsc1tpXS5uYW1lfVsxXWBcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBnZXRNYWluUmVzdWx0S2VybmVsQXJyYXkzVGV4dHVyZSgpIHtcbiAgICByZXR1cm4gW1xuICAgICAgJyAgdGhyZWFkSWQgPSBpbmRleFRvM0QoaW5kZXgsIHVPdXRwdXREaW0pJyxcbiAgICAgICcgIGtlcm5lbCgpJyxcbiAgICAgICcgIGdsX0ZyYWdEYXRhWzBdWzBdID0ga2VybmVsUmVzdWx0WzBdJyxcbiAgICAgICcgIGdsX0ZyYWdEYXRhWzBdWzFdID0ga2VybmVsUmVzdWx0WzFdJyxcbiAgICAgICcgIGdsX0ZyYWdEYXRhWzBdWzJdID0ga2VybmVsUmVzdWx0WzJdJyxcbiAgICBdO1xuICB9XG5cbiAgZ2V0TWFpblJlc3VsdFN1Yktlcm5lbEFycmF5M1RleHR1cmUoKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgaWYgKCF0aGlzLnN1Yktlcm5lbHMpIHJldHVybiByZXN1bHQ7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnN1Yktlcm5lbHMubGVuZ3RoOyArK2kpIHtcbiAgICAgIHJlc3VsdC5wdXNoKFxuICAgICAgICBgICBnbF9GcmFnRGF0YVske2kgKyAxfV1bMF0gPSBzdWJLZXJuZWxSZXN1bHRfJHt0aGlzLnN1Yktlcm5lbHNbaV0ubmFtZX1bMF1gLFxuICAgICAgICBgICBnbF9GcmFnRGF0YVske2kgKyAxfV1bMV0gPSBzdWJLZXJuZWxSZXN1bHRfJHt0aGlzLnN1Yktlcm5lbHNbaV0ubmFtZX1bMV1gLFxuICAgICAgICBgICBnbF9GcmFnRGF0YVske2kgKyAxfV1bMl0gPSBzdWJLZXJuZWxSZXN1bHRfJHt0aGlzLnN1Yktlcm5lbHNbaV0ubmFtZX1bMl1gXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgZ2V0TWFpblJlc3VsdEtlcm5lbEFycmF5NFRleHR1cmUoKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgICcgIHRocmVhZElkID0gaW5kZXhUbzNEKGluZGV4LCB1T3V0cHV0RGltKScsXG4gICAgICAnICBrZXJuZWwoKScsXG4gICAgICAnICBnbF9GcmFnRGF0YVswXSA9IGtlcm5lbFJlc3VsdCcsXG4gICAgXTtcbiAgfVxuXG4gIGdldE1haW5SZXN1bHRTdWJLZXJuZWxBcnJheTRUZXh0dXJlKCkge1xuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIGlmICghdGhpcy5zdWJLZXJuZWxzKSByZXR1cm4gcmVzdWx0O1xuICAgIHN3aXRjaCAodGhpcy5yZXR1cm5UeXBlKSB7XG4gICAgICBjYXNlICdOdW1iZXInOlxuICAgICAgY2FzZSAnRmxvYXQnOlxuICAgICAgY2FzZSAnSW50ZWdlcic6XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5zdWJLZXJuZWxzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgY29uc3Qgc3ViS2VybmVsID0gdGhpcy5zdWJLZXJuZWxzW2ldO1xuICAgICAgICAgIGlmIChzdWJLZXJuZWwucmV0dXJuVHlwZSA9PT0gJ0ludGVnZXInKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChcbiAgICAgICAgICAgICAgYCAgZ2xfRnJhZ0RhdGFbJHtpICsgMX1dID0gZmxvYXQoc3ViS2VybmVsUmVzdWx0XyR7dGhpcy5zdWJLZXJuZWxzW2ldLm5hbWV9KWBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKFxuICAgICAgICAgICAgICBgICBnbF9GcmFnRGF0YVske2kgKyAxfV0gPSBzdWJLZXJuZWxSZXN1bHRfJHt0aGlzLnN1Yktlcm5lbHNbaV0ubmFtZX1gXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ0FycmF5KDIpJzpcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnN1Yktlcm5lbHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICByZXN1bHQucHVzaChcbiAgICAgICAgICAgIGAgIGdsX0ZyYWdEYXRhWyR7aSArIDF9XVswXSA9IHN1Yktlcm5lbFJlc3VsdF8ke3RoaXMuc3ViS2VybmVsc1tpXS5uYW1lfVswXWAsXG4gICAgICAgICAgICBgICBnbF9GcmFnRGF0YVske2kgKyAxfV1bMV0gPSBzdWJLZXJuZWxSZXN1bHRfJHt0aGlzLnN1Yktlcm5lbHNbaV0ubmFtZX1bMV1gXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ0FycmF5KDMpJzpcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnN1Yktlcm5lbHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICByZXN1bHQucHVzaChcbiAgICAgICAgICAgIGAgIGdsX0ZyYWdEYXRhWyR7aSArIDF9XVswXSA9IHN1Yktlcm5lbFJlc3VsdF8ke3RoaXMuc3ViS2VybmVsc1tpXS5uYW1lfVswXWAsXG4gICAgICAgICAgICBgICBnbF9GcmFnRGF0YVske2kgKyAxfV1bMV0gPSBzdWJLZXJuZWxSZXN1bHRfJHt0aGlzLnN1Yktlcm5lbHNbaV0ubmFtZX1bMV1gLFxuICAgICAgICAgICAgYCAgZ2xfRnJhZ0RhdGFbJHtpICsgMX1dWzJdID0gc3ViS2VybmVsUmVzdWx0XyR7dGhpcy5zdWJLZXJuZWxzW2ldLm5hbWV9WzJdYFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdBcnJheSg0KSc6XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5zdWJLZXJuZWxzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2goXG4gICAgICAgICAgICBgICBnbF9GcmFnRGF0YVske2kgKyAxfV1bMF0gPSBzdWJLZXJuZWxSZXN1bHRfJHt0aGlzLnN1Yktlcm5lbHNbaV0ubmFtZX1bMF1gLFxuICAgICAgICAgICAgYCAgZ2xfRnJhZ0RhdGFbJHtpICsgMX1dWzFdID0gc3ViS2VybmVsUmVzdWx0XyR7dGhpcy5zdWJLZXJuZWxzW2ldLm5hbWV9WzFdYCxcbiAgICAgICAgICAgIGAgIGdsX0ZyYWdEYXRhWyR7aSArIDF9XVsyXSA9IHN1Yktlcm5lbFJlc3VsdF8ke3RoaXMuc3ViS2VybmVsc1tpXS5uYW1lfVsyXWAsXG4gICAgICAgICAgICBgICBnbF9GcmFnRGF0YVske2kgKyAxfV1bM10gPSBzdWJLZXJuZWxSZXN1bHRfJHt0aGlzLnN1Yktlcm5lbHNbaV0ubmFtZX1bM11gXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgcmVwbGFjZUFydGlmYWN0cyhzcmMsIG1hcCkge1xuICAgIHJldHVybiBzcmMucmVwbGFjZSgvWyBdKl9fKFtBLVpdK1swLTldKihbX10/W0EtWl0qWzAtOV0/KSopX187XFxuL2csIChtYXRjaCwgYXJ0aWZhY3QpID0+IHtcbiAgICAgIGlmIChtYXAuaGFzT3duUHJvcGVydHkoYXJ0aWZhY3QpKSB7XG4gICAgICAgIHJldHVybiBtYXBbYXJ0aWZhY3RdO1xuICAgICAgfVxuICAgICAgdGhyb3cgYHVuaGFuZGxlZCBhcnRpZmFjdCAke2FydGlmYWN0fWA7XG4gICAgfSk7XG4gIH1cblxuICBnZXRGcmFnbWVudFNoYWRlcihhcmdzKSB7XG4gICAgaWYgKHRoaXMuY29tcGlsZWRGcmFnbWVudFNoYWRlciAhPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHRoaXMuY29tcGlsZWRGcmFnbWVudFNoYWRlcjtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY29tcGlsZWRGcmFnbWVudFNoYWRlciA9IHRoaXMucmVwbGFjZUFydGlmYWN0cyh0aGlzLmNvbnN0cnVjdG9yLmZyYWdtZW50U2hhZGVyLCB0aGlzLl9nZXRGcmFnU2hhZGVyQXJ0aWZhY3RNYXAoYXJncykpO1xuICB9XG5cbiAgZ2V0VmVydGV4U2hhZGVyKGFyZ3MpIHtcbiAgICBpZiAodGhpcy5jb21waWxlZFZlcnRleFNoYWRlciAhPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHRoaXMuY29tcGlsZWRWZXJ0ZXhTaGFkZXI7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmNvbXBpbGVkVmVydGV4U2hhZGVyID0gdGhpcy5yZXBsYWNlQXJ0aWZhY3RzKHRoaXMuY29uc3RydWN0b3IudmVydGV4U2hhZGVyLCB0aGlzLl9nZXRWZXJ0U2hhZGVyQXJ0aWZhY3RNYXAoYXJncykpO1xuICB9XG5cbiAgdG9TdHJpbmcoKSB7XG4gICAgY29uc3Qgc2V0dXBDb250ZXh0U3RyaW5nID0gdXRpbHMubGluZXNUb1N0cmluZyhbXG4gICAgICBgY29uc3QgZ2wgPSBjb250ZXh0YCxcbiAgICBdKTtcbiAgICByZXR1cm4gZ2xLZXJuZWxTdHJpbmcodGhpcy5jb25zdHJ1Y3RvciwgYXJndW1lbnRzLCB0aGlzLCBzZXR1cENvbnRleHRTdHJpbmcpO1xuICB9XG5cbiAgZGVzdHJveShyZW1vdmVDYW52YXNSZWZlcmVuY2VzKSB7XG4gICAgaWYgKCF0aGlzLmNvbnRleHQpIHJldHVybjtcbiAgICBpZiAodGhpcy5idWZmZXIpIHtcbiAgICAgIHRoaXMuY29udGV4dC5kZWxldGVCdWZmZXIodGhpcy5idWZmZXIpO1xuICAgIH1cbiAgICBpZiAodGhpcy5mcmFtZWJ1ZmZlcikge1xuICAgICAgdGhpcy5jb250ZXh0LmRlbGV0ZUZyYW1lYnVmZmVyKHRoaXMuZnJhbWVidWZmZXIpO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IHdpZHRoIGluIHRoaXMucmF3VmFsdWVGcmFtZWJ1ZmZlcnMpIHtcbiAgICAgIGZvciAoY29uc3QgaGVpZ2h0IGluIHRoaXMucmF3VmFsdWVGcmFtZWJ1ZmZlcnNbd2lkdGhdKSB7XG4gICAgICAgIHRoaXMuY29udGV4dC5kZWxldGVGcmFtZWJ1ZmZlcih0aGlzLnJhd1ZhbHVlRnJhbWVidWZmZXJzW3dpZHRoXVtoZWlnaHRdKTtcbiAgICAgICAgZGVsZXRlIHRoaXMucmF3VmFsdWVGcmFtZWJ1ZmZlcnNbd2lkdGhdW2hlaWdodF07XG4gICAgICB9XG4gICAgICBkZWxldGUgdGhpcy5yYXdWYWx1ZUZyYW1lYnVmZmVyc1t3aWR0aF07XG4gICAgfVxuICAgIGlmICh0aGlzLnZlcnRTaGFkZXIpIHtcbiAgICAgIHRoaXMuY29udGV4dC5kZWxldGVTaGFkZXIodGhpcy52ZXJ0U2hhZGVyKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuZnJhZ1NoYWRlcikge1xuICAgICAgdGhpcy5jb250ZXh0LmRlbGV0ZVNoYWRlcih0aGlzLmZyYWdTaGFkZXIpO1xuICAgIH1cbiAgICBpZiAodGhpcy5wcm9ncmFtKSB7XG4gICAgICB0aGlzLmNvbnRleHQuZGVsZXRlUHJvZ3JhbSh0aGlzLnByb2dyYW0pO1xuICAgIH1cbiAgICBpZiAodGhpcy50ZXh0dXJlKSB7XG4gICAgICB0aGlzLnRleHR1cmUuZGVsZXRlKCk7XG4gICAgICBjb25zdCB0ZXh0dXJlQ2FjaGVJbmRleCA9IHRoaXMudGV4dHVyZUNhY2hlLmluZGV4T2YodGhpcy50ZXh0dXJlLnRleHR1cmUpO1xuICAgICAgaWYgKHRleHR1cmVDYWNoZUluZGV4ID4gLTEpIHtcbiAgICAgICAgdGhpcy50ZXh0dXJlQ2FjaGUuc3BsaWNlKHRleHR1cmVDYWNoZUluZGV4LCAxKTtcbiAgICAgIH1cbiAgICAgIHRoaXMudGV4dHVyZSA9IG51bGw7XG4gICAgfVxuICAgIGlmICh0aGlzLm1hcHBlZFRleHR1cmVzICYmIHRoaXMubWFwcGVkVGV4dHVyZXMubGVuZ3RoKSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubWFwcGVkVGV4dHVyZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgbWFwcGVkVGV4dHVyZSA9IHRoaXMubWFwcGVkVGV4dHVyZXNbaV07XG4gICAgICAgIG1hcHBlZFRleHR1cmUuZGVsZXRlKCk7XG4gICAgICAgIGNvbnN0IHRleHR1cmVDYWNoZUluZGV4ID0gdGhpcy50ZXh0dXJlQ2FjaGUuaW5kZXhPZihtYXBwZWRUZXh0dXJlLnRleHR1cmUpO1xuICAgICAgICBpZiAodGV4dHVyZUNhY2hlSW5kZXggPiAtMSkge1xuICAgICAgICAgIHRoaXMudGV4dHVyZUNhY2hlLnNwbGljZSh0ZXh0dXJlQ2FjaGVJbmRleCwgMSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMubWFwcGVkVGV4dHVyZXMgPSBudWxsO1xuICAgIH1cbiAgICBpZiAodGhpcy5rZXJuZWxBcmd1bWVudHMpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5rZXJuZWxBcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy5rZXJuZWxBcmd1bWVudHNbaV0uZGVzdHJveSgpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGhpcy5rZXJuZWxDb25zdGFudHMpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5rZXJuZWxDb25zdGFudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy5rZXJuZWxDb25zdGFudHNbaV0uZGVzdHJveSgpO1xuICAgICAgfVxuICAgIH1cbiAgICB3aGlsZSAodGhpcy50ZXh0dXJlQ2FjaGUubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgdGV4dHVyZSA9IHRoaXMudGV4dHVyZUNhY2hlLnBvcCgpO1xuICAgICAgdGhpcy5jb250ZXh0LmRlbGV0ZVRleHR1cmUodGV4dHVyZSk7XG4gICAgfVxuICAgIGlmIChyZW1vdmVDYW52YXNSZWZlcmVuY2VzKSB7XG4gICAgICBjb25zdCBpZHggPSBjYW52YXNlcy5pbmRleE9mKHRoaXMuY2FudmFzKTtcbiAgICAgIGlmIChpZHggPj0gMCkge1xuICAgICAgICBjYW52YXNlc1tpZHhdID0gbnVsbDtcbiAgICAgICAgbWF4VGV4U2l6ZXNbaWR4XSA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuZGVzdHJveUV4dGVuc2lvbnMoKTtcbiAgICBkZWxldGUgdGhpcy5jb250ZXh0O1xuICAgIGRlbGV0ZSB0aGlzLmNhbnZhcztcbiAgICBpZiAoIXRoaXMuZ3B1KSByZXR1cm47XG4gICAgY29uc3QgaSA9IHRoaXMuZ3B1Lmtlcm5lbHMuaW5kZXhPZih0aGlzKTtcbiAgICBpZiAoaSA9PT0gLTEpIHJldHVybjtcbiAgICB0aGlzLmdwdS5rZXJuZWxzLnNwbGljZShpLCAxKTtcbiAgfVxuXG4gIGRlc3Ryb3lFeHRlbnNpb25zKCkge1xuICAgIHRoaXMuZXh0ZW5zaW9ucy5PRVNfdGV4dHVyZV9mbG9hdCA9IG51bGw7XG4gICAgdGhpcy5leHRlbnNpb25zLk9FU190ZXh0dXJlX2Zsb2F0X2xpbmVhciA9IG51bGw7XG4gICAgdGhpcy5leHRlbnNpb25zLk9FU19lbGVtZW50X2luZGV4X3VpbnQgPSBudWxsO1xuICAgIHRoaXMuZXh0ZW5zaW9ucy5XRUJHTF9kcmF3X2J1ZmZlcnMgPSBudWxsO1xuICB9XG5cbiAgc3RhdGljIGRlc3Ryb3lDb250ZXh0KGNvbnRleHQpIHtcbiAgICBjb25zdCBleHRlbnNpb24gPSBjb250ZXh0LmdldEV4dGVuc2lvbignV0VCR0xfbG9zZV9jb250ZXh0Jyk7XG4gICAgaWYgKGV4dGVuc2lvbikge1xuICAgICAgZXh0ZW5zaW9uLmxvc2VDb250ZXh0KCk7XG4gICAgfVxuICB9XG5cbiAgdG9KU09OKCkge1xuICAgIGNvbnN0IGpzb24gPSBzdXBlci50b0pTT04oKTtcbiAgICBqc29uLmZ1bmN0aW9uTm9kZXMgPSBGdW5jdGlvbkJ1aWxkZXIuZnJvbUtlcm5lbCh0aGlzLCBXZWJHTEZ1bmN0aW9uTm9kZSkudG9KU09OKCk7XG4gICAganNvbi5zZXR0aW5ncy50aHJlYWREaW0gPSB0aGlzLnRocmVhZERpbTtcbiAgICByZXR1cm4ganNvbjtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgV2ViR0xLZXJuZWxcbn07XG59LHtcIi4uLy4uL3BsdWdpbnMvbWF0aC1yYW5kb20tdW5pZm9ybWx5LWRpc3RyaWJ1dGVkXCI6MTEyLFwiLi4vLi4vdXRpbHNcIjoxMTQsXCIuLi9mdW5jdGlvbi1idWlsZGVyXCI6OSxcIi4uL2dsL2tlcm5lbFwiOjEzLFwiLi4vZ2wva2VybmVsLXN0cmluZ1wiOjEyLFwiLi9mcmFnbWVudC1zaGFkZXJcIjozNyxcIi4vZnVuY3Rpb24tbm9kZVwiOjM4LFwiLi9rZXJuZWwtdmFsdWUtbWFwc1wiOjM5LFwiLi92ZXJ0ZXgtc2hhZGVyXCI6NzF9XSw3MTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5jb25zdCB2ZXJ0ZXhTaGFkZXIgPSBgX19GTE9BVF9UQUNUSUNfREVDTEFSQVRJT05fXztcbl9fSU5UX1RBQ1RJQ19ERUNMQVJBVElPTl9fO1xuX19TQU1QTEVSXzJEX1RBQ1RJQ19ERUNMQVJBVElPTl9fO1xuXG5hdHRyaWJ1dGUgdmVjMiBhUG9zO1xuYXR0cmlidXRlIHZlYzIgYVRleENvb3JkO1xuXG52YXJ5aW5nIHZlYzIgdlRleENvb3JkO1xudW5pZm9ybSB2ZWMyIHJhdGlvO1xuXG52b2lkIG1haW4odm9pZCkge1xuICBnbF9Qb3NpdGlvbiA9IHZlYzQoKGFQb3MgKyB2ZWMyKDEpKSAqIHJhdGlvICsgdmVjMigtMSksIDAsIDEpO1xuICB2VGV4Q29vcmQgPSBhVGV4Q29vcmQ7XG59YDtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHZlcnRleFNoYWRlclxufTtcbn0se31dLDcyOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbmNvbnN0IGZyYWdtZW50U2hhZGVyID0gYCN2ZXJzaW9uIDMwMCBlc1xuX19IRUFERVJfXztcbl9fRkxPQVRfVEFDVElDX0RFQ0xBUkFUSU9OX187XG5fX0lOVF9UQUNUSUNfREVDTEFSQVRJT05fXztcbl9fU0FNUExFUl8yRF9UQUNUSUNfREVDTEFSQVRJT05fXztcbl9fU0FNUExFUl8yRF9BUlJBWV9UQUNUSUNfREVDTEFSQVRJT05fXztcblxuY29uc3QgaW50IExPT1BfTUFYID0gX19MT09QX01BWF9fO1xuXG5fX1BMVUdJTlNfXztcbl9fQ09OU1RBTlRTX187XG5cbmluIHZlYzIgdlRleENvb3JkO1xuXG5mbG9hdCBhdGFuMihmbG9hdCB2MSwgZmxvYXQgdjIpIHtcbiAgaWYgKHYxID09IDAuMCB8fCB2MiA9PSAwLjApIHJldHVybiAwLjA7XG4gIHJldHVybiBhdGFuKHYxIC8gdjIpO1xufVxuXG5mbG9hdCBjYnJ0KGZsb2F0IHgpIHtcbiAgaWYgKHggPj0gMC4wKSB7XG4gICAgcmV0dXJuIHBvdyh4LCAxLjAgLyAzLjApO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiAtcG93KHgsIDEuMCAvIDMuMCk7XG4gIH1cbn1cblxuZmxvYXQgZXhwbTEoZmxvYXQgeCkge1xuICByZXR1cm4gcG93KCR7TWF0aC5FfSwgeCkgLSAxLjA7IFxufVxuXG5mbG9hdCBmcm91bmQoaGlnaHAgZmxvYXQgeCkge1xuICByZXR1cm4geDtcbn1cblxuZmxvYXQgaW11bChmbG9hdCB2MSwgZmxvYXQgdjIpIHtcbiAgcmV0dXJuIGZsb2F0KGludCh2MSkgKiBpbnQodjIpKTtcbn1cblxuZmxvYXQgbG9nMTAoZmxvYXQgeCkge1xuICByZXR1cm4gbG9nMih4KSAqICgxLjAgLyBsb2cyKDEwLjApKTtcbn1cblxuZmxvYXQgbG9nMXAoZmxvYXQgeCkge1xuICByZXR1cm4gbG9nKDEuMCArIHgpO1xufVxuXG5mbG9hdCBfcG93KGZsb2F0IHYxLCBmbG9hdCB2Mikge1xuICBpZiAodjIgPT0gMC4wKSByZXR1cm4gMS4wO1xuICByZXR1cm4gcG93KHYxLCB2Mik7XG59XG5cbmZsb2F0IF9yb3VuZChmbG9hdCB4KSB7XG4gIHJldHVybiBmbG9vcih4ICsgMC41KTtcbn1cblxuXG5jb25zdCBpbnQgQklUX0NPVU5UID0gMzI7XG5pbnQgbW9kaShpbnQgeCwgaW50IHkpIHtcbiAgcmV0dXJuIHggLSB5ICogKHggLyB5KTtcbn1cblxuaW50IGJpdHdpc2VPcihpbnQgYSwgaW50IGIpIHtcbiAgaW50IHJlc3VsdCA9IDA7XG4gIGludCBuID0gMTtcbiAgXG4gIGZvciAoaW50IGkgPSAwOyBpIDwgQklUX0NPVU5UOyBpKyspIHtcbiAgICBpZiAoKG1vZGkoYSwgMikgPT0gMSkgfHwgKG1vZGkoYiwgMikgPT0gMSkpIHtcbiAgICAgIHJlc3VsdCArPSBuO1xuICAgIH1cbiAgICBhID0gYSAvIDI7XG4gICAgYiA9IGIgLyAyO1xuICAgIG4gPSBuICogMjtcbiAgICBpZighKGEgPiAwIHx8IGIgPiAwKSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5pbnQgYml0d2lzZVhPUihpbnQgYSwgaW50IGIpIHtcbiAgaW50IHJlc3VsdCA9IDA7XG4gIGludCBuID0gMTtcbiAgXG4gIGZvciAoaW50IGkgPSAwOyBpIDwgQklUX0NPVU5UOyBpKyspIHtcbiAgICBpZiAoKG1vZGkoYSwgMikgPT0gMSkgIT0gKG1vZGkoYiwgMikgPT0gMSkpIHtcbiAgICAgIHJlc3VsdCArPSBuO1xuICAgIH1cbiAgICBhID0gYSAvIDI7XG4gICAgYiA9IGIgLyAyO1xuICAgIG4gPSBuICogMjtcbiAgICBpZighKGEgPiAwIHx8IGIgPiAwKSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5pbnQgYml0d2lzZUFuZChpbnQgYSwgaW50IGIpIHtcbiAgaW50IHJlc3VsdCA9IDA7XG4gIGludCBuID0gMTtcbiAgZm9yIChpbnQgaSA9IDA7IGkgPCBCSVRfQ09VTlQ7IGkrKykge1xuICAgIGlmICgobW9kaShhLCAyKSA9PSAxKSAmJiAobW9kaShiLCAyKSA9PSAxKSkge1xuICAgICAgcmVzdWx0ICs9IG47XG4gICAgfVxuICAgIGEgPSBhIC8gMjtcbiAgICBiID0gYiAvIDI7XG4gICAgbiA9IG4gKiAyO1xuICAgIGlmKCEoYSA+IDAgJiYgYiA+IDApKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmludCBiaXR3aXNlTm90KGludCBhKSB7XG4gIGludCByZXN1bHQgPSAwO1xuICBpbnQgbiA9IDE7XG4gIFxuICBmb3IgKGludCBpID0gMDsgaSA8IEJJVF9DT1VOVDsgaSsrKSB7XG4gICAgaWYgKG1vZGkoYSwgMikgPT0gMCkge1xuICAgICAgcmVzdWx0ICs9IG47ICAgIFxuICAgIH1cbiAgICBhID0gYSAvIDI7XG4gICAgbiA9IG4gKiAyO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5pbnQgYml0d2lzZVplcm9GaWxsTGVmdFNoaWZ0KGludCBuLCBpbnQgc2hpZnQpIHtcbiAgaW50IG1heEJ5dGVzID0gQklUX0NPVU5UO1xuICBmb3IgKGludCBpID0gMDsgaSA8IEJJVF9DT1VOVDsgaSsrKSB7XG4gICAgaWYgKG1heEJ5dGVzID49IG4pIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBtYXhCeXRlcyAqPSAyO1xuICB9XG4gIGZvciAoaW50IGkgPSAwOyBpIDwgQklUX0NPVU5UOyBpKyspIHtcbiAgICBpZiAoaSA+PSBzaGlmdCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIG4gKj0gMjtcbiAgfVxuXG4gIGludCByZXN1bHQgPSAwO1xuICBpbnQgYnl0ZVZhbCA9IDE7XG4gIGZvciAoaW50IGkgPSAwOyBpIDwgQklUX0NPVU5UOyBpKyspIHtcbiAgICBpZiAoaSA+PSBtYXhCeXRlcykgYnJlYWs7XG4gICAgaWYgKG1vZGkobiwgMikgPiAwKSB7IHJlc3VsdCArPSBieXRlVmFsOyB9XG4gICAgbiA9IGludChuIC8gMik7XG4gICAgYnl0ZVZhbCAqPSAyO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmludCBiaXR3aXNlU2lnbmVkUmlnaHRTaGlmdChpbnQgbnVtLCBpbnQgc2hpZnRzKSB7XG4gIHJldHVybiBpbnQoZmxvb3IoZmxvYXQobnVtKSAvIHBvdygyLjAsIGZsb2F0KHNoaWZ0cykpKSk7XG59XG5cbmludCBiaXR3aXNlWmVyb0ZpbGxSaWdodFNoaWZ0KGludCBuLCBpbnQgc2hpZnQpIHtcbiAgaW50IG1heEJ5dGVzID0gQklUX0NPVU5UO1xuICBmb3IgKGludCBpID0gMDsgaSA8IEJJVF9DT1VOVDsgaSsrKSB7XG4gICAgaWYgKG1heEJ5dGVzID49IG4pIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBtYXhCeXRlcyAqPSAyO1xuICB9XG4gIGZvciAoaW50IGkgPSAwOyBpIDwgQklUX0NPVU5UOyBpKyspIHtcbiAgICBpZiAoaSA+PSBzaGlmdCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIG4gLz0gMjtcbiAgfVxuICBpbnQgcmVzdWx0ID0gMDtcbiAgaW50IGJ5dGVWYWwgPSAxO1xuICBmb3IgKGludCBpID0gMDsgaSA8IEJJVF9DT1VOVDsgaSsrKSB7XG4gICAgaWYgKGkgPj0gbWF4Qnl0ZXMpIGJyZWFrO1xuICAgIGlmIChtb2RpKG4sIDIpID4gMCkgeyByZXN1bHQgKz0gYnl0ZVZhbDsgfVxuICAgIG4gPSBpbnQobiAvIDIpO1xuICAgIGJ5dGVWYWwgKj0gMjtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG52ZWMyIGludGVnZXJNb2QodmVjMiB4LCBmbG9hdCB5KSB7XG4gIHZlYzIgcmVzID0gZmxvb3IobW9kKHgsIHkpKTtcbiAgcmV0dXJuIHJlcyAqIHN0ZXAoMS4wIC0gZmxvb3IoeSksIC1yZXMpO1xufVxuXG52ZWMzIGludGVnZXJNb2QodmVjMyB4LCBmbG9hdCB5KSB7XG4gIHZlYzMgcmVzID0gZmxvb3IobW9kKHgsIHkpKTtcbiAgcmV0dXJuIHJlcyAqIHN0ZXAoMS4wIC0gZmxvb3IoeSksIC1yZXMpO1xufVxuXG52ZWM0IGludGVnZXJNb2QodmVjNCB4LCB2ZWM0IHkpIHtcbiAgdmVjNCByZXMgPSBmbG9vcihtb2QoeCwgeSkpO1xuICByZXR1cm4gcmVzICogc3RlcCgxLjAgLSBmbG9vcih5KSwgLXJlcyk7XG59XG5cbmZsb2F0IGludGVnZXJNb2QoZmxvYXQgeCwgZmxvYXQgeSkge1xuICBmbG9hdCByZXMgPSBmbG9vcihtb2QoeCwgeSkpO1xuICByZXR1cm4gcmVzICogKHJlcyA+IGZsb29yKHkpIC0gMS4wID8gMC4wIDogMS4wKTtcbn1cblxuaW50IGludGVnZXJNb2QoaW50IHgsIGludCB5KSB7XG4gIHJldHVybiB4IC0gKHkgKiBpbnQoeC95KSk7XG59XG5cbl9fRElWSURFX1dJVEhfSU5URUdFUl9DSEVDS19fO1xuXG4vLyBIZXJlIGJlIGRyYWdvbnMhXG4vLyBETyBOT1QgT1BUSU1JWkUgVEhJUyBDT0RFXG4vLyBZT1UgV0lMTCBCUkVBSyBTT01FVEhJTkcgT04gU09NRUJPRFlcXCdTIE1BQ0hJTkVcbi8vIExFQVZFIElUIEFTIElUIElTLCBMRVNUIFlPVSBXQVNURSBZT1VSIE9XTiBUSU1FXG5jb25zdCB2ZWMyIE1BR0lDX1ZFQyA9IHZlYzIoMS4wLCAtMjU2LjApO1xuY29uc3QgdmVjNCBTQ0FMRV9GQUNUT1IgPSB2ZWM0KDEuMCwgMjU2LjAsIDY1NTM2LjAsIDAuMCk7XG5jb25zdCB2ZWM0IFNDQUxFX0ZBQ1RPUl9JTlYgPSB2ZWM0KDEuMCwgMC4wMDM5MDYyNSwgMC4wMDAwMTUyNTg3ODkwNjI1LCAwLjApOyAvLyAxLCAxLzI1NiwgMS82NTUzNlxuZmxvYXQgZGVjb2RlMzIodmVjNCB0ZXhlbCkge1xuICBfX0RFQ09ERTMyX0VORElBTk5FU1NfXztcbiAgdGV4ZWwgKj0gMjU1LjA7XG4gIHZlYzIgZ3RlMTI4O1xuICBndGUxMjgueCA9IHRleGVsLmIgPj0gMTI4LjAgPyAxLjAgOiAwLjA7XG4gIGd0ZTEyOC55ID0gdGV4ZWwuYSA+PSAxMjguMCA/IDEuMCA6IDAuMDtcbiAgZmxvYXQgZXhwb25lbnQgPSAyLjAgKiB0ZXhlbC5hIC0gMTI3LjAgKyBkb3QoZ3RlMTI4LCBNQUdJQ19WRUMpO1xuICBmbG9hdCByZXMgPSBleHAyKHJvdW5kKGV4cG9uZW50KSk7XG4gIHRleGVsLmIgPSB0ZXhlbC5iIC0gMTI4LjAgKiBndGUxMjgueDtcbiAgcmVzID0gZG90KHRleGVsLCBTQ0FMRV9GQUNUT1IpICogZXhwMihyb3VuZChleHBvbmVudC0yMy4wKSkgKyByZXM7XG4gIHJlcyAqPSBndGUxMjgueSAqIC0yLjAgKyAxLjA7XG4gIHJldHVybiByZXM7XG59XG5cbmZsb2F0IGRlY29kZTE2KHZlYzQgdGV4ZWwsIGludCBpbmRleCkge1xuICBpbnQgY2hhbm5lbCA9IGludGVnZXJNb2QoaW5kZXgsIDIpO1xuICByZXR1cm4gdGV4ZWxbY2hhbm5lbCoyXSAqIDI1NS4wICsgdGV4ZWxbY2hhbm5lbCoyICsgMV0gKiA2NTI4MC4wO1xufVxuXG5mbG9hdCBkZWNvZGU4KHZlYzQgdGV4ZWwsIGludCBpbmRleCkge1xuICBpbnQgY2hhbm5lbCA9IGludGVnZXJNb2QoaW5kZXgsIDQpO1xuICByZXR1cm4gdGV4ZWxbY2hhbm5lbF0gKiAyNTUuMDtcbn1cblxudmVjNCBsZWdhY3lFbmNvZGUzMihmbG9hdCBmKSB7XG4gIGZsb2F0IEYgPSBhYnMoZik7XG4gIGZsb2F0IHNpZ24gPSBmIDwgMC4wID8gMS4wIDogMC4wO1xuICBmbG9hdCBleHBvbmVudCA9IGZsb29yKGxvZzIoRikpO1xuICBmbG9hdCBtYW50aXNzYSA9IChleHAyKC1leHBvbmVudCkgKiBGKTtcbiAgLy8gZXhwb25lbnQgKz0gZmxvb3IobG9nMihtYW50aXNzYSkpO1xuICB2ZWM0IHRleGVsID0gdmVjNChGICogZXhwMigyMy4wLWV4cG9uZW50KSkgKiBTQ0FMRV9GQUNUT1JfSU5WO1xuICB0ZXhlbC5yZyA9IGludGVnZXJNb2QodGV4ZWwucmcsIDI1Ni4wKTtcbiAgdGV4ZWwuYiA9IGludGVnZXJNb2QodGV4ZWwuYiwgMTI4LjApO1xuICB0ZXhlbC5hID0gZXhwb25lbnQqMC41ICsgNjMuNTtcbiAgdGV4ZWwuYmEgKz0gdmVjMihpbnRlZ2VyTW9kKGV4cG9uZW50KzEyNy4wLCAyLjApLCBzaWduKSAqIDEyOC4wO1xuICB0ZXhlbCA9IGZsb29yKHRleGVsKTtcbiAgdGV4ZWwgKj0gMC4wMDM5MjE1Njk7IC8vIDEvMjU1XG4gIF9fRU5DT0RFMzJfRU5ESUFOTkVTU19fO1xuICByZXR1cm4gdGV4ZWw7XG59XG5cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ncHVqcy9ncHUuanMvd2lraS9FbmNvZGVyLWRldGFpbHNcbnZlYzQgZW5jb2RlMzIoZmxvYXQgdmFsdWUpIHtcbiAgaWYgKHZhbHVlID09IDAuMCkgcmV0dXJuIHZlYzQoMCwgMCwgMCwgMCk7XG5cbiAgZmxvYXQgZXhwb25lbnQ7XG4gIGZsb2F0IG1hbnRpc3NhO1xuICB2ZWM0ICByZXN1bHQ7XG4gIGZsb2F0IHNnbjtcblxuICBzZ24gPSBzdGVwKDAuMCwgLXZhbHVlKTtcbiAgdmFsdWUgPSBhYnModmFsdWUpO1xuXG4gIGV4cG9uZW50ID0gZmxvb3IobG9nMih2YWx1ZSkpO1xuXG4gIG1hbnRpc3NhID0gdmFsdWUqcG93KDIuMCwgLWV4cG9uZW50KS0xLjA7XG4gIGV4cG9uZW50ID0gZXhwb25lbnQrMTI3LjA7XG4gIHJlc3VsdCAgID0gdmVjNCgwLDAsMCwwKTtcblxuICByZXN1bHQuYSA9IGZsb29yKGV4cG9uZW50LzIuMCk7XG4gIGV4cG9uZW50ID0gZXhwb25lbnQgLSByZXN1bHQuYSoyLjA7XG4gIHJlc3VsdC5hID0gcmVzdWx0LmEgKyAxMjguMCpzZ247XG5cbiAgcmVzdWx0LmIgPSBmbG9vcihtYW50aXNzYSAqIDEyOC4wKTtcbiAgbWFudGlzc2EgPSBtYW50aXNzYSAtIHJlc3VsdC5iIC8gMTI4LjA7XG4gIHJlc3VsdC5iID0gcmVzdWx0LmIgKyBleHBvbmVudCoxMjguMDtcblxuICByZXN1bHQuZyA9IGZsb29yKG1hbnRpc3NhKjMyNzY4LjApO1xuICBtYW50aXNzYSA9IG1hbnRpc3NhIC0gcmVzdWx0LmcvMzI3NjguMDtcblxuICByZXN1bHQuciA9IGZsb29yKG1hbnRpc3NhKjgzODg2MDguMCk7XG4gIHJldHVybiByZXN1bHQvMjU1LjA7XG59XG4vLyBEcmFnb25zIGVuZCBoZXJlXG5cbmludCBpbmRleDtcbml2ZWMzIHRocmVhZElkO1xuXG5pdmVjMyBpbmRleFRvM0QoaW50IGlkeCwgaXZlYzMgdGV4RGltKSB7XG4gIGludCB6ID0gaW50KGlkeCAvICh0ZXhEaW0ueCAqIHRleERpbS55KSk7XG4gIGlkeCAtPSB6ICogaW50KHRleERpbS54ICogdGV4RGltLnkpO1xuICBpbnQgeSA9IGludChpZHggLyB0ZXhEaW0ueCk7XG4gIGludCB4ID0gaW50KGludGVnZXJNb2QoaWR4LCB0ZXhEaW0ueCkpO1xuICByZXR1cm4gaXZlYzMoeCwgeSwgeik7XG59XG5cbmZsb2F0IGdldDMyKHNhbXBsZXIyRCB0ZXgsIGl2ZWMyIHRleFNpemUsIGl2ZWMzIHRleERpbSwgaW50IHosIGludCB5LCBpbnQgeCkge1xuICBpbnQgaW5kZXggPSB4ICsgdGV4RGltLnggKiAoeSArIHRleERpbS55ICogeik7XG4gIGludCB3ID0gdGV4U2l6ZS54O1xuICB2ZWMyIHN0ID0gdmVjMihmbG9hdChpbnRlZ2VyTW9kKGluZGV4LCB3KSksIGZsb2F0KGluZGV4IC8gdykpICsgMC41O1xuICB2ZWM0IHRleGVsID0gdGV4dHVyZSh0ZXgsIHN0IC8gdmVjMih0ZXhTaXplKSk7XG4gIHJldHVybiBkZWNvZGUzMih0ZXhlbCk7XG59XG5cbmZsb2F0IGdldDE2KHNhbXBsZXIyRCB0ZXgsIGl2ZWMyIHRleFNpemUsIGl2ZWMzIHRleERpbSwgaW50IHosIGludCB5LCBpbnQgeCkge1xuICBpbnQgaW5kZXggPSB4ICsgKHRleERpbS54ICogKHkgKyAodGV4RGltLnkgKiB6KSkpO1xuICBpbnQgdyA9IHRleFNpemUueCAqIDI7XG4gIHZlYzIgc3QgPSB2ZWMyKGZsb2F0KGludGVnZXJNb2QoaW5kZXgsIHcpKSwgZmxvYXQoaW5kZXggLyB3KSkgKyAwLjU7XG4gIHZlYzQgdGV4ZWwgPSB0ZXh0dXJlKHRleCwgc3QgLyB2ZWMyKHRleFNpemUueCAqIDIsIHRleFNpemUueSkpO1xuICByZXR1cm4gZGVjb2RlMTYodGV4ZWwsIGluZGV4KTtcbn1cblxuZmxvYXQgZ2V0OChzYW1wbGVyMkQgdGV4LCBpdmVjMiB0ZXhTaXplLCBpdmVjMyB0ZXhEaW0sIGludCB6LCBpbnQgeSwgaW50IHgpIHtcbiAgaW50IGluZGV4ID0geCArICh0ZXhEaW0ueCAqICh5ICsgKHRleERpbS55ICogeikpKTtcbiAgaW50IHcgPSB0ZXhTaXplLnggKiA0O1xuICB2ZWMyIHN0ID0gdmVjMihmbG9hdChpbnRlZ2VyTW9kKGluZGV4LCB3KSksIGZsb2F0KGluZGV4IC8gdykpICsgMC41O1xuICB2ZWM0IHRleGVsID0gdGV4dHVyZSh0ZXgsIHN0IC8gdmVjMih0ZXhTaXplLnggKiA0LCB0ZXhTaXplLnkpKTtcbiAgcmV0dXJuIGRlY29kZTgodGV4ZWwsIGluZGV4KTtcbn1cblxuZmxvYXQgZ2V0TWVtb3J5T3B0aW1pemVkMzIoc2FtcGxlcjJEIHRleCwgaXZlYzIgdGV4U2l6ZSwgaXZlYzMgdGV4RGltLCBpbnQgeiwgaW50IHksIGludCB4KSB7XG4gIGludCBpbmRleCA9IHggKyAodGV4RGltLnggKiAoeSArICh0ZXhEaW0ueSAqIHopKSk7XG4gIGludCBjaGFubmVsID0gaW50ZWdlck1vZChpbmRleCwgNCk7XG4gIGluZGV4ID0gaW5kZXggLyA0O1xuICBpbnQgdyA9IHRleFNpemUueDtcbiAgdmVjMiBzdCA9IHZlYzIoZmxvYXQoaW50ZWdlck1vZChpbmRleCwgdykpLCBmbG9hdChpbmRleCAvIHcpKSArIDAuNTtcbiAgaW5kZXggPSBpbmRleCAvIDQ7XG4gIHZlYzQgdGV4ZWwgPSB0ZXh0dXJlKHRleCwgc3QgLyB2ZWMyKHRleFNpemUpKTtcbiAgcmV0dXJuIHRleGVsW2NoYW5uZWxdO1xufVxuXG52ZWM0IGdldEltYWdlMkQoc2FtcGxlcjJEIHRleCwgaXZlYzIgdGV4U2l6ZSwgaXZlYzMgdGV4RGltLCBpbnQgeiwgaW50IHksIGludCB4KSB7XG4gIGludCBpbmRleCA9IHggKyB0ZXhEaW0ueCAqICh5ICsgdGV4RGltLnkgKiB6KTtcbiAgaW50IHcgPSB0ZXhTaXplLng7XG4gIHZlYzIgc3QgPSB2ZWMyKGZsb2F0KGludGVnZXJNb2QoaW5kZXgsIHcpKSwgZmxvYXQoaW5kZXggLyB3KSkgKyAwLjU7XG4gIHJldHVybiB0ZXh0dXJlKHRleCwgc3QgLyB2ZWMyKHRleFNpemUpKTtcbn1cblxudmVjNCBnZXRJbWFnZTNEKHNhbXBsZXIyREFycmF5IHRleCwgaXZlYzIgdGV4U2l6ZSwgaXZlYzMgdGV4RGltLCBpbnQgeiwgaW50IHksIGludCB4KSB7XG4gIGludCBpbmRleCA9IHggKyB0ZXhEaW0ueCAqICh5ICsgdGV4RGltLnkgKiB6KTtcbiAgaW50IHcgPSB0ZXhTaXplLng7XG4gIHZlYzIgc3QgPSB2ZWMyKGZsb2F0KGludGVnZXJNb2QoaW5kZXgsIHcpKSwgZmxvYXQoaW5kZXggLyB3KSkgKyAwLjU7XG4gIHJldHVybiB0ZXh0dXJlKHRleCwgdmVjMyhzdCAvIHZlYzIodGV4U2l6ZSksIHopKTtcbn1cblxuZmxvYXQgZ2V0RmxvYXRGcm9tU2FtcGxlcjJEKHNhbXBsZXIyRCB0ZXgsIGl2ZWMyIHRleFNpemUsIGl2ZWMzIHRleERpbSwgaW50IHosIGludCB5LCBpbnQgeCkge1xuICB2ZWM0IHJlc3VsdCA9IGdldEltYWdlMkQodGV4LCB0ZXhTaXplLCB0ZXhEaW0sIHosIHksIHgpO1xuICByZXR1cm4gcmVzdWx0WzBdO1xufVxuXG52ZWMyIGdldFZlYzJGcm9tU2FtcGxlcjJEKHNhbXBsZXIyRCB0ZXgsIGl2ZWMyIHRleFNpemUsIGl2ZWMzIHRleERpbSwgaW50IHosIGludCB5LCBpbnQgeCkge1xuICB2ZWM0IHJlc3VsdCA9IGdldEltYWdlMkQodGV4LCB0ZXhTaXplLCB0ZXhEaW0sIHosIHksIHgpO1xuICByZXR1cm4gdmVjMihyZXN1bHRbMF0sIHJlc3VsdFsxXSk7XG59XG5cbnZlYzIgZ2V0TWVtb3J5T3B0aW1pemVkVmVjMihzYW1wbGVyMkQgdGV4LCBpdmVjMiB0ZXhTaXplLCBpdmVjMyB0ZXhEaW0sIGludCB6LCBpbnQgeSwgaW50IHgpIHtcbiAgaW50IGluZGV4ID0geCArIHRleERpbS54ICogKHkgKyB0ZXhEaW0ueSAqIHopO1xuICBpbnQgY2hhbm5lbCA9IGludGVnZXJNb2QoaW5kZXgsIDIpO1xuICBpbmRleCA9IGluZGV4IC8gMjtcbiAgaW50IHcgPSB0ZXhTaXplLng7XG4gIHZlYzIgc3QgPSB2ZWMyKGZsb2F0KGludGVnZXJNb2QoaW5kZXgsIHcpKSwgZmxvYXQoaW5kZXggLyB3KSkgKyAwLjU7XG4gIHZlYzQgdGV4ZWwgPSB0ZXh0dXJlKHRleCwgc3QgLyB2ZWMyKHRleFNpemUpKTtcbiAgaWYgKGNoYW5uZWwgPT0gMCkgcmV0dXJuIHZlYzIodGV4ZWwuciwgdGV4ZWwuZyk7XG4gIGlmIChjaGFubmVsID09IDEpIHJldHVybiB2ZWMyKHRleGVsLmIsIHRleGVsLmEpO1xuICByZXR1cm4gdmVjMigwLjAsIDAuMCk7XG59XG5cbnZlYzMgZ2V0VmVjM0Zyb21TYW1wbGVyMkQoc2FtcGxlcjJEIHRleCwgaXZlYzIgdGV4U2l6ZSwgaXZlYzMgdGV4RGltLCBpbnQgeiwgaW50IHksIGludCB4KSB7XG4gIHZlYzQgcmVzdWx0ID0gZ2V0SW1hZ2UyRCh0ZXgsIHRleFNpemUsIHRleERpbSwgeiwgeSwgeCk7XG4gIHJldHVybiB2ZWMzKHJlc3VsdFswXSwgcmVzdWx0WzFdLCByZXN1bHRbMl0pO1xufVxuXG52ZWMzIGdldE1lbW9yeU9wdGltaXplZFZlYzMoc2FtcGxlcjJEIHRleCwgaXZlYzIgdGV4U2l6ZSwgaXZlYzMgdGV4RGltLCBpbnQgeiwgaW50IHksIGludCB4KSB7XG4gIGludCBmaWVsZEluZGV4ID0gMyAqICh4ICsgdGV4RGltLnggKiAoeSArIHRleERpbS55ICogeikpO1xuICBpbnQgdmVjdG9ySW5kZXggPSBmaWVsZEluZGV4IC8gNDtcbiAgaW50IHZlY3Rvck9mZnNldCA9IGZpZWxkSW5kZXggLSB2ZWN0b3JJbmRleCAqIDQ7XG4gIGludCByZWFkWSA9IHZlY3RvckluZGV4IC8gdGV4U2l6ZS54O1xuICBpbnQgcmVhZFggPSB2ZWN0b3JJbmRleCAtIHJlYWRZICogdGV4U2l6ZS54O1xuICB2ZWM0IHRleDEgPSB0ZXh0dXJlKHRleCwgKHZlYzIocmVhZFgsIHJlYWRZKSArIDAuNSkgLyB2ZWMyKHRleFNpemUpKTtcblxuICBpZiAodmVjdG9yT2Zmc2V0ID09IDApIHtcbiAgICByZXR1cm4gdGV4MS54eXo7XG4gIH0gZWxzZSBpZiAodmVjdG9yT2Zmc2V0ID09IDEpIHtcbiAgICByZXR1cm4gdGV4MS55enc7XG4gIH0gZWxzZSB7XG4gICAgcmVhZFgrKztcbiAgICBpZiAocmVhZFggPj0gdGV4U2l6ZS54KSB7XG4gICAgICByZWFkWCA9IDA7XG4gICAgICByZWFkWSsrO1xuICAgIH1cbiAgICB2ZWM0IHRleDIgPSB0ZXh0dXJlKHRleCwgdmVjMihyZWFkWCwgcmVhZFkpIC8gdmVjMih0ZXhTaXplKSk7XG4gICAgaWYgKHZlY3Rvck9mZnNldCA9PSAyKSB7XG4gICAgICByZXR1cm4gdmVjMyh0ZXgxLnosIHRleDEudywgdGV4Mi54KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHZlYzModGV4MS53LCB0ZXgyLngsIHRleDIueSk7XG4gICAgfVxuICB9XG59XG5cbnZlYzQgZ2V0VmVjNEZyb21TYW1wbGVyMkQoc2FtcGxlcjJEIHRleCwgaXZlYzIgdGV4U2l6ZSwgaXZlYzMgdGV4RGltLCBpbnQgeiwgaW50IHksIGludCB4KSB7XG4gIHJldHVybiBnZXRJbWFnZTJEKHRleCwgdGV4U2l6ZSwgdGV4RGltLCB6LCB5LCB4KTtcbn1cblxudmVjNCBnZXRNZW1vcnlPcHRpbWl6ZWRWZWM0KHNhbXBsZXIyRCB0ZXgsIGl2ZWMyIHRleFNpemUsIGl2ZWMzIHRleERpbSwgaW50IHosIGludCB5LCBpbnQgeCkge1xuICBpbnQgaW5kZXggPSB4ICsgdGV4RGltLnggKiAoeSArIHRleERpbS55ICogeik7XG4gIGludCBjaGFubmVsID0gaW50ZWdlck1vZChpbmRleCwgMik7XG4gIGludCB3ID0gdGV4U2l6ZS54O1xuICB2ZWMyIHN0ID0gdmVjMihmbG9hdChpbnRlZ2VyTW9kKGluZGV4LCB3KSksIGZsb2F0KGluZGV4IC8gdykpICsgMC41O1xuICB2ZWM0IHRleGVsID0gdGV4dHVyZSh0ZXgsIHN0IC8gdmVjMih0ZXhTaXplKSk7XG4gIHJldHVybiB2ZWM0KHRleGVsLnIsIHRleGVsLmcsIHRleGVsLmIsIHRleGVsLmEpO1xufVxuXG52ZWM0IGFjdHVhbENvbG9yO1xudm9pZCBjb2xvcihmbG9hdCByLCBmbG9hdCBnLCBmbG9hdCBiLCBmbG9hdCBhKSB7XG4gIGFjdHVhbENvbG9yID0gdmVjNChyLGcsYixhKTtcbn1cblxudm9pZCBjb2xvcihmbG9hdCByLCBmbG9hdCBnLCBmbG9hdCBiKSB7XG4gIGNvbG9yKHIsZyxiLDEuMCk7XG59XG5cbmZsb2F0IG1vZHVsbyhmbG9hdCBudW1iZXIsIGZsb2F0IGRpdmlzb3IpIHtcbiAgaWYgKG51bWJlciA8IDAuMCkge1xuICAgIG51bWJlciA9IGFicyhudW1iZXIpO1xuICAgIGlmIChkaXZpc29yIDwgMC4wKSB7XG4gICAgICBkaXZpc29yID0gYWJzKGRpdmlzb3IpO1xuICAgIH1cbiAgICByZXR1cm4gLW1vZChudW1iZXIsIGRpdmlzb3IpO1xuICB9XG4gIGlmIChkaXZpc29yIDwgMC4wKSB7XG4gICAgZGl2aXNvciA9IGFicyhkaXZpc29yKTtcbiAgfVxuICByZXR1cm4gbW9kKG51bWJlciwgZGl2aXNvcik7XG59XG5cbl9fSU5KRUNURURfTkFUSVZFX187XG5fX01BSU5fQ09OU1RBTlRTX187XG5fX01BSU5fQVJHVU1FTlRTX187XG5fX0tFUk5FTF9fO1xuXG52b2lkIG1haW4odm9pZCkge1xuICBpbmRleCA9IGludCh2VGV4Q29vcmQucyAqIGZsb2F0KHVUZXhTaXplLngpKSArIGludCh2VGV4Q29vcmQudCAqIGZsb2F0KHVUZXhTaXplLnkpKSAqIHVUZXhTaXplLng7XG4gIF9fTUFJTl9SRVNVTFRfXztcbn1gO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZnJhZ21lbnRTaGFkZXJcbn07XG59LHt9XSw3MzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5jb25zdCB7IHV0aWxzIH0gPSByZXF1aXJlKCcuLi8uLi91dGlscycpO1xuY29uc3QgeyBXZWJHTEZ1bmN0aW9uTm9kZSB9ID0gcmVxdWlyZSgnLi4vd2ViLWdsL2Z1bmN0aW9uLW5vZGUnKTtcblxuY2xhc3MgV2ViR0wyRnVuY3Rpb25Ob2RlIGV4dGVuZHMgV2ViR0xGdW5jdGlvbk5vZGUge1xuXG4gIGFzdElkZW50aWZpZXJFeHByZXNzaW9uKGlkdE5vZGUsIHJldEFycikge1xuICAgIGlmIChpZHROb2RlLnR5cGUgIT09ICdJZGVudGlmaWVyJykge1xuICAgICAgdGhyb3cgdGhpcy5hc3RFcnJvck91dHB1dChcbiAgICAgICAgJ0lkZW50aWZpZXJFeHByZXNzaW9uIC0gbm90IGFuIElkZW50aWZpZXInLFxuICAgICAgICBpZHROb2RlXG4gICAgICApO1xuICAgIH1cblxuICAgIGNvbnN0IHR5cGUgPSB0aGlzLmdldFR5cGUoaWR0Tm9kZSk7XG5cbiAgICBjb25zdCBuYW1lID0gdXRpbHMuc2FuaXRpemVOYW1lKGlkdE5vZGUubmFtZSk7XG4gICAgaWYgKGlkdE5vZGUubmFtZSA9PT0gJ0luZmluaXR5Jykge1xuICAgICAgcmV0QXJyLnB1c2goJ2ludEJpdHNUb0Zsb2F0KDIxMzkwOTUwMzkpJyk7XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnQm9vbGVhbicpIHtcbiAgICAgIGlmICh0aGlzLmFyZ3VtZW50TmFtZXMuaW5kZXhPZihuYW1lKSA+IC0xKSB7XG4gICAgICAgIHJldEFyci5wdXNoKGBib29sKHVzZXJfJHtuYW1lfSlgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldEFyci5wdXNoKGB1c2VyXyR7bmFtZX1gKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0QXJyLnB1c2goYHVzZXJfJHtuYW1lfWApO1xuICAgIH1cblxuICAgIHJldHVybiByZXRBcnI7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIFdlYkdMMkZ1bmN0aW9uTm9kZVxufTtcbn0se1wiLi4vLi4vdXRpbHNcIjoxMTQsXCIuLi93ZWItZ2wvZnVuY3Rpb24tbm9kZVwiOjM4fV0sNzQ6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuY29uc3QgeyBXZWJHTDJLZXJuZWxWYWx1ZUJvb2xlYW4gfSA9IHJlcXVpcmUoJy4va2VybmVsLXZhbHVlL2Jvb2xlYW4nKTtcbmNvbnN0IHsgV2ViR0wyS2VybmVsVmFsdWVGbG9hdCB9ID0gcmVxdWlyZSgnLi9rZXJuZWwtdmFsdWUvZmxvYXQnKTtcbmNvbnN0IHsgV2ViR0wyS2VybmVsVmFsdWVJbnRlZ2VyIH0gPSByZXF1aXJlKCcuL2tlcm5lbC12YWx1ZS9pbnRlZ2VyJyk7XG5cbmNvbnN0IHsgV2ViR0wyS2VybmVsVmFsdWVIVE1MSW1hZ2UgfSA9IHJlcXVpcmUoJy4va2VybmVsLXZhbHVlL2h0bWwtaW1hZ2UnKTtcbmNvbnN0IHsgV2ViR0wyS2VybmVsVmFsdWVEeW5hbWljSFRNTEltYWdlIH0gPSByZXF1aXJlKCcuL2tlcm5lbC12YWx1ZS9keW5hbWljLWh0bWwtaW1hZ2UnKTtcblxuY29uc3QgeyBXZWJHTDJLZXJuZWxWYWx1ZUhUTUxJbWFnZUFycmF5IH0gPSByZXF1aXJlKCcuL2tlcm5lbC12YWx1ZS9odG1sLWltYWdlLWFycmF5Jyk7XG5jb25zdCB7IFdlYkdMMktlcm5lbFZhbHVlRHluYW1pY0hUTUxJbWFnZUFycmF5IH0gPSByZXF1aXJlKCcuL2tlcm5lbC12YWx1ZS9keW5hbWljLWh0bWwtaW1hZ2UtYXJyYXknKTtcblxuY29uc3QgeyBXZWJHTDJLZXJuZWxWYWx1ZUhUTUxWaWRlbyB9ID0gcmVxdWlyZSgnLi9rZXJuZWwtdmFsdWUvaHRtbC12aWRlbycpO1xuY29uc3QgeyBXZWJHTDJLZXJuZWxWYWx1ZUR5bmFtaWNIVE1MVmlkZW8gfSA9IHJlcXVpcmUoJy4va2VybmVsLXZhbHVlL2R5bmFtaWMtaHRtbC12aWRlbycpO1xuXG5jb25zdCB7IFdlYkdMMktlcm5lbFZhbHVlU2luZ2xlSW5wdXQgfSA9IHJlcXVpcmUoJy4va2VybmVsLXZhbHVlL3NpbmdsZS1pbnB1dCcpO1xuY29uc3QgeyBXZWJHTDJLZXJuZWxWYWx1ZUR5bmFtaWNTaW5nbGVJbnB1dCB9ID0gcmVxdWlyZSgnLi9rZXJuZWwtdmFsdWUvZHluYW1pYy1zaW5nbGUtaW5wdXQnKTtcblxuY29uc3QgeyBXZWJHTDJLZXJuZWxWYWx1ZVVuc2lnbmVkSW5wdXQgfSA9IHJlcXVpcmUoJy4va2VybmVsLXZhbHVlL3Vuc2lnbmVkLWlucHV0Jyk7XG5jb25zdCB7IFdlYkdMMktlcm5lbFZhbHVlRHluYW1pY1Vuc2lnbmVkSW5wdXQgfSA9IHJlcXVpcmUoJy4va2VybmVsLXZhbHVlL2R5bmFtaWMtdW5zaWduZWQtaW5wdXQnKTtcblxuY29uc3QgeyBXZWJHTDJLZXJuZWxWYWx1ZU1lbW9yeU9wdGltaXplZE51bWJlclRleHR1cmUgfSA9IHJlcXVpcmUoJy4va2VybmVsLXZhbHVlL21lbW9yeS1vcHRpbWl6ZWQtbnVtYmVyLXRleHR1cmUnKTtcbmNvbnN0IHsgV2ViR0wyS2VybmVsVmFsdWVEeW5hbWljTWVtb3J5T3B0aW1pemVkTnVtYmVyVGV4dHVyZSB9ID0gcmVxdWlyZSgnLi9rZXJuZWwtdmFsdWUvZHluYW1pYy1tZW1vcnktb3B0aW1pemVkLW51bWJlci10ZXh0dXJlJyk7XG5cbmNvbnN0IHsgV2ViR0wyS2VybmVsVmFsdWVOdW1iZXJUZXh0dXJlIH0gPSByZXF1aXJlKCcuL2tlcm5lbC12YWx1ZS9udW1iZXItdGV4dHVyZScpO1xuY29uc3QgeyBXZWJHTDJLZXJuZWxWYWx1ZUR5bmFtaWNOdW1iZXJUZXh0dXJlIH0gPSByZXF1aXJlKCcuL2tlcm5lbC12YWx1ZS9keW5hbWljLW51bWJlci10ZXh0dXJlJyk7XG5cbmNvbnN0IHsgV2ViR0wyS2VybmVsVmFsdWVTaW5nbGVBcnJheSB9ID0gcmVxdWlyZSgnLi9rZXJuZWwtdmFsdWUvc2luZ2xlLWFycmF5Jyk7XG5jb25zdCB7IFdlYkdMMktlcm5lbFZhbHVlRHluYW1pY1NpbmdsZUFycmF5IH0gPSByZXF1aXJlKCcuL2tlcm5lbC12YWx1ZS9keW5hbWljLXNpbmdsZS1hcnJheScpO1xuXG5jb25zdCB7IFdlYkdMMktlcm5lbFZhbHVlU2luZ2xlQXJyYXkxREkgfSA9IHJlcXVpcmUoJy4va2VybmVsLXZhbHVlL3NpbmdsZS1hcnJheTFkLWknKTtcbmNvbnN0IHsgV2ViR0wyS2VybmVsVmFsdWVEeW5hbWljU2luZ2xlQXJyYXkxREkgfSA9IHJlcXVpcmUoJy4va2VybmVsLXZhbHVlL2R5bmFtaWMtc2luZ2xlLWFycmF5MWQtaScpO1xuXG5jb25zdCB7IFdlYkdMMktlcm5lbFZhbHVlU2luZ2xlQXJyYXkyREkgfSA9IHJlcXVpcmUoJy4va2VybmVsLXZhbHVlL3NpbmdsZS1hcnJheTJkLWknKTtcbmNvbnN0IHsgV2ViR0wyS2VybmVsVmFsdWVEeW5hbWljU2luZ2xlQXJyYXkyREkgfSA9IHJlcXVpcmUoJy4va2VybmVsLXZhbHVlL2R5bmFtaWMtc2luZ2xlLWFycmF5MmQtaScpO1xuXG5jb25zdCB7IFdlYkdMMktlcm5lbFZhbHVlU2luZ2xlQXJyYXkzREkgfSA9IHJlcXVpcmUoJy4va2VybmVsLXZhbHVlL3NpbmdsZS1hcnJheTNkLWknKTtcbmNvbnN0IHsgV2ViR0wyS2VybmVsVmFsdWVEeW5hbWljU2luZ2xlQXJyYXkzREkgfSA9IHJlcXVpcmUoJy4va2VybmVsLXZhbHVlL2R5bmFtaWMtc2luZ2xlLWFycmF5M2QtaScpO1xuXG5jb25zdCB7IFdlYkdMMktlcm5lbFZhbHVlU2luZ2xlQXJyYXkyIH0gPSByZXF1aXJlKCcuL2tlcm5lbC12YWx1ZS9zaW5nbGUtYXJyYXkyJyk7XG5jb25zdCB7IFdlYkdMMktlcm5lbFZhbHVlU2luZ2xlQXJyYXkzIH0gPSByZXF1aXJlKCcuL2tlcm5lbC12YWx1ZS9zaW5nbGUtYXJyYXkzJyk7XG5jb25zdCB7IFdlYkdMMktlcm5lbFZhbHVlU2luZ2xlQXJyYXk0IH0gPSByZXF1aXJlKCcuL2tlcm5lbC12YWx1ZS9zaW5nbGUtYXJyYXk0Jyk7XG5cbmNvbnN0IHsgV2ViR0wyS2VybmVsVmFsdWVVbnNpZ25lZEFycmF5IH0gPSByZXF1aXJlKCcuL2tlcm5lbC12YWx1ZS91bnNpZ25lZC1hcnJheScpO1xuY29uc3QgeyBXZWJHTDJLZXJuZWxWYWx1ZUR5bmFtaWNVbnNpZ25lZEFycmF5IH0gPSByZXF1aXJlKCcuL2tlcm5lbC12YWx1ZS9keW5hbWljLXVuc2lnbmVkLWFycmF5Jyk7XG5cbmNvbnN0IGtlcm5lbFZhbHVlTWFwcyA9IHtcbiAgdW5zaWduZWQ6IHtcbiAgICBkeW5hbWljOiB7XG4gICAgICAnQm9vbGVhbic6IFdlYkdMMktlcm5lbFZhbHVlQm9vbGVhbixcbiAgICAgICdJbnRlZ2VyJzogV2ViR0wyS2VybmVsVmFsdWVJbnRlZ2VyLFxuICAgICAgJ0Zsb2F0JzogV2ViR0wyS2VybmVsVmFsdWVGbG9hdCxcbiAgICAgICdBcnJheSc6IFdlYkdMMktlcm5lbFZhbHVlRHluYW1pY1Vuc2lnbmVkQXJyYXksXG4gICAgICAnQXJyYXkoMiknOiBmYWxzZSxcbiAgICAgICdBcnJheSgzKSc6IGZhbHNlLFxuICAgICAgJ0FycmF5KDQpJzogZmFsc2UsXG4gICAgICAnQXJyYXkxRCgyKSc6IGZhbHNlLFxuICAgICAgJ0FycmF5MUQoMyknOiBmYWxzZSxcbiAgICAgICdBcnJheTFEKDQpJzogZmFsc2UsXG4gICAgICAnQXJyYXkyRCgyKSc6IGZhbHNlLFxuICAgICAgJ0FycmF5MkQoMyknOiBmYWxzZSxcbiAgICAgICdBcnJheTJEKDQpJzogZmFsc2UsXG4gICAgICAnQXJyYXkzRCgyKSc6IGZhbHNlLFxuICAgICAgJ0FycmF5M0QoMyknOiBmYWxzZSxcbiAgICAgICdBcnJheTNEKDQpJzogZmFsc2UsXG4gICAgICAnSW5wdXQnOiBXZWJHTDJLZXJuZWxWYWx1ZUR5bmFtaWNVbnNpZ25lZElucHV0LFxuICAgICAgJ051bWJlclRleHR1cmUnOiBXZWJHTDJLZXJuZWxWYWx1ZUR5bmFtaWNOdW1iZXJUZXh0dXJlLFxuICAgICAgJ0FycmF5VGV4dHVyZSgxKSc6IFdlYkdMMktlcm5lbFZhbHVlRHluYW1pY051bWJlclRleHR1cmUsXG4gICAgICAnQXJyYXlUZXh0dXJlKDIpJzogV2ViR0wyS2VybmVsVmFsdWVEeW5hbWljTnVtYmVyVGV4dHVyZSxcbiAgICAgICdBcnJheVRleHR1cmUoMyknOiBXZWJHTDJLZXJuZWxWYWx1ZUR5bmFtaWNOdW1iZXJUZXh0dXJlLFxuICAgICAgJ0FycmF5VGV4dHVyZSg0KSc6IFdlYkdMMktlcm5lbFZhbHVlRHluYW1pY051bWJlclRleHR1cmUsXG4gICAgICAnTWVtb3J5T3B0aW1pemVkTnVtYmVyVGV4dHVyZSc6IFdlYkdMMktlcm5lbFZhbHVlRHluYW1pY01lbW9yeU9wdGltaXplZE51bWJlclRleHR1cmUsXG4gICAgICAnSFRNTENhbnZhcyc6IFdlYkdMMktlcm5lbFZhbHVlRHluYW1pY0hUTUxJbWFnZSxcbiAgICAgICdIVE1MSW1hZ2UnOiBXZWJHTDJLZXJuZWxWYWx1ZUR5bmFtaWNIVE1MSW1hZ2UsXG4gICAgICAnSFRNTEltYWdlQXJyYXknOiBXZWJHTDJLZXJuZWxWYWx1ZUR5bmFtaWNIVE1MSW1hZ2VBcnJheSxcbiAgICAgICdIVE1MVmlkZW8nOiBXZWJHTDJLZXJuZWxWYWx1ZUR5bmFtaWNIVE1MVmlkZW8sXG4gICAgfSxcbiAgICBzdGF0aWM6IHtcbiAgICAgICdCb29sZWFuJzogV2ViR0wyS2VybmVsVmFsdWVCb29sZWFuLFxuICAgICAgJ0Zsb2F0JzogV2ViR0wyS2VybmVsVmFsdWVGbG9hdCxcbiAgICAgICdJbnRlZ2VyJzogV2ViR0wyS2VybmVsVmFsdWVJbnRlZ2VyLFxuICAgICAgJ0FycmF5JzogV2ViR0wyS2VybmVsVmFsdWVVbnNpZ25lZEFycmF5LFxuICAgICAgJ0FycmF5KDIpJzogZmFsc2UsXG4gICAgICAnQXJyYXkoMyknOiBmYWxzZSxcbiAgICAgICdBcnJheSg0KSc6IGZhbHNlLFxuICAgICAgJ0FycmF5MUQoMiknOiBmYWxzZSxcbiAgICAgICdBcnJheTFEKDMpJzogZmFsc2UsXG4gICAgICAnQXJyYXkxRCg0KSc6IGZhbHNlLFxuICAgICAgJ0FycmF5MkQoMiknOiBmYWxzZSxcbiAgICAgICdBcnJheTJEKDMpJzogZmFsc2UsXG4gICAgICAnQXJyYXkyRCg0KSc6IGZhbHNlLFxuICAgICAgJ0FycmF5M0QoMiknOiBmYWxzZSxcbiAgICAgICdBcnJheTNEKDMpJzogZmFsc2UsXG4gICAgICAnQXJyYXkzRCg0KSc6IGZhbHNlLFxuICAgICAgJ0lucHV0JzogV2ViR0wyS2VybmVsVmFsdWVVbnNpZ25lZElucHV0LFxuICAgICAgJ051bWJlclRleHR1cmUnOiBXZWJHTDJLZXJuZWxWYWx1ZU51bWJlclRleHR1cmUsXG4gICAgICAnQXJyYXlUZXh0dXJlKDEpJzogV2ViR0wyS2VybmVsVmFsdWVOdW1iZXJUZXh0dXJlLFxuICAgICAgJ0FycmF5VGV4dHVyZSgyKSc6IFdlYkdMMktlcm5lbFZhbHVlTnVtYmVyVGV4dHVyZSxcbiAgICAgICdBcnJheVRleHR1cmUoMyknOiBXZWJHTDJLZXJuZWxWYWx1ZU51bWJlclRleHR1cmUsXG4gICAgICAnQXJyYXlUZXh0dXJlKDQpJzogV2ViR0wyS2VybmVsVmFsdWVOdW1iZXJUZXh0dXJlLFxuICAgICAgJ01lbW9yeU9wdGltaXplZE51bWJlclRleHR1cmUnOiBXZWJHTDJLZXJuZWxWYWx1ZUR5bmFtaWNNZW1vcnlPcHRpbWl6ZWROdW1iZXJUZXh0dXJlLFxuICAgICAgJ0hUTUxDYW52YXMnOiBXZWJHTDJLZXJuZWxWYWx1ZUhUTUxJbWFnZSxcbiAgICAgICdIVE1MSW1hZ2UnOiBXZWJHTDJLZXJuZWxWYWx1ZUhUTUxJbWFnZSxcbiAgICAgICdIVE1MSW1hZ2VBcnJheSc6IFdlYkdMMktlcm5lbFZhbHVlSFRNTEltYWdlQXJyYXksXG4gICAgICAnSFRNTFZpZGVvJzogV2ViR0wyS2VybmVsVmFsdWVIVE1MVmlkZW8sXG4gICAgfVxuICB9LFxuICBzaW5nbGU6IHtcbiAgICBkeW5hbWljOiB7XG4gICAgICAnQm9vbGVhbic6IFdlYkdMMktlcm5lbFZhbHVlQm9vbGVhbixcbiAgICAgICdJbnRlZ2VyJzogV2ViR0wyS2VybmVsVmFsdWVJbnRlZ2VyLFxuICAgICAgJ0Zsb2F0JzogV2ViR0wyS2VybmVsVmFsdWVGbG9hdCxcbiAgICAgICdBcnJheSc6IFdlYkdMMktlcm5lbFZhbHVlRHluYW1pY1NpbmdsZUFycmF5LFxuICAgICAgJ0FycmF5KDIpJzogV2ViR0wyS2VybmVsVmFsdWVTaW5nbGVBcnJheTIsXG4gICAgICAnQXJyYXkoMyknOiBXZWJHTDJLZXJuZWxWYWx1ZVNpbmdsZUFycmF5MyxcbiAgICAgICdBcnJheSg0KSc6IFdlYkdMMktlcm5lbFZhbHVlU2luZ2xlQXJyYXk0LFxuICAgICAgJ0FycmF5MUQoMiknOiBXZWJHTDJLZXJuZWxWYWx1ZUR5bmFtaWNTaW5nbGVBcnJheTFESSxcbiAgICAgICdBcnJheTFEKDMpJzogV2ViR0wyS2VybmVsVmFsdWVEeW5hbWljU2luZ2xlQXJyYXkxREksXG4gICAgICAnQXJyYXkxRCg0KSc6IFdlYkdMMktlcm5lbFZhbHVlRHluYW1pY1NpbmdsZUFycmF5MURJLFxuICAgICAgJ0FycmF5MkQoMiknOiBXZWJHTDJLZXJuZWxWYWx1ZUR5bmFtaWNTaW5nbGVBcnJheTJESSxcbiAgICAgICdBcnJheTJEKDMpJzogV2ViR0wyS2VybmVsVmFsdWVEeW5hbWljU2luZ2xlQXJyYXkyREksXG4gICAgICAnQXJyYXkyRCg0KSc6IFdlYkdMMktlcm5lbFZhbHVlRHluYW1pY1NpbmdsZUFycmF5MkRJLFxuICAgICAgJ0FycmF5M0QoMiknOiBXZWJHTDJLZXJuZWxWYWx1ZUR5bmFtaWNTaW5nbGVBcnJheTNESSxcbiAgICAgICdBcnJheTNEKDMpJzogV2ViR0wyS2VybmVsVmFsdWVEeW5hbWljU2luZ2xlQXJyYXkzREksXG4gICAgICAnQXJyYXkzRCg0KSc6IFdlYkdMMktlcm5lbFZhbHVlRHluYW1pY1NpbmdsZUFycmF5M0RJLFxuICAgICAgJ0lucHV0JzogV2ViR0wyS2VybmVsVmFsdWVEeW5hbWljU2luZ2xlSW5wdXQsXG4gICAgICAnTnVtYmVyVGV4dHVyZSc6IFdlYkdMMktlcm5lbFZhbHVlRHluYW1pY051bWJlclRleHR1cmUsXG4gICAgICAnQXJyYXlUZXh0dXJlKDEpJzogV2ViR0wyS2VybmVsVmFsdWVEeW5hbWljTnVtYmVyVGV4dHVyZSxcbiAgICAgICdBcnJheVRleHR1cmUoMiknOiBXZWJHTDJLZXJuZWxWYWx1ZUR5bmFtaWNOdW1iZXJUZXh0dXJlLFxuICAgICAgJ0FycmF5VGV4dHVyZSgzKSc6IFdlYkdMMktlcm5lbFZhbHVlRHluYW1pY051bWJlclRleHR1cmUsXG4gICAgICAnQXJyYXlUZXh0dXJlKDQpJzogV2ViR0wyS2VybmVsVmFsdWVEeW5hbWljTnVtYmVyVGV4dHVyZSxcbiAgICAgICdNZW1vcnlPcHRpbWl6ZWROdW1iZXJUZXh0dXJlJzogV2ViR0wyS2VybmVsVmFsdWVEeW5hbWljTWVtb3J5T3B0aW1pemVkTnVtYmVyVGV4dHVyZSxcbiAgICAgICdIVE1MQ2FudmFzJzogV2ViR0wyS2VybmVsVmFsdWVEeW5hbWljSFRNTEltYWdlLFxuICAgICAgJ0hUTUxJbWFnZSc6IFdlYkdMMktlcm5lbFZhbHVlRHluYW1pY0hUTUxJbWFnZSxcbiAgICAgICdIVE1MSW1hZ2VBcnJheSc6IFdlYkdMMktlcm5lbFZhbHVlRHluYW1pY0hUTUxJbWFnZUFycmF5LFxuICAgICAgJ0hUTUxWaWRlbyc6IFdlYkdMMktlcm5lbFZhbHVlRHluYW1pY0hUTUxWaWRlbyxcbiAgICB9LFxuICAgIHN0YXRpYzoge1xuICAgICAgJ0Jvb2xlYW4nOiBXZWJHTDJLZXJuZWxWYWx1ZUJvb2xlYW4sXG4gICAgICAnRmxvYXQnOiBXZWJHTDJLZXJuZWxWYWx1ZUZsb2F0LFxuICAgICAgJ0ludGVnZXInOiBXZWJHTDJLZXJuZWxWYWx1ZUludGVnZXIsXG4gICAgICAnQXJyYXknOiBXZWJHTDJLZXJuZWxWYWx1ZVNpbmdsZUFycmF5LFxuICAgICAgJ0FycmF5KDIpJzogV2ViR0wyS2VybmVsVmFsdWVTaW5nbGVBcnJheTIsXG4gICAgICAnQXJyYXkoMyknOiBXZWJHTDJLZXJuZWxWYWx1ZVNpbmdsZUFycmF5MyxcbiAgICAgICdBcnJheSg0KSc6IFdlYkdMMktlcm5lbFZhbHVlU2luZ2xlQXJyYXk0LFxuICAgICAgJ0FycmF5MUQoMiknOiBXZWJHTDJLZXJuZWxWYWx1ZVNpbmdsZUFycmF5MURJLFxuICAgICAgJ0FycmF5MUQoMyknOiBXZWJHTDJLZXJuZWxWYWx1ZVNpbmdsZUFycmF5MURJLFxuICAgICAgJ0FycmF5MUQoNCknOiBXZWJHTDJLZXJuZWxWYWx1ZVNpbmdsZUFycmF5MURJLFxuICAgICAgJ0FycmF5MkQoMiknOiBXZWJHTDJLZXJuZWxWYWx1ZVNpbmdsZUFycmF5MkRJLFxuICAgICAgJ0FycmF5MkQoMyknOiBXZWJHTDJLZXJuZWxWYWx1ZVNpbmdsZUFycmF5MkRJLFxuICAgICAgJ0FycmF5MkQoNCknOiBXZWJHTDJLZXJuZWxWYWx1ZVNpbmdsZUFycmF5MkRJLFxuICAgICAgJ0FycmF5M0QoMiknOiBXZWJHTDJLZXJuZWxWYWx1ZVNpbmdsZUFycmF5M0RJLFxuICAgICAgJ0FycmF5M0QoMyknOiBXZWJHTDJLZXJuZWxWYWx1ZVNpbmdsZUFycmF5M0RJLFxuICAgICAgJ0FycmF5M0QoNCknOiBXZWJHTDJLZXJuZWxWYWx1ZVNpbmdsZUFycmF5M0RJLFxuICAgICAgJ0lucHV0JzogV2ViR0wyS2VybmVsVmFsdWVTaW5nbGVJbnB1dCxcbiAgICAgICdOdW1iZXJUZXh0dXJlJzogV2ViR0wyS2VybmVsVmFsdWVOdW1iZXJUZXh0dXJlLFxuICAgICAgJ0FycmF5VGV4dHVyZSgxKSc6IFdlYkdMMktlcm5lbFZhbHVlTnVtYmVyVGV4dHVyZSxcbiAgICAgICdBcnJheVRleHR1cmUoMiknOiBXZWJHTDJLZXJuZWxWYWx1ZU51bWJlclRleHR1cmUsXG4gICAgICAnQXJyYXlUZXh0dXJlKDMpJzogV2ViR0wyS2VybmVsVmFsdWVOdW1iZXJUZXh0dXJlLFxuICAgICAgJ0FycmF5VGV4dHVyZSg0KSc6IFdlYkdMMktlcm5lbFZhbHVlTnVtYmVyVGV4dHVyZSxcbiAgICAgICdNZW1vcnlPcHRpbWl6ZWROdW1iZXJUZXh0dXJlJzogV2ViR0wyS2VybmVsVmFsdWVNZW1vcnlPcHRpbWl6ZWROdW1iZXJUZXh0dXJlLFxuICAgICAgJ0hUTUxDYW52YXMnOiBXZWJHTDJLZXJuZWxWYWx1ZUhUTUxJbWFnZSxcbiAgICAgICdIVE1MSW1hZ2UnOiBXZWJHTDJLZXJuZWxWYWx1ZUhUTUxJbWFnZSxcbiAgICAgICdIVE1MSW1hZ2VBcnJheSc6IFdlYkdMMktlcm5lbFZhbHVlSFRNTEltYWdlQXJyYXksXG4gICAgICAnSFRNTFZpZGVvJzogV2ViR0wyS2VybmVsVmFsdWVIVE1MVmlkZW8sXG4gICAgfVxuICB9LFxufTtcblxuZnVuY3Rpb24gbG9va3VwS2VybmVsVmFsdWVUeXBlKHR5cGUsIGR5bmFtaWMsIHByZWNpc2lvbiwgdmFsdWUpIHtcbiAgaWYgKCF0eXBlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCd0eXBlIG1pc3NpbmcnKTtcbiAgfVxuICBpZiAoIWR5bmFtaWMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2R5bmFtaWMgbWlzc2luZycpO1xuICB9XG4gIGlmICghcHJlY2lzaW9uKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcmVjaXNpb24gbWlzc2luZycpO1xuICB9XG4gIGlmICh2YWx1ZS50eXBlKSB7XG4gICAgdHlwZSA9IHZhbHVlLnR5cGU7XG4gIH1cbiAgY29uc3QgdHlwZXMgPSBrZXJuZWxWYWx1ZU1hcHNbcHJlY2lzaW9uXVtkeW5hbWljXTtcbiAgaWYgKHR5cGVzW3R5cGVdID09PSBmYWxzZSkge1xuICAgIHJldHVybiBudWxsO1xuICB9IGVsc2UgaWYgKHR5cGVzW3R5cGVdID09PSB1bmRlZmluZWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYENvdWxkIG5vdCBmaW5kIGEgS2VybmVsVmFsdWUgZm9yICR7IHR5cGUgfWApO1xuICB9XG4gIHJldHVybiB0eXBlc1t0eXBlXTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGtlcm5lbFZhbHVlTWFwcyxcbiAgbG9va3VwS2VybmVsVmFsdWVUeXBlXG59O1xufSx7XCIuL2tlcm5lbC12YWx1ZS9ib29sZWFuXCI6NzUsXCIuL2tlcm5lbC12YWx1ZS9keW5hbWljLWh0bWwtaW1hZ2VcIjo3NyxcIi4va2VybmVsLXZhbHVlL2R5bmFtaWMtaHRtbC1pbWFnZS1hcnJheVwiOjc2LFwiLi9rZXJuZWwtdmFsdWUvZHluYW1pYy1odG1sLXZpZGVvXCI6NzgsXCIuL2tlcm5lbC12YWx1ZS9keW5hbWljLW1lbW9yeS1vcHRpbWl6ZWQtbnVtYmVyLXRleHR1cmVcIjo3OSxcIi4va2VybmVsLXZhbHVlL2R5bmFtaWMtbnVtYmVyLXRleHR1cmVcIjo4MCxcIi4va2VybmVsLXZhbHVlL2R5bmFtaWMtc2luZ2xlLWFycmF5XCI6ODEsXCIuL2tlcm5lbC12YWx1ZS9keW5hbWljLXNpbmdsZS1hcnJheTFkLWlcIjo4MixcIi4va2VybmVsLXZhbHVlL2R5bmFtaWMtc2luZ2xlLWFycmF5MmQtaVwiOjgzLFwiLi9rZXJuZWwtdmFsdWUvZHluYW1pYy1zaW5nbGUtYXJyYXkzZC1pXCI6ODQsXCIuL2tlcm5lbC12YWx1ZS9keW5hbWljLXNpbmdsZS1pbnB1dFwiOjg1LFwiLi9rZXJuZWwtdmFsdWUvZHluYW1pYy11bnNpZ25lZC1hcnJheVwiOjg2LFwiLi9rZXJuZWwtdmFsdWUvZHluYW1pYy11bnNpZ25lZC1pbnB1dFwiOjg3LFwiLi9rZXJuZWwtdmFsdWUvZmxvYXRcIjo4OCxcIi4va2VybmVsLXZhbHVlL2h0bWwtaW1hZ2VcIjo5MCxcIi4va2VybmVsLXZhbHVlL2h0bWwtaW1hZ2UtYXJyYXlcIjo4OSxcIi4va2VybmVsLXZhbHVlL2h0bWwtdmlkZW9cIjo5MSxcIi4va2VybmVsLXZhbHVlL2ludGVnZXJcIjo5MixcIi4va2VybmVsLXZhbHVlL21lbW9yeS1vcHRpbWl6ZWQtbnVtYmVyLXRleHR1cmVcIjo5MyxcIi4va2VybmVsLXZhbHVlL251bWJlci10ZXh0dXJlXCI6OTQsXCIuL2tlcm5lbC12YWx1ZS9zaW5nbGUtYXJyYXlcIjo5NSxcIi4va2VybmVsLXZhbHVlL3NpbmdsZS1hcnJheTFkLWlcIjo5NixcIi4va2VybmVsLXZhbHVlL3NpbmdsZS1hcnJheTJcIjo5NyxcIi4va2VybmVsLXZhbHVlL3NpbmdsZS1hcnJheTJkLWlcIjo5OCxcIi4va2VybmVsLXZhbHVlL3NpbmdsZS1hcnJheTNcIjo5OSxcIi4va2VybmVsLXZhbHVlL3NpbmdsZS1hcnJheTNkLWlcIjoxMDAsXCIuL2tlcm5lbC12YWx1ZS9zaW5nbGUtYXJyYXk0XCI6MTAxLFwiLi9rZXJuZWwtdmFsdWUvc2luZ2xlLWlucHV0XCI6MTAyLFwiLi9rZXJuZWwtdmFsdWUvdW5zaWduZWQtYXJyYXlcIjoxMDMsXCIuL2tlcm5lbC12YWx1ZS91bnNpZ25lZC1pbnB1dFwiOjEwNH1dLDc1OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbmNvbnN0IHsgV2ViR0xLZXJuZWxWYWx1ZUJvb2xlYW4gfSA9IHJlcXVpcmUoJy4uLy4uL3dlYi1nbC9rZXJuZWwtdmFsdWUvYm9vbGVhbicpO1xuXG5jbGFzcyBXZWJHTDJLZXJuZWxWYWx1ZUJvb2xlYW4gZXh0ZW5kcyBXZWJHTEtlcm5lbFZhbHVlQm9vbGVhbiB7fVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgV2ViR0wyS2VybmVsVmFsdWVCb29sZWFuXG59O1xufSx7XCIuLi8uLi93ZWItZ2wva2VybmVsLXZhbHVlL2Jvb2xlYW5cIjo0MX1dLDc2OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbmNvbnN0IHsgdXRpbHMgfSA9IHJlcXVpcmUoJy4uLy4uLy4uL3V0aWxzJyk7XG5jb25zdCB7IFdlYkdMMktlcm5lbFZhbHVlSFRNTEltYWdlQXJyYXkgfSA9IHJlcXVpcmUoJy4vaHRtbC1pbWFnZS1hcnJheScpO1xuXG5jbGFzcyBXZWJHTDJLZXJuZWxWYWx1ZUR5bmFtaWNIVE1MSW1hZ2VBcnJheSBleHRlbmRzIFdlYkdMMktlcm5lbFZhbHVlSFRNTEltYWdlQXJyYXkge1xuICBnZXRTb3VyY2UoKSB7XG4gICAgY29uc3QgdmFyaWFibGVQcmVjaXNpb24gPSB0aGlzLmdldFZhcmlhYmxlUHJlY2lzaW9uU3RyaW5nKCk7XG4gICAgcmV0dXJuIHV0aWxzLmxpbmVzVG9TdHJpbmcoW1xuICAgICAgYHVuaWZvcm0gJHsgdmFyaWFibGVQcmVjaXNpb24gfSBzYW1wbGVyMkRBcnJheSAke3RoaXMuaWR9YCxcbiAgICAgIGB1bmlmb3JtICR7IHZhcmlhYmxlUHJlY2lzaW9uIH0gaXZlYzIgJHt0aGlzLnNpemVJZH1gLFxuICAgICAgYHVuaWZvcm0gJHsgdmFyaWFibGVQcmVjaXNpb24gfSBpdmVjMyAke3RoaXMuZGltZW5zaW9uc0lkfWAsXG4gICAgXSk7XG4gIH1cblxuICB1cGRhdGVWYWx1ZShpbWFnZXMpIHtcbiAgICBjb25zdCB7IHdpZHRoLCBoZWlnaHQgfSA9IGltYWdlc1swXTtcbiAgICB0aGlzLmNoZWNrU2l6ZSh3aWR0aCwgaGVpZ2h0KTtcbiAgICB0aGlzLmRpbWVuc2lvbnMgPSBbd2lkdGgsIGhlaWdodCwgaW1hZ2VzLmxlbmd0aF07XG4gICAgdGhpcy50ZXh0dXJlU2l6ZSA9IFt3aWR0aCwgaGVpZ2h0XTtcbiAgICB0aGlzLmtlcm5lbC5zZXRVbmlmb3JtM2l2KHRoaXMuZGltZW5zaW9uc0lkLCB0aGlzLmRpbWVuc2lvbnMpO1xuICAgIHRoaXMua2VybmVsLnNldFVuaWZvcm0yaXYodGhpcy5zaXplSWQsIHRoaXMudGV4dHVyZVNpemUpO1xuICAgIHN1cGVyLnVwZGF0ZVZhbHVlKGltYWdlcyk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIFdlYkdMMktlcm5lbFZhbHVlRHluYW1pY0hUTUxJbWFnZUFycmF5XG59O1xufSx7XCIuLi8uLi8uLi91dGlsc1wiOjExNCxcIi4vaHRtbC1pbWFnZS1hcnJheVwiOjg5fV0sNzc6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuY29uc3QgeyB1dGlscyB9ID0gcmVxdWlyZSgnLi4vLi4vLi4vdXRpbHMnKTtcbmNvbnN0IHsgV2ViR0xLZXJuZWxWYWx1ZUR5bmFtaWNIVE1MSW1hZ2UgfSA9IHJlcXVpcmUoJy4uLy4uL3dlYi1nbC9rZXJuZWwtdmFsdWUvZHluYW1pYy1odG1sLWltYWdlJyk7XG5cbmNsYXNzIFdlYkdMMktlcm5lbFZhbHVlRHluYW1pY0hUTUxJbWFnZSBleHRlbmRzIFdlYkdMS2VybmVsVmFsdWVEeW5hbWljSFRNTEltYWdlIHtcbiAgZ2V0U291cmNlKCkge1xuICAgIGNvbnN0IHZhcmlhYmxlUHJlY2lzaW9uID0gdGhpcy5nZXRWYXJpYWJsZVByZWNpc2lvblN0cmluZygpO1xuICAgIHJldHVybiB1dGlscy5saW5lc1RvU3RyaW5nKFtcbiAgICAgIGB1bmlmb3JtICR7IHZhcmlhYmxlUHJlY2lzaW9uIH0gc2FtcGxlcjJEICR7dGhpcy5pZH1gLFxuICAgICAgYHVuaWZvcm0gJHsgdmFyaWFibGVQcmVjaXNpb24gfSBpdmVjMiAke3RoaXMuc2l6ZUlkfWAsXG4gICAgICBgdW5pZm9ybSAkeyB2YXJpYWJsZVByZWNpc2lvbiB9IGl2ZWMzICR7dGhpcy5kaW1lbnNpb25zSWR9YCxcbiAgICBdKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgV2ViR0wyS2VybmVsVmFsdWVEeW5hbWljSFRNTEltYWdlXG59O1xufSx7XCIuLi8uLi8uLi91dGlsc1wiOjExNCxcIi4uLy4uL3dlYi1nbC9rZXJuZWwtdmFsdWUvZHluYW1pYy1odG1sLWltYWdlXCI6NDJ9XSw3ODpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5jb25zdCB7IHV0aWxzIH0gPSByZXF1aXJlKCcuLi8uLi8uLi91dGlscycpO1xuY29uc3QgeyBXZWJHTDJLZXJuZWxWYWx1ZUR5bmFtaWNIVE1MSW1hZ2UgfSA9IHJlcXVpcmUoJy4vZHluYW1pYy1odG1sLWltYWdlJyk7XG5cbmNsYXNzIFdlYkdMMktlcm5lbFZhbHVlRHluYW1pY0hUTUxWaWRlbyBleHRlbmRzIFdlYkdMMktlcm5lbFZhbHVlRHluYW1pY0hUTUxJbWFnZSB7fVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgV2ViR0wyS2VybmVsVmFsdWVEeW5hbWljSFRNTFZpZGVvXG59O1xufSx7XCIuLi8uLi8uLi91dGlsc1wiOjExNCxcIi4vZHluYW1pYy1odG1sLWltYWdlXCI6Nzd9XSw3OTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5jb25zdCB7IHV0aWxzIH0gPSByZXF1aXJlKCcuLi8uLi8uLi91dGlscycpO1xuY29uc3QgeyBXZWJHTEtlcm5lbFZhbHVlRHluYW1pY01lbW9yeU9wdGltaXplZE51bWJlclRleHR1cmUgfSA9IHJlcXVpcmUoJy4uLy4uL3dlYi1nbC9rZXJuZWwtdmFsdWUvZHluYW1pYy1tZW1vcnktb3B0aW1pemVkLW51bWJlci10ZXh0dXJlJyk7XG5cbmNsYXNzIFdlYkdMMktlcm5lbFZhbHVlRHluYW1pY01lbW9yeU9wdGltaXplZE51bWJlclRleHR1cmUgZXh0ZW5kcyBXZWJHTEtlcm5lbFZhbHVlRHluYW1pY01lbW9yeU9wdGltaXplZE51bWJlclRleHR1cmUge1xuICBnZXRTb3VyY2UoKSB7XG4gICAgcmV0dXJuIHV0aWxzLmxpbmVzVG9TdHJpbmcoW1xuICAgICAgYHVuaWZvcm0gc2FtcGxlcjJEICR7dGhpcy5pZH1gLFxuICAgICAgYHVuaWZvcm0gaXZlYzIgJHt0aGlzLnNpemVJZH1gLFxuICAgICAgYHVuaWZvcm0gaXZlYzMgJHt0aGlzLmRpbWVuc2lvbnNJZH1gLFxuICAgIF0pO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBXZWJHTDJLZXJuZWxWYWx1ZUR5bmFtaWNNZW1vcnlPcHRpbWl6ZWROdW1iZXJUZXh0dXJlXG59O1xufSx7XCIuLi8uLi8uLi91dGlsc1wiOjExNCxcIi4uLy4uL3dlYi1nbC9rZXJuZWwtdmFsdWUvZHluYW1pYy1tZW1vcnktb3B0aW1pemVkLW51bWJlci10ZXh0dXJlXCI6NDR9XSw4MDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5jb25zdCB7IHV0aWxzIH0gPSByZXF1aXJlKCcuLi8uLi8uLi91dGlscycpO1xuY29uc3QgeyBXZWJHTEtlcm5lbFZhbHVlRHluYW1pY051bWJlclRleHR1cmUgfSA9IHJlcXVpcmUoJy4uLy4uL3dlYi1nbC9rZXJuZWwtdmFsdWUvZHluYW1pYy1udW1iZXItdGV4dHVyZScpO1xuXG5jbGFzcyBXZWJHTDJLZXJuZWxWYWx1ZUR5bmFtaWNOdW1iZXJUZXh0dXJlIGV4dGVuZHMgV2ViR0xLZXJuZWxWYWx1ZUR5bmFtaWNOdW1iZXJUZXh0dXJlIHtcbiAgZ2V0U291cmNlKCkge1xuICAgIGNvbnN0IHZhcmlhYmxlUHJlY2lzaW9uID0gdGhpcy5nZXRWYXJpYWJsZVByZWNpc2lvblN0cmluZygpO1xuICAgIHJldHVybiB1dGlscy5saW5lc1RvU3RyaW5nKFtcbiAgICAgIGB1bmlmb3JtICR7IHZhcmlhYmxlUHJlY2lzaW9uIH0gc2FtcGxlcjJEICR7dGhpcy5pZH1gLFxuICAgICAgYHVuaWZvcm0gJHsgdmFyaWFibGVQcmVjaXNpb24gfSBpdmVjMiAke3RoaXMuc2l6ZUlkfWAsXG4gICAgICBgdW5pZm9ybSAkeyB2YXJpYWJsZVByZWNpc2lvbiB9IGl2ZWMzICR7dGhpcy5kaW1lbnNpb25zSWR9YCxcbiAgICBdKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgV2ViR0wyS2VybmVsVmFsdWVEeW5hbWljTnVtYmVyVGV4dHVyZVxufTtcbn0se1wiLi4vLi4vLi4vdXRpbHNcIjoxMTQsXCIuLi8uLi93ZWItZ2wva2VybmVsLXZhbHVlL2R5bmFtaWMtbnVtYmVyLXRleHR1cmVcIjo0NX1dLDgxOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbmNvbnN0IHsgdXRpbHMgfSA9IHJlcXVpcmUoJy4uLy4uLy4uL3V0aWxzJyk7XG5jb25zdCB7IFdlYkdMMktlcm5lbFZhbHVlU2luZ2xlQXJyYXkgfSA9IHJlcXVpcmUoJy4uLy4uL3dlYi1nbDIva2VybmVsLXZhbHVlL3NpbmdsZS1hcnJheScpO1xuXG5jbGFzcyBXZWJHTDJLZXJuZWxWYWx1ZUR5bmFtaWNTaW5nbGVBcnJheSBleHRlbmRzIFdlYkdMMktlcm5lbFZhbHVlU2luZ2xlQXJyYXkge1xuICBnZXRTb3VyY2UoKSB7XG4gICAgY29uc3QgdmFyaWFibGVQcmVjaXNpb24gPSB0aGlzLmdldFZhcmlhYmxlUHJlY2lzaW9uU3RyaW5nKCk7XG4gICAgcmV0dXJuIHV0aWxzLmxpbmVzVG9TdHJpbmcoW1xuICAgICAgYHVuaWZvcm0gJHsgdmFyaWFibGVQcmVjaXNpb24gfSBzYW1wbGVyMkQgJHt0aGlzLmlkfWAsXG4gICAgICBgdW5pZm9ybSAkeyB2YXJpYWJsZVByZWNpc2lvbiB9IGl2ZWMyICR7dGhpcy5zaXplSWR9YCxcbiAgICAgIGB1bmlmb3JtICR7IHZhcmlhYmxlUHJlY2lzaW9uIH0gaXZlYzMgJHt0aGlzLmRpbWVuc2lvbnNJZH1gLFxuICAgIF0pO1xuICB9XG5cbiAgdXBkYXRlVmFsdWUodmFsdWUpIHtcbiAgICB0aGlzLmRpbWVuc2lvbnMgPSB1dGlscy5nZXREaW1lbnNpb25zKHZhbHVlLCB0cnVlKTtcbiAgICB0aGlzLnRleHR1cmVTaXplID0gdXRpbHMuZ2V0TWVtb3J5T3B0aW1pemVkRmxvYXRUZXh0dXJlU2l6ZSh0aGlzLmRpbWVuc2lvbnMsIHRoaXMuYml0UmF0aW8pO1xuICAgIHRoaXMudXBsb2FkQXJyYXlMZW5ndGggPSB0aGlzLnRleHR1cmVTaXplWzBdICogdGhpcy50ZXh0dXJlU2l6ZVsxXSAqIHRoaXMuYml0UmF0aW87XG4gICAgdGhpcy5jaGVja1NpemUodGhpcy50ZXh0dXJlU2l6ZVswXSwgdGhpcy50ZXh0dXJlU2l6ZVsxXSk7XG4gICAgdGhpcy51cGxvYWRWYWx1ZSA9IG5ldyBGbG9hdDMyQXJyYXkodGhpcy51cGxvYWRBcnJheUxlbmd0aCk7XG4gICAgdGhpcy5rZXJuZWwuc2V0VW5pZm9ybTNpdih0aGlzLmRpbWVuc2lvbnNJZCwgdGhpcy5kaW1lbnNpb25zKTtcbiAgICB0aGlzLmtlcm5lbC5zZXRVbmlmb3JtMml2KHRoaXMuc2l6ZUlkLCB0aGlzLnRleHR1cmVTaXplKTtcbiAgICBzdXBlci51cGRhdGVWYWx1ZSh2YWx1ZSk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIFdlYkdMMktlcm5lbFZhbHVlRHluYW1pY1NpbmdsZUFycmF5XG59O1xufSx7XCIuLi8uLi8uLi91dGlsc1wiOjExNCxcIi4uLy4uL3dlYi1nbDIva2VybmVsLXZhbHVlL3NpbmdsZS1hcnJheVwiOjk1fV0sODI6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuY29uc3QgeyB1dGlscyB9ID0gcmVxdWlyZSgnLi4vLi4vLi4vdXRpbHMnKTtcbmNvbnN0IHsgV2ViR0wyS2VybmVsVmFsdWVTaW5nbGVBcnJheTFESSB9ID0gcmVxdWlyZSgnLi4vLi4vd2ViLWdsMi9rZXJuZWwtdmFsdWUvc2luZ2xlLWFycmF5MWQtaScpO1xuXG5jbGFzcyBXZWJHTDJLZXJuZWxWYWx1ZUR5bmFtaWNTaW5nbGVBcnJheTFESSBleHRlbmRzIFdlYkdMMktlcm5lbFZhbHVlU2luZ2xlQXJyYXkxREkge1xuICBnZXRTb3VyY2UoKSB7XG4gICAgY29uc3QgdmFyaWFibGVQcmVjaXNpb24gPSB0aGlzLmdldFZhcmlhYmxlUHJlY2lzaW9uU3RyaW5nKCk7XG4gICAgcmV0dXJuIHV0aWxzLmxpbmVzVG9TdHJpbmcoW1xuICAgICAgYHVuaWZvcm0gJHsgdmFyaWFibGVQcmVjaXNpb24gfSBzYW1wbGVyMkQgJHt0aGlzLmlkfWAsXG4gICAgICBgdW5pZm9ybSAkeyB2YXJpYWJsZVByZWNpc2lvbiB9IGl2ZWMyICR7dGhpcy5zaXplSWR9YCxcbiAgICAgIGB1bmlmb3JtICR7IHZhcmlhYmxlUHJlY2lzaW9uIH0gaXZlYzMgJHt0aGlzLmRpbWVuc2lvbnNJZH1gLFxuICAgIF0pO1xuICB9XG5cbiAgdXBkYXRlVmFsdWUodmFsdWUpIHtcbiAgICB0aGlzLnNldFNoYXBlKHZhbHVlKTtcbiAgICB0aGlzLmtlcm5lbC5zZXRVbmlmb3JtM2l2KHRoaXMuZGltZW5zaW9uc0lkLCB0aGlzLmRpbWVuc2lvbnMpO1xuICAgIHRoaXMua2VybmVsLnNldFVuaWZvcm0yaXYodGhpcy5zaXplSWQsIHRoaXMudGV4dHVyZVNpemUpO1xuICAgIHN1cGVyLnVwZGF0ZVZhbHVlKHZhbHVlKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgV2ViR0wyS2VybmVsVmFsdWVEeW5hbWljU2luZ2xlQXJyYXkxRElcbn07XG59LHtcIi4uLy4uLy4uL3V0aWxzXCI6MTE0LFwiLi4vLi4vd2ViLWdsMi9rZXJuZWwtdmFsdWUvc2luZ2xlLWFycmF5MWQtaVwiOjk2fV0sODM6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuY29uc3QgeyB1dGlscyB9ID0gcmVxdWlyZSgnLi4vLi4vLi4vdXRpbHMnKTtcbmNvbnN0IHsgV2ViR0wyS2VybmVsVmFsdWVTaW5nbGVBcnJheTJESSB9ID0gcmVxdWlyZSgnLi4vLi4vd2ViLWdsMi9rZXJuZWwtdmFsdWUvc2luZ2xlLWFycmF5MmQtaScpO1xuXG5jbGFzcyBXZWJHTDJLZXJuZWxWYWx1ZUR5bmFtaWNTaW5nbGVBcnJheTJESSBleHRlbmRzIFdlYkdMMktlcm5lbFZhbHVlU2luZ2xlQXJyYXkyREkge1xuICBnZXRTb3VyY2UoKSB7XG4gICAgY29uc3QgdmFyaWFibGVQcmVjaXNpb24gPSB0aGlzLmdldFZhcmlhYmxlUHJlY2lzaW9uU3RyaW5nKCk7XG4gICAgcmV0dXJuIHV0aWxzLmxpbmVzVG9TdHJpbmcoW1xuICAgICAgYHVuaWZvcm0gJHsgdmFyaWFibGVQcmVjaXNpb24gfSBzYW1wbGVyMkQgJHt0aGlzLmlkfWAsXG4gICAgICBgdW5pZm9ybSAkeyB2YXJpYWJsZVByZWNpc2lvbiB9IGl2ZWMyICR7dGhpcy5zaXplSWR9YCxcbiAgICAgIGB1bmlmb3JtICR7IHZhcmlhYmxlUHJlY2lzaW9uIH0gaXZlYzMgJHt0aGlzLmRpbWVuc2lvbnNJZH1gLFxuICAgIF0pO1xuICB9XG5cbiAgdXBkYXRlVmFsdWUodmFsdWUpIHtcbiAgICB0aGlzLnNldFNoYXBlKHZhbHVlKTtcbiAgICB0aGlzLmtlcm5lbC5zZXRVbmlmb3JtM2l2KHRoaXMuZGltZW5zaW9uc0lkLCB0aGlzLmRpbWVuc2lvbnMpO1xuICAgIHRoaXMua2VybmVsLnNldFVuaWZvcm0yaXYodGhpcy5zaXplSWQsIHRoaXMudGV4dHVyZVNpemUpO1xuICAgIHN1cGVyLnVwZGF0ZVZhbHVlKHZhbHVlKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgV2ViR0wyS2VybmVsVmFsdWVEeW5hbWljU2luZ2xlQXJyYXkyRElcbn07XG59LHtcIi4uLy4uLy4uL3V0aWxzXCI6MTE0LFwiLi4vLi4vd2ViLWdsMi9rZXJuZWwtdmFsdWUvc2luZ2xlLWFycmF5MmQtaVwiOjk4fV0sODQ6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuY29uc3QgeyB1dGlscyB9ID0gcmVxdWlyZSgnLi4vLi4vLi4vdXRpbHMnKTtcbmNvbnN0IHsgV2ViR0wyS2VybmVsVmFsdWVTaW5nbGVBcnJheTNESSB9ID0gcmVxdWlyZSgnLi4vLi4vd2ViLWdsMi9rZXJuZWwtdmFsdWUvc2luZ2xlLWFycmF5M2QtaScpO1xuXG5jbGFzcyBXZWJHTDJLZXJuZWxWYWx1ZUR5bmFtaWNTaW5nbGVBcnJheTNESSBleHRlbmRzIFdlYkdMMktlcm5lbFZhbHVlU2luZ2xlQXJyYXkzREkge1xuICBnZXRTb3VyY2UoKSB7XG4gICAgY29uc3QgdmFyaWFibGVQcmVjaXNpb24gPSB0aGlzLmdldFZhcmlhYmxlUHJlY2lzaW9uU3RyaW5nKCk7XG4gICAgcmV0dXJuIHV0aWxzLmxpbmVzVG9TdHJpbmcoW1xuICAgICAgYHVuaWZvcm0gJHsgdmFyaWFibGVQcmVjaXNpb24gfSBzYW1wbGVyMkQgJHt0aGlzLmlkfWAsXG4gICAgICBgdW5pZm9ybSAkeyB2YXJpYWJsZVByZWNpc2lvbiB9IGl2ZWMyICR7dGhpcy5zaXplSWR9YCxcbiAgICAgIGB1bmlmb3JtICR7IHZhcmlhYmxlUHJlY2lzaW9uIH0gaXZlYzMgJHt0aGlzLmRpbWVuc2lvbnNJZH1gLFxuICAgIF0pO1xuICB9XG5cbiAgdXBkYXRlVmFsdWUodmFsdWUpIHtcbiAgICB0aGlzLnNldFNoYXBlKHZhbHVlKTtcbiAgICB0aGlzLmtlcm5lbC5zZXRVbmlmb3JtM2l2KHRoaXMuZGltZW5zaW9uc0lkLCB0aGlzLmRpbWVuc2lvbnMpO1xuICAgIHRoaXMua2VybmVsLnNldFVuaWZvcm0yaXYodGhpcy5zaXplSWQsIHRoaXMudGV4dHVyZVNpemUpO1xuICAgIHN1cGVyLnVwZGF0ZVZhbHVlKHZhbHVlKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgV2ViR0wyS2VybmVsVmFsdWVEeW5hbWljU2luZ2xlQXJyYXkzRElcbn07XG59LHtcIi4uLy4uLy4uL3V0aWxzXCI6MTE0LFwiLi4vLi4vd2ViLWdsMi9rZXJuZWwtdmFsdWUvc2luZ2xlLWFycmF5M2QtaVwiOjEwMH1dLDg1OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbmNvbnN0IHsgdXRpbHMgfSA9IHJlcXVpcmUoJy4uLy4uLy4uL3V0aWxzJyk7XG5jb25zdCB7IFdlYkdMMktlcm5lbFZhbHVlU2luZ2xlSW5wdXQgfSA9IHJlcXVpcmUoJy4uLy4uL3dlYi1nbDIva2VybmVsLXZhbHVlL3NpbmdsZS1pbnB1dCcpO1xuXG5jbGFzcyBXZWJHTDJLZXJuZWxWYWx1ZUR5bmFtaWNTaW5nbGVJbnB1dCBleHRlbmRzIFdlYkdMMktlcm5lbFZhbHVlU2luZ2xlSW5wdXQge1xuICBnZXRTb3VyY2UoKSB7XG4gICAgY29uc3QgdmFyaWFibGVQcmVjaXNpb24gPSB0aGlzLmdldFZhcmlhYmxlUHJlY2lzaW9uU3RyaW5nKCk7XG4gICAgcmV0dXJuIHV0aWxzLmxpbmVzVG9TdHJpbmcoW1xuICAgICAgYHVuaWZvcm0gJHsgdmFyaWFibGVQcmVjaXNpb24gfSBzYW1wbGVyMkQgJHt0aGlzLmlkfWAsXG4gICAgICBgdW5pZm9ybSAkeyB2YXJpYWJsZVByZWNpc2lvbiB9IGl2ZWMyICR7dGhpcy5zaXplSWR9YCxcbiAgICAgIGB1bmlmb3JtICR7IHZhcmlhYmxlUHJlY2lzaW9uIH0gaXZlYzMgJHt0aGlzLmRpbWVuc2lvbnNJZH1gLFxuICAgIF0pO1xuICB9XG5cbiAgdXBkYXRlVmFsdWUodmFsdWUpIHtcbiAgICBsZXQgW3csIGgsIGRdID0gdmFsdWUuc2l6ZTtcbiAgICB0aGlzLmRpbWVuc2lvbnMgPSBuZXcgSW50MzJBcnJheShbdyB8fCAxLCBoIHx8IDEsIGQgfHwgMV0pO1xuICAgIHRoaXMudGV4dHVyZVNpemUgPSB1dGlscy5nZXRNZW1vcnlPcHRpbWl6ZWRGbG9hdFRleHR1cmVTaXplKHRoaXMuZGltZW5zaW9ucywgdGhpcy5iaXRSYXRpbyk7XG4gICAgdGhpcy51cGxvYWRBcnJheUxlbmd0aCA9IHRoaXMudGV4dHVyZVNpemVbMF0gKiB0aGlzLnRleHR1cmVTaXplWzFdICogdGhpcy5iaXRSYXRpbztcbiAgICB0aGlzLmNoZWNrU2l6ZSh0aGlzLnRleHR1cmVTaXplWzBdLCB0aGlzLnRleHR1cmVTaXplWzFdKTtcbiAgICB0aGlzLnVwbG9hZFZhbHVlID0gbmV3IEZsb2F0MzJBcnJheSh0aGlzLnVwbG9hZEFycmF5TGVuZ3RoKTtcbiAgICB0aGlzLmtlcm5lbC5zZXRVbmlmb3JtM2l2KHRoaXMuZGltZW5zaW9uc0lkLCB0aGlzLmRpbWVuc2lvbnMpO1xuICAgIHRoaXMua2VybmVsLnNldFVuaWZvcm0yaXYodGhpcy5zaXplSWQsIHRoaXMudGV4dHVyZVNpemUpO1xuICAgIHN1cGVyLnVwZGF0ZVZhbHVlKHZhbHVlKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgV2ViR0wyS2VybmVsVmFsdWVEeW5hbWljU2luZ2xlSW5wdXRcbn07XG59LHtcIi4uLy4uLy4uL3V0aWxzXCI6MTE0LFwiLi4vLi4vd2ViLWdsMi9rZXJuZWwtdmFsdWUvc2luZ2xlLWlucHV0XCI6MTAyfV0sODY6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuY29uc3QgeyB1dGlscyB9ID0gcmVxdWlyZSgnLi4vLi4vLi4vdXRpbHMnKTtcbmNvbnN0IHsgV2ViR0xLZXJuZWxWYWx1ZUR5bmFtaWNVbnNpZ25lZEFycmF5IH0gPSByZXF1aXJlKCcuLi8uLi93ZWItZ2wva2VybmVsLXZhbHVlL2R5bmFtaWMtdW5zaWduZWQtYXJyYXknKTtcblxuY2xhc3MgV2ViR0wyS2VybmVsVmFsdWVEeW5hbWljVW5zaWduZWRBcnJheSBleHRlbmRzIFdlYkdMS2VybmVsVmFsdWVEeW5hbWljVW5zaWduZWRBcnJheSB7XG4gIGdldFNvdXJjZSgpIHtcbiAgICBjb25zdCB2YXJpYWJsZVByZWNpc2lvbiA9IHRoaXMuZ2V0VmFyaWFibGVQcmVjaXNpb25TdHJpbmcoKTtcbiAgICByZXR1cm4gdXRpbHMubGluZXNUb1N0cmluZyhbXG4gICAgICBgdW5pZm9ybSAkeyB2YXJpYWJsZVByZWNpc2lvbiB9IHNhbXBsZXIyRCAke3RoaXMuaWR9YCxcbiAgICAgIGB1bmlmb3JtICR7IHZhcmlhYmxlUHJlY2lzaW9uIH0gaXZlYzIgJHt0aGlzLnNpemVJZH1gLFxuICAgICAgYHVuaWZvcm0gJHsgdmFyaWFibGVQcmVjaXNpb24gfSBpdmVjMyAke3RoaXMuZGltZW5zaW9uc0lkfWAsXG4gICAgXSk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIFdlYkdMMktlcm5lbFZhbHVlRHluYW1pY1Vuc2lnbmVkQXJyYXlcbn07XG59LHtcIi4uLy4uLy4uL3V0aWxzXCI6MTE0LFwiLi4vLi4vd2ViLWdsL2tlcm5lbC12YWx1ZS9keW5hbWljLXVuc2lnbmVkLWFycmF5XCI6NTF9XSw4NzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5jb25zdCB7IHV0aWxzIH0gPSByZXF1aXJlKCcuLi8uLi8uLi91dGlscycpO1xuY29uc3QgeyBXZWJHTEtlcm5lbFZhbHVlRHluYW1pY1Vuc2lnbmVkSW5wdXQgfSA9IHJlcXVpcmUoJy4uLy4uL3dlYi1nbC9rZXJuZWwtdmFsdWUvZHluYW1pYy11bnNpZ25lZC1pbnB1dCcpO1xuXG5jbGFzcyBXZWJHTDJLZXJuZWxWYWx1ZUR5bmFtaWNVbnNpZ25lZElucHV0IGV4dGVuZHMgV2ViR0xLZXJuZWxWYWx1ZUR5bmFtaWNVbnNpZ25lZElucHV0IHtcbiAgZ2V0U291cmNlKCkge1xuICAgIGNvbnN0IHZhcmlhYmxlUHJlY2lzaW9uID0gdGhpcy5nZXRWYXJpYWJsZVByZWNpc2lvblN0cmluZygpO1xuICAgIHJldHVybiB1dGlscy5saW5lc1RvU3RyaW5nKFtcbiAgICAgIGB1bmlmb3JtICR7IHZhcmlhYmxlUHJlY2lzaW9uIH0gc2FtcGxlcjJEICR7dGhpcy5pZH1gLFxuICAgICAgYHVuaWZvcm0gJHsgdmFyaWFibGVQcmVjaXNpb24gfSBpdmVjMiAke3RoaXMuc2l6ZUlkfWAsXG4gICAgICBgdW5pZm9ybSAkeyB2YXJpYWJsZVByZWNpc2lvbiB9IGl2ZWMzICR7dGhpcy5kaW1lbnNpb25zSWR9YCxcbiAgICBdKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgV2ViR0wyS2VybmVsVmFsdWVEeW5hbWljVW5zaWduZWRJbnB1dFxufTtcbn0se1wiLi4vLi4vLi4vdXRpbHNcIjoxMTQsXCIuLi8uLi93ZWItZ2wva2VybmVsLXZhbHVlL2R5bmFtaWMtdW5zaWduZWQtaW5wdXRcIjo1Mn1dLDg4OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbmNvbnN0IHsgdXRpbHMgfSA9IHJlcXVpcmUoJy4uLy4uLy4uL3V0aWxzJyk7XG5jb25zdCB7IFdlYkdMS2VybmVsVmFsdWVGbG9hdCB9ID0gcmVxdWlyZSgnLi4vLi4vd2ViLWdsL2tlcm5lbC12YWx1ZS9mbG9hdCcpO1xuXG5jbGFzcyBXZWJHTDJLZXJuZWxWYWx1ZUZsb2F0IGV4dGVuZHMgV2ViR0xLZXJuZWxWYWx1ZUZsb2F0IHt9XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBXZWJHTDJLZXJuZWxWYWx1ZUZsb2F0XG59O1xufSx7XCIuLi8uLi8uLi91dGlsc1wiOjExNCxcIi4uLy4uL3dlYi1nbC9rZXJuZWwtdmFsdWUvZmxvYXRcIjo1M31dLDg5OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbmNvbnN0IHsgdXRpbHMgfSA9IHJlcXVpcmUoJy4uLy4uLy4uL3V0aWxzJyk7XG5jb25zdCB7IFdlYkdMS2VybmVsQXJyYXkgfSA9IHJlcXVpcmUoJy4uLy4uL3dlYi1nbC9rZXJuZWwtdmFsdWUvYXJyYXknKTtcblxuY2xhc3MgV2ViR0wyS2VybmVsVmFsdWVIVE1MSW1hZ2VBcnJheSBleHRlbmRzIFdlYkdMS2VybmVsQXJyYXkge1xuICBjb25zdHJ1Y3Rvcih2YWx1ZSwgc2V0dGluZ3MpIHtcbiAgICBzdXBlcih2YWx1ZSwgc2V0dGluZ3MpO1xuICAgIHRoaXMuY2hlY2tTaXplKHZhbHVlWzBdLndpZHRoLCB2YWx1ZVswXS5oZWlnaHQpO1xuICAgIHRoaXMuZGltZW5zaW9ucyA9IFt2YWx1ZVswXS53aWR0aCwgdmFsdWVbMF0uaGVpZ2h0LCB2YWx1ZS5sZW5ndGhdO1xuICAgIHRoaXMudGV4dHVyZVNpemUgPSBbdmFsdWVbMF0ud2lkdGgsIHZhbHVlWzBdLmhlaWdodF07XG4gIH1cbiAgZGVmaW5lVGV4dHVyZSgpIHtcbiAgICBjb25zdCB7IGNvbnRleHQ6IGdsIH0gPSB0aGlzO1xuICAgIGdsLmFjdGl2ZVRleHR1cmUodGhpcy5jb250ZXh0SGFuZGxlKTtcbiAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJEX0FSUkFZLCB0aGlzLnRleHR1cmUpO1xuICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRF9BUlJBWSwgZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCBnbC5ORUFSRVNUKTtcbiAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkRfQVJSQVksIGdsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgZ2wuTkVBUkVTVCk7XG4gIH1cblxuICBnZXRTdHJpbmdWYWx1ZUhhbmRsZXIoKSB7XG4gICAgcmV0dXJuIGBjb25zdCB1cGxvYWRWYWx1ZV8ke3RoaXMubmFtZX0gPSAke3RoaXMudmFyTmFtZX07XFxuYDtcbiAgfVxuICBnZXRTb3VyY2UoKSB7XG4gICAgY29uc3QgdmFyaWFibGVQcmVjaXNpb24gPSB0aGlzLmdldFZhcmlhYmxlUHJlY2lzaW9uU3RyaW5nKCk7XG4gICAgcmV0dXJuIHV0aWxzLmxpbmVzVG9TdHJpbmcoW1xuICAgICAgYHVuaWZvcm0gJHsgdmFyaWFibGVQcmVjaXNpb24gfSBzYW1wbGVyMkRBcnJheSAke3RoaXMuaWR9YCxcbiAgICAgIGAkeyB2YXJpYWJsZVByZWNpc2lvbiB9IGl2ZWMyICR7dGhpcy5zaXplSWR9ID0gaXZlYzIoJHt0aGlzLnRleHR1cmVTaXplWzBdfSwgJHt0aGlzLnRleHR1cmVTaXplWzFdfSlgLFxuICAgICAgYCR7IHZhcmlhYmxlUHJlY2lzaW9uIH0gaXZlYzMgJHt0aGlzLmRpbWVuc2lvbnNJZH0gPSBpdmVjMygke3RoaXMuZGltZW5zaW9uc1swXX0sICR7dGhpcy5kaW1lbnNpb25zWzFdfSwgJHt0aGlzLmRpbWVuc2lvbnNbMl19KWAsXG4gICAgXSk7XG4gIH1cblxuICB1cGRhdGVWYWx1ZShpbWFnZXMpIHtcbiAgICBjb25zdCB7IGNvbnRleHQ6IGdsIH0gPSB0aGlzO1xuICAgIGdsLmFjdGl2ZVRleHR1cmUodGhpcy5jb250ZXh0SGFuZGxlKTtcbiAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJEX0FSUkFZLCB0aGlzLnRleHR1cmUpO1xuICAgIGdsLnBpeGVsU3RvcmVpKGdsLlVOUEFDS19GTElQX1lfV0VCR0wsIHRydWUpO1xuICAgIGdsLnRleEltYWdlM0QoXG4gICAgICBnbC5URVhUVVJFXzJEX0FSUkFZLFxuICAgICAgMCxcbiAgICAgIGdsLlJHQkEsXG4gICAgICBpbWFnZXNbMF0ud2lkdGgsXG4gICAgICBpbWFnZXNbMF0uaGVpZ2h0LFxuICAgICAgaW1hZ2VzLmxlbmd0aCxcbiAgICAgIDAsXG4gICAgICBnbC5SR0JBLFxuICAgICAgZ2wuVU5TSUdORURfQllURSxcbiAgICAgIG51bGxcbiAgICApO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW1hZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCB4T2Zmc2V0ID0gMDtcbiAgICAgIGNvbnN0IHlPZmZzZXQgPSAwO1xuICAgICAgY29uc3QgaW1hZ2VEZXB0aCA9IDE7XG4gICAgICBnbC50ZXhTdWJJbWFnZTNEKFxuICAgICAgICBnbC5URVhUVVJFXzJEX0FSUkFZLFxuICAgICAgICAwLFxuICAgICAgICB4T2Zmc2V0LFxuICAgICAgICB5T2Zmc2V0LFxuICAgICAgICBpLFxuICAgICAgICBpbWFnZXNbaV0ud2lkdGgsXG4gICAgICAgIGltYWdlc1tpXS5oZWlnaHQsXG4gICAgICAgIGltYWdlRGVwdGgsXG4gICAgICAgIGdsLlJHQkEsXG4gICAgICAgIGdsLlVOU0lHTkVEX0JZVEUsXG4gICAgICAgIHRoaXMudXBsb2FkVmFsdWUgPSBpbWFnZXNbaV1cbiAgICAgICk7XG4gICAgfVxuICAgIHRoaXMua2VybmVsLnNldFVuaWZvcm0xaSh0aGlzLmlkLCB0aGlzLmluZGV4KTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgV2ViR0wyS2VybmVsVmFsdWVIVE1MSW1hZ2VBcnJheVxufTtcbn0se1wiLi4vLi4vLi4vdXRpbHNcIjoxMTQsXCIuLi8uLi93ZWItZ2wva2VybmVsLXZhbHVlL2FycmF5XCI6NDB9XSw5MDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5jb25zdCB7IHV0aWxzIH0gPSByZXF1aXJlKCcuLi8uLi8uLi91dGlscycpO1xuY29uc3QgeyBXZWJHTEtlcm5lbFZhbHVlSFRNTEltYWdlIH0gPSByZXF1aXJlKCcuLi8uLi93ZWItZ2wva2VybmVsLXZhbHVlL2h0bWwtaW1hZ2UnKTtcblxuY2xhc3MgV2ViR0wyS2VybmVsVmFsdWVIVE1MSW1hZ2UgZXh0ZW5kcyBXZWJHTEtlcm5lbFZhbHVlSFRNTEltYWdlIHtcbiAgZ2V0U291cmNlKCkge1xuICAgIGNvbnN0IHZhcmlhYmxlUHJlY2lzaW9uID0gdGhpcy5nZXRWYXJpYWJsZVByZWNpc2lvblN0cmluZygpO1xuICAgIHJldHVybiB1dGlscy5saW5lc1RvU3RyaW5nKFtcbiAgICAgIGB1bmlmb3JtICR7IHZhcmlhYmxlUHJlY2lzaW9uIH0gc2FtcGxlcjJEICR7dGhpcy5pZH1gLFxuICAgICAgYCR7IHZhcmlhYmxlUHJlY2lzaW9uIH0gaXZlYzIgJHt0aGlzLnNpemVJZH0gPSBpdmVjMigke3RoaXMudGV4dHVyZVNpemVbMF19LCAke3RoaXMudGV4dHVyZVNpemVbMV19KWAsXG4gICAgICBgJHsgdmFyaWFibGVQcmVjaXNpb24gfSBpdmVjMyAke3RoaXMuZGltZW5zaW9uc0lkfSA9IGl2ZWMzKCR7dGhpcy5kaW1lbnNpb25zWzBdfSwgJHt0aGlzLmRpbWVuc2lvbnNbMV19LCAke3RoaXMuZGltZW5zaW9uc1syXX0pYCxcbiAgICBdKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgV2ViR0wyS2VybmVsVmFsdWVIVE1MSW1hZ2Vcbn07XG59LHtcIi4uLy4uLy4uL3V0aWxzXCI6MTE0LFwiLi4vLi4vd2ViLWdsL2tlcm5lbC12YWx1ZS9odG1sLWltYWdlXCI6NTR9XSw5MTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5jb25zdCB7IHV0aWxzIH0gPSByZXF1aXJlKCcuLi8uLi8uLi91dGlscycpO1xuY29uc3QgeyBXZWJHTDJLZXJuZWxWYWx1ZUhUTUxJbWFnZSB9ID0gcmVxdWlyZSgnLi9odG1sLWltYWdlJyk7XG5cbmNsYXNzIFdlYkdMMktlcm5lbFZhbHVlSFRNTFZpZGVvIGV4dGVuZHMgV2ViR0wyS2VybmVsVmFsdWVIVE1MSW1hZ2Uge31cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIFdlYkdMMktlcm5lbFZhbHVlSFRNTFZpZGVvXG59O1xufSx7XCIuLi8uLi8uLi91dGlsc1wiOjExNCxcIi4vaHRtbC1pbWFnZVwiOjkwfV0sOTI6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuY29uc3QgeyBXZWJHTEtlcm5lbFZhbHVlSW50ZWdlciB9ID0gcmVxdWlyZSgnLi4vLi4vd2ViLWdsL2tlcm5lbC12YWx1ZS9pbnRlZ2VyJyk7XG5cbmNsYXNzIFdlYkdMMktlcm5lbFZhbHVlSW50ZWdlciBleHRlbmRzIFdlYkdMS2VybmVsVmFsdWVJbnRlZ2VyIHtcbiAgZ2V0U291cmNlKHZhbHVlKSB7XG4gICAgY29uc3QgdmFyaWFibGVQcmVjaXNpb24gPSB0aGlzLmdldFZhcmlhYmxlUHJlY2lzaW9uU3RyaW5nKCk7XG4gICAgaWYgKHRoaXMub3JpZ2luID09PSAnY29uc3RhbnRzJykge1xuICAgICAgcmV0dXJuIGBjb25zdCAkeyB2YXJpYWJsZVByZWNpc2lvbiB9IGludCAke3RoaXMuaWR9ID0gJHsgcGFyc2VJbnQodmFsdWUpIH07XFxuYDtcbiAgICB9XG4gICAgcmV0dXJuIGB1bmlmb3JtICR7IHZhcmlhYmxlUHJlY2lzaW9uIH0gaW50ICR7dGhpcy5pZH07XFxuYDtcbiAgfVxuXG4gIHVwZGF0ZVZhbHVlKHZhbHVlKSB7XG4gICAgaWYgKHRoaXMub3JpZ2luID09PSAnY29uc3RhbnRzJykgcmV0dXJuO1xuICAgIHRoaXMua2VybmVsLnNldFVuaWZvcm0xaSh0aGlzLmlkLCB0aGlzLnVwbG9hZFZhbHVlID0gdmFsdWUpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBXZWJHTDJLZXJuZWxWYWx1ZUludGVnZXJcbn07XG59LHtcIi4uLy4uL3dlYi1nbC9rZXJuZWwtdmFsdWUvaW50ZWdlclwiOjU3fV0sOTM6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuY29uc3QgeyB1dGlscyB9ID0gcmVxdWlyZSgnLi4vLi4vLi4vdXRpbHMnKTtcbmNvbnN0IHsgV2ViR0xLZXJuZWxWYWx1ZU1lbW9yeU9wdGltaXplZE51bWJlclRleHR1cmUgfSA9IHJlcXVpcmUoJy4uLy4uL3dlYi1nbC9rZXJuZWwtdmFsdWUvbWVtb3J5LW9wdGltaXplZC1udW1iZXItdGV4dHVyZScpO1xuXG5jbGFzcyBXZWJHTDJLZXJuZWxWYWx1ZU1lbW9yeU9wdGltaXplZE51bWJlclRleHR1cmUgZXh0ZW5kcyBXZWJHTEtlcm5lbFZhbHVlTWVtb3J5T3B0aW1pemVkTnVtYmVyVGV4dHVyZSB7XG4gIGdldFNvdXJjZSgpIHtcbiAgICBjb25zdCB7IGlkLCBzaXplSWQsIHRleHR1cmVTaXplLCBkaW1lbnNpb25zSWQsIGRpbWVuc2lvbnMgfSA9IHRoaXM7XG4gICAgY29uc3QgdmFyaWFibGVQcmVjaXNpb24gPSB0aGlzLmdldFZhcmlhYmxlUHJlY2lzaW9uU3RyaW5nKCk7XG4gICAgcmV0dXJuIHV0aWxzLmxpbmVzVG9TdHJpbmcoW1xuICAgICAgYHVuaWZvcm0gc2FtcGxlcjJEICR7aWR9YCxcbiAgICAgIGAkeyB2YXJpYWJsZVByZWNpc2lvbiB9IGl2ZWMyICR7c2l6ZUlkfSA9IGl2ZWMyKCR7dGV4dHVyZVNpemVbMF19LCAke3RleHR1cmVTaXplWzFdfSlgLFxuICAgICAgYCR7IHZhcmlhYmxlUHJlY2lzaW9uIH0gaXZlYzMgJHtkaW1lbnNpb25zSWR9ID0gaXZlYzMoJHtkaW1lbnNpb25zWzBdfSwgJHtkaW1lbnNpb25zWzFdfSwgJHtkaW1lbnNpb25zWzJdfSlgLFxuICAgIF0pO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBXZWJHTDJLZXJuZWxWYWx1ZU1lbW9yeU9wdGltaXplZE51bWJlclRleHR1cmVcbn07XG59LHtcIi4uLy4uLy4uL3V0aWxzXCI6MTE0LFwiLi4vLi4vd2ViLWdsL2tlcm5lbC12YWx1ZS9tZW1vcnktb3B0aW1pemVkLW51bWJlci10ZXh0dXJlXCI6NTh9XSw5NDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5jb25zdCB7IHV0aWxzIH0gPSByZXF1aXJlKCcuLi8uLi8uLi91dGlscycpO1xuY29uc3QgeyBXZWJHTEtlcm5lbFZhbHVlTnVtYmVyVGV4dHVyZSB9ID0gcmVxdWlyZSgnLi4vLi4vd2ViLWdsL2tlcm5lbC12YWx1ZS9udW1iZXItdGV4dHVyZScpO1xuXG5jbGFzcyBXZWJHTDJLZXJuZWxWYWx1ZU51bWJlclRleHR1cmUgZXh0ZW5kcyBXZWJHTEtlcm5lbFZhbHVlTnVtYmVyVGV4dHVyZSB7XG4gIGdldFNvdXJjZSgpIHtcbiAgICBjb25zdCB7IGlkLCBzaXplSWQsIHRleHR1cmVTaXplLCBkaW1lbnNpb25zSWQsIGRpbWVuc2lvbnMgfSA9IHRoaXM7XG4gICAgY29uc3QgdmFyaWFibGVQcmVjaXNpb24gPSB0aGlzLmdldFZhcmlhYmxlUHJlY2lzaW9uU3RyaW5nKCk7XG4gICAgcmV0dXJuIHV0aWxzLmxpbmVzVG9TdHJpbmcoW1xuICAgICAgYHVuaWZvcm0gJHsgdmFyaWFibGVQcmVjaXNpb24gfSBzYW1wbGVyMkQgJHtpZH1gLFxuICAgICAgYCR7IHZhcmlhYmxlUHJlY2lzaW9uIH0gaXZlYzIgJHtzaXplSWR9ID0gaXZlYzIoJHt0ZXh0dXJlU2l6ZVswXX0sICR7dGV4dHVyZVNpemVbMV19KWAsXG4gICAgICBgJHsgdmFyaWFibGVQcmVjaXNpb24gfSBpdmVjMyAke2RpbWVuc2lvbnNJZH0gPSBpdmVjMygke2RpbWVuc2lvbnNbMF19LCAke2RpbWVuc2lvbnNbMV19LCAke2RpbWVuc2lvbnNbMl19KWAsXG4gICAgXSk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIFdlYkdMMktlcm5lbFZhbHVlTnVtYmVyVGV4dHVyZVxufTtcbn0se1wiLi4vLi4vLi4vdXRpbHNcIjoxMTQsXCIuLi8uLi93ZWItZ2wva2VybmVsLXZhbHVlL251bWJlci10ZXh0dXJlXCI6NTl9XSw5NTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5jb25zdCB7IHV0aWxzIH0gPSByZXF1aXJlKCcuLi8uLi8uLi91dGlscycpO1xuY29uc3QgeyBXZWJHTEtlcm5lbFZhbHVlU2luZ2xlQXJyYXkgfSA9IHJlcXVpcmUoJy4uLy4uL3dlYi1nbC9rZXJuZWwtdmFsdWUvc2luZ2xlLWFycmF5Jyk7XG5cbmNsYXNzIFdlYkdMMktlcm5lbFZhbHVlU2luZ2xlQXJyYXkgZXh0ZW5kcyBXZWJHTEtlcm5lbFZhbHVlU2luZ2xlQXJyYXkge1xuICBnZXRTb3VyY2UoKSB7XG4gICAgY29uc3QgdmFyaWFibGVQcmVjaXNpb24gPSB0aGlzLmdldFZhcmlhYmxlUHJlY2lzaW9uU3RyaW5nKCk7XG4gICAgcmV0dXJuIHV0aWxzLmxpbmVzVG9TdHJpbmcoW1xuICAgICAgYHVuaWZvcm0gJHsgdmFyaWFibGVQcmVjaXNpb24gfSBzYW1wbGVyMkQgJHt0aGlzLmlkfWAsXG4gICAgICBgJHsgdmFyaWFibGVQcmVjaXNpb24gfSBpdmVjMiAke3RoaXMuc2l6ZUlkfSA9IGl2ZWMyKCR7dGhpcy50ZXh0dXJlU2l6ZVswXX0sICR7dGhpcy50ZXh0dXJlU2l6ZVsxXX0pYCxcbiAgICAgIGAkeyB2YXJpYWJsZVByZWNpc2lvbiB9IGl2ZWMzICR7dGhpcy5kaW1lbnNpb25zSWR9ID0gaXZlYzMoJHt0aGlzLmRpbWVuc2lvbnNbMF19LCAke3RoaXMuZGltZW5zaW9uc1sxXX0sICR7dGhpcy5kaW1lbnNpb25zWzJdfSlgLFxuICAgIF0pO1xuICB9XG5cbiAgdXBkYXRlVmFsdWUodmFsdWUpIHtcbiAgICBpZiAodmFsdWUuY29uc3RydWN0b3IgIT09IHRoaXMuaW5pdGlhbFZhbHVlQ29uc3RydWN0b3IpIHtcbiAgICAgIHRoaXMub25VcGRhdGVWYWx1ZU1pc21hdGNoKHZhbHVlLmNvbnN0cnVjdG9yKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgeyBjb250ZXh0OiBnbCB9ID0gdGhpcztcbiAgICB1dGlscy5mbGF0dGVuVG8odmFsdWUsIHRoaXMudXBsb2FkVmFsdWUpO1xuICAgIGdsLmFjdGl2ZVRleHR1cmUodGhpcy5jb250ZXh0SGFuZGxlKTtcbiAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0aGlzLnRleHR1cmUpO1xuICAgIGdsLnBpeGVsU3RvcmVpKGdsLlVOUEFDS19GTElQX1lfV0VCR0wsIGZhbHNlKTtcbiAgICBnbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIGdsLlJHQkEzMkYsIHRoaXMudGV4dHVyZVNpemVbMF0sIHRoaXMudGV4dHVyZVNpemVbMV0sIDAsIGdsLlJHQkEsIGdsLkZMT0FULCB0aGlzLnVwbG9hZFZhbHVlKTtcbiAgICB0aGlzLmtlcm5lbC5zZXRVbmlmb3JtMWkodGhpcy5pZCwgdGhpcy5pbmRleCk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIFdlYkdMMktlcm5lbFZhbHVlU2luZ2xlQXJyYXlcbn07XG59LHtcIi4uLy4uLy4uL3V0aWxzXCI6MTE0LFwiLi4vLi4vd2ViLWdsL2tlcm5lbC12YWx1ZS9zaW5nbGUtYXJyYXlcIjo2MH1dLDk2OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbmNvbnN0IHsgdXRpbHMgfSA9IHJlcXVpcmUoJy4uLy4uLy4uL3V0aWxzJyk7XG5jb25zdCB7IFdlYkdMS2VybmVsVmFsdWVTaW5nbGVBcnJheTFESSB9ID0gcmVxdWlyZSgnLi4vLi4vd2ViLWdsL2tlcm5lbC12YWx1ZS9zaW5nbGUtYXJyYXkxZC1pJyk7XG5cbmNsYXNzIFdlYkdMMktlcm5lbFZhbHVlU2luZ2xlQXJyYXkxREkgZXh0ZW5kcyBXZWJHTEtlcm5lbFZhbHVlU2luZ2xlQXJyYXkxREkge1xuICB1cGRhdGVWYWx1ZSh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZS5jb25zdHJ1Y3RvciAhPT0gdGhpcy5pbml0aWFsVmFsdWVDb25zdHJ1Y3Rvcikge1xuICAgICAgdGhpcy5vblVwZGF0ZVZhbHVlTWlzbWF0Y2godmFsdWUuY29uc3RydWN0b3IpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7IGNvbnRleHQ6IGdsIH0gPSB0aGlzO1xuICAgIHV0aWxzLmZsYXR0ZW5Ubyh2YWx1ZSwgdGhpcy51cGxvYWRWYWx1ZSk7XG4gICAgZ2wuYWN0aXZlVGV4dHVyZSh0aGlzLmNvbnRleHRIYW5kbGUpO1xuICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRoaXMudGV4dHVyZSk7XG4gICAgZ2wucGl4ZWxTdG9yZWkoZ2wuVU5QQUNLX0ZMSVBfWV9XRUJHTCwgZmFsc2UpO1xuICAgIGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgZ2wuUkdCQTMyRiwgdGhpcy50ZXh0dXJlU2l6ZVswXSwgdGhpcy50ZXh0dXJlU2l6ZVsxXSwgMCwgZ2wuUkdCQSwgZ2wuRkxPQVQsIHRoaXMudXBsb2FkVmFsdWUpO1xuICAgIHRoaXMua2VybmVsLnNldFVuaWZvcm0xaSh0aGlzLmlkLCB0aGlzLmluZGV4KTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgV2ViR0wyS2VybmVsVmFsdWVTaW5nbGVBcnJheTFESVxufTtcbn0se1wiLi4vLi4vLi4vdXRpbHNcIjoxMTQsXCIuLi8uLi93ZWItZ2wva2VybmVsLXZhbHVlL3NpbmdsZS1hcnJheTFkLWlcIjo2MX1dLDk3OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbmNvbnN0IHsgV2ViR0xLZXJuZWxWYWx1ZVNpbmdsZUFycmF5MiB9ID0gcmVxdWlyZSgnLi4vLi4vd2ViLWdsL2tlcm5lbC12YWx1ZS9zaW5nbGUtYXJyYXkyJyk7XG5cbmNsYXNzIFdlYkdMMktlcm5lbFZhbHVlU2luZ2xlQXJyYXkyIGV4dGVuZHMgV2ViR0xLZXJuZWxWYWx1ZVNpbmdsZUFycmF5MiB7fVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgV2ViR0wyS2VybmVsVmFsdWVTaW5nbGVBcnJheTJcbn07XG59LHtcIi4uLy4uL3dlYi1nbC9rZXJuZWwtdmFsdWUvc2luZ2xlLWFycmF5MlwiOjYyfV0sOTg6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuY29uc3QgeyB1dGlscyB9ID0gcmVxdWlyZSgnLi4vLi4vLi4vdXRpbHMnKTtcbmNvbnN0IHsgV2ViR0xLZXJuZWxWYWx1ZVNpbmdsZUFycmF5MkRJIH0gPSByZXF1aXJlKCcuLi8uLi93ZWItZ2wva2VybmVsLXZhbHVlL3NpbmdsZS1hcnJheTJkLWknKTtcblxuY2xhc3MgV2ViR0wyS2VybmVsVmFsdWVTaW5nbGVBcnJheTJESSBleHRlbmRzIFdlYkdMS2VybmVsVmFsdWVTaW5nbGVBcnJheTJESSB7XG4gIHVwZGF0ZVZhbHVlKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlLmNvbnN0cnVjdG9yICE9PSB0aGlzLmluaXRpYWxWYWx1ZUNvbnN0cnVjdG9yKSB7XG4gICAgICB0aGlzLm9uVXBkYXRlVmFsdWVNaXNtYXRjaCh2YWx1ZS5jb25zdHJ1Y3Rvcik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHsgY29udGV4dDogZ2wgfSA9IHRoaXM7XG4gICAgdXRpbHMuZmxhdHRlblRvKHZhbHVlLCB0aGlzLnVwbG9hZFZhbHVlKTtcbiAgICBnbC5hY3RpdmVUZXh0dXJlKHRoaXMuY29udGV4dEhhbmRsZSk7XG4gICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGhpcy50ZXh0dXJlKTtcbiAgICBnbC5waXhlbFN0b3JlaShnbC5VTlBBQ0tfRkxJUF9ZX1dFQkdMLCBmYWxzZSk7XG4gICAgZ2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCBnbC5SR0JBMzJGLCB0aGlzLnRleHR1cmVTaXplWzBdLCB0aGlzLnRleHR1cmVTaXplWzFdLCAwLCBnbC5SR0JBLCBnbC5GTE9BVCwgdGhpcy51cGxvYWRWYWx1ZSk7XG4gICAgdGhpcy5rZXJuZWwuc2V0VW5pZm9ybTFpKHRoaXMuaWQsIHRoaXMuaW5kZXgpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBXZWJHTDJLZXJuZWxWYWx1ZVNpbmdsZUFycmF5MkRJXG59O1xufSx7XCIuLi8uLi8uLi91dGlsc1wiOjExNCxcIi4uLy4uL3dlYi1nbC9rZXJuZWwtdmFsdWUvc2luZ2xlLWFycmF5MmQtaVwiOjYzfV0sOTk6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuY29uc3QgeyBXZWJHTEtlcm5lbFZhbHVlU2luZ2xlQXJyYXkzIH0gPSByZXF1aXJlKCcuLi8uLi93ZWItZ2wva2VybmVsLXZhbHVlL3NpbmdsZS1hcnJheTMnKTtcblxuY2xhc3MgV2ViR0wyS2VybmVsVmFsdWVTaW5nbGVBcnJheTMgZXh0ZW5kcyBXZWJHTEtlcm5lbFZhbHVlU2luZ2xlQXJyYXkzIHt9XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBXZWJHTDJLZXJuZWxWYWx1ZVNpbmdsZUFycmF5M1xufTtcbn0se1wiLi4vLi4vd2ViLWdsL2tlcm5lbC12YWx1ZS9zaW5nbGUtYXJyYXkzXCI6NjR9XSwxMDA6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuY29uc3QgeyB1dGlscyB9ID0gcmVxdWlyZSgnLi4vLi4vLi4vdXRpbHMnKTtcbmNvbnN0IHsgV2ViR0xLZXJuZWxWYWx1ZVNpbmdsZUFycmF5M0RJIH0gPSByZXF1aXJlKCcuLi8uLi93ZWItZ2wva2VybmVsLXZhbHVlL3NpbmdsZS1hcnJheTNkLWknKTtcblxuY2xhc3MgV2ViR0wyS2VybmVsVmFsdWVTaW5nbGVBcnJheTNESSBleHRlbmRzIFdlYkdMS2VybmVsVmFsdWVTaW5nbGVBcnJheTNESSB7XG4gIHVwZGF0ZVZhbHVlKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlLmNvbnN0cnVjdG9yICE9PSB0aGlzLmluaXRpYWxWYWx1ZUNvbnN0cnVjdG9yKSB7XG4gICAgICB0aGlzLm9uVXBkYXRlVmFsdWVNaXNtYXRjaCh2YWx1ZS5jb25zdHJ1Y3Rvcik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHsgY29udGV4dDogZ2wgfSA9IHRoaXM7XG4gICAgdXRpbHMuZmxhdHRlblRvKHZhbHVlLCB0aGlzLnVwbG9hZFZhbHVlKTtcbiAgICBnbC5hY3RpdmVUZXh0dXJlKHRoaXMuY29udGV4dEhhbmRsZSk7XG4gICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGhpcy50ZXh0dXJlKTtcbiAgICBnbC5waXhlbFN0b3JlaShnbC5VTlBBQ0tfRkxJUF9ZX1dFQkdMLCBmYWxzZSk7XG4gICAgZ2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCBnbC5SR0JBMzJGLCB0aGlzLnRleHR1cmVTaXplWzBdLCB0aGlzLnRleHR1cmVTaXplWzFdLCAwLCBnbC5SR0JBLCBnbC5GTE9BVCwgdGhpcy51cGxvYWRWYWx1ZSk7XG4gICAgdGhpcy5rZXJuZWwuc2V0VW5pZm9ybTFpKHRoaXMuaWQsIHRoaXMuaW5kZXgpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBXZWJHTDJLZXJuZWxWYWx1ZVNpbmdsZUFycmF5M0RJXG59O1xufSx7XCIuLi8uLi8uLi91dGlsc1wiOjExNCxcIi4uLy4uL3dlYi1nbC9rZXJuZWwtdmFsdWUvc2luZ2xlLWFycmF5M2QtaVwiOjY1fV0sMTAxOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbmNvbnN0IHsgV2ViR0xLZXJuZWxWYWx1ZVNpbmdsZUFycmF5NCB9ID0gcmVxdWlyZSgnLi4vLi4vd2ViLWdsL2tlcm5lbC12YWx1ZS9zaW5nbGUtYXJyYXk0Jyk7XG5cbmNsYXNzIFdlYkdMMktlcm5lbFZhbHVlU2luZ2xlQXJyYXk0IGV4dGVuZHMgV2ViR0xLZXJuZWxWYWx1ZVNpbmdsZUFycmF5NCB7fVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgV2ViR0wyS2VybmVsVmFsdWVTaW5nbGVBcnJheTRcbn07XG59LHtcIi4uLy4uL3dlYi1nbC9rZXJuZWwtdmFsdWUvc2luZ2xlLWFycmF5NFwiOjY2fV0sMTAyOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbmNvbnN0IHsgdXRpbHMgfSA9IHJlcXVpcmUoJy4uLy4uLy4uL3V0aWxzJyk7XG5jb25zdCB7IFdlYkdMS2VybmVsVmFsdWVTaW5nbGVJbnB1dCB9ID0gcmVxdWlyZSgnLi4vLi4vd2ViLWdsL2tlcm5lbC12YWx1ZS9zaW5nbGUtaW5wdXQnKTtcblxuY2xhc3MgV2ViR0wyS2VybmVsVmFsdWVTaW5nbGVJbnB1dCBleHRlbmRzIFdlYkdMS2VybmVsVmFsdWVTaW5nbGVJbnB1dCB7XG4gIGdldFNvdXJjZSgpIHtcbiAgICBjb25zdCB2YXJpYWJsZVByZWNpc2lvbiA9IHRoaXMuZ2V0VmFyaWFibGVQcmVjaXNpb25TdHJpbmcoKTtcbiAgICByZXR1cm4gdXRpbHMubGluZXNUb1N0cmluZyhbXG4gICAgICBgdW5pZm9ybSAkeyB2YXJpYWJsZVByZWNpc2lvbiB9IHNhbXBsZXIyRCAke3RoaXMuaWR9YCxcbiAgICAgIGAkeyB2YXJpYWJsZVByZWNpc2lvbiB9IGl2ZWMyICR7dGhpcy5zaXplSWR9ID0gaXZlYzIoJHt0aGlzLnRleHR1cmVTaXplWzBdfSwgJHt0aGlzLnRleHR1cmVTaXplWzFdfSlgLFxuICAgICAgYCR7IHZhcmlhYmxlUHJlY2lzaW9uIH0gaXZlYzMgJHt0aGlzLmRpbWVuc2lvbnNJZH0gPSBpdmVjMygke3RoaXMuZGltZW5zaW9uc1swXX0sICR7dGhpcy5kaW1lbnNpb25zWzFdfSwgJHt0aGlzLmRpbWVuc2lvbnNbMl19KWAsXG4gICAgXSk7XG4gIH1cblxuICB1cGRhdGVWYWx1ZShpbnB1dCkge1xuICAgIGNvbnN0IHsgY29udGV4dDogZ2wgfSA9IHRoaXM7XG4gICAgdXRpbHMuZmxhdHRlblRvKGlucHV0LnZhbHVlLCB0aGlzLnVwbG9hZFZhbHVlKTtcbiAgICBnbC5hY3RpdmVUZXh0dXJlKHRoaXMuY29udGV4dEhhbmRsZSk7XG4gICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGhpcy50ZXh0dXJlKTtcbiAgICBnbC5waXhlbFN0b3JlaShnbC5VTlBBQ0tfRkxJUF9ZX1dFQkdMLCBmYWxzZSk7XG4gICAgZ2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCBnbC5SR0JBMzJGLCB0aGlzLnRleHR1cmVTaXplWzBdLCB0aGlzLnRleHR1cmVTaXplWzFdLCAwLCBnbC5SR0JBLCBnbC5GTE9BVCwgdGhpcy51cGxvYWRWYWx1ZSk7XG4gICAgdGhpcy5rZXJuZWwuc2V0VW5pZm9ybTFpKHRoaXMuaWQsIHRoaXMuaW5kZXgpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBXZWJHTDJLZXJuZWxWYWx1ZVNpbmdsZUlucHV0XG59O1xufSx7XCIuLi8uLi8uLi91dGlsc1wiOjExNCxcIi4uLy4uL3dlYi1nbC9rZXJuZWwtdmFsdWUvc2luZ2xlLWlucHV0XCI6Njd9XSwxMDM6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuY29uc3QgeyB1dGlscyB9ID0gcmVxdWlyZSgnLi4vLi4vLi4vdXRpbHMnKTtcbmNvbnN0IHsgV2ViR0xLZXJuZWxWYWx1ZVVuc2lnbmVkQXJyYXkgfSA9IHJlcXVpcmUoJy4uLy4uL3dlYi1nbC9rZXJuZWwtdmFsdWUvdW5zaWduZWQtYXJyYXknKTtcblxuY2xhc3MgV2ViR0wyS2VybmVsVmFsdWVVbnNpZ25lZEFycmF5IGV4dGVuZHMgV2ViR0xLZXJuZWxWYWx1ZVVuc2lnbmVkQXJyYXkge1xuICBnZXRTb3VyY2UoKSB7XG4gICAgY29uc3QgdmFyaWFibGVQcmVjaXNpb24gPSB0aGlzLmdldFZhcmlhYmxlUHJlY2lzaW9uU3RyaW5nKCk7XG4gICAgcmV0dXJuIHV0aWxzLmxpbmVzVG9TdHJpbmcoW1xuICAgICAgYHVuaWZvcm0gJHsgdmFyaWFibGVQcmVjaXNpb24gfSBzYW1wbGVyMkQgJHt0aGlzLmlkfWAsXG4gICAgICBgJHsgdmFyaWFibGVQcmVjaXNpb24gfSBpdmVjMiAke3RoaXMuc2l6ZUlkfSA9IGl2ZWMyKCR7dGhpcy50ZXh0dXJlU2l6ZVswXX0sICR7dGhpcy50ZXh0dXJlU2l6ZVsxXX0pYCxcbiAgICAgIGAkeyB2YXJpYWJsZVByZWNpc2lvbiB9IGl2ZWMzICR7dGhpcy5kaW1lbnNpb25zSWR9ID0gaXZlYzMoJHt0aGlzLmRpbWVuc2lvbnNbMF19LCAke3RoaXMuZGltZW5zaW9uc1sxXX0sICR7dGhpcy5kaW1lbnNpb25zWzJdfSlgLFxuICAgIF0pO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBXZWJHTDJLZXJuZWxWYWx1ZVVuc2lnbmVkQXJyYXlcbn07XG59LHtcIi4uLy4uLy4uL3V0aWxzXCI6MTE0LFwiLi4vLi4vd2ViLWdsL2tlcm5lbC12YWx1ZS91bnNpZ25lZC1hcnJheVwiOjY4fV0sMTA0OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbmNvbnN0IHsgdXRpbHMgfSA9IHJlcXVpcmUoJy4uLy4uLy4uL3V0aWxzJyk7XG5jb25zdCB7IFdlYkdMS2VybmVsVmFsdWVVbnNpZ25lZElucHV0IH0gPSByZXF1aXJlKCcuLi8uLi93ZWItZ2wva2VybmVsLXZhbHVlL3Vuc2lnbmVkLWlucHV0Jyk7XG5cbmNsYXNzIFdlYkdMMktlcm5lbFZhbHVlVW5zaWduZWRJbnB1dCBleHRlbmRzIFdlYkdMS2VybmVsVmFsdWVVbnNpZ25lZElucHV0IHtcbiAgZ2V0U291cmNlKCkge1xuICAgIGNvbnN0IHZhcmlhYmxlUHJlY2lzaW9uID0gdGhpcy5nZXRWYXJpYWJsZVByZWNpc2lvblN0cmluZygpO1xuICAgIHJldHVybiB1dGlscy5saW5lc1RvU3RyaW5nKFtcbiAgICAgIGB1bmlmb3JtICR7IHZhcmlhYmxlUHJlY2lzaW9uIH0gc2FtcGxlcjJEICR7dGhpcy5pZH1gLFxuICAgICAgYCR7IHZhcmlhYmxlUHJlY2lzaW9uIH0gaXZlYzIgJHt0aGlzLnNpemVJZH0gPSBpdmVjMigke3RoaXMudGV4dHVyZVNpemVbMF19LCAke3RoaXMudGV4dHVyZVNpemVbMV19KWAsXG4gICAgICBgJHsgdmFyaWFibGVQcmVjaXNpb24gfSBpdmVjMyAke3RoaXMuZGltZW5zaW9uc0lkfSA9IGl2ZWMzKCR7dGhpcy5kaW1lbnNpb25zWzBdfSwgJHt0aGlzLmRpbWVuc2lvbnNbMV19LCAke3RoaXMuZGltZW5zaW9uc1syXX0pYCxcbiAgICBdKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgV2ViR0wyS2VybmVsVmFsdWVVbnNpZ25lZElucHV0XG59O1xufSx7XCIuLi8uLi8uLi91dGlsc1wiOjExNCxcIi4uLy4uL3dlYi1nbC9rZXJuZWwtdmFsdWUvdW5zaWduZWQtaW5wdXRcIjo2OX1dLDEwNTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5jb25zdCB7IFdlYkdMS2VybmVsIH0gPSByZXF1aXJlKCcuLi93ZWItZ2wva2VybmVsJyk7XG5jb25zdCB7IFdlYkdMMkZ1bmN0aW9uTm9kZSB9ID0gcmVxdWlyZSgnLi9mdW5jdGlvbi1ub2RlJyk7XG5jb25zdCB7IEZ1bmN0aW9uQnVpbGRlciB9ID0gcmVxdWlyZSgnLi4vZnVuY3Rpb24tYnVpbGRlcicpO1xuY29uc3QgeyB1dGlscyB9ID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMnKTtcbmNvbnN0IHsgZnJhZ21lbnRTaGFkZXIgfSA9IHJlcXVpcmUoJy4vZnJhZ21lbnQtc2hhZGVyJyk7XG5jb25zdCB7IHZlcnRleFNoYWRlciB9ID0gcmVxdWlyZSgnLi92ZXJ0ZXgtc2hhZGVyJyk7XG5jb25zdCB7IGxvb2t1cEtlcm5lbFZhbHVlVHlwZSB9ID0gcmVxdWlyZSgnLi9rZXJuZWwtdmFsdWUtbWFwcycpO1xuXG5sZXQgaXNTdXBwb3J0ZWQgPSBudWxsO1xubGV0IHRlc3RDYW52YXMgPSBudWxsO1xubGV0IHRlc3RDb250ZXh0ID0gbnVsbDtcbmxldCB0ZXN0RXh0ZW5zaW9ucyA9IG51bGw7XG5cbmxldCBmZWF0dXJlcyA9IG51bGw7XG5cbmNsYXNzIFdlYkdMMktlcm5lbCBleHRlbmRzIFdlYkdMS2VybmVsIHtcbiAgc3RhdGljIGdldCBpc1N1cHBvcnRlZCgpIHtcbiAgICBpZiAoaXNTdXBwb3J0ZWQgIT09IG51bGwpIHtcbiAgICAgIHJldHVybiBpc1N1cHBvcnRlZDtcbiAgICB9XG4gICAgdGhpcy5zZXR1cEZlYXR1cmVDaGVja3MoKTtcbiAgICBpc1N1cHBvcnRlZCA9IHRoaXMuaXNDb250ZXh0TWF0Y2godGVzdENvbnRleHQpO1xuICAgIHJldHVybiBpc1N1cHBvcnRlZDtcbiAgfVxuXG4gIHN0YXRpYyBzZXR1cEZlYXR1cmVDaGVja3MoKSB7XG4gICAgaWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRlc3RDYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBPZmZzY3JlZW5DYW52YXMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0ZXN0Q2FudmFzID0gbmV3IE9mZnNjcmVlbkNhbnZhcygwLCAwKTtcbiAgICB9XG4gICAgaWYgKCF0ZXN0Q2FudmFzKSByZXR1cm47XG4gICAgdGVzdENvbnRleHQgPSB0ZXN0Q2FudmFzLmdldENvbnRleHQoJ3dlYmdsMicpO1xuICAgIGlmICghdGVzdENvbnRleHQgfHwgIXRlc3RDb250ZXh0LmdldEV4dGVuc2lvbikgcmV0dXJuO1xuICAgIHRlc3RFeHRlbnNpb25zID0ge1xuICAgICAgRVhUX2NvbG9yX2J1ZmZlcl9mbG9hdDogdGVzdENvbnRleHQuZ2V0RXh0ZW5zaW9uKCdFWFRfY29sb3JfYnVmZmVyX2Zsb2F0JyksXG4gICAgICBPRVNfdGV4dHVyZV9mbG9hdF9saW5lYXI6IHRlc3RDb250ZXh0LmdldEV4dGVuc2lvbignT0VTX3RleHR1cmVfZmxvYXRfbGluZWFyJyksXG4gICAgfTtcbiAgICBmZWF0dXJlcyA9IHRoaXMuZ2V0RmVhdHVyZXMoKTtcbiAgfVxuXG4gIHN0YXRpYyBpc0NvbnRleHRNYXRjaChjb250ZXh0KSB7XG4gICAgaWYgKHR5cGVvZiBXZWJHTDJSZW5kZXJpbmdDb250ZXh0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgcmV0dXJuIGNvbnRleHQgaW5zdGFuY2VvZiBXZWJHTDJSZW5kZXJpbmdDb250ZXh0O1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBzdGF0aWMgZ2V0RmVhdHVyZXMoKSB7XG4gICAgY29uc3QgZ2wgPSB0aGlzLnRlc3RDb250ZXh0O1xuICAgIHJldHVybiBPYmplY3QuZnJlZXplKHtcbiAgICAgIGlzRmxvYXRSZWFkOiB0aGlzLmdldElzRmxvYXRSZWFkKCksXG4gICAgICBpc0ludGVnZXJEaXZpc2lvbkFjY3VyYXRlOiB0aGlzLmdldElzSW50ZWdlckRpdmlzaW9uQWNjdXJhdGUoKSxcbiAgICAgIGlzU3BlZWRUYWN0aWNTdXBwb3J0ZWQ6IHRoaXMuZ2V0SXNTcGVlZFRhY3RpY1N1cHBvcnRlZCgpLFxuICAgICAga2VybmVsTWFwOiB0cnVlLFxuICAgICAgaXNUZXh0dXJlRmxvYXQ6IHRydWUsXG4gICAgICBpc0RyYXdCdWZmZXJzOiB0cnVlLFxuICAgICAgY2hhbm5lbENvdW50OiB0aGlzLmdldENoYW5uZWxDb3VudCgpLFxuICAgICAgbWF4VGV4dHVyZVNpemU6IHRoaXMuZ2V0TWF4VGV4dHVyZVNpemUoKSxcbiAgICAgIGxvd0ludFByZWNpc2lvbjogZ2wuZ2V0U2hhZGVyUHJlY2lzaW9uRm9ybWF0KGdsLkZSQUdNRU5UX1NIQURFUiwgZ2wuTE9XX0lOVCksXG4gICAgICBsb3dGbG9hdFByZWNpc2lvbjogZ2wuZ2V0U2hhZGVyUHJlY2lzaW9uRm9ybWF0KGdsLkZSQUdNRU5UX1NIQURFUiwgZ2wuTE9XX0ZMT0FUKSxcbiAgICAgIG1lZGl1bUludFByZWNpc2lvbjogZ2wuZ2V0U2hhZGVyUHJlY2lzaW9uRm9ybWF0KGdsLkZSQUdNRU5UX1NIQURFUiwgZ2wuTUVESVVNX0lOVCksXG4gICAgICBtZWRpdW1GbG9hdFByZWNpc2lvbjogZ2wuZ2V0U2hhZGVyUHJlY2lzaW9uRm9ybWF0KGdsLkZSQUdNRU5UX1NIQURFUiwgZ2wuTUVESVVNX0ZMT0FUKSxcbiAgICAgIGhpZ2hJbnRQcmVjaXNpb246IGdsLmdldFNoYWRlclByZWNpc2lvbkZvcm1hdChnbC5GUkFHTUVOVF9TSEFERVIsIGdsLkhJR0hfSU5UKSxcbiAgICAgIGhpZ2hGbG9hdFByZWNpc2lvbjogZ2wuZ2V0U2hhZGVyUHJlY2lzaW9uRm9ybWF0KGdsLkZSQUdNRU5UX1NIQURFUiwgZ2wuSElHSF9GTE9BVCksXG4gICAgfSk7XG4gIH1cblxuICBzdGF0aWMgZ2V0SXNUZXh0dXJlRmxvYXQoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBzdGF0aWMgZ2V0Q2hhbm5lbENvdW50KCkge1xuICAgIHJldHVybiB0ZXN0Q29udGV4dC5nZXRQYXJhbWV0ZXIodGVzdENvbnRleHQuTUFYX0RSQVdfQlVGRkVSUyk7XG4gIH1cblxuICBzdGF0aWMgZ2V0TWF4VGV4dHVyZVNpemUoKSB7XG4gICAgcmV0dXJuIHRlc3RDb250ZXh0LmdldFBhcmFtZXRlcih0ZXN0Q29udGV4dC5NQVhfVEVYVFVSRV9TSVpFKTtcbiAgfVxuXG4gIHN0YXRpYyBsb29rdXBLZXJuZWxWYWx1ZVR5cGUodHlwZSwgZHluYW1pYywgcHJlY2lzaW9uLCB2YWx1ZSkge1xuICAgIHJldHVybiBsb29rdXBLZXJuZWxWYWx1ZVR5cGUodHlwZSwgZHluYW1pYywgcHJlY2lzaW9uLCB2YWx1ZSk7XG4gIH1cblxuICBzdGF0aWMgZ2V0IHRlc3RDYW52YXMoKSB7XG4gICAgcmV0dXJuIHRlc3RDYW52YXM7XG4gIH1cblxuICBzdGF0aWMgZ2V0IHRlc3RDb250ZXh0KCkge1xuICAgIHJldHVybiB0ZXN0Q29udGV4dDtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgZmVhdHVyZXMoKSB7XG4gICAgcmV0dXJuIGZlYXR1cmVzO1xuICB9XG5cbiAgc3RhdGljIGdldCBmcmFnbWVudFNoYWRlcigpIHtcbiAgICByZXR1cm4gZnJhZ21lbnRTaGFkZXI7XG4gIH1cbiAgc3RhdGljIGdldCB2ZXJ0ZXhTaGFkZXIoKSB7XG4gICAgcmV0dXJuIHZlcnRleFNoYWRlcjtcbiAgfVxuXG4gIGluaXRDb250ZXh0KCkge1xuICAgIGNvbnN0IHNldHRpbmdzID0ge1xuICAgICAgYWxwaGE6IGZhbHNlLFxuICAgICAgZGVwdGg6IGZhbHNlLFxuICAgICAgYW50aWFsaWFzOiBmYWxzZVxuICAgIH07XG4gICAgcmV0dXJuIHRoaXMuY2FudmFzLmdldENvbnRleHQoJ3dlYmdsMicsIHNldHRpbmdzKTtcbiAgfVxuXG4gIGluaXRFeHRlbnNpb25zKCkge1xuICAgIHRoaXMuZXh0ZW5zaW9ucyA9IHtcbiAgICAgIEVYVF9jb2xvcl9idWZmZXJfZmxvYXQ6IHRoaXMuY29udGV4dC5nZXRFeHRlbnNpb24oJ0VYVF9jb2xvcl9idWZmZXJfZmxvYXQnKSxcbiAgICAgIE9FU190ZXh0dXJlX2Zsb2F0X2xpbmVhcjogdGhpcy5jb250ZXh0LmdldEV4dGVuc2lvbignT0VTX3RleHR1cmVfZmxvYXRfbGluZWFyJyksXG4gICAgfTtcbiAgfVxuXG4gIHZhbGlkYXRlU2V0dGluZ3MoYXJncykge1xuICAgIGlmICghdGhpcy52YWxpZGF0ZSkge1xuICAgICAgdGhpcy50ZXhTaXplID0gdXRpbHMuZ2V0S2VybmVsVGV4dHVyZVNpemUoe1xuICAgICAgICBvcHRpbWl6ZUZsb2F0TWVtb3J5OiB0aGlzLm9wdGltaXplRmxvYXRNZW1vcnksXG4gICAgICAgIHByZWNpc2lvbjogdGhpcy5wcmVjaXNpb24sXG4gICAgICB9LCB0aGlzLm91dHB1dCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgeyBmZWF0dXJlcyB9ID0gdGhpcy5jb25zdHJ1Y3RvcjtcbiAgICBpZiAodGhpcy5wcmVjaXNpb24gPT09ICdzaW5nbGUnICYmICFmZWF0dXJlcy5pc0Zsb2F0UmVhZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdGbG9hdCB0ZXh0dXJlIG91dHB1dHMgYXJlIG5vdCBzdXBwb3J0ZWQnKTtcbiAgICB9IGVsc2UgaWYgKCF0aGlzLmdyYXBoaWNhbCAmJiB0aGlzLnByZWNpc2lvbiA9PT0gbnVsbCkge1xuICAgICAgdGhpcy5wcmVjaXNpb24gPSBmZWF0dXJlcy5pc0Zsb2F0UmVhZCA/ICdzaW5nbGUnIDogJ3Vuc2lnbmVkJztcbiAgICB9XG5cbiAgICBpZiAodGhpcy5maXhJbnRlZ2VyRGl2aXNpb25BY2N1cmFjeSA9PT0gbnVsbCkge1xuICAgICAgdGhpcy5maXhJbnRlZ2VyRGl2aXNpb25BY2N1cmFjeSA9ICFmZWF0dXJlcy5pc0ludGVnZXJEaXZpc2lvbkFjY3VyYXRlO1xuICAgIH0gZWxzZSBpZiAodGhpcy5maXhJbnRlZ2VyRGl2aXNpb25BY2N1cmFjeSAmJiBmZWF0dXJlcy5pc0ludGVnZXJEaXZpc2lvbkFjY3VyYXRlKSB7XG4gICAgICB0aGlzLmZpeEludGVnZXJEaXZpc2lvbkFjY3VyYWN5ID0gZmFsc2U7XG4gICAgfVxuXG4gICAgdGhpcy5jaGVja091dHB1dCgpO1xuXG4gICAgaWYgKCF0aGlzLm91dHB1dCB8fCB0aGlzLm91dHB1dC5sZW5ndGggPT09IDApIHtcbiAgICAgIGlmIChhcmdzLmxlbmd0aCAhPT0gMSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0F1dG8gb3V0cHV0IG9ubHkgc3VwcG9ydGVkIGZvciBrZXJuZWxzIHdpdGggb25seSBvbmUgaW5wdXQnKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgYXJnVHlwZSA9IHV0aWxzLmdldFZhcmlhYmxlVHlwZShhcmdzWzBdLCB0aGlzLnN0cmljdEludGVnZXJzKTtcbiAgICAgIHN3aXRjaCAoYXJnVHlwZSkge1xuICAgICAgICBjYXNlICdBcnJheSc6XG4gICAgICAgICAgdGhpcy5vdXRwdXQgPSB1dGlscy5nZXREaW1lbnNpb25zKGFyZ1R5cGUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdOdW1iZXJUZXh0dXJlJzpcbiAgICAgICAgY2FzZSAnTWVtb3J5T3B0aW1pemVkTnVtYmVyVGV4dHVyZSc6XG4gICAgICAgIGNhc2UgJ0FycmF5VGV4dHVyZSgxKSc6XG4gICAgICAgIGNhc2UgJ0FycmF5VGV4dHVyZSgyKSc6XG4gICAgICAgIGNhc2UgJ0FycmF5VGV4dHVyZSgzKSc6XG4gICAgICAgIGNhc2UgJ0FycmF5VGV4dHVyZSg0KSc6XG4gICAgICAgICAgdGhpcy5vdXRwdXQgPSBhcmdzWzBdLm91dHB1dDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0F1dG8gb3V0cHV0IG5vdCBzdXBwb3J0ZWQgZm9yIGlucHV0IHR5cGU6ICcgKyBhcmdUeXBlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5ncmFwaGljYWwpIHtcbiAgICAgIGlmICh0aGlzLm91dHB1dC5sZW5ndGggIT09IDIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdPdXRwdXQgbXVzdCBoYXZlIDIgZGltZW5zaW9ucyBvbiBncmFwaGljYWwgbW9kZScpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5wcmVjaXNpb24gPT09ICdzaW5nbGUnKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignQ2Fubm90IHVzZSBncmFwaGljYWwgbW9kZSBhbmQgc2luZ2xlIHByZWNpc2lvbiBhdCB0aGUgc2FtZSB0aW1lJyk7XG4gICAgICAgIHRoaXMucHJlY2lzaW9uID0gJ3Vuc2lnbmVkJztcbiAgICAgIH1cblxuICAgICAgdGhpcy50ZXhTaXplID0gdXRpbHMuY2xvbmUodGhpcy5vdXRwdXQpO1xuICAgICAgcmV0dXJuO1xuICAgIH0gZWxzZSBpZiAoIXRoaXMuZ3JhcGhpY2FsICYmIHRoaXMucHJlY2lzaW9uID09PSBudWxsICYmIGZlYXR1cmVzLmlzVGV4dHVyZUZsb2F0KSB7XG4gICAgICB0aGlzLnByZWNpc2lvbiA9ICdzaW5nbGUnO1xuICAgIH1cblxuICAgIHRoaXMudGV4U2l6ZSA9IHV0aWxzLmdldEtlcm5lbFRleHR1cmVTaXplKHtcbiAgICAgIG9wdGltaXplRmxvYXRNZW1vcnk6IHRoaXMub3B0aW1pemVGbG9hdE1lbW9yeSxcbiAgICAgIHByZWNpc2lvbjogdGhpcy5wcmVjaXNpb24sXG4gICAgfSwgdGhpcy5vdXRwdXQpO1xuXG4gICAgdGhpcy5jaGVja1RleHR1cmVTaXplKCk7XG4gIH1cblxuICB0cmFuc2xhdGVTb3VyY2UoKSB7XG4gICAgY29uc3QgZnVuY3Rpb25CdWlsZGVyID0gRnVuY3Rpb25CdWlsZGVyLmZyb21LZXJuZWwodGhpcywgV2ViR0wyRnVuY3Rpb25Ob2RlLCB7XG4gICAgICBmaXhJbnRlZ2VyRGl2aXNpb25BY2N1cmFjeTogdGhpcy5maXhJbnRlZ2VyRGl2aXNpb25BY2N1cmFjeVxuICAgIH0pO1xuICAgIHRoaXMudHJhbnNsYXRlZFNvdXJjZSA9IGZ1bmN0aW9uQnVpbGRlci5nZXRQcm90b3R5cGVTdHJpbmcoJ2tlcm5lbCcpO1xuICAgIHRoaXMuc2V0dXBSZXR1cm5UeXBlcyhmdW5jdGlvbkJ1aWxkZXIpO1xuICB9XG5cbiAgZHJhd0J1ZmZlcnMoKSB7XG4gICAgdGhpcy5jb250ZXh0LmRyYXdCdWZmZXJzKHRoaXMuZHJhd0J1ZmZlcnNNYXApO1xuICB9XG5cbiAgZ2V0VGV4dHVyZUZvcm1hdCgpIHtcbiAgICBjb25zdCB7IGNvbnRleHQ6IGdsIH0gPSB0aGlzO1xuICAgIHN3aXRjaCAodGhpcy5nZXRJbnRlcm5hbEZvcm1hdCgpKSB7XG4gICAgICBjYXNlIGdsLlIzMkY6XG4gICAgICAgIHJldHVybiBnbC5SRUQ7XG4gICAgICBjYXNlIGdsLlJHMzJGOlxuICAgICAgICByZXR1cm4gZ2wuUkc7XG4gICAgICBjYXNlIGdsLlJHQkEzMkY6XG4gICAgICAgIHJldHVybiBnbC5SR0JBO1xuICAgICAgY2FzZSBnbC5SR0JBOlxuICAgICAgICByZXR1cm4gZ2wuUkdCQTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBpbnRlcm5hbCBmb3JtYXQnKTtcbiAgICB9XG4gIH1cbiAgZ2V0SW50ZXJuYWxGb3JtYXQoKSB7XG4gICAgY29uc3QgeyBjb250ZXh0OiBnbCB9ID0gdGhpcztcblxuICAgIGlmICh0aGlzLnByZWNpc2lvbiA9PT0gJ3NpbmdsZScpIHtcbiAgICAgIGlmICh0aGlzLnBpcGVsaW5lKSB7XG4gICAgICAgIHN3aXRjaCAodGhpcy5yZXR1cm5UeXBlKSB7XG4gICAgICAgICAgY2FzZSAnTnVtYmVyJzpcbiAgICAgICAgICBjYXNlICdGbG9hdCc6XG4gICAgICAgICAgY2FzZSAnSW50ZWdlcic6XG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpbWl6ZUZsb2F0TWVtb3J5KSB7XG4gICAgICAgICAgICAgIHJldHVybiBnbC5SR0JBMzJGO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGdsLlIzMkY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlICdBcnJheSgyKSc6XG4gICAgICAgICAgICAgIHJldHVybiBnbC5SRzMyRjtcbiAgICAgICAgICAgIGNhc2UgJ0FycmF5KDMpJzogXG4gICAgICAgICAgICBjYXNlICdBcnJheSg0KSc6XG4gICAgICAgICAgICAgIHJldHVybiBnbC5SR0JBMzJGO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmhhbmRsZWQgcmV0dXJuIHR5cGUnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGdsLlJHQkEzMkY7XG4gICAgfVxuICAgIHJldHVybiBnbC5SR0JBO1xuICB9XG5cbiAgX3NldHVwT3V0cHV0VGV4dHVyZSgpIHtcbiAgICBjb25zdCBnbCA9IHRoaXMuY29udGV4dDtcbiAgICBpZiAodGhpcy50ZXh0dXJlKSB7XG4gICAgICBnbC5mcmFtZWJ1ZmZlclRleHR1cmUyRChnbC5GUkFNRUJVRkZFUiwgZ2wuQ09MT1JfQVRUQUNITUVOVDAsIGdsLlRFWFRVUkVfMkQsIHRoaXMudGV4dHVyZS50ZXh0dXJlLCAwKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCB0aGlzLmZyYW1lYnVmZmVyKTtcbiAgICBjb25zdCB0ZXh0dXJlID0gZ2wuY3JlYXRlVGV4dHVyZSgpO1xuICAgIGNvbnN0IHRleFNpemUgPSB0aGlzLnRleFNpemU7XG4gICAgZ2wuYWN0aXZlVGV4dHVyZShnbC5URVhUVVJFMCArIHRoaXMuY29uc3RhbnRUZXh0dXJlQ291bnQgKyB0aGlzLmFyZ3VtZW50VGV4dHVyZUNvdW50KTtcbiAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0ZXh0dXJlKTtcbiAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9TLCBnbC5SRVBFQVQpO1xuICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1QsIGdsLlJFUEVBVCk7XG4gICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01JTl9GSUxURVIsIGdsLk5FQVJFU1QpO1xuICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCBnbC5ORUFSRVNUKTtcbiAgICBjb25zdCBmb3JtYXQgPSB0aGlzLmdldEludGVybmFsRm9ybWF0KCk7XG4gICAgaWYgKHRoaXMucHJlY2lzaW9uID09PSAnc2luZ2xlJykge1xuICAgICAgZ2wudGV4U3RvcmFnZTJEKGdsLlRFWFRVUkVfMkQsIDEsIGZvcm1hdCwgdGV4U2l6ZVswXSwgdGV4U2l6ZVsxXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgZm9ybWF0LCB0ZXhTaXplWzBdLCB0ZXhTaXplWzFdLCAwLCBmb3JtYXQsIGdsLlVOU0lHTkVEX0JZVEUsIG51bGwpO1xuICAgIH1cbiAgICBnbC5mcmFtZWJ1ZmZlclRleHR1cmUyRChnbC5GUkFNRUJVRkZFUiwgZ2wuQ09MT1JfQVRUQUNITUVOVDAsIGdsLlRFWFRVUkVfMkQsIHRleHR1cmUsIDApO1xuICAgIHRoaXMudGV4dHVyZSA9IG5ldyB0aGlzLlRleHR1cmVDb25zdHJ1Y3Rvcih7XG4gICAgICB0ZXh0dXJlLFxuICAgICAgc2l6ZTogdGV4U2l6ZSxcbiAgICAgIGRpbWVuc2lvbnM6IHRoaXMudGhyZWFkRGltLFxuICAgICAgb3V0cHV0OiB0aGlzLm91dHB1dCxcbiAgICAgIGNvbnRleHQ6IHRoaXMuY29udGV4dCxcbiAgICAgIGludGVybmFsRm9ybWF0OiB0aGlzLmdldEludGVybmFsRm9ybWF0KCksXG4gICAgICB0ZXh0dXJlRm9ybWF0OiB0aGlzLmdldFRleHR1cmVGb3JtYXQoKSxcbiAgICAgIGtlcm5lbDogdGhpcyxcbiAgICB9KTtcbiAgfVxuXG4gIF9zZXR1cFN1Yk91dHB1dFRleHR1cmVzKCkge1xuICAgIGNvbnN0IGdsID0gdGhpcy5jb250ZXh0O1xuICAgIGlmICh0aGlzLm1hcHBlZFRleHR1cmVzKSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuc3ViS2VybmVscy5sZW5ndGg7IGkrKykge1xuICAgICAgICBnbC5mcmFtZWJ1ZmZlclRleHR1cmUyRChnbC5GUkFNRUJVRkZFUiwgZ2wuQ09MT1JfQVRUQUNITUVOVDAgKyBpICsgMSwgZ2wuVEVYVFVSRV8yRCwgdGhpcy5tYXBwZWRUZXh0dXJlc1tpXS50ZXh0dXJlLCAwKTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgdGV4U2l6ZSA9IHRoaXMudGV4U2l6ZTtcbiAgICB0aGlzLmRyYXdCdWZmZXJzTWFwID0gW2dsLkNPTE9SX0FUVEFDSE1FTlQwXTtcbiAgICB0aGlzLm1hcHBlZFRleHR1cmVzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnN1Yktlcm5lbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHRleHR1cmUgPSB0aGlzLmNyZWF0ZVRleHR1cmUoKTtcbiAgICAgIHRoaXMuZHJhd0J1ZmZlcnNNYXAucHVzaChnbC5DT0xPUl9BVFRBQ0hNRU5UMCArIGkgKyAxKTtcbiAgICAgIGdsLmFjdGl2ZVRleHR1cmUoZ2wuVEVYVFVSRTAgKyB0aGlzLmNvbnN0YW50VGV4dHVyZUNvdW50ICsgdGhpcy5hcmd1bWVudFRleHR1cmVDb3VudCArIGkpO1xuICAgICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGV4dHVyZSk7XG4gICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9TLCBnbC5DTEFNUF9UT19FREdFKTtcbiAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1QsIGdsLkNMQU1QX1RPX0VER0UpO1xuICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01JTl9GSUxURVIsIGdsLk5FQVJFU1QpO1xuICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01BR19GSUxURVIsIGdsLk5FQVJFU1QpO1xuICAgICAgY29uc3QgZm9ybWF0ID0gdGhpcy5nZXRJbnRlcm5hbEZvcm1hdCgpO1xuICAgICAgaWYgKHRoaXMucHJlY2lzaW9uID09PSAnc2luZ2xlJykge1xuICAgICAgICBnbC50ZXhTdG9yYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMSwgZm9ybWF0LCB0ZXhTaXplWzBdLCB0ZXhTaXplWzFdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgZ2wuUkdCQSwgdGV4U2l6ZVswXSwgdGV4U2l6ZVsxXSwgMCwgZ2wuUkdCQSwgZ2wuVU5TSUdORURfQllURSwgbnVsbCk7XG4gICAgICB9XG4gICAgICBnbC5mcmFtZWJ1ZmZlclRleHR1cmUyRChnbC5GUkFNRUJVRkZFUiwgZ2wuQ09MT1JfQVRUQUNITUVOVDAgKyBpICsgMSwgZ2wuVEVYVFVSRV8yRCwgdGV4dHVyZSwgMCk7XG5cbiAgICAgIHRoaXMubWFwcGVkVGV4dHVyZXMucHVzaChuZXcgdGhpcy5UZXh0dXJlQ29uc3RydWN0b3Ioe1xuICAgICAgICB0ZXh0dXJlLFxuICAgICAgICBzaXplOiB0ZXhTaXplLFxuICAgICAgICBkaW1lbnNpb25zOiB0aGlzLnRocmVhZERpbSxcbiAgICAgICAgb3V0cHV0OiB0aGlzLm91dHB1dCxcbiAgICAgICAgY29udGV4dDogdGhpcy5jb250ZXh0LFxuICAgICAgICBpbnRlcm5hbEZvcm1hdDogdGhpcy5nZXRJbnRlcm5hbEZvcm1hdCgpLFxuICAgICAgICB0ZXh0dXJlRm9ybWF0OiB0aGlzLmdldFRleHR1cmVGb3JtYXQoKSxcbiAgICAgICAga2VybmVsOiB0aGlzLFxuICAgICAgfSkpO1xuICAgIH1cbiAgfVxuXG4gIF9nZXRIZWFkZXJTdHJpbmcoKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgX2dldFRleHR1cmVDb29yZGluYXRlKCkge1xuICAgIGNvbnN0IHN1Yktlcm5lbHMgPSB0aGlzLnN1Yktlcm5lbHM7XG4gICAgY29uc3QgdmFyaWFibGVQcmVjaXNpb24gPSB0aGlzLmdldFZhcmlhYmxlUHJlY2lzaW9uU3RyaW5nKHRoaXMudGV4U2l6ZSwgdGhpcy50YWN0aWMpO1xuICAgIGlmIChzdWJLZXJuZWxzID09PSBudWxsIHx8IHN1Yktlcm5lbHMubGVuZ3RoIDwgMSkge1xuICAgICAgcmV0dXJuIGBpbiAkeyB2YXJpYWJsZVByZWNpc2lvbiB9IHZlYzIgdlRleENvb3JkO1xcbmA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBgb3V0ICR7IHZhcmlhYmxlUHJlY2lzaW9uIH0gdmVjMiB2VGV4Q29vcmQ7XFxuYDtcbiAgICB9XG4gIH1cblxuICBfZ2V0TWFpbkFyZ3VtZW50c1N0cmluZyhhcmdzKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgY29uc3QgYXJndW1lbnROYW1lcyA9IHRoaXMuYXJndW1lbnROYW1lcztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFyZ3VtZW50TmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHJlc3VsdC5wdXNoKHRoaXMua2VybmVsQXJndW1lbnRzW2ldLmdldFNvdXJjZShhcmdzW2ldKSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQuam9pbignJyk7XG4gIH1cblxuICBnZXRLZXJuZWxTdHJpbmcoKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gW3RoaXMuZ2V0S2VybmVsUmVzdWx0RGVjbGFyYXRpb24oKV07XG4gICAgY29uc3Qgc3ViS2VybmVscyA9IHRoaXMuc3ViS2VybmVscztcbiAgICBpZiAoc3ViS2VybmVscyAhPT0gbnVsbCkge1xuICAgICAgcmVzdWx0LnB1c2goXG4gICAgICAgICdsYXlvdXQobG9jYXRpb24gPSAwKSBvdXQgdmVjNCBkYXRhMCdcbiAgICAgICk7XG4gICAgICBzd2l0Y2ggKHRoaXMucmV0dXJuVHlwZSkge1xuICAgICAgICBjYXNlICdOdW1iZXInOlxuICAgICAgICBjYXNlICdGbG9hdCc6XG4gICAgICAgIGNhc2UgJ0ludGVnZXInOlxuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3ViS2VybmVscy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3Qgc3ViS2VybmVsID0gc3ViS2VybmVsc1tpXTtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKFxuICAgICAgICAgICAgICBzdWJLZXJuZWwucmV0dXJuVHlwZSA9PT0gJ0ludGVnZXInID9cbiAgICAgICAgICAgICAgYGludCBzdWJLZXJuZWxSZXN1bHRfJHsgc3ViS2VybmVsLm5hbWUgfSA9IDBgIDpcbiAgICAgICAgICAgICAgYGZsb2F0IHN1Yktlcm5lbFJlc3VsdF8keyBzdWJLZXJuZWwubmFtZSB9ID0gMC4wYCxcbiAgICAgICAgICAgICAgYGxheW91dChsb2NhdGlvbiA9ICR7IGkgKyAxIH0pIG91dCB2ZWM0IGRhdGEkeyBpICsgMSB9YFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ0FycmF5KDIpJzpcbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN1Yktlcm5lbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKFxuICAgICAgICAgICAgICBgdmVjMiBzdWJLZXJuZWxSZXN1bHRfJHsgc3ViS2VybmVsc1tpXS5uYW1lIH1gLFxuICAgICAgICAgICAgICBgbGF5b3V0KGxvY2F0aW9uID0gJHsgaSArIDEgfSkgb3V0IHZlYzQgZGF0YSR7IGkgKyAxIH1gXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnQXJyYXkoMyknOlxuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3ViS2VybmVscy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goXG4gICAgICAgICAgICAgIGB2ZWMzIHN1Yktlcm5lbFJlc3VsdF8keyBzdWJLZXJuZWxzW2ldLm5hbWUgfWAsXG4gICAgICAgICAgICAgIGBsYXlvdXQobG9jYXRpb24gPSAkeyBpICsgMSB9KSBvdXQgdmVjNCBkYXRhJHsgaSArIDEgfWBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdBcnJheSg0KSc6XG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdWJLZXJuZWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChcbiAgICAgICAgICAgICAgYHZlYzQgc3ViS2VybmVsUmVzdWx0XyR7IHN1Yktlcm5lbHNbaV0ubmFtZSB9YCxcbiAgICAgICAgICAgICAgYGxheW91dChsb2NhdGlvbiA9ICR7IGkgKyAxIH0pIG91dCB2ZWM0IGRhdGEkeyBpICsgMSB9YFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdC5wdXNoKFxuICAgICAgICAnb3V0IHZlYzQgZGF0YTAnXG4gICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiB1dGlscy5saW5lc1RvU3RyaW5nKHJlc3VsdCkgKyB0aGlzLnRyYW5zbGF0ZWRTb3VyY2U7XG4gIH1cblxuICBnZXRNYWluUmVzdWx0R3JhcGhpY2FsKCkge1xuICAgIHJldHVybiB1dGlscy5saW5lc1RvU3RyaW5nKFtcbiAgICAgICcgIHRocmVhZElkID0gaW5kZXhUbzNEKGluZGV4LCB1T3V0cHV0RGltKScsXG4gICAgICAnICBrZXJuZWwoKScsXG4gICAgICAnICBkYXRhMCA9IGFjdHVhbENvbG9yJyxcbiAgICBdKTtcbiAgfVxuXG4gIGdldE1haW5SZXN1bHRQYWNrZWRQaXhlbHMoKSB7XG4gICAgc3dpdGNoICh0aGlzLnJldHVyblR5cGUpIHtcbiAgICAgIGNhc2UgJ0xpdGVyYWxJbnRlZ2VyJzpcbiAgICAgIGNhc2UgJ051bWJlcic6XG4gICAgICBjYXNlICdJbnRlZ2VyJzpcbiAgICAgIGNhc2UgJ0Zsb2F0JzpcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TWFpblJlc3VsdEtlcm5lbFBhY2tlZFBpeGVscygpICtcbiAgICAgICAgICB0aGlzLmdldE1haW5SZXN1bHRTdWJLZXJuZWxQYWNrZWRQaXhlbHMoKTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgcGFja2VkIG91dHB1dCBvbmx5IHVzYWJsZSB3aXRoIE51bWJlcnMsIFwiJHt0aGlzLnJldHVyblR5cGV9XCIgc3BlY2lmaWVkYCk7XG4gICAgfVxuICB9XG5cbiAgZ2V0TWFpblJlc3VsdEtlcm5lbFBhY2tlZFBpeGVscygpIHtcbiAgICByZXR1cm4gdXRpbHMubGluZXNUb1N0cmluZyhbXG4gICAgICAnICB0aHJlYWRJZCA9IGluZGV4VG8zRChpbmRleCwgdU91dHB1dERpbSknLFxuICAgICAgJyAga2VybmVsKCknLFxuICAgICAgYCAgZGF0YTAgPSAke3RoaXMudXNlTGVnYWN5RW5jb2RlciA/ICdsZWdhY3lFbmNvZGUzMicgOiAnZW5jb2RlMzInfShrZXJuZWxSZXN1bHQpYFxuICAgIF0pO1xuICB9XG5cbiAgZ2V0TWFpblJlc3VsdFN1Yktlcm5lbFBhY2tlZFBpeGVscygpIHtcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICBpZiAoIXRoaXMuc3ViS2VybmVscykgcmV0dXJuICcnO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5zdWJLZXJuZWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBzdWJLZXJuZWwgPSB0aGlzLnN1Yktlcm5lbHNbaV07XG4gICAgICBpZiAoc3ViS2VybmVsLnJldHVyblR5cGUgPT09ICdJbnRlZ2VyJykge1xuICAgICAgICByZXN1bHQucHVzaChcbiAgICAgICAgICBgICBkYXRhJHtpICsgMX0gPSAke3RoaXMudXNlTGVnYWN5RW5jb2RlciA/ICdsZWdhY3lFbmNvZGUzMicgOiAnZW5jb2RlMzInfShmbG9hdChzdWJLZXJuZWxSZXN1bHRfJHt0aGlzLnN1Yktlcm5lbHNbaV0ubmFtZX0pKWBcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKFxuICAgICAgICAgIGAgIGRhdGEke2kgKyAxfSA9ICR7dGhpcy51c2VMZWdhY3lFbmNvZGVyID8gJ2xlZ2FjeUVuY29kZTMyJyA6ICdlbmNvZGUzMid9KHN1Yktlcm5lbFJlc3VsdF8ke3RoaXMuc3ViS2VybmVsc1tpXS5uYW1lfSlgXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB1dGlscy5saW5lc1RvU3RyaW5nKHJlc3VsdCk7XG4gIH1cblxuICBnZXRNYWluUmVzdWx0S2VybmVsTWVtb3J5T3B0aW1pemVkRmxvYXRzKHJlc3VsdCwgY2hhbm5lbCkge1xuICAgIHJlc3VsdC5wdXNoKFxuICAgICAgJyAgdGhyZWFkSWQgPSBpbmRleFRvM0QoaW5kZXgsIHVPdXRwdXREaW0pJyxcbiAgICAgICcgIGtlcm5lbCgpJyxcbiAgICAgIGAgIGRhdGEwLiR7Y2hhbm5lbH0gPSBrZXJuZWxSZXN1bHRgXG4gICAgKTtcbiAgfVxuXG4gIGdldE1haW5SZXN1bHRTdWJLZXJuZWxNZW1vcnlPcHRpbWl6ZWRGbG9hdHMocmVzdWx0LCBjaGFubmVsKSB7XG4gICAgaWYgKCF0aGlzLnN1Yktlcm5lbHMpIHJldHVybiByZXN1bHQ7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnN1Yktlcm5lbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHN1Yktlcm5lbCA9IHRoaXMuc3ViS2VybmVsc1tpXTtcbiAgICAgIGlmIChzdWJLZXJuZWwucmV0dXJuVHlwZSA9PT0gJ0ludGVnZXInKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKFxuICAgICAgICAgIGAgIGRhdGEke2kgKyAxfS4ke2NoYW5uZWx9ID0gZmxvYXQoc3ViS2VybmVsUmVzdWx0XyR7c3ViS2VybmVsLm5hbWV9KWBcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKFxuICAgICAgICAgIGAgIGRhdGEke2kgKyAxfS4ke2NoYW5uZWx9ID0gc3ViS2VybmVsUmVzdWx0XyR7c3ViS2VybmVsLm5hbWV9YFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGdldE1haW5SZXN1bHRLZXJuZWxOdW1iZXJUZXh0dXJlKCkge1xuICAgIHJldHVybiBbXG4gICAgICAnICB0aHJlYWRJZCA9IGluZGV4VG8zRChpbmRleCwgdU91dHB1dERpbSknLFxuICAgICAgJyAga2VybmVsKCknLFxuICAgICAgJyAgZGF0YTBbMF0gPSBrZXJuZWxSZXN1bHQnLFxuICAgIF07XG4gIH1cblxuICBnZXRNYWluUmVzdWx0U3ViS2VybmVsTnVtYmVyVGV4dHVyZSgpIHtcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICBpZiAoIXRoaXMuc3ViS2VybmVscykgcmV0dXJuIHJlc3VsdDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuc3ViS2VybmVscy5sZW5ndGg7ICsraSkge1xuICAgICAgY29uc3Qgc3ViS2VybmVsID0gdGhpcy5zdWJLZXJuZWxzW2ldO1xuICAgICAgaWYgKHN1Yktlcm5lbC5yZXR1cm5UeXBlID09PSAnSW50ZWdlcicpIHtcbiAgICAgICAgcmVzdWx0LnB1c2goXG4gICAgICAgICAgYCAgZGF0YSR7aSArIDF9WzBdID0gZmxvYXQoc3ViS2VybmVsUmVzdWx0XyR7c3ViS2VybmVsLm5hbWV9KWBcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKFxuICAgICAgICAgIGAgIGRhdGEke2kgKyAxfVswXSA9IHN1Yktlcm5lbFJlc3VsdF8ke3N1Yktlcm5lbC5uYW1lfWBcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGdldE1haW5SZXN1bHRLZXJuZWxBcnJheTJUZXh0dXJlKCkge1xuICAgIHJldHVybiBbXG4gICAgICAnICB0aHJlYWRJZCA9IGluZGV4VG8zRChpbmRleCwgdU91dHB1dERpbSknLFxuICAgICAgJyAga2VybmVsKCknLFxuICAgICAgJyAgZGF0YTBbMF0gPSBrZXJuZWxSZXN1bHRbMF0nLFxuICAgICAgJyAgZGF0YTBbMV0gPSBrZXJuZWxSZXN1bHRbMV0nLFxuICAgIF07XG4gIH1cblxuICBnZXRNYWluUmVzdWx0U3ViS2VybmVsQXJyYXkyVGV4dHVyZSgpIHtcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICBpZiAoIXRoaXMuc3ViS2VybmVscykgcmV0dXJuIHJlc3VsdDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuc3ViS2VybmVscy5sZW5ndGg7ICsraSkge1xuICAgICAgY29uc3Qgc3ViS2VybmVsID0gdGhpcy5zdWJLZXJuZWxzW2ldO1xuICAgICAgcmVzdWx0LnB1c2goXG4gICAgICAgIGAgIGRhdGEke2kgKyAxfVswXSA9IHN1Yktlcm5lbFJlc3VsdF8ke3N1Yktlcm5lbC5uYW1lfVswXWAsXG4gICAgICAgIGAgIGRhdGEke2kgKyAxfVsxXSA9IHN1Yktlcm5lbFJlc3VsdF8ke3N1Yktlcm5lbC5uYW1lfVsxXWBcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBnZXRNYWluUmVzdWx0S2VybmVsQXJyYXkzVGV4dHVyZSgpIHtcbiAgICByZXR1cm4gW1xuICAgICAgJyAgdGhyZWFkSWQgPSBpbmRleFRvM0QoaW5kZXgsIHVPdXRwdXREaW0pJyxcbiAgICAgICcgIGtlcm5lbCgpJyxcbiAgICAgICcgIGRhdGEwWzBdID0ga2VybmVsUmVzdWx0WzBdJyxcbiAgICAgICcgIGRhdGEwWzFdID0ga2VybmVsUmVzdWx0WzFdJyxcbiAgICAgICcgIGRhdGEwWzJdID0ga2VybmVsUmVzdWx0WzJdJyxcbiAgICBdO1xuICB9XG5cbiAgZ2V0TWFpblJlc3VsdFN1Yktlcm5lbEFycmF5M1RleHR1cmUoKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgaWYgKCF0aGlzLnN1Yktlcm5lbHMpIHJldHVybiByZXN1bHQ7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnN1Yktlcm5lbHMubGVuZ3RoOyArK2kpIHtcbiAgICAgIGNvbnN0IHN1Yktlcm5lbCA9IHRoaXMuc3ViS2VybmVsc1tpXTtcbiAgICAgIHJlc3VsdC5wdXNoKFxuICAgICAgICBgICBkYXRhJHtpICsgMX1bMF0gPSBzdWJLZXJuZWxSZXN1bHRfJHtzdWJLZXJuZWwubmFtZX1bMF1gLFxuICAgICAgICBgICBkYXRhJHtpICsgMX1bMV0gPSBzdWJLZXJuZWxSZXN1bHRfJHtzdWJLZXJuZWwubmFtZX1bMV1gLFxuICAgICAgICBgICBkYXRhJHtpICsgMX1bMl0gPSBzdWJLZXJuZWxSZXN1bHRfJHtzdWJLZXJuZWwubmFtZX1bMl1gXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgZ2V0TWFpblJlc3VsdEtlcm5lbEFycmF5NFRleHR1cmUoKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgICcgIHRocmVhZElkID0gaW5kZXhUbzNEKGluZGV4LCB1T3V0cHV0RGltKScsXG4gICAgICAnICBrZXJuZWwoKScsXG4gICAgICAnICBkYXRhMCA9IGtlcm5lbFJlc3VsdCcsXG4gICAgXTtcbiAgfVxuXG4gIGdldE1haW5SZXN1bHRTdWJLZXJuZWxBcnJheTRUZXh0dXJlKCkge1xuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIGlmICghdGhpcy5zdWJLZXJuZWxzKSByZXR1cm4gcmVzdWx0O1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5zdWJLZXJuZWxzLmxlbmd0aDsgKytpKSB7XG4gICAgICByZXN1bHQucHVzaChcbiAgICAgICAgYCAgZGF0YSR7aSArIDF9ID0gc3ViS2VybmVsUmVzdWx0XyR7dGhpcy5zdWJLZXJuZWxzW2ldLm5hbWV9YFxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGRlc3Ryb3lFeHRlbnNpb25zKCkge1xuICAgIHRoaXMuZXh0ZW5zaW9ucy5FWFRfY29sb3JfYnVmZmVyX2Zsb2F0ID0gbnVsbDtcbiAgICB0aGlzLmV4dGVuc2lvbnMuT0VTX3RleHR1cmVfZmxvYXRfbGluZWFyID0gbnVsbDtcbiAgfVxuXG4gIHRvSlNPTigpIHtcbiAgICBjb25zdCBqc29uID0gc3VwZXIudG9KU09OKCk7XG4gICAganNvbi5mdW5jdGlvbk5vZGVzID0gRnVuY3Rpb25CdWlsZGVyLmZyb21LZXJuZWwodGhpcywgV2ViR0wyRnVuY3Rpb25Ob2RlKS50b0pTT04oKTtcbiAgICBqc29uLnNldHRpbmdzLnRocmVhZERpbSA9IHRoaXMudGhyZWFkRGltO1xuICAgIHJldHVybiBqc29uO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBXZWJHTDJLZXJuZWxcbn07XG59LHtcIi4uLy4uL3V0aWxzXCI6MTE0LFwiLi4vZnVuY3Rpb24tYnVpbGRlclwiOjksXCIuLi93ZWItZ2wva2VybmVsXCI6NzAsXCIuL2ZyYWdtZW50LXNoYWRlclwiOjcyLFwiLi9mdW5jdGlvbi1ub2RlXCI6NzMsXCIuL2tlcm5lbC12YWx1ZS1tYXBzXCI6NzQsXCIuL3ZlcnRleC1zaGFkZXJcIjoxMDZ9XSwxMDY6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuY29uc3QgdmVydGV4U2hhZGVyID0gYCN2ZXJzaW9uIDMwMCBlc1xuX19GTE9BVF9UQUNUSUNfREVDTEFSQVRJT05fXztcbl9fSU5UX1RBQ1RJQ19ERUNMQVJBVElPTl9fO1xuX19TQU1QTEVSXzJEX1RBQ1RJQ19ERUNMQVJBVElPTl9fO1xuXG5pbiB2ZWMyIGFQb3M7XG5pbiB2ZWMyIGFUZXhDb29yZDtcblxub3V0IHZlYzIgdlRleENvb3JkO1xudW5pZm9ybSB2ZWMyIHJhdGlvO1xuXG52b2lkIG1haW4odm9pZCkge1xuICBnbF9Qb3NpdGlvbiA9IHZlYzQoKGFQb3MgKyB2ZWMyKDEpKSAqIHJhdGlvICsgdmVjMigtMSksIDAsIDEpO1xuICB2VGV4Q29vcmQgPSBhVGV4Q29vcmQ7XG59YDtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHZlcnRleFNoYWRlclxufTtcbn0se31dLDEwNzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5jb25zdCBsaWIgPSByZXF1aXJlKCcuL2luZGV4Jyk7XG5jb25zdCBHUFUgPSBsaWIuR1BVO1xuZm9yIChjb25zdCBwIGluIGxpYikge1xuICBpZiAoIWxpYi5oYXNPd25Qcm9wZXJ0eShwKSkgY29udGludWU7XG4gIGlmIChwID09PSAnR1BVJykgY29udGludWU7IFxuICBHUFVbcF0gPSBsaWJbcF07XG59XG5cbmlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICBiaW5kVG8od2luZG93KTtcbn1cbmlmICh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgYmluZFRvKHNlbGYpO1xufVxuXG5mdW5jdGlvbiBiaW5kVG8odGFyZ2V0KSB7XG4gIGlmICh0YXJnZXQuR1BVKSByZXR1cm47XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsICdHUFUnLCB7XG4gICAgZ2V0KCkge1xuICAgICAgcmV0dXJuIEdQVTtcbiAgICB9XG4gIH0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGxpYjtcbn0se1wiLi9pbmRleFwiOjEwOX1dLDEwODpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5jb25zdCB7IGdwdU1vY2sgfSA9IHJlcXVpcmUoJ2dwdS1tb2NrLmpzJyk7XG5jb25zdCB7IHV0aWxzIH0gPSByZXF1aXJlKCcuL3V0aWxzJyk7XG5jb25zdCB7IEtlcm5lbCB9ID0gcmVxdWlyZSgnLi9iYWNrZW5kL2tlcm5lbCcpO1xuY29uc3QgeyBDUFVLZXJuZWwgfSA9IHJlcXVpcmUoJy4vYmFja2VuZC9jcHUva2VybmVsJyk7XG5jb25zdCB7IEhlYWRsZXNzR0xLZXJuZWwgfSA9IHJlcXVpcmUoJy4vYmFja2VuZC9oZWFkbGVzcy1nbC9rZXJuZWwnKTtcbmNvbnN0IHsgV2ViR0wyS2VybmVsIH0gPSByZXF1aXJlKCcuL2JhY2tlbmQvd2ViLWdsMi9rZXJuZWwnKTtcbmNvbnN0IHsgV2ViR0xLZXJuZWwgfSA9IHJlcXVpcmUoJy4vYmFja2VuZC93ZWItZ2wva2VybmVsJyk7XG5jb25zdCB7IGtlcm5lbFJ1blNob3J0Y3V0IH0gPSByZXF1aXJlKCcuL2tlcm5lbC1ydW4tc2hvcnRjdXQnKTtcblxuXG5jb25zdCBrZXJuZWxPcmRlciA9IFtIZWFkbGVzc0dMS2VybmVsLCBXZWJHTDJLZXJuZWwsIFdlYkdMS2VybmVsXTtcblxuY29uc3Qga2VybmVsVHlwZXMgPSBbJ2dwdScsICdjcHUnXTtcblxuY29uc3QgaW50ZXJuYWxLZXJuZWxzID0ge1xuICAnaGVhZGxlc3NnbCc6IEhlYWRsZXNzR0xLZXJuZWwsXG4gICd3ZWJnbDInOiBXZWJHTDJLZXJuZWwsXG4gICd3ZWJnbCc6IFdlYkdMS2VybmVsLFxufTtcblxubGV0IHZhbGlkYXRlID0gdHJ1ZTtcblxuY2xhc3MgR1BVIHtcbiAgc3RhdGljIGRpc2FibGVWYWxpZGF0aW9uKCkge1xuICAgIHZhbGlkYXRlID0gZmFsc2U7XG4gIH1cblxuICBzdGF0aWMgZW5hYmxlVmFsaWRhdGlvbigpIHtcbiAgICB2YWxpZGF0ZSA9IHRydWU7XG4gIH1cblxuICBzdGF0aWMgZ2V0IGlzR1BVU3VwcG9ydGVkKCkge1xuICAgIHJldHVybiBrZXJuZWxPcmRlci5zb21lKEtlcm5lbCA9PiBLZXJuZWwuaXNTdXBwb3J0ZWQpO1xuICB9XG5cbiAgc3RhdGljIGdldCBpc0tlcm5lbE1hcFN1cHBvcnRlZCgpIHtcbiAgICByZXR1cm4ga2VybmVsT3JkZXIuc29tZShLZXJuZWwgPT4gS2VybmVsLmlzU3VwcG9ydGVkICYmIEtlcm5lbC5mZWF0dXJlcy5rZXJuZWxNYXApO1xuICB9XG5cbiAgc3RhdGljIGdldCBpc09mZnNjcmVlbkNhbnZhc1N1cHBvcnRlZCgpIHtcbiAgICByZXR1cm4gKHR5cGVvZiBXb3JrZXIgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBPZmZzY3JlZW5DYW52YXMgIT09ICd1bmRlZmluZWQnKSB8fCB0eXBlb2YgaW1wb3J0U2NyaXB0cyAhPT0gJ3VuZGVmaW5lZCc7XG4gIH1cblxuICBzdGF0aWMgZ2V0IGlzV2ViR0xTdXBwb3J0ZWQoKSB7XG4gICAgcmV0dXJuIFdlYkdMS2VybmVsLmlzU3VwcG9ydGVkO1xuICB9XG5cbiAgc3RhdGljIGdldCBpc1dlYkdMMlN1cHBvcnRlZCgpIHtcbiAgICByZXR1cm4gV2ViR0wyS2VybmVsLmlzU3VwcG9ydGVkO1xuICB9XG5cbiAgc3RhdGljIGdldCBpc0hlYWRsZXNzR0xTdXBwb3J0ZWQoKSB7XG4gICAgcmV0dXJuIEhlYWRsZXNzR0xLZXJuZWwuaXNTdXBwb3J0ZWQ7XG4gIH1cblxuICBzdGF0aWMgZ2V0IGlzQ2FudmFzU3VwcG9ydGVkKCkge1xuICAgIHJldHVybiB0eXBlb2YgSFRNTENhbnZhc0VsZW1lbnQgIT09ICd1bmRlZmluZWQnO1xuICB9XG5cbiAgc3RhdGljIGdldCBpc0dQVUhUTUxJbWFnZUFycmF5U3VwcG9ydGVkKCkge1xuICAgIHJldHVybiBXZWJHTDJLZXJuZWwuaXNTdXBwb3J0ZWQ7XG4gIH1cblxuICBzdGF0aWMgZ2V0IGlzU2luZ2xlUHJlY2lzaW9uU3VwcG9ydGVkKCkge1xuICAgIHJldHVybiBrZXJuZWxPcmRlci5zb21lKEtlcm5lbCA9PiBLZXJuZWwuaXNTdXBwb3J0ZWQgJiYgS2VybmVsLmZlYXR1cmVzLmlzRmxvYXRSZWFkICYmIEtlcm5lbC5mZWF0dXJlcy5pc1RleHR1cmVGbG9hdCk7XG4gIH1cblxuICBjb25zdHJ1Y3RvcihzZXR0aW5ncykge1xuICAgIHNldHRpbmdzID0gc2V0dGluZ3MgfHwge307XG4gICAgdGhpcy5jYW52YXMgPSBzZXR0aW5ncy5jYW52YXMgfHwgbnVsbDtcbiAgICB0aGlzLmNvbnRleHQgPSBzZXR0aW5ncy5jb250ZXh0IHx8IG51bGw7XG4gICAgdGhpcy5tb2RlID0gc2V0dGluZ3MubW9kZTtcbiAgICB0aGlzLktlcm5lbCA9IG51bGw7XG4gICAgdGhpcy5rZXJuZWxzID0gW107XG4gICAgdGhpcy5mdW5jdGlvbnMgPSBbXTtcbiAgICB0aGlzLm5hdGl2ZUZ1bmN0aW9ucyA9IFtdO1xuICAgIHRoaXMuaW5qZWN0ZWROYXRpdmUgPSBudWxsO1xuICAgIGlmICh0aGlzLm1vZGUgPT09ICdkZXYnKSByZXR1cm47XG4gICAgdGhpcy5jaG9vc2VLZXJuZWwoKTtcbiAgICBpZiAoc2V0dGluZ3MuZnVuY3Rpb25zKSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNldHRpbmdzLmZ1bmN0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLmFkZEZ1bmN0aW9uKHNldHRpbmdzLmZ1bmN0aW9uc1tpXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHNldHRpbmdzLm5hdGl2ZUZ1bmN0aW9ucykge1xuICAgICAgZm9yIChjb25zdCBwIGluIHNldHRpbmdzLm5hdGl2ZUZ1bmN0aW9ucykge1xuICAgICAgICBpZiAoIXNldHRpbmdzLm5hdGl2ZUZ1bmN0aW9ucy5oYXNPd25Qcm9wZXJ0eShwKSkgY29udGludWU7XG4gICAgICAgIGNvbnN0IHMgPSBzZXR0aW5ncy5uYXRpdmVGdW5jdGlvbnNbcF07XG4gICAgICAgIGNvbnN0IHsgbmFtZSwgc291cmNlIH0gPSBzO1xuICAgICAgICB0aGlzLmFkZE5hdGl2ZUZ1bmN0aW9uKG5hbWUsIHNvdXJjZSwgcyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgY2hvb3NlS2VybmVsKCkge1xuICAgIGlmICh0aGlzLktlcm5lbCkgcmV0dXJuO1xuXG4gICAgbGV0IEtlcm5lbCA9IG51bGw7XG5cbiAgICBpZiAodGhpcy5jb250ZXh0KSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGtlcm5lbE9yZGVyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IEV4dGVybmFsS2VybmVsID0ga2VybmVsT3JkZXJbaV07XG4gICAgICAgIGlmIChFeHRlcm5hbEtlcm5lbC5pc0NvbnRleHRNYXRjaCh0aGlzLmNvbnRleHQpKSB7XG4gICAgICAgICAgaWYgKCFFeHRlcm5hbEtlcm5lbC5pc1N1cHBvcnRlZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBLZXJuZWwgdHlwZSAke0V4dGVybmFsS2VybmVsLm5hbWV9IG5vdCBzdXBwb3J0ZWRgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgS2VybmVsID0gRXh0ZXJuYWxLZXJuZWw7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChLZXJuZWwgPT09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bmtub3duIENvbnRleHQnKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHRoaXMubW9kZSkge1xuICAgICAgaWYgKHRoaXMubW9kZSBpbiBpbnRlcm5hbEtlcm5lbHMpIHtcbiAgICAgICAgaWYgKCF2YWxpZGF0ZSB8fCBpbnRlcm5hbEtlcm5lbHNbdGhpcy5tb2RlXS5pc1N1cHBvcnRlZCkge1xuICAgICAgICAgIEtlcm5lbCA9IGludGVybmFsS2VybmVsc1t0aGlzLm1vZGVdO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHRoaXMubW9kZSA9PT0gJ2dwdScpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXJuZWxPcmRlci5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmIChrZXJuZWxPcmRlcltpXS5pc1N1cHBvcnRlZCkge1xuICAgICAgICAgICAgS2VybmVsID0ga2VybmVsT3JkZXJbaV07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodGhpcy5tb2RlID09PSAnY3B1Jykge1xuICAgICAgICBLZXJuZWwgPSBDUFVLZXJuZWw7XG4gICAgICB9XG4gICAgICBpZiAoIUtlcm5lbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEEgcmVxdWVzdGVkIG1vZGUgb2YgXCIke3RoaXMubW9kZX1cIiBhbmQgaXMgbm90IHN1cHBvcnRlZGApO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGtlcm5lbE9yZGVyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChrZXJuZWxPcmRlcltpXS5pc1N1cHBvcnRlZCkge1xuICAgICAgICAgIEtlcm5lbCA9IGtlcm5lbE9yZGVyW2ldO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIUtlcm5lbCkge1xuICAgICAgICBLZXJuZWwgPSBDUFVLZXJuZWw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLm1vZGUpIHtcbiAgICAgIHRoaXMubW9kZSA9IEtlcm5lbC5tb2RlO1xuICAgIH1cbiAgICB0aGlzLktlcm5lbCA9IEtlcm5lbDtcbiAgfVxuXG4gIGNyZWF0ZUtlcm5lbChzb3VyY2UsIHNldHRpbmdzKSB7XG4gICAgaWYgKHR5cGVvZiBzb3VyY2UgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ01pc3Npbmcgc291cmNlIHBhcmFtZXRlcicpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHNvdXJjZSAhPT0gJ29iamVjdCcgJiYgIXV0aWxzLmlzRnVuY3Rpb24oc291cmNlKSAmJiB0eXBlb2Ygc291cmNlICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdzb3VyY2UgcGFyYW1ldGVyIG5vdCBhIGZ1bmN0aW9uJyk7XG4gICAgfVxuXG4gICAgY29uc3Qga2VybmVscyA9IHRoaXMua2VybmVscztcbiAgICBpZiAodGhpcy5tb2RlID09PSAnZGV2Jykge1xuICAgICAgY29uc3QgZGV2S2VybmVsID0gZ3B1TW9jayhzb3VyY2UsIHVwZ3JhZGVEZXByZWNhdGVkQ3JlYXRlS2VybmVsU2V0dGluZ3Moc2V0dGluZ3MpKTtcbiAgICAgIGtlcm5lbHMucHVzaChkZXZLZXJuZWwpO1xuICAgICAgcmV0dXJuIGRldktlcm5lbDtcbiAgICB9XG5cbiAgICBzb3VyY2UgPSB0eXBlb2Ygc291cmNlID09PSAnZnVuY3Rpb24nID8gc291cmNlLnRvU3RyaW5nKCkgOiBzb3VyY2U7XG4gICAgY29uc3Qgc3dpdGNoYWJsZUtlcm5lbHMgPSB7fTtcbiAgICBjb25zdCBzZXR0aW5nc0NvcHkgPSB1cGdyYWRlRGVwcmVjYXRlZENyZWF0ZUtlcm5lbFNldHRpbmdzKHNldHRpbmdzKSB8fCB7fTtcbiAgICBpZiAoc2V0dGluZ3MgJiYgdHlwZW9mIHNldHRpbmdzLmFyZ3VtZW50VHlwZXMgPT09ICdvYmplY3QnKSB7XG4gICAgICBzZXR0aW5nc0NvcHkuYXJndW1lbnRUeXBlcyA9IE9iamVjdC5rZXlzKHNldHRpbmdzLmFyZ3VtZW50VHlwZXMpLm1hcChhcmd1bWVudE5hbWUgPT4gc2V0dGluZ3MuYXJndW1lbnRUeXBlc1thcmd1bWVudE5hbWVdKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBvblJlcXVlc3RGYWxsYmFjayhhcmdzKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ0ZhbGxpbmcgYmFjayB0byBDUFUnKTtcbiAgICAgIGNvbnN0IGZhbGxiYWNrS2VybmVsID0gbmV3IENQVUtlcm5lbChzb3VyY2UsIHtcbiAgICAgICAgYXJndW1lbnRUeXBlczoga2VybmVsUnVuLmFyZ3VtZW50VHlwZXMsXG4gICAgICAgIGNvbnN0YW50VHlwZXM6IGtlcm5lbFJ1bi5jb25zdGFudFR5cGVzLFxuICAgICAgICBncmFwaGljYWw6IGtlcm5lbFJ1bi5ncmFwaGljYWwsXG4gICAgICAgIGxvb3BNYXhJdGVyYXRpb25zOiBrZXJuZWxSdW4ubG9vcE1heEl0ZXJhdGlvbnMsXG4gICAgICAgIGNvbnN0YW50czoga2VybmVsUnVuLmNvbnN0YW50cyxcbiAgICAgICAgZHluYW1pY091dHB1dDoga2VybmVsUnVuLmR5bmFtaWNPdXRwdXQsXG4gICAgICAgIGR5bmFtaWNBcmd1bWVudDoga2VybmVsUnVuLmR5bmFtaWNBcmd1bWVudHMsXG4gICAgICAgIG91dHB1dDoga2VybmVsUnVuLm91dHB1dCxcbiAgICAgICAgcHJlY2lzaW9uOiBrZXJuZWxSdW4ucHJlY2lzaW9uLFxuICAgICAgICBwaXBlbGluZToga2VybmVsUnVuLnBpcGVsaW5lLFxuICAgICAgICBpbW11dGFibGU6IGtlcm5lbFJ1bi5pbW11dGFibGUsXG4gICAgICAgIG9wdGltaXplRmxvYXRNZW1vcnk6IGtlcm5lbFJ1bi5vcHRpbWl6ZUZsb2F0TWVtb3J5LFxuICAgICAgICBmaXhJbnRlZ2VyRGl2aXNpb25BY2N1cmFjeToga2VybmVsUnVuLmZpeEludGVnZXJEaXZpc2lvbkFjY3VyYWN5LFxuICAgICAgICBmdW5jdGlvbnM6IGtlcm5lbFJ1bi5mdW5jdGlvbnMsXG4gICAgICAgIG5hdGl2ZUZ1bmN0aW9uczoga2VybmVsUnVuLm5hdGl2ZUZ1bmN0aW9ucyxcbiAgICAgICAgaW5qZWN0ZWROYXRpdmU6IGtlcm5lbFJ1bi5pbmplY3RlZE5hdGl2ZSxcbiAgICAgICAgc3ViS2VybmVsczoga2VybmVsUnVuLnN1Yktlcm5lbHMsXG4gICAgICAgIHN0cmljdEludGVnZXJzOiBrZXJuZWxSdW4uc3RyaWN0SW50ZWdlcnMsXG4gICAgICAgIGRlYnVnOiBrZXJuZWxSdW4uZGVidWcsXG4gICAgICB9KTtcbiAgICAgIGZhbGxiYWNrS2VybmVsLmJ1aWxkLmFwcGx5KGZhbGxiYWNrS2VybmVsLCBhcmdzKTtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGZhbGxiYWNrS2VybmVsLnJ1bi5hcHBseShmYWxsYmFja0tlcm5lbCwgYXJncyk7XG4gICAgICBrZXJuZWxSdW4ucmVwbGFjZUtlcm5lbChmYWxsYmFja0tlcm5lbCk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9uUmVxdWVzdFN3aXRjaEtlcm5lbChyZWFzb25zLCBhcmdzLCBfa2VybmVsKSB7XG4gICAgICBpZiAoX2tlcm5lbC5kZWJ1Zykge1xuICAgICAgICBjb25zb2xlLndhcm4oJ1N3aXRjaGluZyBrZXJuZWxzJyk7XG4gICAgICB9XG4gICAgICBsZXQgbmV3T3V0cHV0ID0gbnVsbDtcbiAgICAgIGlmIChfa2VybmVsLnNpZ25hdHVyZSAmJiAhc3dpdGNoYWJsZUtlcm5lbHNbX2tlcm5lbC5zaWduYXR1cmVdKSB7XG4gICAgICAgIHN3aXRjaGFibGVLZXJuZWxzW19rZXJuZWwuc2lnbmF0dXJlXSA9IF9rZXJuZWw7XG4gICAgICB9XG4gICAgICBpZiAoX2tlcm5lbC5keW5hbWljT3V0cHV0KSB7XG4gICAgICAgIGZvciAobGV0IGkgPSByZWFzb25zLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgY29uc3QgcmVhc29uID0gcmVhc29uc1tpXTtcbiAgICAgICAgICBpZiAocmVhc29uLnR5cGUgPT09ICdvdXRwdXRQcmVjaXNpb25NaXNtYXRjaCcpIHtcbiAgICAgICAgICAgIG5ld091dHB1dCA9IHJlYXNvbi5uZWVkZWQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IENvbnN0cnVjdG9yID0gX2tlcm5lbC5jb25zdHJ1Y3RvcjtcbiAgICAgIGNvbnN0IGFyZ3VtZW50VHlwZXMgPSBDb25zdHJ1Y3Rvci5nZXRBcmd1bWVudFR5cGVzKF9rZXJuZWwsIGFyZ3MpO1xuICAgICAgY29uc3Qgc2lnbmF0dXJlID0gQ29uc3RydWN0b3IuZ2V0U2lnbmF0dXJlKF9rZXJuZWwsIGFyZ3VtZW50VHlwZXMpO1xuICAgICAgY29uc3QgZXhpc3RpbmdLZXJuZWwgPSBzd2l0Y2hhYmxlS2VybmVsc1tzaWduYXR1cmVdO1xuICAgICAgaWYgKGV4aXN0aW5nS2VybmVsKSB7XG4gICAgICAgIGV4aXN0aW5nS2VybmVsLm9uQWN0aXZhdGUoX2tlcm5lbCk7XG4gICAgICAgIHJldHVybiBleGlzdGluZ0tlcm5lbDtcbiAgICAgIH1cblxuICAgICAgY29uc3QgbmV3S2VybmVsID0gc3dpdGNoYWJsZUtlcm5lbHNbc2lnbmF0dXJlXSA9IG5ldyBDb25zdHJ1Y3Rvcihzb3VyY2UsIHtcbiAgICAgICAgYXJndW1lbnRUeXBlcyxcbiAgICAgICAgY29uc3RhbnRUeXBlczogX2tlcm5lbC5jb25zdGFudFR5cGVzLFxuICAgICAgICBncmFwaGljYWw6IF9rZXJuZWwuZ3JhcGhpY2FsLFxuICAgICAgICBsb29wTWF4SXRlcmF0aW9uczogX2tlcm5lbC5sb29wTWF4SXRlcmF0aW9ucyxcbiAgICAgICAgY29uc3RhbnRzOiBfa2VybmVsLmNvbnN0YW50cyxcbiAgICAgICAgZHluYW1pY091dHB1dDogX2tlcm5lbC5keW5hbWljT3V0cHV0LFxuICAgICAgICBkeW5hbWljQXJndW1lbnQ6IF9rZXJuZWwuZHluYW1pY0FyZ3VtZW50cyxcbiAgICAgICAgY29udGV4dDogX2tlcm5lbC5jb250ZXh0LFxuICAgICAgICBjYW52YXM6IF9rZXJuZWwuY2FudmFzLFxuICAgICAgICBvdXRwdXQ6IG5ld091dHB1dCB8fCBfa2VybmVsLm91dHB1dCxcbiAgICAgICAgcHJlY2lzaW9uOiBfa2VybmVsLnByZWNpc2lvbixcbiAgICAgICAgcGlwZWxpbmU6IF9rZXJuZWwucGlwZWxpbmUsXG4gICAgICAgIGltbXV0YWJsZTogX2tlcm5lbC5pbW11dGFibGUsXG4gICAgICAgIG9wdGltaXplRmxvYXRNZW1vcnk6IF9rZXJuZWwub3B0aW1pemVGbG9hdE1lbW9yeSxcbiAgICAgICAgZml4SW50ZWdlckRpdmlzaW9uQWNjdXJhY3k6IF9rZXJuZWwuZml4SW50ZWdlckRpdmlzaW9uQWNjdXJhY3ksXG4gICAgICAgIGZ1bmN0aW9uczogX2tlcm5lbC5mdW5jdGlvbnMsXG4gICAgICAgIG5hdGl2ZUZ1bmN0aW9uczogX2tlcm5lbC5uYXRpdmVGdW5jdGlvbnMsXG4gICAgICAgIGluamVjdGVkTmF0aXZlOiBfa2VybmVsLmluamVjdGVkTmF0aXZlLFxuICAgICAgICBzdWJLZXJuZWxzOiBfa2VybmVsLnN1Yktlcm5lbHMsXG4gICAgICAgIHN0cmljdEludGVnZXJzOiBfa2VybmVsLnN0cmljdEludGVnZXJzLFxuICAgICAgICBkZWJ1ZzogX2tlcm5lbC5kZWJ1ZyxcbiAgICAgICAgZ3B1OiBfa2VybmVsLmdwdSxcbiAgICAgICAgdmFsaWRhdGUsXG4gICAgICAgIHJldHVyblR5cGU6IF9rZXJuZWwucmV0dXJuVHlwZSxcbiAgICAgICAgdGFjdGljOiBfa2VybmVsLnRhY3RpYyxcbiAgICAgICAgb25SZXF1ZXN0RmFsbGJhY2ssXG4gICAgICAgIG9uUmVxdWVzdFN3aXRjaEtlcm5lbCxcbiAgICAgICAgdGV4dHVyZTogX2tlcm5lbC50ZXh0dXJlLFxuICAgICAgICBtYXBwZWRUZXh0dXJlczogX2tlcm5lbC5tYXBwZWRUZXh0dXJlcyxcbiAgICAgICAgZHJhd0J1ZmZlcnNNYXA6IF9rZXJuZWwuZHJhd0J1ZmZlcnNNYXAsXG4gICAgICB9KTtcbiAgICAgIG5ld0tlcm5lbC5idWlsZC5hcHBseShuZXdLZXJuZWwsIGFyZ3MpO1xuICAgICAga2VybmVsUnVuLnJlcGxhY2VLZXJuZWwobmV3S2VybmVsKTtcbiAgICAgIGtlcm5lbHMucHVzaChuZXdLZXJuZWwpO1xuICAgICAgcmV0dXJuIG5ld0tlcm5lbDtcbiAgICB9XG4gICAgY29uc3QgbWVyZ2VkU2V0dGluZ3MgPSBPYmplY3QuYXNzaWduKHtcbiAgICAgIGNvbnRleHQ6IHRoaXMuY29udGV4dCxcbiAgICAgIGNhbnZhczogdGhpcy5jYW52YXMsXG4gICAgICBmdW5jdGlvbnM6IHRoaXMuZnVuY3Rpb25zLFxuICAgICAgbmF0aXZlRnVuY3Rpb25zOiB0aGlzLm5hdGl2ZUZ1bmN0aW9ucyxcbiAgICAgIGluamVjdGVkTmF0aXZlOiB0aGlzLmluamVjdGVkTmF0aXZlLFxuICAgICAgZ3B1OiB0aGlzLFxuICAgICAgdmFsaWRhdGUsXG4gICAgICBvblJlcXVlc3RGYWxsYmFjayxcbiAgICAgIG9uUmVxdWVzdFN3aXRjaEtlcm5lbFxuICAgIH0sIHNldHRpbmdzQ29weSk7XG5cbiAgICBjb25zdCBrZXJuZWwgPSBuZXcgdGhpcy5LZXJuZWwoc291cmNlLCBtZXJnZWRTZXR0aW5ncyk7XG4gICAgY29uc3Qga2VybmVsUnVuID0ga2VybmVsUnVuU2hvcnRjdXQoa2VybmVsKTtcblxuICAgIGlmICghdGhpcy5jYW52YXMpIHtcbiAgICAgIHRoaXMuY2FudmFzID0ga2VybmVsLmNhbnZhcztcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuY29udGV4dCkge1xuICAgICAgdGhpcy5jb250ZXh0ID0ga2VybmVsLmNvbnRleHQ7XG4gICAgfVxuXG4gICAga2VybmVscy5wdXNoKGtlcm5lbCk7XG5cbiAgICByZXR1cm4ga2VybmVsUnVuO1xuICB9XG5cbiAgY3JlYXRlS2VybmVsTWFwKCkge1xuICAgIGxldCBmbjtcbiAgICBsZXQgc2V0dGluZ3M7XG4gICAgY29uc3QgYXJndW1lbnQyVHlwZSA9IHR5cGVvZiBhcmd1bWVudHNbYXJndW1lbnRzLmxlbmd0aCAtIDJdO1xuICAgIGlmIChhcmd1bWVudDJUeXBlID09PSAnZnVuY3Rpb24nIHx8IGFyZ3VtZW50MlR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICBmbiA9IGFyZ3VtZW50c1thcmd1bWVudHMubGVuZ3RoIC0gMl07XG4gICAgICBzZXR0aW5ncyA9IGFyZ3VtZW50c1thcmd1bWVudHMubGVuZ3RoIC0gMV07XG4gICAgfSBlbHNlIHtcbiAgICAgIGZuID0gYXJndW1lbnRzW2FyZ3VtZW50cy5sZW5ndGggLSAxXTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5tb2RlICE9PSAnZGV2Jykge1xuICAgICAgaWYgKCF0aGlzLktlcm5lbC5pc1N1cHBvcnRlZCB8fCAhdGhpcy5LZXJuZWwuZmVhdHVyZXMua2VybmVsTWFwKSB7XG4gICAgICAgIGlmICh0aGlzLm1vZGUgJiYga2VybmVsVHlwZXMuaW5kZXhPZih0aGlzLm1vZGUpIDwgMCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihga2VybmVsTWFwIG5vdCBzdXBwb3J0ZWQgb24gJHt0aGlzLktlcm5lbC5uYW1lfWApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3Qgc2V0dGluZ3NDb3B5ID0gdXBncmFkZURlcHJlY2F0ZWRDcmVhdGVLZXJuZWxTZXR0aW5ncyhzZXR0aW5ncyk7XG4gICAgaWYgKHNldHRpbmdzICYmIHR5cGVvZiBzZXR0aW5ncy5hcmd1bWVudFR5cGVzID09PSAnb2JqZWN0Jykge1xuICAgICAgc2V0dGluZ3NDb3B5LmFyZ3VtZW50VHlwZXMgPSBPYmplY3Qua2V5cyhzZXR0aW5ncy5hcmd1bWVudFR5cGVzKS5tYXAoYXJndW1lbnROYW1lID0+IHNldHRpbmdzLmFyZ3VtZW50VHlwZXNbYXJndW1lbnROYW1lXSk7XG4gICAgfVxuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYXJndW1lbnRzWzBdKSkge1xuICAgICAgc2V0dGluZ3NDb3B5LnN1Yktlcm5lbHMgPSBbXTtcbiAgICAgIGNvbnN0IGZ1bmN0aW9ucyA9IGFyZ3VtZW50c1swXTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZnVuY3Rpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHNvdXJjZSA9IGZ1bmN0aW9uc1tpXS50b1N0cmluZygpO1xuICAgICAgICBjb25zdCBuYW1lID0gdXRpbHMuZ2V0RnVuY3Rpb25OYW1lRnJvbVN0cmluZyhzb3VyY2UpO1xuICAgICAgICBzZXR0aW5nc0NvcHkuc3ViS2VybmVscy5wdXNoKHtcbiAgICAgICAgICBuYW1lLFxuICAgICAgICAgIHNvdXJjZSxcbiAgICAgICAgICBwcm9wZXJ0eTogaSxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHNldHRpbmdzQ29weS5zdWJLZXJuZWxzID0gW107XG4gICAgICBjb25zdCBmdW5jdGlvbnMgPSBhcmd1bWVudHNbMF07XG4gICAgICBmb3IgKGxldCBwIGluIGZ1bmN0aW9ucykge1xuICAgICAgICBpZiAoIWZ1bmN0aW9ucy5oYXNPd25Qcm9wZXJ0eShwKSkgY29udGludWU7XG4gICAgICAgIGNvbnN0IHNvdXJjZSA9IGZ1bmN0aW9uc1twXS50b1N0cmluZygpO1xuICAgICAgICBjb25zdCBuYW1lID0gdXRpbHMuZ2V0RnVuY3Rpb25OYW1lRnJvbVN0cmluZyhzb3VyY2UpO1xuICAgICAgICBzZXR0aW5nc0NvcHkuc3ViS2VybmVscy5wdXNoKHtcbiAgICAgICAgICBuYW1lOiBuYW1lIHx8IHAsXG4gICAgICAgICAgc291cmNlLFxuICAgICAgICAgIHByb3BlcnR5OiBwLFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY3JlYXRlS2VybmVsKGZuLCBzZXR0aW5nc0NvcHkpO1xuICB9XG5cbiAgY29tYmluZUtlcm5lbHMoKSB7XG4gICAgY29uc3QgZmlyc3RLZXJuZWwgPSBhcmd1bWVudHNbMF07XG4gICAgY29uc3QgY29tYmluZWRLZXJuZWwgPSBhcmd1bWVudHNbYXJndW1lbnRzLmxlbmd0aCAtIDFdO1xuICAgIGlmIChmaXJzdEtlcm5lbC5rZXJuZWwuY29uc3RydWN0b3IubW9kZSA9PT0gJ2NwdScpIHJldHVybiBjb21iaW5lZEtlcm5lbDtcbiAgICBjb25zdCBjYW52YXMgPSBhcmd1bWVudHNbMF0uY2FudmFzO1xuICAgIGNvbnN0IGNvbnRleHQgPSBhcmd1bWVudHNbMF0uY29udGV4dDtcbiAgICBjb25zdCBtYXggPSBhcmd1bWVudHMubGVuZ3RoIC0gMTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1heDsgaSsrKSB7XG4gICAgICBhcmd1bWVudHNbaV1cbiAgICAgICAgLnNldENhbnZhcyhjYW52YXMpXG4gICAgICAgIC5zZXRDb250ZXh0KGNvbnRleHQpXG4gICAgICAgIC5zZXRQaXBlbGluZSh0cnVlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICBjb25zdCB0ZXh0dXJlID0gY29tYmluZWRLZXJuZWwuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIGlmICh0ZXh0dXJlLnRvQXJyYXkpIHtcbiAgICAgICAgcmV0dXJuIHRleHR1cmUudG9BcnJheSgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRleHR1cmU7XG4gICAgfTtcbiAgfVxuXG4gIHNldEZ1bmN0aW9ucyhmdW5jdGlvbnMpIHtcbiAgICB0aGlzLmZ1bmN0aW9ucyA9IGZ1bmN0aW9ucztcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHNldE5hdGl2ZUZ1bmN0aW9ucyhuYXRpdmVGdW5jdGlvbnMpIHtcbiAgICB0aGlzLm5hdGl2ZUZ1bmN0aW9ucyA9IG5hdGl2ZUZ1bmN0aW9ucztcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGFkZEZ1bmN0aW9uKHNvdXJjZSwgc2V0dGluZ3MpIHtcbiAgICB0aGlzLmZ1bmN0aW9ucy5wdXNoKHsgc291cmNlLCBzZXR0aW5ncyB9KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGFkZE5hdGl2ZUZ1bmN0aW9uKG5hbWUsIHNvdXJjZSwgc2V0dGluZ3MpIHtcbiAgICBpZiAodGhpcy5rZXJuZWxzLmxlbmd0aCA+IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGNhbGwgXCJhZGROYXRpdmVGdW5jdGlvblwiIGFmdGVyIFwiY3JlYXRlS2VybmVsc1wiIGhhcyBiZWVuIGNhbGxlZC4nKTtcbiAgICB9XG4gICAgdGhpcy5uYXRpdmVGdW5jdGlvbnMucHVzaChPYmplY3QuYXNzaWduKHsgbmFtZSwgc291cmNlIH0sIHNldHRpbmdzKSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBpbmplY3ROYXRpdmUoc291cmNlKSB7XG4gICAgdGhpcy5pbmplY3RlZE5hdGl2ZSA9IHNvdXJjZTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGRlc3Ryb3koKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGlmICghdGhpcy5rZXJuZWxzKSB7XG4gICAgICAgIHJlc29sdmUoKTtcbiAgICAgIH1cbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5rZXJuZWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLmtlcm5lbHNbaV0uZGVzdHJveSh0cnVlKTsgXG4gICAgICAgICAgfVxuICAgICAgICAgIGxldCBmaXJzdEtlcm5lbCA9IHRoaXMua2VybmVsc1swXTtcbiAgICAgICAgICBpZiAoZmlyc3RLZXJuZWwpIHtcbiAgICAgICAgICAgIGlmIChmaXJzdEtlcm5lbC5rZXJuZWwpIHtcbiAgICAgICAgICAgICAgZmlyc3RLZXJuZWwgPSBmaXJzdEtlcm5lbC5rZXJuZWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZmlyc3RLZXJuZWwuY29uc3RydWN0b3IuZGVzdHJveUNvbnRleHQpIHtcbiAgICAgICAgICAgICAgZmlyc3RLZXJuZWwuY29uc3RydWN0b3IuZGVzdHJveUNvbnRleHQodGhpcy5jb250ZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgfSwgMCk7XG4gICAgfSk7XG4gIH1cbn1cblxuXG5mdW5jdGlvbiB1cGdyYWRlRGVwcmVjYXRlZENyZWF0ZUtlcm5lbFNldHRpbmdzKHNldHRpbmdzKSB7XG4gIGlmICghc2V0dGluZ3MpIHtcbiAgICByZXR1cm4ge307XG4gIH1cbiAgY29uc3QgdXBncmFkZWRTZXR0aW5ncyA9IE9iamVjdC5hc3NpZ24oe30sIHNldHRpbmdzKTtcblxuICBpZiAoc2V0dGluZ3MuaGFzT3duUHJvcGVydHkoJ2Zsb2F0T3V0cHV0JykpIHtcbiAgICB1dGlscy53YXJuRGVwcmVjYXRlZCgnc2V0dGluZycsICdmbG9hdE91dHB1dCcsICdwcmVjaXNpb24nKTtcbiAgICB1cGdyYWRlZFNldHRpbmdzLnByZWNpc2lvbiA9IHNldHRpbmdzLmZsb2F0T3V0cHV0ID8gJ3NpbmdsZScgOiAndW5zaWduZWQnO1xuICB9XG4gIGlmIChzZXR0aW5ncy5oYXNPd25Qcm9wZXJ0eSgnb3V0cHV0VG9UZXh0dXJlJykpIHtcbiAgICB1dGlscy53YXJuRGVwcmVjYXRlZCgnc2V0dGluZycsICdvdXRwdXRUb1RleHR1cmUnLCAncGlwZWxpbmUnKTtcbiAgICB1cGdyYWRlZFNldHRpbmdzLnBpcGVsaW5lID0gQm9vbGVhbihzZXR0aW5ncy5vdXRwdXRUb1RleHR1cmUpO1xuICB9XG4gIGlmIChzZXR0aW5ncy5oYXNPd25Qcm9wZXJ0eSgnb3V0cHV0SW1tdXRhYmxlJykpIHtcbiAgICB1dGlscy53YXJuRGVwcmVjYXRlZCgnc2V0dGluZycsICdvdXRwdXRJbW11dGFibGUnLCAnaW1tdXRhYmxlJyk7XG4gICAgdXBncmFkZWRTZXR0aW5ncy5pbW11dGFibGUgPSBCb29sZWFuKHNldHRpbmdzLm91dHB1dEltbXV0YWJsZSk7XG4gIH1cbiAgaWYgKHNldHRpbmdzLmhhc093blByb3BlcnR5KCdmbG9hdFRleHR1cmVzJykpIHtcbiAgICB1dGlscy53YXJuRGVwcmVjYXRlZCgnc2V0dGluZycsICdmbG9hdFRleHR1cmVzJywgJ29wdGltaXplRmxvYXRNZW1vcnknKTtcbiAgICB1cGdyYWRlZFNldHRpbmdzLm9wdGltaXplRmxvYXRNZW1vcnkgPSBCb29sZWFuKHNldHRpbmdzLmZsb2F0VGV4dHVyZXMpO1xuICB9XG4gIHJldHVybiB1cGdyYWRlZFNldHRpbmdzO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgR1BVLFxuICBrZXJuZWxPcmRlcixcbiAga2VybmVsVHlwZXNcbn07XG59LHtcIi4vYmFja2VuZC9jcHUva2VybmVsXCI6OCxcIi4vYmFja2VuZC9oZWFkbGVzcy1nbC9rZXJuZWxcIjozNCxcIi4vYmFja2VuZC9rZXJuZWxcIjozNixcIi4vYmFja2VuZC93ZWItZ2wva2VybmVsXCI6NzAsXCIuL2JhY2tlbmQvd2ViLWdsMi9rZXJuZWxcIjoxMDUsXCIuL2tlcm5lbC1ydW4tc2hvcnRjdXRcIjoxMTEsXCIuL3V0aWxzXCI6MTE0LFwiZ3B1LW1vY2suanNcIjo0fV0sMTA5OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbmNvbnN0IHsgR1BVIH0gPSByZXF1aXJlKCcuL2dwdScpO1xuY29uc3QgeyBhbGlhcyB9ID0gcmVxdWlyZSgnLi9hbGlhcycpO1xuY29uc3QgeyB1dGlscyB9ID0gcmVxdWlyZSgnLi91dGlscycpO1xuY29uc3QgeyBJbnB1dCwgaW5wdXQgfSA9IHJlcXVpcmUoJy4vaW5wdXQnKTtcbmNvbnN0IHsgVGV4dHVyZSB9ID0gcmVxdWlyZSgnLi90ZXh0dXJlJyk7XG5jb25zdCB7IEZ1bmN0aW9uQnVpbGRlciB9ID0gcmVxdWlyZSgnLi9iYWNrZW5kL2Z1bmN0aW9uLWJ1aWxkZXInKTtcbmNvbnN0IHsgRnVuY3Rpb25Ob2RlIH0gPSByZXF1aXJlKCcuL2JhY2tlbmQvZnVuY3Rpb24tbm9kZScpO1xuY29uc3QgeyBDUFVGdW5jdGlvbk5vZGUgfSA9IHJlcXVpcmUoJy4vYmFja2VuZC9jcHUvZnVuY3Rpb24tbm9kZScpO1xuY29uc3QgeyBDUFVLZXJuZWwgfSA9IHJlcXVpcmUoJy4vYmFja2VuZC9jcHUva2VybmVsJyk7XG5cbmNvbnN0IHsgSGVhZGxlc3NHTEtlcm5lbCB9ID0gcmVxdWlyZSgnLi9iYWNrZW5kL2hlYWRsZXNzLWdsL2tlcm5lbCcpO1xuXG5jb25zdCB7IFdlYkdMRnVuY3Rpb25Ob2RlIH0gPSByZXF1aXJlKCcuL2JhY2tlbmQvd2ViLWdsL2Z1bmN0aW9uLW5vZGUnKTtcbmNvbnN0IHsgV2ViR0xLZXJuZWwgfSA9IHJlcXVpcmUoJy4vYmFja2VuZC93ZWItZ2wva2VybmVsJyk7XG5jb25zdCB7IGtlcm5lbFZhbHVlTWFwczogd2ViR0xLZXJuZWxWYWx1ZU1hcHMgfSA9IHJlcXVpcmUoJy4vYmFja2VuZC93ZWItZ2wva2VybmVsLXZhbHVlLW1hcHMnKTtcblxuY29uc3QgeyBXZWJHTDJGdW5jdGlvbk5vZGUgfSA9IHJlcXVpcmUoJy4vYmFja2VuZC93ZWItZ2wyL2Z1bmN0aW9uLW5vZGUnKTtcbmNvbnN0IHsgV2ViR0wyS2VybmVsIH0gPSByZXF1aXJlKCcuL2JhY2tlbmQvd2ViLWdsMi9rZXJuZWwnKTtcbmNvbnN0IHsga2VybmVsVmFsdWVNYXBzOiB3ZWJHTDJLZXJuZWxWYWx1ZU1hcHMgfSA9IHJlcXVpcmUoJy4vYmFja2VuZC93ZWItZ2wyL2tlcm5lbC12YWx1ZS1tYXBzJyk7XG5cbmNvbnN0IHsgR0xLZXJuZWwgfSA9IHJlcXVpcmUoJy4vYmFja2VuZC9nbC9rZXJuZWwnKTtcblxuY29uc3QgeyBLZXJuZWwgfSA9IHJlcXVpcmUoJy4vYmFja2VuZC9rZXJuZWwnKTtcblxuY29uc3QgeyBGdW5jdGlvblRyYWNlciB9ID0gcmVxdWlyZSgnLi9iYWNrZW5kL2Z1bmN0aW9uLXRyYWNlcicpO1xuXG5jb25zdCBtYXRoUmFuZG9tID0gcmVxdWlyZSgnLi9wbHVnaW5zL21hdGgtcmFuZG9tLXVuaWZvcm1seS1kaXN0cmlidXRlZCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgYWxpYXMsXG4gIENQVUZ1bmN0aW9uTm9kZSxcbiAgQ1BVS2VybmVsLFxuICBHUFUsXG4gIEZ1bmN0aW9uQnVpbGRlcixcbiAgRnVuY3Rpb25Ob2RlLFxuICBIZWFkbGVzc0dMS2VybmVsLFxuICBJbnB1dCxcbiAgaW5wdXQsXG4gIFRleHR1cmUsXG4gIHV0aWxzLFxuXG4gIFdlYkdMMkZ1bmN0aW9uTm9kZSxcbiAgV2ViR0wyS2VybmVsLFxuICB3ZWJHTDJLZXJuZWxWYWx1ZU1hcHMsXG5cbiAgV2ViR0xGdW5jdGlvbk5vZGUsXG4gIFdlYkdMS2VybmVsLFxuICB3ZWJHTEtlcm5lbFZhbHVlTWFwcyxcblxuICBHTEtlcm5lbCxcbiAgS2VybmVsLFxuICBGdW5jdGlvblRyYWNlcixcblxuICBwbHVnaW5zOiB7XG4gICAgbWF0aFJhbmRvbVxuICB9XG59O1xufSx7XCIuL2FsaWFzXCI6NSxcIi4vYmFja2VuZC9jcHUvZnVuY3Rpb24tbm9kZVwiOjYsXCIuL2JhY2tlbmQvY3B1L2tlcm5lbFwiOjgsXCIuL2JhY2tlbmQvZnVuY3Rpb24tYnVpbGRlclwiOjksXCIuL2JhY2tlbmQvZnVuY3Rpb24tbm9kZVwiOjEwLFwiLi9iYWNrZW5kL2Z1bmN0aW9uLXRyYWNlclwiOjExLFwiLi9iYWNrZW5kL2dsL2tlcm5lbFwiOjEzLFwiLi9iYWNrZW5kL2hlYWRsZXNzLWdsL2tlcm5lbFwiOjM0LFwiLi9iYWNrZW5kL2tlcm5lbFwiOjM2LFwiLi9iYWNrZW5kL3dlYi1nbC9mdW5jdGlvbi1ub2RlXCI6MzgsXCIuL2JhY2tlbmQvd2ViLWdsL2tlcm5lbFwiOjcwLFwiLi9iYWNrZW5kL3dlYi1nbC9rZXJuZWwtdmFsdWUtbWFwc1wiOjM5LFwiLi9iYWNrZW5kL3dlYi1nbDIvZnVuY3Rpb24tbm9kZVwiOjczLFwiLi9iYWNrZW5kL3dlYi1nbDIva2VybmVsXCI6MTA1LFwiLi9iYWNrZW5kL3dlYi1nbDIva2VybmVsLXZhbHVlLW1hcHNcIjo3NCxcIi4vZ3B1XCI6MTA4LFwiLi9pbnB1dFwiOjExMCxcIi4vcGx1Z2lucy9tYXRoLXJhbmRvbS11bmlmb3JtbHktZGlzdHJpYnV0ZWRcIjoxMTIsXCIuL3RleHR1cmVcIjoxMTMsXCIuL3V0aWxzXCI6MTE0fV0sMTEwOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbmNsYXNzIElucHV0IHtcbiAgY29uc3RydWN0b3IodmFsdWUsIHNpemUpIHtcbiAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoc2l6ZSkpIHtcbiAgICAgIHRoaXMuc2l6ZSA9IHNpemU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc2l6ZSA9IG5ldyBJbnQzMkFycmF5KDMpO1xuICAgICAgaWYgKHNpemUueikge1xuICAgICAgICB0aGlzLnNpemUgPSBuZXcgSW50MzJBcnJheShbc2l6ZS54LCBzaXplLnksIHNpemUuel0pO1xuICAgICAgfSBlbHNlIGlmIChzaXplLnkpIHtcbiAgICAgICAgdGhpcy5zaXplID0gbmV3IEludDMyQXJyYXkoW3NpemUueCwgc2l6ZS55XSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnNpemUgPSBuZXcgSW50MzJBcnJheShbc2l6ZS54XSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgW3csIGgsIGRdID0gdGhpcy5zaXplO1xuICAgIGlmIChkKSB7XG4gICAgICBpZiAodGhpcy52YWx1ZS5sZW5ndGggIT09ICh3ICogaCAqIGQpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW5wdXQgc2l6ZSAke3RoaXMudmFsdWUubGVuZ3RofSBkb2VzIG5vdCBtYXRjaCAke3d9ICogJHtofSAqICR7ZH0gPSAkeyhoICogdyAqIGQpfWApO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaCkge1xuICAgICAgaWYgKHRoaXMudmFsdWUubGVuZ3RoICE9PSAodyAqIGgpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW5wdXQgc2l6ZSAke3RoaXMudmFsdWUubGVuZ3RofSBkb2VzIG5vdCBtYXRjaCAke3d9ICogJHtofSA9ICR7KGggKiB3KX1gKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHRoaXMudmFsdWUubGVuZ3RoICE9PSB3KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW5wdXQgc2l6ZSAke3RoaXMudmFsdWUubGVuZ3RofSBkb2VzIG5vdCBtYXRjaCAke3d9YCk7XG4gICAgICB9XG4gICAgfVxuXG4gIH1cblxuICB0b0FycmF5KCkge1xuICAgIGNvbnN0IHsgdXRpbHMgfSA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcbiAgICBjb25zdCBbdywgaCwgZF0gPSB0aGlzLnNpemU7XG4gICAgaWYgKGQpIHtcbiAgICAgIHJldHVybiB1dGlscy5lcmVjdE1lbW9yeU9wdGltaXplZDNERmxvYXQodGhpcy52YWx1ZS5zdWJhcnJheSA/IHRoaXMudmFsdWUgOiBuZXcgRmxvYXQzMkFycmF5KHRoaXMudmFsdWUpLCB3LCBoLCBkKTtcbiAgICB9IGVsc2UgaWYgKGgpIHtcbiAgICAgIHJldHVybiB1dGlscy5lcmVjdE1lbW9yeU9wdGltaXplZDJERmxvYXQodGhpcy52YWx1ZS5zdWJhcnJheSA/IHRoaXMudmFsdWUgOiBuZXcgRmxvYXQzMkFycmF5KHRoaXMudmFsdWUpLCB3LCBoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMudmFsdWU7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGlucHV0KHZhbHVlLCBzaXplKSB7XG4gIHJldHVybiBuZXcgSW5wdXQodmFsdWUsIHNpemUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgSW5wdXQsXG4gIGlucHV0XG59O1xufSx7XCIuL3V0aWxzXCI6MTE0fV0sMTExOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbmNvbnN0IHsgdXRpbHMgfSA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcblxuZnVuY3Rpb24ga2VybmVsUnVuU2hvcnRjdXQoa2VybmVsKSB7XG4gIGxldCBydW4gPSBmdW5jdGlvbigpIHtcbiAgICBrZXJuZWwuYnVpbGQuYXBwbHkoa2VybmVsLCBhcmd1bWVudHMpO1xuICAgIHJ1biA9IGZ1bmN0aW9uKCkge1xuICAgICAgbGV0IHJlc3VsdCA9IGtlcm5lbC5ydW4uYXBwbHkoa2VybmVsLCBhcmd1bWVudHMpO1xuICAgICAgaWYgKGtlcm5lbC5zd2l0Y2hpbmdLZXJuZWxzKSB7XG4gICAgICAgIGNvbnN0IHJlYXNvbnMgPSBrZXJuZWwucmVzZXRTd2l0Y2hpbmdLZXJuZWxzKCk7XG4gICAgICAgIGNvbnN0IG5ld0tlcm5lbCA9IGtlcm5lbC5vblJlcXVlc3RTd2l0Y2hLZXJuZWwocmVhc29ucywgYXJndW1lbnRzLCBrZXJuZWwpO1xuICAgICAgICBzaG9ydGN1dC5rZXJuZWwgPSBrZXJuZWwgPSBuZXdLZXJuZWw7XG4gICAgICAgIHJlc3VsdCA9IG5ld0tlcm5lbC5ydW4uYXBwbHkobmV3S2VybmVsLCBhcmd1bWVudHMpO1xuICAgICAgfVxuICAgICAgaWYgKGtlcm5lbC5yZW5kZXJLZXJuZWxzKSB7XG4gICAgICAgIHJldHVybiBrZXJuZWwucmVuZGVyS2VybmVscygpO1xuICAgICAgfSBlbHNlIGlmIChrZXJuZWwucmVuZGVyT3V0cHV0KSB7XG4gICAgICAgIHJldHVybiBrZXJuZWwucmVuZGVyT3V0cHV0KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIHJ1bi5hcHBseShrZXJuZWwsIGFyZ3VtZW50cyk7XG4gIH07XG4gIGNvbnN0IHNob3J0Y3V0ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHJ1bi5hcHBseShrZXJuZWwsIGFyZ3VtZW50cyk7XG4gIH07XG4gIHNob3J0Y3V0LmV4ZWMgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKGFjY2VwdCwgcmVqZWN0KSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBhY2NlcHQocnVuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZWplY3QoZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG4gIHNob3J0Y3V0LnJlcGxhY2VLZXJuZWwgPSBmdW5jdGlvbihyZXBsYWNlbWVudEtlcm5lbCkge1xuICAgIGtlcm5lbCA9IHJlcGxhY2VtZW50S2VybmVsO1xuICAgIGJpbmRLZXJuZWxUb1Nob3J0Y3V0KGtlcm5lbCwgc2hvcnRjdXQpO1xuICB9O1xuXG4gIGJpbmRLZXJuZWxUb1Nob3J0Y3V0KGtlcm5lbCwgc2hvcnRjdXQpO1xuICByZXR1cm4gc2hvcnRjdXQ7XG59XG5cbmZ1bmN0aW9uIGJpbmRLZXJuZWxUb1Nob3J0Y3V0KGtlcm5lbCwgc2hvcnRjdXQpIHtcbiAgaWYgKHNob3J0Y3V0Lmtlcm5lbCkge1xuICAgIHNob3J0Y3V0Lmtlcm5lbCA9IGtlcm5lbDtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgcHJvcGVydGllcyA9IHV0aWxzLmFsbFByb3BlcnRpZXNPZihrZXJuZWwpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHByb3BlcnRpZXMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBwcm9wZXJ0eSA9IHByb3BlcnRpZXNbaV07XG4gICAgaWYgKHByb3BlcnR5WzBdID09PSAnXycgJiYgcHJvcGVydHlbMV0gPT09ICdfJykgY29udGludWU7XG4gICAgaWYgKHR5cGVvZiBrZXJuZWxbcHJvcGVydHldID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpZiAocHJvcGVydHkuc3Vic3RyaW5nKDAsIDMpID09PSAnYWRkJyB8fCBwcm9wZXJ0eS5zdWJzdHJpbmcoMCwgMykgPT09ICdzZXQnKSB7XG4gICAgICAgIHNob3J0Y3V0W3Byb3BlcnR5XSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHNob3J0Y3V0Lmtlcm5lbFtwcm9wZXJ0eV0uYXBwbHkoc2hvcnRjdXQua2VybmVsLCBhcmd1bWVudHMpO1xuICAgICAgICAgIHJldHVybiBzaG9ydGN1dDtcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNob3J0Y3V0W3Byb3BlcnR5XSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiBzaG9ydGN1dC5rZXJuZWxbcHJvcGVydHldLmFwcGx5KHNob3J0Y3V0Lmtlcm5lbCwgYXJndW1lbnRzKTtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc2hvcnRjdXQuX19kZWZpbmVHZXR0ZXJfXyhwcm9wZXJ0eSwgKCkgPT4gc2hvcnRjdXQua2VybmVsW3Byb3BlcnR5XSk7XG4gICAgICBzaG9ydGN1dC5fX2RlZmluZVNldHRlcl9fKHByb3BlcnR5LCAodmFsdWUpID0+IHtcbiAgICAgICAgc2hvcnRjdXQua2VybmVsW3Byb3BlcnR5XSA9IHZhbHVlO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIHNob3J0Y3V0Lmtlcm5lbCA9IGtlcm5lbDtcbn1cbm1vZHVsZS5leHBvcnRzID0ge1xuICBrZXJuZWxSdW5TaG9ydGN1dFxufTtcbn0se1wiLi91dGlsc1wiOjExNH1dLDExMjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5jb25zdCBzb3VyY2UgPSBgLy8gaHR0cHM6Ly93d3cuc2hhZGVydG95LmNvbS92aWV3LzR0MlNEaFxuLy9ub3RlOiB1bmlmb3JtbHkgZGlzdHJpYnV0ZWQsIG5vcm1hbGl6ZWQgcmFuZCwgWzAsMV1cbmhpZ2hwIGZsb2F0IHJhbmRvbVNlZWRTaGlmdCA9IDEuMDtcbmhpZ2hwIGZsb2F0IHNsaWRlID0gMS4wO1xudW5pZm9ybSBoaWdocCBmbG9hdCByYW5kb21TZWVkMTtcbnVuaWZvcm0gaGlnaHAgZmxvYXQgcmFuZG9tU2VlZDI7XG5cbmhpZ2hwIGZsb2F0IG5yYW5kKGhpZ2hwIHZlYzIgbikge1xuICBoaWdocCBmbG9hdCByZXN1bHQgPSBmcmFjdChzaW4oZG90KChuLnh5ICsgMS4wKSAqIHZlYzIocmFuZG9tU2VlZDEgKiBzbGlkZSwgcmFuZG9tU2VlZDIgKiByYW5kb21TZWVkU2hpZnQpLCB2ZWMyKDEyLjk4OTgsIDc4LjIzMykpKSAqIDQzNzU4LjU0NTMpO1xuICByYW5kb21TZWVkU2hpZnQgPSByZXN1bHQ7XG4gIGlmIChyYW5kb21TZWVkU2hpZnQgPiAwLjUpIHtcbiAgICBzbGlkZSArPSAwLjAwMDA5OyBcbiAgfSBlbHNlIHtcbiAgICBzbGlkZSArPSAwLjAwMDk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1gO1xuXG5jb25zdCBuYW1lID0gJ21hdGgtcmFuZG9tLXVuaWZvcm1seS1kaXN0cmlidXRlZCc7XG5cbmNvbnN0IGZ1bmN0aW9uTWF0Y2ggPSBgTWF0aC5yYW5kb20oKWA7XG5cbmNvbnN0IGZ1bmN0aW9uUmVwbGFjZSA9IGBucmFuZCh2VGV4Q29vcmQpYDtcblxuY29uc3QgZnVuY3Rpb25SZXR1cm5UeXBlID0gJ051bWJlcic7XG5jb25zdCBvbkJlZm9yZVJ1biA9IChrZXJuZWwpID0+IHtcbiAga2VybmVsLnNldFVuaWZvcm0xZigncmFuZG9tU2VlZDEnLCBNYXRoLnJhbmRvbSgpKTtcbiAga2VybmVsLnNldFVuaWZvcm0xZigncmFuZG9tU2VlZDInLCBNYXRoLnJhbmRvbSgpKTtcbn07XG5cbmNvbnN0IHBsdWdpbiA9IHtcbiAgbmFtZSxcbiAgb25CZWZvcmVSdW4sXG4gIGZ1bmN0aW9uTWF0Y2gsXG4gIGZ1bmN0aW9uUmVwbGFjZSxcbiAgZnVuY3Rpb25SZXR1cm5UeXBlLFxuICBzb3VyY2Vcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gcGx1Z2luO1xufSx7fV0sMTEzOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbmNsYXNzIFRleHR1cmUge1xuICBjb25zdHJ1Y3RvcihzZXR0aW5ncykge1xuICAgIGNvbnN0IHtcbiAgICAgIHRleHR1cmUsXG4gICAgICBzaXplLFxuICAgICAgZGltZW5zaW9ucyxcbiAgICAgIG91dHB1dCxcbiAgICAgIGNvbnRleHQsXG4gICAgICB0eXBlID0gJ051bWJlclRleHR1cmUnLFxuICAgICAga2VybmVsLFxuICAgICAgaW50ZXJuYWxGb3JtYXQsXG4gICAgICB0ZXh0dXJlRm9ybWF0XG4gICAgfSA9IHNldHRpbmdzO1xuICAgIGlmICghb3V0cHV0KSB0aHJvdyBuZXcgRXJyb3IoJ3NldHRpbmdzIHByb3BlcnR5IFwib3V0cHV0XCIgcmVxdWlyZWQuJyk7XG4gICAgaWYgKCFjb250ZXh0KSB0aHJvdyBuZXcgRXJyb3IoJ3NldHRpbmdzIHByb3BlcnR5IFwiY29udGV4dFwiIHJlcXVpcmVkLicpO1xuICAgIGlmICghdGV4dHVyZSkgdGhyb3cgbmV3IEVycm9yKCdzZXR0aW5ncyBwcm9wZXJ0eSBcInRleHR1cmVcIiByZXF1aXJlZC4nKTtcbiAgICBpZiAoIWtlcm5lbCkgdGhyb3cgbmV3IEVycm9yKCdzZXR0aW5ncyBwcm9wZXJ0eSBcImtlcm5lbFwiIHJlcXVpcmVkLicpO1xuICAgIHRoaXMudGV4dHVyZSA9IHRleHR1cmU7XG4gICAgaWYgKHRleHR1cmUuX3JlZnMpIHtcbiAgICAgIHRleHR1cmUuX3JlZnMrKztcbiAgICB9IGVsc2Uge1xuICAgICAgdGV4dHVyZS5fcmVmcyA9IDE7XG4gICAgfVxuICAgIHRoaXMuc2l6ZSA9IHNpemU7XG4gICAgdGhpcy5kaW1lbnNpb25zID0gZGltZW5zaW9ucztcbiAgICB0aGlzLm91dHB1dCA9IG91dHB1dDtcbiAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgIHRoaXMua2VybmVsID0ga2VybmVsO1xuICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgdGhpcy5fZGVsZXRlZCA9IGZhbHNlO1xuICAgIHRoaXMuaW50ZXJuYWxGb3JtYXQgPSBpbnRlcm5hbEZvcm1hdDtcbiAgICB0aGlzLnRleHR1cmVGb3JtYXQgPSB0ZXh0dXJlRm9ybWF0O1xuICB9XG5cbiAgdG9BcnJheSgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYE5vdCBpbXBsZW1lbnRlZCBvbiAke3RoaXMuY29uc3RydWN0b3IubmFtZX1gKTtcbiAgfVxuXG4gIGNsb25lKCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgTm90IGltcGxlbWVudGVkIG9uICR7dGhpcy5jb25zdHJ1Y3Rvci5uYW1lfWApO1xuICB9XG5cbiAgZGVsZXRlKCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgTm90IGltcGxlbWVudGVkIG9uICR7dGhpcy5jb25zdHJ1Y3Rvci5uYW1lfWApO1xuICB9XG5cbiAgY2xlYXIoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBOb3QgaW1wbGVtZW50ZWQgb24gJHt0aGlzLmNvbnN0cnVjdG9yLm5hbWV9YCk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIFRleHR1cmVcbn07XG59LHt9XSwxMTQ6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuY29uc3QgYWNvcm4gPSByZXF1aXJlKCdhY29ybicpO1xuY29uc3QgeyBJbnB1dCB9ID0gcmVxdWlyZSgnLi9pbnB1dCcpO1xuY29uc3QgeyBUZXh0dXJlIH0gPSByZXF1aXJlKCcuL3RleHR1cmUnKTtcblxuY29uc3QgRlVOQ1RJT05fTkFNRSA9IC9mdW5jdGlvbiAoW14oXSopLztcbmNvbnN0IFNUUklQX0NPTU1FTlRTID0gLygoXFwvXFwvLiokKXwoXFwvXFwqW1xcc1xcU10qP1xcKlxcLykpL21nO1xuY29uc3QgQVJHVU1FTlRfTkFNRVMgPSAvKFteXFxzLF0rKS9nO1xuXG5jb25zdCB1dGlscyA9IHtcbiAgc3lzdGVtRW5kaWFubmVzcygpIHtcbiAgICByZXR1cm4gX3N5c3RlbUVuZGlhbm5lc3M7XG4gIH0sXG4gIGdldFN5c3RlbUVuZGlhbm5lc3MoKSB7XG4gICAgY29uc3QgYiA9IG5ldyBBcnJheUJ1ZmZlcig0KTtcbiAgICBjb25zdCBhID0gbmV3IFVpbnQzMkFycmF5KGIpO1xuICAgIGNvbnN0IGMgPSBuZXcgVWludDhBcnJheShiKTtcbiAgICBhWzBdID0gMHhkZWFkYmVlZjtcbiAgICBpZiAoY1swXSA9PT0gMHhlZikgcmV0dXJuICdMRSc7XG4gICAgaWYgKGNbMF0gPT09IDB4ZGUpIHJldHVybiAnQkUnO1xuICAgIHRocm93IG5ldyBFcnJvcigndW5rbm93biBlbmRpYW5uZXNzJyk7XG4gIH0sXG5cbiAgaXNGdW5jdGlvbihmdW5jT2JqKSB7XG4gICAgcmV0dXJuIHR5cGVvZihmdW5jT2JqKSA9PT0gJ2Z1bmN0aW9uJztcbiAgfSxcblxuICBpc0Z1bmN0aW9uU3RyaW5nKGZuKSB7XG4gICAgaWYgKHR5cGVvZiBmbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiAoZm5cbiAgICAgICAgLnNsaWNlKDAsICdmdW5jdGlvbicubGVuZ3RoKVxuICAgICAgICAudG9Mb3dlckNhc2UoKSA9PT0gJ2Z1bmN0aW9uJyk7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfSxcblxuICBnZXRGdW5jdGlvbk5hbWVGcm9tU3RyaW5nKGZ1bmNTdHIpIHtcbiAgICBjb25zdCByZXN1bHQgPSBGVU5DVElPTl9OQU1FLmV4ZWMoZnVuY1N0cik7XG4gICAgaWYgKCFyZXN1bHQgfHwgcmVzdWx0Lmxlbmd0aCA9PT0gMCkgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuIHJlc3VsdFsxXS50cmltKCk7XG4gIH0sXG5cbiAgZ2V0RnVuY3Rpb25Cb2R5RnJvbVN0cmluZyhmdW5jU3RyKSB7XG4gICAgcmV0dXJuIGZ1bmNTdHIuc3Vic3RyaW5nKGZ1bmNTdHIuaW5kZXhPZigneycpICsgMSwgZnVuY1N0ci5sYXN0SW5kZXhPZignfScpKTtcbiAgfSxcblxuICBnZXRBcmd1bWVudE5hbWVzRnJvbVN0cmluZyhmbikge1xuICAgIGNvbnN0IGZuU3RyID0gZm4ucmVwbGFjZShTVFJJUF9DT01NRU5UUywgJycpO1xuICAgIGxldCByZXN1bHQgPSBmblN0ci5zbGljZShmblN0ci5pbmRleE9mKCcoJykgKyAxLCBmblN0ci5pbmRleE9mKCcpJykpLm1hdGNoKEFSR1VNRU5UX05BTUVTKTtcbiAgICBpZiAocmVzdWx0ID09PSBudWxsKSB7XG4gICAgICByZXN1bHQgPSBbXTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSxcblxuICBjbG9uZShvYmopIHtcbiAgICBpZiAob2JqID09PSBudWxsIHx8IHR5cGVvZiBvYmogIT09ICdvYmplY3QnIHx8IG9iai5oYXNPd25Qcm9wZXJ0eSgnaXNBY3RpdmVDbG9uZScpKSByZXR1cm4gb2JqO1xuXG4gICAgY29uc3QgdGVtcCA9IG9iai5jb25zdHJ1Y3RvcigpOyBcblxuICAgIGZvciAobGV0IGtleSBpbiBvYmopIHtcbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSB7XG4gICAgICAgIG9iai5pc0FjdGl2ZUNsb25lID0gbnVsbDtcbiAgICAgICAgdGVtcFtrZXldID0gdXRpbHMuY2xvbmUob2JqW2tleV0pO1xuICAgICAgICBkZWxldGUgb2JqLmlzQWN0aXZlQ2xvbmU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRlbXA7XG4gIH0sXG5cbiAgaXNBcnJheShhcnJheSkge1xuICAgIHJldHVybiAhaXNOYU4oYXJyYXkubGVuZ3RoKTtcbiAgfSxcblxuICBnZXRWYXJpYWJsZVR5cGUodmFsdWUsIHN0cmljdEludGVnZXJzKSB7XG4gICAgaWYgKHV0aWxzLmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICBpZiAodmFsdWUubGVuZ3RoID4gMCAmJiB2YWx1ZVswXS5ub2RlTmFtZSA9PT0gJ0lNRycpIHtcbiAgICAgICAgcmV0dXJuICdIVE1MSW1hZ2VBcnJheSc7XG4gICAgICB9XG4gICAgICByZXR1cm4gJ0FycmF5JztcbiAgICB9XG5cbiAgICBzd2l0Y2ggKHZhbHVlLmNvbnN0cnVjdG9yKSB7XG4gICAgICBjYXNlIEJvb2xlYW46XG4gICAgICAgIHJldHVybiAnQm9vbGVhbic7XG4gICAgICBjYXNlIE51bWJlcjpcbiAgICAgICAgaWYgKHN0cmljdEludGVnZXJzICYmIE51bWJlci5pc0ludGVnZXIodmFsdWUpKSB7XG4gICAgICAgICAgcmV0dXJuICdJbnRlZ2VyJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJ0Zsb2F0JztcbiAgICAgIGNhc2UgVGV4dHVyZTpcbiAgICAgICAgcmV0dXJuIHZhbHVlLnR5cGU7XG4gICAgICBjYXNlIElucHV0OlxuICAgICAgICByZXR1cm4gJ0lucHV0JztcbiAgICB9XG4gICAgc3dpdGNoICh2YWx1ZS5ub2RlTmFtZSkge1xuICAgICAgY2FzZSAnSU1HJzpcbiAgICAgICAgcmV0dXJuICdIVE1MSW1hZ2UnO1xuICAgICAgY2FzZSAnQ0FOVkFTJzpcbiAgICAgICAgcmV0dXJuICdIVE1MSW1hZ2UnO1xuICAgICAgY2FzZSAnVklERU8nOlxuICAgICAgICByZXR1cm4gJ0hUTUxWaWRlbyc7XG4gICAgfVxuICAgIGlmICh2YWx1ZS5oYXNPd25Qcm9wZXJ0eSgndHlwZScpKSB7XG4gICAgICByZXR1cm4gdmFsdWUudHlwZTtcbiAgICB9XG4gICAgcmV0dXJuICdVbmtub3duJztcbiAgfSxcblxuICBnZXRLZXJuZWxUZXh0dXJlU2l6ZShzZXR0aW5ncywgZGltZW5zaW9ucykge1xuICAgIGxldCBbdywgaCwgZF0gPSBkaW1lbnNpb25zO1xuICAgIGxldCB0ZXhlbENvdW50ID0gKHcgfHwgMSkgKiAoaCB8fCAxKSAqIChkIHx8IDEpO1xuXG4gICAgaWYgKHNldHRpbmdzLm9wdGltaXplRmxvYXRNZW1vcnkgJiYgc2V0dGluZ3MucHJlY2lzaW9uID09PSAnc2luZ2xlJykge1xuICAgICAgdyA9IHRleGVsQ291bnQgPSBNYXRoLmNlaWwodGV4ZWxDb3VudCAvIDQpO1xuICAgIH1cbiAgICBpZiAoaCA+IDEgJiYgdyAqIGggPT09IHRleGVsQ291bnQpIHtcbiAgICAgIHJldHVybiBuZXcgSW50MzJBcnJheShbdywgaF0pO1xuICAgIH1cbiAgICByZXR1cm4gdXRpbHMuY2xvc2VzdFNxdWFyZURpbWVuc2lvbnModGV4ZWxDb3VudCk7XG4gIH0sXG5cbiAgY2xvc2VzdFNxdWFyZURpbWVuc2lvbnMobGVuZ3RoKSB7XG4gICAgY29uc3Qgc3FydCA9IE1hdGguc3FydChsZW5ndGgpO1xuICAgIGxldCBoaWdoID0gTWF0aC5jZWlsKHNxcnQpO1xuICAgIGxldCBsb3cgPSBNYXRoLmZsb29yKHNxcnQpO1xuICAgIHdoaWxlIChoaWdoICogbG93IDwgbGVuZ3RoKSB7XG4gICAgICBoaWdoLS07XG4gICAgICBsb3cgPSBNYXRoLmNlaWwobGVuZ3RoIC8gaGlnaCk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgSW50MzJBcnJheShbbG93LCBNYXRoLmNlaWwobGVuZ3RoIC8gbG93KV0pO1xuICB9LFxuXG4gIGdldE1lbW9yeU9wdGltaXplZEZsb2F0VGV4dHVyZVNpemUoZGltZW5zaW9ucywgYml0UmF0aW8pIHtcbiAgICBjb25zdCB0b3RhbEFyZWEgPSB1dGlscy5yb3VuZFRvKChkaW1lbnNpb25zWzBdIHx8IDEpICogKGRpbWVuc2lvbnNbMV0gfHwgMSkgKiAoZGltZW5zaW9uc1syXSB8fCAxKSAqIChkaW1lbnNpb25zWzNdIHx8IDEpLCA0KTtcbiAgICBjb25zdCB0ZXhlbENvdW50ID0gdG90YWxBcmVhIC8gYml0UmF0aW87XG4gICAgcmV0dXJuIHV0aWxzLmNsb3Nlc3RTcXVhcmVEaW1lbnNpb25zKHRleGVsQ291bnQpO1xuICB9LFxuXG4gIGdldE1lbW9yeU9wdGltaXplZFBhY2tlZFRleHR1cmVTaXplKGRpbWVuc2lvbnMsIGJpdFJhdGlvKSB7XG4gICAgY29uc3QgW3csIGgsIGRdID0gZGltZW5zaW9ucztcbiAgICBjb25zdCB0b3RhbEFyZWEgPSB1dGlscy5yb3VuZFRvKCh3IHx8IDEpICogKGggfHwgMSkgKiAoZCB8fCAxKSwgNCk7XG4gICAgY29uc3QgdGV4ZWxDb3VudCA9IHRvdGFsQXJlYSAvICg0IC8gYml0UmF0aW8pO1xuICAgIHJldHVybiB1dGlscy5jbG9zZXN0U3F1YXJlRGltZW5zaW9ucyh0ZXhlbENvdW50KTtcbiAgfSxcblxuICByb3VuZFRvKG4sIGQpIHtcbiAgICByZXR1cm4gTWF0aC5mbG9vcigobiArIGQgLSAxKSAvIGQpICogZDtcbiAgfSxcbiAgZ2V0RGltZW5zaW9ucyh4LCBwYWQpIHtcbiAgICBsZXQgcmV0O1xuICAgIGlmICh1dGlscy5pc0FycmF5KHgpKSB7XG4gICAgICBjb25zdCBkaW0gPSBbXTtcbiAgICAgIGxldCB0ZW1wID0geDtcbiAgICAgIHdoaWxlICh1dGlscy5pc0FycmF5KHRlbXApKSB7XG4gICAgICAgIGRpbS5wdXNoKHRlbXAubGVuZ3RoKTtcbiAgICAgICAgdGVtcCA9IHRlbXBbMF07XG4gICAgICB9XG4gICAgICByZXQgPSBkaW0ucmV2ZXJzZSgpO1xuICAgIH0gZWxzZSBpZiAoeCBpbnN0YW5jZW9mIFRleHR1cmUpIHtcbiAgICAgIHJldCA9IHgub3V0cHV0O1xuICAgIH0gZWxzZSBpZiAoeCBpbnN0YW5jZW9mIElucHV0KSB7XG4gICAgICByZXQgPSB4LnNpemU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBkaW1lbnNpb25zIG9mICR7eH1gKTtcbiAgICB9XG5cbiAgICBpZiAocGFkKSB7XG4gICAgICByZXQgPSBBcnJheS5mcm9tKHJldCk7XG4gICAgICB3aGlsZSAocmV0Lmxlbmd0aCA8IDMpIHtcbiAgICAgICAgcmV0LnB1c2goMSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBJbnQzMkFycmF5KHJldCk7XG4gIH0sXG5cbiAgZmxhdHRlbjJkQXJyYXlUbyhhcnJheSwgdGFyZ2V0KSB7XG4gICAgbGV0IG9mZnNldCA9IDA7XG4gICAgZm9yIChsZXQgeSA9IDA7IHkgPCBhcnJheS5sZW5ndGg7IHkrKykge1xuICAgICAgdGFyZ2V0LnNldChhcnJheVt5XSwgb2Zmc2V0KTtcbiAgICAgIG9mZnNldCArPSBhcnJheVt5XS5sZW5ndGg7XG4gICAgfVxuICB9LFxuXG4gIGZsYXR0ZW4zZEFycmF5VG8oYXJyYXksIHRhcmdldCkge1xuICAgIGxldCBvZmZzZXQgPSAwO1xuICAgIGZvciAobGV0IHogPSAwOyB6IDwgYXJyYXkubGVuZ3RoOyB6KyspIHtcbiAgICAgIGZvciAobGV0IHkgPSAwOyB5IDwgYXJyYXlbel0ubGVuZ3RoOyB5KyspIHtcbiAgICAgICAgdGFyZ2V0LnNldChhcnJheVt6XVt5XSwgb2Zmc2V0KTtcbiAgICAgICAgb2Zmc2V0ICs9IGFycmF5W3pdW3ldLmxlbmd0aDtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgZmxhdHRlbjRkQXJyYXlUbyhhcnJheSwgdGFyZ2V0KSB7XG4gICAgbGV0IG9mZnNldCA9IDA7XG4gICAgZm9yIChsZXQgbCA9IDA7IGwgPCBhcnJheS5sZW5ndGg7IGwrKykge1xuICAgICAgZm9yIChsZXQgeiA9IDA7IHogPCBhcnJheVtsXS5sZW5ndGg7IHorKykge1xuICAgICAgICBmb3IgKGxldCB5ID0gMDsgeSA8IGFycmF5W2xdW3pdLmxlbmd0aDsgeSsrKSB7XG4gICAgICAgICAgdGFyZ2V0LnNldChhcnJheVtsXVt6XVt5XSwgb2Zmc2V0KTtcbiAgICAgICAgICBvZmZzZXQgKz0gYXJyYXlbbF1bel1beV0ubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIGZsYXR0ZW5UbyhhcnJheSwgdGFyZ2V0KSB7XG4gICAgaWYgKHV0aWxzLmlzQXJyYXkoYXJyYXlbMF0pKSB7XG4gICAgICBpZiAodXRpbHMuaXNBcnJheShhcnJheVswXVswXSkpIHtcbiAgICAgICAgaWYgKHV0aWxzLmlzQXJyYXkoYXJyYXlbMF1bMF1bMF0pKSB7XG4gICAgICAgICAgdXRpbHMuZmxhdHRlbjRkQXJyYXlUbyhhcnJheSwgdGFyZ2V0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB1dGlscy5mbGF0dGVuM2RBcnJheVRvKGFycmF5LCB0YXJnZXQpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB1dGlscy5mbGF0dGVuMmRBcnJheVRvKGFycmF5LCB0YXJnZXQpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0YXJnZXQuc2V0KGFycmF5KTtcbiAgICB9XG4gIH0sXG5cbiAgc3BsaXRBcnJheShhcnJheSwgcGFydCkge1xuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpICs9IHBhcnQpIHtcbiAgICAgIHJlc3VsdC5wdXNoKG5ldyBhcnJheS5jb25zdHJ1Y3RvcihhcnJheS5idWZmZXIsIGkgKiA0ICsgYXJyYXkuYnl0ZU9mZnNldCwgcGFydCkpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9LFxuXG4gIGdldEFzdFN0cmluZyhzb3VyY2UsIGFzdCkge1xuICAgIGNvbnN0IGxpbmVzID0gQXJyYXkuaXNBcnJheShzb3VyY2UpID8gc291cmNlIDogc291cmNlLnNwbGl0KC9cXHI/XFxuL2cpO1xuICAgIGNvbnN0IHN0YXJ0ID0gYXN0LmxvYy5zdGFydDtcbiAgICBjb25zdCBlbmQgPSBhc3QubG9jLmVuZDtcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICBpZiAoc3RhcnQubGluZSA9PT0gZW5kLmxpbmUpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGxpbmVzW3N0YXJ0LmxpbmUgLSAxXS5zdWJzdHJpbmcoc3RhcnQuY29sdW1uLCBlbmQuY29sdW1uKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdC5wdXNoKGxpbmVzW3N0YXJ0LmxpbmUgLSAxXS5zbGljZShzdGFydC5jb2x1bW4pKTtcbiAgICAgIGZvciAobGV0IGkgPSBzdGFydC5saW5lOyBpIDwgZW5kLmxpbmU7IGkrKykge1xuICAgICAgICByZXN1bHQucHVzaChsaW5lc1tpXSk7XG4gICAgICB9XG4gICAgICByZXN1bHQucHVzaChsaW5lc1tlbmQubGluZSAtIDFdLnNsaWNlKDAsIGVuZC5jb2x1bW4pKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdC5qb2luKCdcXG4nKTtcbiAgfSxcblxuICBhbGxQcm9wZXJ0aWVzT2Yob2JqKSB7XG4gICAgY29uc3QgcHJvcHMgPSBbXTtcblxuICAgIGRvIHtcbiAgICAgIHByb3BzLnB1c2guYXBwbHkocHJvcHMsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKG9iaikpO1xuICAgIH0gd2hpbGUgKG9iaiA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmopKTtcblxuICAgIHJldHVybiBwcm9wcztcbiAgfSxcblxuICBsaW5lc1RvU3RyaW5nKGxpbmVzKSB7XG4gICAgaWYgKGxpbmVzLmxlbmd0aCA+IDApIHtcbiAgICAgIHJldHVybiBsaW5lcy5qb2luKCc7XFxuJykgKyAnO1xcbic7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAnXFxuJztcbiAgICB9XG4gIH0sXG4gIHdhcm5EZXByZWNhdGVkKHR5cGUsIG9sZE5hbWUsIG5ld05hbWUpIHtcbiAgICBpZiAobmV3TmFtZSkge1xuICAgICAgY29uc29sZS53YXJuKGBZb3UgYXJlIHVzaW5nIGEgZGVwcmVjYXRlZCAkeyB0eXBlIH0gXCIkeyBvbGROYW1lIH1cIi4gSXQgaGFzIGJlZW4gcmVwbGFjZWQgd2l0aCBcIiR7IG5ld05hbWUgfVwiLiBGaXhpbmcsIGJ1dCBwbGVhc2UgdXBncmFkZSBhcyBpdCB3aWxsIHNvb24gYmUgcmVtb3ZlZC5gKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc29sZS53YXJuKGBZb3UgYXJlIHVzaW5nIGEgZGVwcmVjYXRlZCAkeyB0eXBlIH0gXCIkeyBvbGROYW1lIH1cIi4gSXQgaGFzIGJlZW4gcmVtb3ZlZC4gRml4aW5nLCBidXQgcGxlYXNlIHVwZ3JhZGUgYXMgaXQgd2lsbCBzb29uIGJlIHJlbW92ZWQuYCk7XG4gICAgfVxuICB9LFxuICBmbGlwUGl4ZWxzOiAocGl4ZWxzLCB3aWR0aCwgaGVpZ2h0KSA9PiB7XG4gICAgY29uc3QgaGFsZkhlaWdodCA9IGhlaWdodCAvIDIgfCAwOyBcbiAgICBjb25zdCBieXRlc1BlclJvdyA9IHdpZHRoICogNDtcbiAgICBjb25zdCB0ZW1wID0gbmV3IFVpbnQ4Q2xhbXBlZEFycmF5KHdpZHRoICogNCk7XG4gICAgY29uc3QgcmVzdWx0ID0gcGl4ZWxzLnNsaWNlKDApO1xuICAgIGZvciAobGV0IHkgPSAwOyB5IDwgaGFsZkhlaWdodDsgKyt5KSB7XG4gICAgICBjb25zdCB0b3BPZmZzZXQgPSB5ICogYnl0ZXNQZXJSb3c7XG4gICAgICBjb25zdCBib3R0b21PZmZzZXQgPSAoaGVpZ2h0IC0geSAtIDEpICogYnl0ZXNQZXJSb3c7XG5cbiAgICAgIHRlbXAuc2V0KHJlc3VsdC5zdWJhcnJheSh0b3BPZmZzZXQsIHRvcE9mZnNldCArIGJ5dGVzUGVyUm93KSk7XG5cbiAgICAgIHJlc3VsdC5jb3B5V2l0aGluKHRvcE9mZnNldCwgYm90dG9tT2Zmc2V0LCBib3R0b21PZmZzZXQgKyBieXRlc1BlclJvdyk7XG5cbiAgICAgIHJlc3VsdC5zZXQodGVtcCwgYm90dG9tT2Zmc2V0KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSxcbiAgZXJlY3RQYWNrZWRGbG9hdDogKGFycmF5LCB3aWR0aCkgPT4ge1xuICAgIHJldHVybiBhcnJheS5zdWJhcnJheSgwLCB3aWR0aCk7XG4gIH0sXG4gIGVyZWN0MkRQYWNrZWRGbG9hdDogKGFycmF5LCB3aWR0aCwgaGVpZ2h0KSA9PiB7XG4gICAgY29uc3QgeVJlc3VsdHMgPSBuZXcgQXJyYXkoaGVpZ2h0KTtcbiAgICBmb3IgKGxldCB5ID0gMDsgeSA8IGhlaWdodDsgeSsrKSB7XG4gICAgICBjb25zdCB4U3RhcnQgPSB5ICogd2lkdGg7XG4gICAgICBjb25zdCB4RW5kID0geFN0YXJ0ICsgd2lkdGg7XG4gICAgICB5UmVzdWx0c1t5XSA9IGFycmF5LnN1YmFycmF5KHhTdGFydCwgeEVuZCk7XG4gICAgfVxuICAgIHJldHVybiB5UmVzdWx0cztcbiAgfSxcbiAgZXJlY3QzRFBhY2tlZEZsb2F0OiAoYXJyYXksIHdpZHRoLCBoZWlnaHQsIGRlcHRoKSA9PiB7XG4gICAgY29uc3QgelJlc3VsdHMgPSBuZXcgQXJyYXkoZGVwdGgpO1xuICAgIGZvciAobGV0IHogPSAwOyB6IDwgZGVwdGg7IHorKykge1xuICAgICAgY29uc3QgeVJlc3VsdHMgPSBuZXcgQXJyYXkoaGVpZ2h0KTtcbiAgICAgIGZvciAobGV0IHkgPSAwOyB5IDwgaGVpZ2h0OyB5KyspIHtcbiAgICAgICAgY29uc3QgeFN0YXJ0ID0gKHogKiBoZWlnaHQgKiB3aWR0aCkgKyB5ICogd2lkdGg7XG4gICAgICAgIGNvbnN0IHhFbmQgPSB4U3RhcnQgKyB3aWR0aDtcbiAgICAgICAgeVJlc3VsdHNbeV0gPSBhcnJheS5zdWJhcnJheSh4U3RhcnQsIHhFbmQpO1xuICAgICAgfVxuICAgICAgelJlc3VsdHNbel0gPSB5UmVzdWx0cztcbiAgICB9XG4gICAgcmV0dXJuIHpSZXN1bHRzO1xuICB9LFxuICBlcmVjdE1lbW9yeU9wdGltaXplZEZsb2F0OiAoYXJyYXksIHdpZHRoKSA9PiB7XG4gICAgcmV0dXJuIGFycmF5LnN1YmFycmF5KDAsIHdpZHRoKTtcbiAgfSxcbiAgZXJlY3RNZW1vcnlPcHRpbWl6ZWQyREZsb2F0OiAoYXJyYXksIHdpZHRoLCBoZWlnaHQpID0+IHtcbiAgICBjb25zdCB5UmVzdWx0cyA9IG5ldyBBcnJheShoZWlnaHQpO1xuICAgIGZvciAobGV0IHkgPSAwOyB5IDwgaGVpZ2h0OyB5KyspIHtcbiAgICAgIGNvbnN0IG9mZnNldCA9IHkgKiB3aWR0aDtcbiAgICAgIHlSZXN1bHRzW3ldID0gYXJyYXkuc3ViYXJyYXkob2Zmc2V0LCBvZmZzZXQgKyB3aWR0aCk7XG4gICAgfVxuICAgIHJldHVybiB5UmVzdWx0cztcbiAgfSxcbiAgZXJlY3RNZW1vcnlPcHRpbWl6ZWQzREZsb2F0OiAoYXJyYXksIHdpZHRoLCBoZWlnaHQsIGRlcHRoKSA9PiB7XG4gICAgY29uc3QgelJlc3VsdHMgPSBuZXcgQXJyYXkoZGVwdGgpO1xuICAgIGZvciAobGV0IHogPSAwOyB6IDwgZGVwdGg7IHorKykge1xuICAgICAgY29uc3QgeVJlc3VsdHMgPSBuZXcgQXJyYXkoaGVpZ2h0KTtcbiAgICAgIGZvciAobGV0IHkgPSAwOyB5IDwgaGVpZ2h0OyB5KyspIHtcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gKHogKiBoZWlnaHQgKiB3aWR0aCkgKyAoeSAqIHdpZHRoKTtcbiAgICAgICAgeVJlc3VsdHNbeV0gPSBhcnJheS5zdWJhcnJheShvZmZzZXQsIG9mZnNldCArIHdpZHRoKTtcbiAgICAgIH1cbiAgICAgIHpSZXN1bHRzW3pdID0geVJlc3VsdHM7XG4gICAgfVxuICAgIHJldHVybiB6UmVzdWx0cztcbiAgfSxcbiAgZXJlY3RGbG9hdDogKGFycmF5LCB3aWR0aCkgPT4ge1xuICAgIGNvbnN0IHhSZXN1bHRzID0gbmV3IEZsb2F0MzJBcnJheSh3aWR0aCk7XG4gICAgbGV0IGkgPSAwO1xuICAgIGZvciAobGV0IHggPSAwOyB4IDwgd2lkdGg7IHgrKykge1xuICAgICAgeFJlc3VsdHNbeF0gPSBhcnJheVtpXTtcbiAgICAgIGkgKz0gNDtcbiAgICB9XG4gICAgcmV0dXJuIHhSZXN1bHRzO1xuICB9LFxuICBlcmVjdDJERmxvYXQ6IChhcnJheSwgd2lkdGgsIGhlaWdodCkgPT4ge1xuICAgIGNvbnN0IHlSZXN1bHRzID0gbmV3IEFycmF5KGhlaWdodCk7XG4gICAgbGV0IGkgPSAwO1xuICAgIGZvciAobGV0IHkgPSAwOyB5IDwgaGVpZ2h0OyB5KyspIHtcbiAgICAgIGNvbnN0IHhSZXN1bHRzID0gbmV3IEZsb2F0MzJBcnJheSh3aWR0aCk7XG4gICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IHdpZHRoOyB4KyspIHtcbiAgICAgICAgeFJlc3VsdHNbeF0gPSBhcnJheVtpXTtcbiAgICAgICAgaSArPSA0O1xuICAgICAgfVxuICAgICAgeVJlc3VsdHNbeV0gPSB4UmVzdWx0cztcbiAgICB9XG4gICAgcmV0dXJuIHlSZXN1bHRzO1xuICB9LFxuICBlcmVjdDNERmxvYXQ6IChhcnJheSwgd2lkdGgsIGhlaWdodCwgZGVwdGgpID0+IHtcbiAgICBjb25zdCB6UmVzdWx0cyA9IG5ldyBBcnJheShkZXB0aCk7XG4gICAgbGV0IGkgPSAwO1xuICAgIGZvciAobGV0IHogPSAwOyB6IDwgZGVwdGg7IHorKykge1xuICAgICAgY29uc3QgeVJlc3VsdHMgPSBuZXcgQXJyYXkoaGVpZ2h0KTtcbiAgICAgIGZvciAobGV0IHkgPSAwOyB5IDwgaGVpZ2h0OyB5KyspIHtcbiAgICAgICAgY29uc3QgeFJlc3VsdHMgPSBuZXcgRmxvYXQzMkFycmF5KHdpZHRoKTtcbiAgICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCB3aWR0aDsgeCsrKSB7XG4gICAgICAgICAgeFJlc3VsdHNbeF0gPSBhcnJheVtpXTtcbiAgICAgICAgICBpICs9IDQ7XG4gICAgICAgIH1cbiAgICAgICAgeVJlc3VsdHNbeV0gPSB4UmVzdWx0cztcbiAgICAgIH1cbiAgICAgIHpSZXN1bHRzW3pdID0geVJlc3VsdHM7XG4gICAgfVxuICAgIHJldHVybiB6UmVzdWx0cztcbiAgfSxcbiAgZXJlY3RBcnJheTI6IChhcnJheSwgd2lkdGgpID0+IHtcbiAgICBjb25zdCB4UmVzdWx0cyA9IG5ldyBBcnJheSh3aWR0aCk7XG4gICAgY29uc3QgeFJlc3VsdHNNYXggPSB3aWR0aCAqIDQ7XG4gICAgbGV0IGkgPSAwO1xuICAgIGZvciAobGV0IHggPSAwOyB4IDwgeFJlc3VsdHNNYXg7IHggKz0gNCkge1xuICAgICAgeFJlc3VsdHNbaSsrXSA9IGFycmF5LnN1YmFycmF5KHgsIHggKyAyKTtcbiAgICB9XG4gICAgcmV0dXJuIHhSZXN1bHRzO1xuICB9LFxuICBlcmVjdDJEQXJyYXkyOiAoYXJyYXksIHdpZHRoLCBoZWlnaHQpID0+IHtcbiAgICBjb25zdCB5UmVzdWx0cyA9IG5ldyBBcnJheShoZWlnaHQpO1xuICAgIGNvbnN0IFhSZXN1bHRzTWF4ID0gd2lkdGggKiA0O1xuICAgIGZvciAobGV0IHkgPSAwOyB5IDwgaGVpZ2h0OyB5KyspIHtcbiAgICAgIGNvbnN0IHhSZXN1bHRzID0gbmV3IEFycmF5KHdpZHRoKTtcbiAgICAgIGNvbnN0IG9mZnNldCA9IHkgKiBYUmVzdWx0c01heDtcbiAgICAgIGxldCBpID0gMDtcbiAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgWFJlc3VsdHNNYXg7IHggKz0gNCkge1xuICAgICAgICB4UmVzdWx0c1tpKytdID0gYXJyYXkuc3ViYXJyYXkoeCArIG9mZnNldCwgeCArIG9mZnNldCArIDIpO1xuICAgICAgfVxuICAgICAgeVJlc3VsdHNbeV0gPSB4UmVzdWx0cztcbiAgICB9XG4gICAgcmV0dXJuIHlSZXN1bHRzO1xuICB9LFxuICBlcmVjdDNEQXJyYXkyOiAoYXJyYXksIHdpZHRoLCBoZWlnaHQsIGRlcHRoKSA9PiB7XG4gICAgY29uc3QgeFJlc3VsdHNNYXggPSB3aWR0aCAqIDQ7XG4gICAgY29uc3QgelJlc3VsdHMgPSBuZXcgQXJyYXkoZGVwdGgpO1xuICAgIGZvciAobGV0IHogPSAwOyB6IDwgZGVwdGg7IHorKykge1xuICAgICAgY29uc3QgeVJlc3VsdHMgPSBuZXcgQXJyYXkoaGVpZ2h0KTtcbiAgICAgIGZvciAobGV0IHkgPSAwOyB5IDwgaGVpZ2h0OyB5KyspIHtcbiAgICAgICAgY29uc3QgeFJlc3VsdHMgPSBuZXcgQXJyYXkod2lkdGgpO1xuICAgICAgICBjb25zdCBvZmZzZXQgPSAoeiAqIHhSZXN1bHRzTWF4ICogaGVpZ2h0KSArICh5ICogeFJlc3VsdHNNYXgpO1xuICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgeFJlc3VsdHNNYXg7IHggKz0gNCkge1xuICAgICAgICAgIHhSZXN1bHRzW2krK10gPSBhcnJheS5zdWJhcnJheSh4ICsgb2Zmc2V0LCB4ICsgb2Zmc2V0ICsgMik7XG4gICAgICAgIH1cbiAgICAgICAgeVJlc3VsdHNbeV0gPSB4UmVzdWx0cztcbiAgICAgIH1cbiAgICAgIHpSZXN1bHRzW3pdID0geVJlc3VsdHM7XG4gICAgfVxuICAgIHJldHVybiB6UmVzdWx0cztcbiAgfSxcbiAgZXJlY3RBcnJheTM6IChhcnJheSwgd2lkdGgpID0+IHtcbiAgICBjb25zdCB4UmVzdWx0cyA9IG5ldyBBcnJheSh3aWR0aCk7XG4gICAgY29uc3QgeFJlc3VsdHNNYXggPSB3aWR0aCAqIDQ7XG4gICAgbGV0IGkgPSAwO1xuICAgIGZvciAobGV0IHggPSAwOyB4IDwgeFJlc3VsdHNNYXg7IHggKz0gNCkge1xuICAgICAgeFJlc3VsdHNbaSsrXSA9IGFycmF5LnN1YmFycmF5KHgsIHggKyAzKTtcbiAgICB9XG4gICAgcmV0dXJuIHhSZXN1bHRzO1xuICB9LFxuICBlcmVjdDJEQXJyYXkzOiAoYXJyYXksIHdpZHRoLCBoZWlnaHQpID0+IHtcbiAgICBjb25zdCB4UmVzdWx0c01heCA9IHdpZHRoICogNDtcbiAgICBjb25zdCB5UmVzdWx0cyA9IG5ldyBBcnJheShoZWlnaHQpO1xuICAgIGZvciAobGV0IHkgPSAwOyB5IDwgaGVpZ2h0OyB5KyspIHtcbiAgICAgIGNvbnN0IHhSZXN1bHRzID0gbmV3IEFycmF5KHdpZHRoKTtcbiAgICAgIGNvbnN0IG9mZnNldCA9IHkgKiB4UmVzdWx0c01heDtcbiAgICAgIGxldCBpID0gMDtcbiAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgeFJlc3VsdHNNYXg7IHggKz0gNCkge1xuICAgICAgICB4UmVzdWx0c1tpKytdID0gYXJyYXkuc3ViYXJyYXkoeCArIG9mZnNldCwgeCArIG9mZnNldCArIDMpO1xuICAgICAgfVxuICAgICAgeVJlc3VsdHNbeV0gPSB4UmVzdWx0cztcbiAgICB9XG4gICAgcmV0dXJuIHlSZXN1bHRzO1xuICB9LFxuICBlcmVjdDNEQXJyYXkzOiAoYXJyYXksIHdpZHRoLCBoZWlnaHQsIGRlcHRoKSA9PiB7XG4gICAgY29uc3QgeFJlc3VsdHNNYXggPSB3aWR0aCAqIDQ7XG4gICAgY29uc3QgelJlc3VsdHMgPSBuZXcgQXJyYXkoZGVwdGgpO1xuICAgIGZvciAobGV0IHogPSAwOyB6IDwgZGVwdGg7IHorKykge1xuICAgICAgY29uc3QgeVJlc3VsdHMgPSBuZXcgQXJyYXkoaGVpZ2h0KTtcbiAgICAgIGZvciAobGV0IHkgPSAwOyB5IDwgaGVpZ2h0OyB5KyspIHtcbiAgICAgICAgY29uc3QgeFJlc3VsdHMgPSBuZXcgQXJyYXkod2lkdGgpO1xuICAgICAgICBjb25zdCBvZmZzZXQgPSAoeiAqIHhSZXN1bHRzTWF4ICogaGVpZ2h0KSArICh5ICogeFJlc3VsdHNNYXgpO1xuICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgeFJlc3VsdHNNYXg7IHggKz0gNCkge1xuICAgICAgICAgIHhSZXN1bHRzW2krK10gPSBhcnJheS5zdWJhcnJheSh4ICsgb2Zmc2V0LCB4ICsgb2Zmc2V0ICsgMyk7XG4gICAgICAgIH1cbiAgICAgICAgeVJlc3VsdHNbeV0gPSB4UmVzdWx0cztcbiAgICAgIH1cbiAgICAgIHpSZXN1bHRzW3pdID0geVJlc3VsdHM7XG4gICAgfVxuICAgIHJldHVybiB6UmVzdWx0cztcbiAgfSxcbiAgZXJlY3RBcnJheTQ6IChhcnJheSwgd2lkdGgpID0+IHtcbiAgICBjb25zdCB4UmVzdWx0cyA9IG5ldyBBcnJheShhcnJheSk7XG4gICAgY29uc3QgeFJlc3VsdHNNYXggPSB3aWR0aCAqIDQ7XG4gICAgbGV0IGkgPSAwO1xuICAgIGZvciAobGV0IHggPSAwOyB4IDwgeFJlc3VsdHNNYXg7IHggKz0gNCkge1xuICAgICAgeFJlc3VsdHNbaSsrXSA9IGFycmF5LnN1YmFycmF5KHgsIHggKyA0KTtcbiAgICB9XG4gICAgcmV0dXJuIHhSZXN1bHRzO1xuICB9LFxuICBlcmVjdDJEQXJyYXk0OiAoYXJyYXksIHdpZHRoLCBoZWlnaHQpID0+IHtcbiAgICBjb25zdCB4UmVzdWx0c01heCA9IHdpZHRoICogNDtcbiAgICBjb25zdCB5UmVzdWx0cyA9IG5ldyBBcnJheShoZWlnaHQpO1xuICAgIGZvciAobGV0IHkgPSAwOyB5IDwgaGVpZ2h0OyB5KyspIHtcbiAgICAgIGNvbnN0IHhSZXN1bHRzID0gbmV3IEFycmF5KHdpZHRoKTtcbiAgICAgIGNvbnN0IG9mZnNldCA9IHkgKiB4UmVzdWx0c01heDtcbiAgICAgIGxldCBpID0gMDtcbiAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgeFJlc3VsdHNNYXg7IHggKz0gNCkge1xuICAgICAgICB4UmVzdWx0c1tpKytdID0gYXJyYXkuc3ViYXJyYXkoeCArIG9mZnNldCwgeCArIG9mZnNldCArIDQpO1xuICAgICAgfVxuICAgICAgeVJlc3VsdHNbeV0gPSB4UmVzdWx0cztcbiAgICB9XG4gICAgcmV0dXJuIHlSZXN1bHRzO1xuICB9LFxuICBlcmVjdDNEQXJyYXk0OiAoYXJyYXksIHdpZHRoLCBoZWlnaHQsIGRlcHRoKSA9PiB7XG4gICAgY29uc3QgeFJlc3VsdHNNYXggPSB3aWR0aCAqIDQ7XG4gICAgY29uc3QgelJlc3VsdHMgPSBuZXcgQXJyYXkoZGVwdGgpO1xuICAgIGZvciAobGV0IHogPSAwOyB6IDwgZGVwdGg7IHorKykge1xuICAgICAgY29uc3QgeVJlc3VsdHMgPSBuZXcgQXJyYXkoaGVpZ2h0KTtcbiAgICAgIGZvciAobGV0IHkgPSAwOyB5IDwgaGVpZ2h0OyB5KyspIHtcbiAgICAgICAgY29uc3QgeFJlc3VsdHMgPSBuZXcgQXJyYXkod2lkdGgpO1xuICAgICAgICBjb25zdCBvZmZzZXQgPSAoeiAqIHhSZXN1bHRzTWF4ICogaGVpZ2h0KSArICh5ICogeFJlc3VsdHNNYXgpO1xuICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgeFJlc3VsdHNNYXg7IHggKz0gNCkge1xuICAgICAgICAgIHhSZXN1bHRzW2krK10gPSBhcnJheS5zdWJhcnJheSh4ICsgb2Zmc2V0LCB4ICsgb2Zmc2V0ICsgNCk7XG4gICAgICAgIH1cbiAgICAgICAgeVJlc3VsdHNbeV0gPSB4UmVzdWx0cztcbiAgICAgIH1cbiAgICAgIHpSZXN1bHRzW3pdID0geVJlc3VsdHM7XG4gICAgfVxuICAgIHJldHVybiB6UmVzdWx0cztcbiAgfSxcblxuICBmbGF0dGVuRnVuY3Rpb25Ub1N0cmluZzogKHNvdXJjZSwgc2V0dGluZ3MpID0+IHtcbiAgICBjb25zdCB7IGZpbmREZXBlbmRlbmN5LCB0aGlzTG9va3VwLCBkb05vdERlZmluZSB9ID0gc2V0dGluZ3M7XG4gICAgbGV0IGZsYXR0ZW5lZCA9IHNldHRpbmdzLmZsYXR0ZW5lZDtcbiAgICBpZiAoIWZsYXR0ZW5lZCkge1xuICAgICAgZmxhdHRlbmVkID0gc2V0dGluZ3MuZmxhdHRlbmVkID0ge307XG4gICAgfVxuICAgIGNvbnN0IGFzdCA9IGFjb3JuLnBhcnNlKHNvdXJjZSk7XG4gICAgY29uc3QgZnVuY3Rpb25EZXBlbmRlbmNpZXMgPSBbXTtcbiAgICBsZXQgaW5kZW50ID0gMDtcblxuICAgIGZ1bmN0aW9uIGZsYXR0ZW4oYXN0KSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShhc3QpKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdHMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICByZXN1bHRzLnB1c2goZmxhdHRlbihhc3RbaV0pKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0cy5qb2luKCcnKTtcbiAgICAgIH1cbiAgICAgIHN3aXRjaCAoYXN0LnR5cGUpIHtcbiAgICAgICAgY2FzZSAnUHJvZ3JhbSc6XG4gICAgICAgICAgcmV0dXJuIGZsYXR0ZW4oYXN0LmJvZHkpICsgKGFzdC5ib2R5WzBdLnR5cGUgPT09ICdWYXJpYWJsZURlY2xhcmF0aW9uJyA/ICc7JyA6ICcnKTtcbiAgICAgICAgY2FzZSAnRnVuY3Rpb25EZWNsYXJhdGlvbic6XG4gICAgICAgICAgcmV0dXJuIGBmdW5jdGlvbiAke2FzdC5pZC5uYW1lfSgke2FzdC5wYXJhbXMubWFwKGZsYXR0ZW4pLmpvaW4oJywgJyl9KSAkeyBmbGF0dGVuKGFzdC5ib2R5KSB9YDtcbiAgICAgICAgY2FzZSAnQmxvY2tTdGF0ZW1lbnQnOiB7XG4gICAgICAgICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgICAgICAgaW5kZW50ICs9IDI7XG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhc3QuYm9keS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgZmxhdCA9IGZsYXR0ZW4oYXN0LmJvZHlbaV0pO1xuICAgICAgICAgICAgaWYgKGZsYXQpIHtcbiAgICAgICAgICAgICAgcmVzdWx0LnB1c2goJyAnLnJlcGVhdChpbmRlbnQpICsgZmxhdCwgJztcXG4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaW5kZW50IC09IDI7XG4gICAgICAgICAgcmV0dXJuIGB7XFxuJHtyZXN1bHQuam9pbignJyl9fWA7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnVmFyaWFibGVEZWNsYXJhdGlvbic6XG4gICAgICAgICAgY29uc3QgZGVjbGFyYXRpb25zID0gdXRpbHMubm9ybWFsaXplRGVjbGFyYXRpb25zKGFzdClcbiAgICAgICAgICAgIC5tYXAoZmxhdHRlbilcbiAgICAgICAgICAgIC5maWx0ZXIociA9PiByICE9PSBudWxsKTtcbiAgICAgICAgICBpZiAoZGVjbGFyYXRpb25zLmxlbmd0aCA8IDEpIHtcbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGAke2FzdC5raW5kfSAke2RlY2xhcmF0aW9ucy5qb2luKCcsJyl9YDtcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSAnVmFyaWFibGVEZWNsYXJhdG9yJzpcbiAgICAgICAgICAgIGlmIChhc3QuaW5pdC5vYmplY3QgJiYgYXN0LmluaXQub2JqZWN0LnR5cGUgPT09ICdUaGlzRXhwcmVzc2lvbicpIHtcbiAgICAgICAgICAgICAgY29uc3QgbG9va3VwID0gdGhpc0xvb2t1cChhc3QuaW5pdC5wcm9wZXJ0eS5uYW1lLCB0cnVlKTtcbiAgICAgICAgICAgICAgaWYgKGxvb2t1cCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBgJHthc3QuaWQubmFtZX0gPSAke2ZsYXR0ZW4oYXN0LmluaXQpfWA7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJldHVybiBgJHthc3QuaWQubmFtZX0gPSAke2ZsYXR0ZW4oYXN0LmluaXQpfWA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlICdDYWxsRXhwcmVzc2lvbic6IHtcbiAgICAgICAgICAgICAgaWYgKGFzdC5jYWxsZWUucHJvcGVydHkubmFtZSA9PT0gJ3N1YmFycmF5Jykge1xuICAgICAgICAgICAgICAgIHJldHVybiBgJHtmbGF0dGVuKGFzdC5jYWxsZWUub2JqZWN0KX0uJHtmbGF0dGVuKGFzdC5jYWxsZWUucHJvcGVydHkpfSgke2FzdC5hcmd1bWVudHMubWFwKHZhbHVlID0+IGZsYXR0ZW4odmFsdWUpKS5qb2luKCcsICcpfSlgO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChhc3QuY2FsbGVlLm9iamVjdC5uYW1lID09PSAnZ2wnIHx8IGFzdC5jYWxsZWUub2JqZWN0Lm5hbWUgPT09ICdjb250ZXh0Jykge1xuICAgICAgICAgICAgICAgIHJldHVybiBgJHtmbGF0dGVuKGFzdC5jYWxsZWUub2JqZWN0KX0uJHtmbGF0dGVuKGFzdC5jYWxsZWUucHJvcGVydHkpfSgke2FzdC5hcmd1bWVudHMubWFwKHZhbHVlID0+IGZsYXR0ZW4odmFsdWUpKS5qb2luKCcsICcpfSlgO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChhc3QuY2FsbGVlLm9iamVjdC50eXBlID09PSAnVGhpc0V4cHJlc3Npb24nKSB7XG4gICAgICAgICAgICAgICAgZnVuY3Rpb25EZXBlbmRlbmNpZXMucHVzaChmaW5kRGVwZW5kZW5jeSgndGhpcycsIGFzdC5jYWxsZWUucHJvcGVydHkubmFtZSkpO1xuICAgICAgICAgICAgICAgIHJldHVybiBgJHthc3QuY2FsbGVlLnByb3BlcnR5Lm5hbWV9KCR7YXN0LmFyZ3VtZW50cy5tYXAodmFsdWUgPT4gZmxhdHRlbih2YWx1ZSkpLmpvaW4oJywgJyl9KWA7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoYXN0LmNhbGxlZS5vYmplY3QubmFtZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGZvdW5kU291cmNlID0gZmluZERlcGVuZGVuY3koYXN0LmNhbGxlZS5vYmplY3QubmFtZSwgYXN0LmNhbGxlZS5wcm9wZXJ0eS5uYW1lKTtcbiAgICAgICAgICAgICAgICBpZiAoZm91bmRTb3VyY2UgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBgJHthc3QuY2FsbGVlLm9iamVjdC5uYW1lfS4ke2FzdC5jYWxsZWUucHJvcGVydHkubmFtZX0oJHthc3QuYXJndW1lbnRzLm1hcCh2YWx1ZSA9PiBmbGF0dGVuKHZhbHVlKSkuam9pbignLCAnKX0pYDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgZnVuY3Rpb25EZXBlbmRlbmNpZXMucHVzaChmb3VuZFNvdXJjZSk7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gYCR7YXN0LmNhbGxlZS5wcm9wZXJ0eS5uYW1lfSgke2FzdC5hcmd1bWVudHMubWFwKHZhbHVlID0+IGZsYXR0ZW4odmFsdWUpKS5qb2luKCcsICcpfSlgO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChhc3QuY2FsbGVlLm9iamVjdC50eXBlID09PSAnTWVtYmVyRXhwcmVzc2lvbicpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYCR7ZmxhdHRlbihhc3QuY2FsbGVlLm9iamVjdCl9LiR7YXN0LmNhbGxlZS5wcm9wZXJ0eS5uYW1lfSgke2FzdC5hcmd1bWVudHMubWFwKHZhbHVlID0+IGZsYXR0ZW4odmFsdWUpKS5qb2luKCcsICcpfSlgO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndW5rbm93biBhc3QuY2FsbGVlJyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ1JldHVyblN0YXRlbWVudCc6XG4gICAgICAgICAgICAgIHJldHVybiBgcmV0dXJuICR7ZmxhdHRlbihhc3QuYXJndW1lbnQpfWA7XG4gICAgICAgICAgICBjYXNlICdCaW5hcnlFeHByZXNzaW9uJzpcbiAgICAgICAgICAgICAgcmV0dXJuIGAoJHtmbGF0dGVuKGFzdC5sZWZ0KX0ke2FzdC5vcGVyYXRvcn0ke2ZsYXR0ZW4oYXN0LnJpZ2h0KX0pYDtcbiAgICAgICAgICAgIGNhc2UgJ1VuYXJ5RXhwcmVzc2lvbic6XG4gICAgICAgICAgICAgIGlmIChhc3QucHJlZml4KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGAke2FzdC5vcGVyYXRvcn0gJHtmbGF0dGVuKGFzdC5hcmd1bWVudCl9YDtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYCR7ZmxhdHRlbihhc3QuYXJndW1lbnQpfSAke2FzdC5vcGVyYXRvcn1gO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNhc2UgJ0V4cHJlc3Npb25TdGF0ZW1lbnQnOlxuICAgICAgICAgICAgICAgIHJldHVybiBgJHtmbGF0dGVuKGFzdC5leHByZXNzaW9uKX1gO1xuICAgICAgICAgICAgICBjYXNlICdTZXF1ZW5jZUV4cHJlc3Npb24nOlxuICAgICAgICAgICAgICAgIHJldHVybiBgKCR7ZmxhdHRlbihhc3QuZXhwcmVzc2lvbnMpfSlgO1xuICAgICAgICAgICAgICBjYXNlICdBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvbic6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGAoJHthc3QucGFyYW1zLm1hcChmbGF0dGVuKS5qb2luKCcsICcpfSkgPT4gJHtmbGF0dGVuKGFzdC5ib2R5KX1gO1xuICAgICAgICAgICAgICBjYXNlICdMaXRlcmFsJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gYXN0LnJhdztcbiAgICAgICAgICAgICAgY2FzZSAnSWRlbnRpZmllcic6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFzdC5uYW1lO1xuICAgICAgICAgICAgICBjYXNlICdNZW1iZXJFeHByZXNzaW9uJzpcbiAgICAgICAgICAgICAgICBpZiAoYXN0Lm9iamVjdC50eXBlID09PSAnVGhpc0V4cHJlc3Npb24nKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gdGhpc0xvb2t1cChhc3QucHJvcGVydHkubmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChhc3QuY29tcHV0ZWQpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBgJHtmbGF0dGVuKGFzdC5vYmplY3QpfVske2ZsYXR0ZW4oYXN0LnByb3BlcnR5KX1dYDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZsYXR0ZW4oYXN0Lm9iamVjdCkgKyAnLicgKyBmbGF0dGVuKGFzdC5wcm9wZXJ0eSk7XG4gICAgICAgICAgICAgIGNhc2UgJ1RoaXNFeHByZXNzaW9uJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gJ3RoaXMnO1xuICAgICAgICAgICAgICBjYXNlICdOZXdFeHByZXNzaW9uJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gYG5ldyAke2ZsYXR0ZW4oYXN0LmNhbGxlZSl9KCR7YXN0LmFyZ3VtZW50cy5tYXAodmFsdWUgPT4gZmxhdHRlbih2YWx1ZSkpLmpvaW4oJywgJyl9KWA7XG4gICAgICAgICAgICAgIGNhc2UgJ0ZvclN0YXRlbWVudCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGBmb3IgKCR7ZmxhdHRlbihhc3QuaW5pdCl9OyR7ZmxhdHRlbihhc3QudGVzdCl9OyR7ZmxhdHRlbihhc3QudXBkYXRlKX0pICR7ZmxhdHRlbihhc3QuYm9keSl9YDtcbiAgICAgICAgICAgICAgY2FzZSAnQXNzaWdubWVudEV4cHJlc3Npb24nOlxuICAgICAgICAgICAgICAgIHJldHVybiBgJHtmbGF0dGVuKGFzdC5sZWZ0KX0ke2FzdC5vcGVyYXRvcn0ke2ZsYXR0ZW4oYXN0LnJpZ2h0KX1gO1xuICAgICAgICAgICAgICBjYXNlICdVcGRhdGVFeHByZXNzaW9uJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gYCR7ZmxhdHRlbihhc3QuYXJndW1lbnQpfSR7YXN0Lm9wZXJhdG9yfWA7XG4gICAgICAgICAgICAgIGNhc2UgJ0lmU3RhdGVtZW50JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gYGlmICgke2ZsYXR0ZW4oYXN0LnRlc3QpfSkgJHtmbGF0dGVuKGFzdC5jb25zZXF1ZW50KX1gO1xuICAgICAgICAgICAgICBjYXNlICdUaHJvd1N0YXRlbWVudCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGB0aHJvdyAke2ZsYXR0ZW4oYXN0LmFyZ3VtZW50KX1gO1xuICAgICAgICAgICAgICBjYXNlICdPYmplY3RQYXR0ZXJuJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gYXN0LnByb3BlcnRpZXMubWFwKGZsYXR0ZW4pLmpvaW4oJywgJyk7XG4gICAgICAgICAgICAgIGNhc2UgJ0FycmF5UGF0dGVybic6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFzdC5lbGVtZW50cy5tYXAoZmxhdHRlbikuam9pbignLCAnKTtcbiAgICAgICAgICAgICAgY2FzZSAnRGVidWdnZXJTdGF0ZW1lbnQnOlxuICAgICAgICAgICAgICAgIHJldHVybiAnZGVidWdnZXI7JztcbiAgICAgICAgICAgICAgY2FzZSAnQ29uZGl0aW9uYWxFeHByZXNzaW9uJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gYCR7ZmxhdHRlbihhc3QudGVzdCl9PyR7ZmxhdHRlbihhc3QuY29uc2VxdWVudCl9OiR7ZmxhdHRlbihhc3QuYWx0ZXJuYXRlKX1gO1xuICAgICAgICAgICAgICBjYXNlICdQcm9wZXJ0eSc6XG4gICAgICAgICAgICAgICAgaWYgKGFzdC5raW5kID09PSAnaW5pdCcpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBmbGF0dGVuKGFzdC5rZXkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBFcnJvcihgdW5oYW5kbGVkIGFzdC50eXBlIG9mICR7IGFzdC50eXBlIH1gKTtcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0gZmxhdHRlbihhc3QpO1xuICAgIGlmIChmdW5jdGlvbkRlcGVuZGVuY2llcy5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCBmbGF0dGVuZWRGdW5jdGlvbkRlcGVuZGVuY2llcyA9IFtdO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmdW5jdGlvbkRlcGVuZGVuY2llcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBmdW5jdGlvbkRlcGVuZGVuY3kgPSBmdW5jdGlvbkRlcGVuZGVuY2llc1tpXTtcbiAgICAgICAgaWYgKCFmbGF0dGVuZWRbZnVuY3Rpb25EZXBlbmRlbmN5XSkge1xuICAgICAgICAgIGZsYXR0ZW5lZFtmdW5jdGlvbkRlcGVuZGVuY3ldID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbkRlcGVuZGVuY3kgPyBmbGF0dGVuZWRGdW5jdGlvbkRlcGVuZGVuY2llcy5wdXNoKHV0aWxzLmZsYXR0ZW5GdW5jdGlvblRvU3RyaW5nKGZ1bmN0aW9uRGVwZW5kZW5jeSwgc2V0dGluZ3MpICsgJ1xcbicpIDogJyc7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmxhdHRlbmVkRnVuY3Rpb25EZXBlbmRlbmNpZXMuam9pbignJykgKyByZXN1bHQ7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH0sXG5cbiAgbm9ybWFsaXplRGVjbGFyYXRpb25zOiAoYXN0KSA9PiB7XG4gICAgaWYgKGFzdC50eXBlICE9PSAnVmFyaWFibGVEZWNsYXJhdGlvbicpIHRocm93IG5ldyBFcnJvcignQXN0IGlzIG5vdCBvZiB0eXBlIFwiVmFyaWFibGVEZWNsYXJhdGlvblwiJyk7XG4gICAgY29uc3Qgbm9ybWFsaXplZERlY2xhcmF0aW9ucyA9IFtdO1xuICAgIGZvciAobGV0IGRlY2xhcmF0aW9uSW5kZXggPSAwOyBkZWNsYXJhdGlvbkluZGV4IDwgYXN0LmRlY2xhcmF0aW9ucy5sZW5ndGg7IGRlY2xhcmF0aW9uSW5kZXgrKykge1xuICAgICAgY29uc3QgZGVjbGFyYXRpb24gPSBhc3QuZGVjbGFyYXRpb25zW2RlY2xhcmF0aW9uSW5kZXhdO1xuICAgICAgaWYgKGRlY2xhcmF0aW9uLmlkICYmIGRlY2xhcmF0aW9uLmlkLnR5cGUgPT09ICdPYmplY3RQYXR0ZXJuJyAmJiBkZWNsYXJhdGlvbi5pZC5wcm9wZXJ0aWVzKSB7XG4gICAgICAgIGNvbnN0IHsgcHJvcGVydGllcyB9ID0gZGVjbGFyYXRpb24uaWQ7XG4gICAgICAgIGZvciAobGV0IHByb3BlcnR5SW5kZXggPSAwOyBwcm9wZXJ0eUluZGV4IDwgcHJvcGVydGllcy5sZW5ndGg7IHByb3BlcnR5SW5kZXgrKykge1xuICAgICAgICAgIGNvbnN0IHByb3BlcnR5ID0gcHJvcGVydGllc1twcm9wZXJ0eUluZGV4XTtcbiAgICAgICAgICBpZiAocHJvcGVydHkudmFsdWUudHlwZSA9PT0gJ09iamVjdFBhdHRlcm4nICYmIHByb3BlcnR5LnZhbHVlLnByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIGZvciAobGV0IHN1YlByb3BlcnR5SW5kZXggPSAwOyBzdWJQcm9wZXJ0eUluZGV4IDwgcHJvcGVydHkudmFsdWUucHJvcGVydGllcy5sZW5ndGg7IHN1YlByb3BlcnR5SW5kZXgrKykge1xuICAgICAgICAgICAgICBjb25zdCBzdWJQcm9wZXJ0eSA9IHByb3BlcnR5LnZhbHVlLnByb3BlcnRpZXNbc3ViUHJvcGVydHlJbmRleF07XG4gICAgICAgICAgICAgIGlmIChzdWJQcm9wZXJ0eS50eXBlID09PSAnUHJvcGVydHknKSB7XG4gICAgICAgICAgICAgICAgbm9ybWFsaXplZERlY2xhcmF0aW9ucy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgIHR5cGU6ICdWYXJpYWJsZURlY2xhcmF0b3InLFxuICAgICAgICAgICAgICAgICAgaWQ6IHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ0lkZW50aWZpZXInLFxuICAgICAgICAgICAgICAgICAgICBuYW1lOiBzdWJQcm9wZXJ0eS5rZXkubmFtZVxuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgIGluaXQ6IHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ01lbWJlckV4cHJlc3Npb24nLFxuICAgICAgICAgICAgICAgICAgICBvYmplY3Q6IHtcbiAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnTWVtYmVyRXhwcmVzc2lvbicsXG4gICAgICAgICAgICAgICAgICAgICAgb2JqZWN0OiBkZWNsYXJhdGlvbi5pbml0LFxuICAgICAgICAgICAgICAgICAgICAgIHByb3BlcnR5OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnSWRlbnRpZmllcicsXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBwcm9wZXJ0eS5rZXkubmFtZVxuICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgY29tcHV0ZWQ6IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHByb3BlcnR5OiB7XG4gICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ0lkZW50aWZpZXInLFxuICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IHN1YlByb3BlcnR5LmtleS5uYW1lXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGNvbXB1dGVkOiBmYWxzZVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndW5leHBlY3RlZCBzdGF0ZScpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmIChwcm9wZXJ0eS52YWx1ZS50eXBlID09PSAnSWRlbnRpZmllcicpIHtcbiAgICAgICAgICAgIG5vcm1hbGl6ZWREZWNsYXJhdGlvbnMucHVzaCh7XG4gICAgICAgICAgICAgIHR5cGU6ICdWYXJpYWJsZURlY2xhcmF0b3InLFxuICAgICAgICAgICAgICBpZDoge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdJZGVudGlmaWVyJyxcbiAgICAgICAgICAgICAgICBuYW1lOiBwcm9wZXJ0eS52YWx1ZSAmJiBwcm9wZXJ0eS52YWx1ZS5uYW1lID8gcHJvcGVydHkudmFsdWUubmFtZSA6IHByb3BlcnR5LmtleS5uYW1lXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIGluaXQ6IHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnTWVtYmVyRXhwcmVzc2lvbicsXG4gICAgICAgICAgICAgICAgb2JqZWN0OiBkZWNsYXJhdGlvbi5pbml0LFxuICAgICAgICAgICAgICAgIHByb3BlcnR5OiB7XG4gICAgICAgICAgICAgICAgICB0eXBlOiAnSWRlbnRpZmllcicsXG4gICAgICAgICAgICAgICAgICBuYW1lOiBwcm9wZXJ0eS5rZXkubmFtZVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgY29tcHV0ZWQ6IGZhbHNlXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3VuZXhwZWN0ZWQgc3RhdGUnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoZGVjbGFyYXRpb24uaWQgJiYgZGVjbGFyYXRpb24uaWQudHlwZSA9PT0gJ0FycmF5UGF0dGVybicgJiYgZGVjbGFyYXRpb24uaWQuZWxlbWVudHMpIHtcbiAgICAgICAgY29uc3QgeyBlbGVtZW50cyB9ID0gZGVjbGFyYXRpb24uaWQ7XG4gICAgICAgIGZvciAobGV0IGVsZW1lbnRJbmRleCA9IDA7IGVsZW1lbnRJbmRleCA8IGVsZW1lbnRzLmxlbmd0aDsgZWxlbWVudEluZGV4KyspIHtcbiAgICAgICAgICBjb25zdCBlbGVtZW50ID0gZWxlbWVudHNbZWxlbWVudEluZGV4XTtcbiAgICAgICAgICBpZiAoZWxlbWVudC50eXBlID09PSAnSWRlbnRpZmllcicpIHtcbiAgICAgICAgICAgIG5vcm1hbGl6ZWREZWNsYXJhdGlvbnMucHVzaCh7XG4gICAgICAgICAgICAgIHR5cGU6ICdWYXJpYWJsZURlY2xhcmF0b3InLFxuICAgICAgICAgICAgICBpZDoge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdJZGVudGlmaWVyJyxcbiAgICAgICAgICAgICAgICBuYW1lOiBlbGVtZW50Lm5hbWVcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgaW5pdDoge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdNZW1iZXJFeHByZXNzaW9uJyxcbiAgICAgICAgICAgICAgICBvYmplY3Q6IGRlY2xhcmF0aW9uLmluaXQsXG4gICAgICAgICAgICAgICAgcHJvcGVydHk6IHtcbiAgICAgICAgICAgICAgICAgIHR5cGU6ICdMaXRlcmFsJyxcbiAgICAgICAgICAgICAgICAgIHZhbHVlOiBlbGVtZW50SW5kZXgsXG4gICAgICAgICAgICAgICAgICByYXc6IGVsZW1lbnRJbmRleC50b1N0cmluZygpLFxuICAgICAgICAgICAgICAgICAgc3RhcnQ6IGVsZW1lbnQuc3RhcnQsXG4gICAgICAgICAgICAgICAgICBlbmQ6IGVsZW1lbnQuZW5kXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBjb21wdXRlZDogdHJ1ZVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bmV4cGVjdGVkIHN0YXRlJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub3JtYWxpemVkRGVjbGFyYXRpb25zLnB1c2goZGVjbGFyYXRpb24pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbm9ybWFsaXplZERlY2xhcmF0aW9ucztcbiAgfSxcblxuICBzcGxpdEhUTUxJbWFnZVRvUkdCOiAoZ3B1LCBpbWFnZSkgPT4ge1xuICAgIGNvbnN0IHJLZXJuZWwgPSBncHUuY3JlYXRlS2VybmVsKGZ1bmN0aW9uKGEpIHtcbiAgICAgIGNvbnN0IHBpeGVsID0gYVt0aGlzLnRocmVhZC55XVt0aGlzLnRocmVhZC54XTtcbiAgICAgIHJldHVybiBwaXhlbC5yICogMjU1O1xuICAgIH0sIHtcbiAgICAgIG91dHB1dDogW2ltYWdlLndpZHRoLCBpbWFnZS5oZWlnaHRdLFxuICAgICAgcHJlY2lzaW9uOiAndW5zaWduZWQnLFxuICAgICAgYXJndW1lbnRUeXBlczogeyBhOiAnSFRNTEltYWdlJyB9LFxuICAgIH0pO1xuICAgIGNvbnN0IGdLZXJuZWwgPSBncHUuY3JlYXRlS2VybmVsKGZ1bmN0aW9uKGEpIHtcbiAgICAgIGNvbnN0IHBpeGVsID0gYVt0aGlzLnRocmVhZC55XVt0aGlzLnRocmVhZC54XTtcbiAgICAgIHJldHVybiBwaXhlbC5nICogMjU1O1xuICAgIH0sIHtcbiAgICAgIG91dHB1dDogW2ltYWdlLndpZHRoLCBpbWFnZS5oZWlnaHRdLFxuICAgICAgcHJlY2lzaW9uOiAndW5zaWduZWQnLFxuICAgICAgYXJndW1lbnRUeXBlczogeyBhOiAnSFRNTEltYWdlJyB9LFxuICAgIH0pO1xuICAgIGNvbnN0IGJLZXJuZWwgPSBncHUuY3JlYXRlS2VybmVsKGZ1bmN0aW9uKGEpIHtcbiAgICAgIGNvbnN0IHBpeGVsID0gYVt0aGlzLnRocmVhZC55XVt0aGlzLnRocmVhZC54XTtcbiAgICAgIHJldHVybiBwaXhlbC5iICogMjU1O1xuICAgIH0sIHtcbiAgICAgIG91dHB1dDogW2ltYWdlLndpZHRoLCBpbWFnZS5oZWlnaHRdLFxuICAgICAgcHJlY2lzaW9uOiAndW5zaWduZWQnLFxuICAgICAgYXJndW1lbnRUeXBlczogeyBhOiAnSFRNTEltYWdlJyB9LFxuICAgIH0pO1xuICAgIGNvbnN0IGFLZXJuZWwgPSBncHUuY3JlYXRlS2VybmVsKGZ1bmN0aW9uKGEpIHtcbiAgICAgIGNvbnN0IHBpeGVsID0gYVt0aGlzLnRocmVhZC55XVt0aGlzLnRocmVhZC54XTtcbiAgICAgIHJldHVybiBwaXhlbC5hICogMjU1O1xuICAgIH0sIHtcbiAgICAgIG91dHB1dDogW2ltYWdlLndpZHRoLCBpbWFnZS5oZWlnaHRdLFxuICAgICAgcHJlY2lzaW9uOiAndW5zaWduZWQnLFxuICAgICAgYXJndW1lbnRUeXBlczogeyBhOiAnSFRNTEltYWdlJyB9LFxuICAgIH0pO1xuICAgIGNvbnN0IHJlc3VsdCA9IFtcbiAgICAgIHJLZXJuZWwoaW1hZ2UpLFxuICAgICAgZ0tlcm5lbChpbWFnZSksXG4gICAgICBiS2VybmVsKGltYWdlKSxcbiAgICAgIGFLZXJuZWwoaW1hZ2UpLFxuICAgIF07XG4gICAgcmVzdWx0LnJLZXJuZWwgPSByS2VybmVsO1xuICAgIHJlc3VsdC5nS2VybmVsID0gZ0tlcm5lbDtcbiAgICByZXN1bHQuYktlcm5lbCA9IGJLZXJuZWw7XG4gICAgcmVzdWx0LmFLZXJuZWwgPSBhS2VybmVsO1xuICAgIHJlc3VsdC5ncHUgPSBncHU7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSxcblxuICBzcGxpdFJHQkFUb0NhbnZhc2VzOiAoZ3B1LCByZ2JhLCB3aWR0aCwgaGVpZ2h0KSA9PiB7XG4gICAgY29uc3QgdmlzdWFsS2VybmVsUiA9IGdwdS5jcmVhdGVLZXJuZWwoZnVuY3Rpb24odikge1xuICAgICAgY29uc3QgcGl4ZWwgPSB2W3RoaXMudGhyZWFkLnldW3RoaXMudGhyZWFkLnhdO1xuICAgICAgdGhpcy5jb2xvcihwaXhlbC5yIC8gMjU1LCAwLCAwLCAyNTUpO1xuICAgIH0sIHtcbiAgICAgIG91dHB1dDogW3dpZHRoLCBoZWlnaHRdLFxuICAgICAgZ3JhcGhpY2FsOiB0cnVlLFxuICAgICAgYXJndW1lbnRUeXBlczogeyB2OiAnQXJyYXkyRCg0KScgfVxuICAgIH0pO1xuICAgIHZpc3VhbEtlcm5lbFIocmdiYSk7XG5cbiAgICBjb25zdCB2aXN1YWxLZXJuZWxHID0gZ3B1LmNyZWF0ZUtlcm5lbChmdW5jdGlvbih2KSB7XG4gICAgICBjb25zdCBwaXhlbCA9IHZbdGhpcy50aHJlYWQueV1bdGhpcy50aHJlYWQueF07XG4gICAgICB0aGlzLmNvbG9yKDAsIHBpeGVsLmcgLyAyNTUsIDAsIDI1NSk7XG4gICAgfSwge1xuICAgICAgb3V0cHV0OiBbd2lkdGgsIGhlaWdodF0sXG4gICAgICBncmFwaGljYWw6IHRydWUsXG4gICAgICBhcmd1bWVudFR5cGVzOiB7IHY6ICdBcnJheTJEKDQpJyB9XG4gICAgfSk7XG4gICAgdmlzdWFsS2VybmVsRyhyZ2JhKTtcblxuICAgIGNvbnN0IHZpc3VhbEtlcm5lbEIgPSBncHUuY3JlYXRlS2VybmVsKGZ1bmN0aW9uKHYpIHtcbiAgICAgIGNvbnN0IHBpeGVsID0gdlt0aGlzLnRocmVhZC55XVt0aGlzLnRocmVhZC54XTtcbiAgICAgIHRoaXMuY29sb3IoMCwgMCwgcGl4ZWwuYiAvIDI1NSwgMjU1KTtcbiAgICB9LCB7XG4gICAgICBvdXRwdXQ6IFt3aWR0aCwgaGVpZ2h0XSxcbiAgICAgIGdyYXBoaWNhbDogdHJ1ZSxcbiAgICAgIGFyZ3VtZW50VHlwZXM6IHsgdjogJ0FycmF5MkQoNCknIH1cbiAgICB9KTtcbiAgICB2aXN1YWxLZXJuZWxCKHJnYmEpO1xuXG4gICAgY29uc3QgdmlzdWFsS2VybmVsQSA9IGdwdS5jcmVhdGVLZXJuZWwoZnVuY3Rpb24odikge1xuICAgICAgY29uc3QgcGl4ZWwgPSB2W3RoaXMudGhyZWFkLnldW3RoaXMudGhyZWFkLnhdO1xuICAgICAgdGhpcy5jb2xvcigyNTUsIDI1NSwgMjU1LCBwaXhlbC5hIC8gMjU1KTtcbiAgICB9LCB7XG4gICAgICBvdXRwdXQ6IFt3aWR0aCwgaGVpZ2h0XSxcbiAgICAgIGdyYXBoaWNhbDogdHJ1ZSxcbiAgICAgIGFyZ3VtZW50VHlwZXM6IHsgdjogJ0FycmF5MkQoNCknIH1cbiAgICB9KTtcbiAgICB2aXN1YWxLZXJuZWxBKHJnYmEpO1xuICAgIHJldHVybiBbXG4gICAgICB2aXN1YWxLZXJuZWxSLmNhbnZhcyxcbiAgICAgIHZpc3VhbEtlcm5lbEcuY2FudmFzLFxuICAgICAgdmlzdWFsS2VybmVsQi5jYW52YXMsXG4gICAgICB2aXN1YWxLZXJuZWxBLmNhbnZhcyxcbiAgICBdO1xuICB9LFxuXG4gIGdldE1pbmlmeVNhZmVOYW1lOiAoZm4pID0+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgYXN0ID0gYWNvcm4ucGFyc2UoYGNvbnN0IHZhbHVlID0gJHtmbi50b1N0cmluZygpfWApO1xuICAgICAgY29uc3QgeyBpbml0IH0gPSBhc3QuYm9keVswXS5kZWNsYXJhdGlvbnNbMF07XG4gICAgICByZXR1cm4gaW5pdC5ib2R5Lm5hbWUgfHwgaW5pdC5ib2R5LmJvZHlbMF0uYXJndW1lbnQubmFtZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VucmVjb2duaXplZCBmdW5jdGlvbiB0eXBlLiAgUGxlYXNlIHVzZSBgKCkgPT4geW91ckZ1bmN0aW9uVmFyaWFibGVIZXJlYCBvciBmdW5jdGlvbigpIHsgcmV0dXJuIHlvdXJGdW5jdGlvblZhcmlhYmxlSGVyZTsgfScpO1xuICAgIH1cbiAgfSxcbiAgc2FuaXRpemVOYW1lOiBmdW5jdGlvbihuYW1lKSB7XG4gICAgaWYgKGRvbGxhclNpZ24udGVzdChuYW1lKSkge1xuICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZShkb2xsYXJTaWduLCAnU19TJyk7XG4gICAgfVxuICAgIGlmIChkb3VibGVVbmRlcnNjb3JlLnRlc3QobmFtZSkpIHtcbiAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UoZG91YmxlVW5kZXJzY29yZSwgJ1VfVScpO1xuICAgIH0gZWxzZSBpZiAoc2luZ2xlVW5kZXJzY29yZS50ZXN0KG5hbWUpKSB7XG4gICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKHNpbmdsZVVuZGVyc2NvcmUsICd1X3UnKTtcbiAgICB9XG4gICAgcmV0dXJuIG5hbWU7XG4gIH1cbn07XG5cbmNvbnN0IGRvbGxhclNpZ24gPSAvXFwkLztcbmNvbnN0IGRvdWJsZVVuZGVyc2NvcmUgPSAvX18vO1xuY29uc3Qgc2luZ2xlVW5kZXJzY29yZSA9IC9fLztcblxuY29uc3QgX3N5c3RlbUVuZGlhbm5lc3MgPSB1dGlscy5nZXRTeXN0ZW1FbmRpYW5uZXNzKCk7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICB1dGlsc1xufTtcbn0se1wiLi9pbnB1dFwiOjExMCxcIi4vdGV4dHVyZVwiOjExMyxcImFjb3JuXCI6MX1dfSx7fSxbMTA3XSkoMTA3KVxufSk7XG4iLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5leHBvcnRzLmNyZWF0ZUFudFByb2dyYW0gPSB2b2lkIDA7XHJcbmNvbnN0IGdwdV9qc18xID0gcmVxdWlyZShcImdwdS5qc1wiKTtcclxuZXhwb3J0cy5jcmVhdGVBbnRQcm9ncmFtID0gKGNvbmZpZywgdXBkYXRlR2V0dGVyKSA9PiAoc2l6ZSkgPT4ge1xyXG4gICAgLy8gQ3JlYXRlIHRoZSBtYWluIHVwZGF0ZSBsb2dpY1xyXG4gICAgLyoqIFRoZSBmdW5jdGlvbiB0aGF0IHVwZGF0ZXMgdGhlIHN0YXRlIGZvciB0aGUgbmV4dCBjeWNsZSAqL1xyXG4gICAgZnVuY3Rpb24gdXBkYXRlQW50cyhkYXRhLCBwaXhlbHMsIHNpemUpIHtcclxuICAgICAgICBjb25zdCBzcGVlZCA9IHRoaXMuY29uc3RhbnRzLnNwZWVkO1xyXG4gICAgICAgIGNvbnN0IHN0ZWVyU3BlZWQgPSB0aGlzLmNvbnN0YW50cy5zdGVlclNwZWVkO1xyXG4gICAgICAgIGNvbnN0IHNlbnNvclNpemUgPSB0aGlzLmNvbnN0YW50cy5zZW5zb3JTaXplO1xyXG4gICAgICAgIGNvbnN0IHNlbnNvck9mZnNldCA9IHRoaXMuY29uc3RhbnRzLnNlbnNvck9mZnNldDtcclxuICAgICAgICBjb25zdCBzZW5zb3JBbmdsZSA9IHRoaXMuY29uc3RhbnRzLnNlbnNvckFuZ2xlO1xyXG4gICAgICAgIGNvbnN0IHJhbmRvbUJvcmRlckJvdW5jZSA9IHRoaXMuY29uc3RhbnRzLnJhbmRvbUJvcmRlckJvdW5jZTtcclxuICAgICAgICAvLyBFeHRyYWN0IGRhdGFcclxuICAgICAgICBsZXQgeCA9IGRhdGFbdGhpcy50aHJlYWQueF1bMF07XHJcbiAgICAgICAgbGV0IHkgPSBkYXRhW3RoaXMudGhyZWFkLnhdWzFdO1xyXG4gICAgICAgIGxldCBhbmdsZSA9IGRhdGFbdGhpcy50aHJlYWQueF1bMl07XHJcbiAgICAgICAgLy8gTW92ZW1lbnQgKyBib3JkZXIgYm91bmNlXHJcbiAgICAgICAgbGV0IHZlbG9YID0gKE1hdGguY29zKGFuZ2xlKSAqIHNwZWVkKSAvIHNpemU7XHJcbiAgICAgICAgbGV0IHZlbG9ZID0gKE1hdGguc2luKGFuZ2xlKSAqIHNwZWVkKSAvIHNpemU7XHJcbiAgICAgICAgeCA9IE1hdGgubWluKE1hdGgubWF4KDAsIHggKyB2ZWxvWCksIDEpO1xyXG4gICAgICAgIHkgPSBNYXRoLm1pbihNYXRoLm1heCgwLCB5ICsgdmVsb1kpLCAxKTtcclxuICAgICAgICBpZiAocmFuZG9tQm9yZGVyQm91bmNlKSB7XHJcbiAgICAgICAgICAgIGlmICh4ID49IDEgfHwgeCA8PSAwIHx8IHkgPj0gMSB8fCB5IDw9IDApXHJcbiAgICAgICAgICAgICAgICBhbmdsZSA9IChNYXRoLnJhbmRvbSgpICsgMSkgKiBNYXRoLlBJICogMjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGlmICh4ID49IDEgfHwgeCA8PSAwKVxyXG4gICAgICAgICAgICAgICAgYW5nbGUgPSBNYXRoLlBJIC0gYW5nbGU7XHJcbiAgICAgICAgICAgIGlmICh5ID49IDEgfHwgeSA8PSAwKVxyXG4gICAgICAgICAgICAgICAgYW5nbGUgPSAtYW5nbGU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIENvbXB1dGUgdGhlIHNlbnNvciB2YWx1ZXNcclxuICAgICAgICBjb25zdCBzZW5zb3JzID0gWzAsIDAsIDBdO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAtMTsgaSA8PSAxOyBpICs9IDEpIHtcclxuICAgICAgICAgICAgY29uc3QgYmFzZVggPSBNYXRoLnJvdW5kKHggKiBzaXplICsgTWF0aC5jb3MoTWF0aC5QSSAqIDIgKyBpICogc2Vuc29yQW5nbGUgKyBhbmdsZSkgKiBzZW5zb3JPZmZzZXQpO1xyXG4gICAgICAgICAgICBjb25zdCBiYXNlWSA9IE1hdGgucm91bmQoeSAqIHNpemUgKyBNYXRoLnNpbihNYXRoLlBJICogMiArIGkgKiBzZW5zb3JBbmdsZSArIGFuZ2xlKSAqIHNlbnNvck9mZnNldCk7XHJcbiAgICAgICAgICAgIGZvciAobGV0IHggPSAtc2Vuc29yU2l6ZSArIDE7IHggPCBzZW5zb3JTaXplOyB4KyspIHtcclxuICAgICAgICAgICAgICAgIGZvciAobGV0IHkgPSAtc2Vuc29yU2l6ZSArIDE7IHkgPCBzZW5zb3JTaXplOyB5KyspIHtcclxuICAgICAgICAgICAgICAgICAgICBzZW5zb3JzW2kgKyAxXSArPSBwaXhlbHNbYmFzZVkgKyB5XVtiYXNlWCArIHhdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFVwZGF0ZSB0aGUgZGlyZWN0aW9uXHJcbiAgICAgICAgY29uc3QgcmFuZG9tU3RlZXJTdHJlbmd0aCA9IE1hdGgucmFuZG9tKCk7XHJcbiAgICAgICAgbGV0IHJpZ2h0ID0gc2Vuc29yc1swXTtcclxuICAgICAgICBjb25zdCBmb3J3YXJkID0gc2Vuc29yc1sxXTtcclxuICAgICAgICBsZXQgbGVmdCA9IHNlbnNvcnNbMl07XHJcbiAgICAgICAgaWYgKGZvcndhcmQgPiBsZWZ0ICYmIGZvcndhcmQgPiByaWdodClcclxuICAgICAgICAgICAgYW5nbGUgPSBhbmdsZTtcclxuICAgICAgICBlbHNlIGlmIChsZWZ0ID4gZm9yd2FyZCAmJiByaWdodCA+IGZvcndhcmQpXHJcbiAgICAgICAgICAgIGFuZ2xlICs9IChyYW5kb21TdGVlclN0cmVuZ3RoIC0gMC41KSAqIDIgKiBzdGVlclNwZWVkO1xyXG4gICAgICAgIGVsc2UgaWYgKGxlZnQgPiByaWdodClcclxuICAgICAgICAgICAgYW5nbGUgKz0gcmFuZG9tU3RlZXJTdHJlbmd0aCAqIHN0ZWVyU3BlZWQ7XHJcbiAgICAgICAgZWxzZSBpZiAocmlnaHQgPiBsZWZ0KVxyXG4gICAgICAgICAgICBhbmdsZSAtPSByYW5kb21TdGVlclN0cmVuZ3RoICogc3RlZXJTcGVlZDtcclxuICAgICAgICByZXR1cm4gW3gsIHksIGFuZ2xlXTtcclxuICAgIH1cclxuICAgIC8qKiBVcGRhdGVzIHRoZSBpbWFnZSBkYXRhICovXHJcbiAgICBmdW5jdGlvbiB1cGRhdGVQaXhlbHMocGl4ZWxzKSB7XHJcbiAgICAgICAgY29uc3QgZXZhcG9yYXRlU3BlZWQgPSB0aGlzLmNvbnN0YW50cy5ldmFwb3JhdGVTcGVlZDtcclxuICAgICAgICBjb25zdCBkaWZmdXNpb25TcGVlZCA9IHRoaXMuY29uc3RhbnRzLmRpZmZ1c2VTcGVlZDtcclxuICAgICAgICAvLyBCbHVyIHRoZSB0cmFpbFxyXG4gICAgICAgIGxldCBhdmcgPSAwO1xyXG4gICAgICAgIGZvciAobGV0IHggPSB0aGlzLnRocmVhZC54IC0gMTsgeCA8PSB0aGlzLnRocmVhZC54ICsgMTsgeCsrKSB7XHJcbiAgICAgICAgICAgIGZvciAobGV0IHkgPSB0aGlzLnRocmVhZC55IC0gMTsgeSA8PSB0aGlzLnRocmVhZC55ICsgMTsgeSsrKSB7XHJcbiAgICAgICAgICAgICAgICBhdmcgKz0gcGl4ZWxzW3ldW3hdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCByZXN1bHQgPSAoMSAtIGRpZmZ1c2lvblNwZWVkKSAqIHBpeGVsc1t0aGlzLnRocmVhZC55XVt0aGlzLnRocmVhZC54XSArXHJcbiAgICAgICAgICAgIChkaWZmdXNpb25TcGVlZCAqIGF2ZykgLyA5O1xyXG4gICAgICAgIC8vIEV2YXBvcmF0ZSB0aGUgdHJhaWxcclxuICAgICAgICByZXN1bHQgPSBNYXRoLm1heCgwLCByZXN1bHQgLSBldmFwb3JhdGVTcGVlZCk7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuICAgIC8qKiBEcmF3cyB0aGUgcGl4ZWxzICovXHJcbiAgICBmdW5jdGlvbiBkcmF3KHBpeGVscykge1xyXG4gICAgICAgIGNvbnN0IHYgPSBNYXRoLm1pbigxLCBwaXhlbHNbdGhpcy50aHJlYWQueV1bdGhpcy50aHJlYWQueF0pO1xyXG4gICAgICAgIGNvbnN0IHIgPSB0aGlzLmNvbnN0YW50cy5yO1xyXG4gICAgICAgIGNvbnN0IGcgPSB0aGlzLmNvbnN0YW50cy5nO1xyXG4gICAgICAgIGNvbnN0IGIgPSB0aGlzLmNvbnN0YW50cy5iO1xyXG4gICAgICAgIHRoaXMuY29sb3IociAqIHYsIGcgKiB2LCBiICogdiwgMSk7XHJcbiAgICB9XHJcbiAgICAvLyBDcmVhdGUgdGhlIEdQVSBrZXJuZWxzXHJcbiAgICBjb25zdCBncHUgPSBuZXcgZ3B1X2pzXzEuR1BVKCk7XHJcbiAgICBsZXQgdXBkYXRlQW50c0s7XHJcbiAgICBsZXQgdXBkYXRlUGl4ZWxzSztcclxuICAgIGxldCBkcmF3SyA9IG51bGw7XHJcbiAgICBjb25zdCBzcGFuID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XHJcbiAgICBmdW5jdGlvbiBpbml0U2hhZGVycygpIHtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgdXBkYXRlQW50c0sgPT09IG51bGwgfHwgdXBkYXRlQW50c0sgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHVwZGF0ZUFudHNLLmRlc3Ryb3koKTtcclxuICAgICAgICB1cGRhdGVBbnRzSyA9IGdwdVxyXG4gICAgICAgICAgICAuY3JlYXRlS2VybmVsKHVwZGF0ZUFudHMpXHJcbiAgICAgICAgICAgIC5zZXRPdXRwdXQoW2NvbmZpZy5hbnQuY291bnRdKVxyXG4gICAgICAgICAgICAuc2V0Q29uc3RhbnRzKGNvbmZpZy5hbnQpO1xyXG4gICAgICAgIHVwZGF0ZVBpeGVsc0sgPT09IG51bGwgfHwgdXBkYXRlUGl4ZWxzSyA9PT0gdm9pZCAwID8gdm9pZCAwIDogdXBkYXRlUGl4ZWxzSy5kZXN0cm95KCk7XHJcbiAgICAgICAgdXBkYXRlUGl4ZWxzSyA9IGdwdVxyXG4gICAgICAgICAgICAuY3JlYXRlS2VybmVsKHVwZGF0ZVBpeGVscylcclxuICAgICAgICAgICAgLnNldE91dHB1dChbc2l6ZSwgc2l6ZV0pXHJcbiAgICAgICAgICAgIC5zZXRDb25zdGFudHMoY29uZmlnLnRyYWlscyk7XHJcbiAgICAgICAgKF9hID0gZHJhd0sgPT09IG51bGwgfHwgZHJhd0sgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGRyYXdLLmNhbnZhcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnJlbW92ZSgpO1xyXG4gICAgICAgIGRyYXdLID09PSBudWxsIHx8IGRyYXdLID09PSB2b2lkIDAgPyB2b2lkIDAgOiBkcmF3Sy5kZXN0cm95KCk7XHJcbiAgICAgICAgZHJhd0sgPSBncHVcclxuICAgICAgICAgICAgLmNyZWF0ZUtlcm5lbChkcmF3KVxyXG4gICAgICAgICAgICAuc2V0R3JhcGhpY2FsKHRydWUpXHJcbiAgICAgICAgICAgIC5zZXRPdXRwdXQoW3NpemUsIHNpemVdKVxyXG4gICAgICAgICAgICAuc2V0Q29uc3RhbnRzKHtcclxuICAgICAgICAgICAgcjogY29uZmlnLnRyYWlscy5jb2xvclswXSxcclxuICAgICAgICAgICAgZzogY29uZmlnLnRyYWlscy5jb2xvclsxXSxcclxuICAgICAgICAgICAgYjogY29uZmlnLnRyYWlscy5jb2xvclsyXSxcclxuICAgICAgICB9KTtcclxuICAgICAgICBzcGFuLmFwcGVuZENoaWxkKGRyYXdLLmNhbnZhcyk7XHJcbiAgICB9XHJcbiAgICBpbml0U2hhZGVycygpO1xyXG4gICAgdXBkYXRlR2V0dGVyID09PSBudWxsIHx8IHVwZGF0ZUdldHRlciA9PT0gdm9pZCAwID8gdm9pZCAwIDogdXBkYXRlR2V0dGVyKChyZXNldCkgPT4ge1xyXG4gICAgICAgIGluaXRTaGFkZXJzKCk7XHJcbiAgICAgICAgaWYgKHJlc2V0KVxyXG4gICAgICAgICAgICBpbml0KCk7XHJcbiAgICB9KTtcclxuICAgIC8vIEluaXRpYWxpemUgdGhlIHN0YXRlXHJcbiAgICBsZXQgYW50cztcclxuICAgIGxldCBwaXhlbHM7XHJcbiAgICBmdW5jdGlvbiBpbml0KCkge1xyXG4gICAgICAgIGNvbnN0IHRlc3RBbnQgPSBjb25maWcuaW5pdGlhbGl6ZShjb25maWcuYW50LmNvdW50KTtcclxuICAgICAgICBhbnRzID1cclxuICAgICAgICAgICAgdGVzdEFudFswXSBpbnN0YW5jZW9mIEFycmF5XHJcbiAgICAgICAgICAgICAgICA/IHRlc3RBbnRcclxuICAgICAgICAgICAgICAgIDogbmV3IEFycmF5KGNvbmZpZy5hbnQuY291bnQpXHJcbiAgICAgICAgICAgICAgICAgICAgLmZpbGwoMClcclxuICAgICAgICAgICAgICAgICAgICAubWFwKCgpID0+IGNvbmZpZy5pbml0aWFsaXplKDEpKTtcclxuICAgICAgICBwaXhlbHMgPSBuZXcgQXJyYXkoc2l6ZSkuZmlsbCgwKS5tYXAoKCkgPT4gbmV3IEFycmF5KHNpemUpLmZpbGwoMCkpO1xyXG4gICAgfVxyXG4gICAgaW5pdCgpO1xyXG4gICAgbGV0IHJ1bm5pbmcgPSB0cnVlO1xyXG4gICAgLy8gQ3JlYXRlIHRoZSByZW5kZXIgbG9vcFxyXG4gICAgY29uc3QgcmVuZGVyID0gKCkgPT4ge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGFudEludGVuc2l0eSA9IGNvbmZpZy5hbnQuaW50ZW5zaXR5O1xyXG4gICAgICAgICAgICBhbnRzID0gdXBkYXRlQW50c0soYW50cywgcGl4ZWxzLCBzaXplKTtcclxuICAgICAgICAgICAgYW50cy5mb3JFYWNoKChbeCwgeV0pID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHB4ID0gTWF0aC5yb3VuZCh4ICogKHNpemUgLSAxKSk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBweSA9IE1hdGgucm91bmQoeSAqIChzaXplIC0gMSkpO1xyXG4gICAgICAgICAgICAgICAgcGl4ZWxzW3B5XVtweF0gPSBNYXRoLm1pbihwaXhlbHNbcHldW3B4XSArIGFudEludGVuc2l0eSwgMSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBwaXhlbHMgPSB1cGRhdGVQaXhlbHNLKHBpeGVscyk7XHJcbiAgICAgICAgICAgIGRyYXdLID09PSBudWxsIHx8IGRyYXdLID09PSB2b2lkIDAgPyB2b2lkIDAgOiBkcmF3SyhwaXhlbHMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocnVubmluZylcclxuICAgICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHJlbmRlcik7XHJcbiAgICB9O1xyXG4gICAgaWYgKHJ1bm5pbmcpXHJcbiAgICAgICAgcmVuZGVyKCk7XHJcbiAgICAvLyBSZXR1cm4gdGhlIGNvbnRyb2xzXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGNhbnZhczogc3BhbixcclxuICAgICAgICBzdGFydDogKCkgPT4ge1xyXG4gICAgICAgICAgICBydW5uaW5nID0gdHJ1ZTtcclxuICAgICAgICAgICAgcmVuZGVyKCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzdG9wOiAoKSA9PiB7XHJcbiAgICAgICAgICAgIHJ1bm5pbmcgPSBmYWxzZTtcclxuICAgICAgICB9LFxyXG4gICAgfTtcclxufTtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuY29uc3QgcmFuZG9tXzEgPSByZXF1aXJlKFwiLi9wcm9ncmFtcy9yYW5kb21cIik7XHJcbmNvbnN0IHJhbmRvbVRpZ2h0XzEgPSByZXF1aXJlKFwiLi9wcm9ncmFtcy9yYW5kb21UaWdodFwiKTtcclxuY29uc3QgY2lyY2xlXzEgPSByZXF1aXJlKFwiLi9wcm9ncmFtcy9jaXJjbGVcIik7XHJcbmNvbnN0IGRpYWdvbmFsXzEgPSByZXF1aXJlKFwiLi9wcm9ncmFtcy9kaWFnb25hbFwiKTtcclxuY29uc3QgbmVydmVzXzEgPSByZXF1aXJlKFwiLi9wcm9ncmFtcy9uZXJ2ZXNcIik7XHJcbmNvbnN0IGJsb2JzXzEgPSByZXF1aXJlKFwiLi9wcm9ncmFtcy9ibG9ic1wiKTtcclxuY29uc3QgY2VsbHNfMSA9IHJlcXVpcmUoXCIuL3Byb2dyYW1zL2NlbGxzXCIpO1xyXG5jb25zdCBhbnRzXzEgPSByZXF1aXJlKFwiLi9wcm9ncmFtcy9hbnRzXCIpO1xyXG5jb25zdCByaW5nc18xID0gcmVxdWlyZShcIi4vcHJvZ3JhbXMvcmluZ3NcIik7XHJcbmNvbnN0IHNxdWFyZV8xID0gcmVxdWlyZShcIi4vcHJvZ3JhbXMvc3F1YXJlXCIpO1xyXG5jb25zdCBjdXN0b21fMSA9IHJlcXVpcmUoXCIuL3Byb2dyYW1zL2N1c3RvbVwiKTtcclxuY29uc3QgcHJvZ3JhbXMgPSB7XHJcbiAgICByYW5kb206IHJhbmRvbV8xLnJhbmRvbSxcclxuICAgIHJhbmRvbVRpZ2h0OiByYW5kb21UaWdodF8xLnJhbmRvbVRpZ2h0LFxyXG4gICAgZGlhZ29uYWw6IGRpYWdvbmFsXzEuZGlhZ29uYWwsXHJcbiAgICBjaXJjbGU6IGNpcmNsZV8xLmNpcmNsZSxcclxuICAgIG5lcnZlczogbmVydmVzXzEubmVydmVzLFxyXG4gICAgYmxvYnM6IGJsb2JzXzEuYmxvYnMsXHJcbiAgICBjZWxsczogY2VsbHNfMS5jZWxscyxcclxuICAgIGFudHM6IGFudHNfMS5hbnRzLFxyXG4gICAgcmluZ3M6IHJpbmdzXzEucmluZ3MsXHJcbiAgICBzcXVhcmU6IHNxdWFyZV8xLnNxdWFyZSxcclxuICAgIGN1c3RvbTogY3VzdG9tXzEuY3VzdG9tLFxyXG59O1xyXG4vLyBDcmVhdGUgYSBmdW5jdGlvbiB0byBjaGFuZ2UgcHJvZ3JhbXNcclxubGV0IHN0b3BQcmV2O1xyXG5mdW5jdGlvbiBzZWxlY3QocHJvZ3JhbU5hbWUpIHtcclxuICAgIGNvbnN0IHByb2dyYW0gPSBwcm9ncmFtc1twcm9ncmFtTmFtZV07XHJcbiAgICBpZiAoIXByb2dyYW0pXHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgc3RvcFByZXYgPT09IG51bGwgfHwgc3RvcFByZXYgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHN0b3BQcmV2KCk7XHJcbiAgICBjb25zdCB7IGNhbnZhcywgc3RvcCB9ID0gcHJvZ3JhbSg5MDApO1xyXG4gICAgZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJib2R5XCIpWzBdLmFwcGVuZENoaWxkKGNhbnZhcyk7XHJcbiAgICBzdG9wUHJldiA9ICgpID0+IHtcclxuICAgICAgICBjYW52YXMucmVtb3ZlKCk7XHJcbiAgICAgICAgc3RvcCgpO1xyXG4gICAgfTtcclxufVxyXG4vLyBDcmVhdGUgYSBkcm9wZG93biB0byBzZWxlY3QgcHJvZ3JhbVxyXG5jb25zdCBzZWxlY3RDb250cm9sID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNlbGVjdFwiKTtcclxuT2JqZWN0LmtleXMocHJvZ3JhbXMpLmZvckVhY2gobmFtZSA9PiB7XHJcbiAgICB2YXIgb3B0aW9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcIm9wdGlvblwiKSwgdGV4dCA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKG5hbWUpO1xyXG4gICAgb3B0aW9uLmFwcGVuZENoaWxkKHRleHQpO1xyXG4gICAgc2VsZWN0Q29udHJvbC5hcHBlbmRDaGlsZChvcHRpb24pO1xyXG59KTtcclxuZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChzZWxlY3RDb250cm9sKTtcclxuc2VsZWN0Q29udHJvbC5hZGRFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsICgpID0+IHtcclxuICAgIHNlbGVjdChzZWxlY3RDb250cm9sLnZhbHVlKTtcclxufSk7XHJcbmNvbnN0IG5ld2xpbmUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYnJcIik7XHJcbmRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQobmV3bGluZSk7XHJcbi8vIEluaXRpYWxpemUgdGhlIGZpcnN0IHByb2dyYW1cclxuY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHByb2dyYW1zKTtcclxuc2VsZWN0KGtleXNbMF0pO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5leHBvcnRzLmFudHMgPSB2b2lkIDA7XHJcbmNvbnN0IGNyZWF0ZUFudFByb2dyYW1fMSA9IHJlcXVpcmUoXCIuLi9jcmVhdGVBbnRQcm9ncmFtXCIpO1xyXG5leHBvcnRzLmFudHMgPSBjcmVhdGVBbnRQcm9ncmFtXzEuY3JlYXRlQW50UHJvZ3JhbSh7XHJcbiAgICBhbnQ6IHtcclxuICAgICAgICBjb3VudDogMTAwMCxcclxuICAgICAgICBpbnRlbnNpdHk6IDEsXHJcbiAgICAgICAgc3BlZWQ6IDEsXHJcbiAgICAgICAgc3RlZXJTcGVlZDogMC4yLFxyXG4gICAgICAgIHNlbnNvclNpemU6IDMsXHJcbiAgICAgICAgc2Vuc29yQW5nbGU6IDAuNSxcclxuICAgICAgICBzZW5zb3JPZmZzZXQ6IDQsXHJcbiAgICAgICAgcmFuZG9tQm9yZGVyQm91bmNlOiB0cnVlLFxyXG4gICAgfSxcclxuICAgIHRyYWlsczoge1xyXG4gICAgICAgIGRpZmZ1c2VTcGVlZDogNWUtMixcclxuICAgICAgICBldmFwb3JhdGVTcGVlZDogMWUtMyxcclxuICAgICAgICBjb2xvcjogWzAuOCwgMC4zLCAwLjRdLFxyXG4gICAgfSxcclxuICAgIGluaXRpYWxpemU6ICgpID0+IFtNYXRoLnJhbmRvbSgpLCBNYXRoLnJhbmRvbSgpLCBNYXRoLnJhbmRvbSgpICogTWF0aC5QSSAqIDJdLFxyXG59KTtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuZXhwb3J0cy5ibG9icyA9IHZvaWQgMDtcclxuY29uc3QgY3JlYXRlQW50UHJvZ3JhbV8xID0gcmVxdWlyZShcIi4uL2NyZWF0ZUFudFByb2dyYW1cIik7XHJcbmV4cG9ydHMuYmxvYnMgPSBjcmVhdGVBbnRQcm9ncmFtXzEuY3JlYXRlQW50UHJvZ3JhbSh7XHJcbiAgICBhbnQ6IHtcclxuICAgICAgICBjb3VudDogMTAwMDAsXHJcbiAgICAgICAgaW50ZW5zaXR5OiAwLjMsXHJcbiAgICAgICAgc3BlZWQ6IDEsXHJcbiAgICAgICAgc3RlZXJTcGVlZDogMC41LFxyXG4gICAgICAgIHNlbnNvclNpemU6IDEwLFxyXG4gICAgICAgIHNlbnNvckFuZ2xlOiAxLFxyXG4gICAgICAgIHNlbnNvck9mZnNldDogNCxcclxuICAgICAgICByYW5kb21Cb3JkZXJCb3VuY2U6IHRydWUsXHJcbiAgICB9LFxyXG4gICAgdHJhaWxzOiB7XHJcbiAgICAgICAgZGlmZnVzZVNwZWVkOiAyZS0yLFxyXG4gICAgICAgIGV2YXBvcmF0ZVNwZWVkOiAxZS0zLFxyXG4gICAgICAgIGNvbG9yOiBbMC41LCAwLjUsIDFdLFxyXG4gICAgfSxcclxuICAgIGluaXRpYWxpemU6ICgpID0+IHtcclxuICAgICAgICBjb25zdCBkaXIgPSBNYXRoLnJhbmRvbSgpICogTWF0aC5QSSAqIDI7XHJcbiAgICAgICAgY29uc3QgZGlzdCA9IE1hdGgucmFuZG9tKCkgKiAwLjU7XHJcbiAgICAgICAgcmV0dXJuIFswLjUgLSBNYXRoLmNvcyhkaXIpICogZGlzdCwgMC41IC0gTWF0aC5zaW4oZGlyKSAqIGRpc3QsIGRpcl07XHJcbiAgICB9LFxyXG59KTtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuZXhwb3J0cy5jZWxscyA9IHZvaWQgMDtcclxuY29uc3QgY3JlYXRlQW50UHJvZ3JhbV8xID0gcmVxdWlyZShcIi4uL2NyZWF0ZUFudFByb2dyYW1cIik7XHJcbmV4cG9ydHMuY2VsbHMgPSBjcmVhdGVBbnRQcm9ncmFtXzEuY3JlYXRlQW50UHJvZ3JhbSh7XHJcbiAgICBhbnQ6IHtcclxuICAgICAgICBjb3VudDogMTAwMDAsXHJcbiAgICAgICAgaW50ZW5zaXR5OiAwLjMsXHJcbiAgICAgICAgc3BlZWQ6IDEsXHJcbiAgICAgICAgc3RlZXJTcGVlZDogMC41LFxyXG4gICAgICAgIHNlbnNvclNpemU6IDMsXHJcbiAgICAgICAgc2Vuc29yQW5nbGU6IDEsXHJcbiAgICAgICAgc2Vuc29yT2Zmc2V0OiA0LFxyXG4gICAgICAgIHJhbmRvbUJvcmRlckJvdW5jZTogdHJ1ZSxcclxuICAgIH0sXHJcbiAgICB0cmFpbHM6IHtcclxuICAgICAgICBkaWZmdXNlU3BlZWQ6IDJlLTIsXHJcbiAgICAgICAgZXZhcG9yYXRlU3BlZWQ6IDFlLTMsXHJcbiAgICAgICAgY29sb3I6IFswLjgsIDAuMywgMC40XSxcclxuICAgIH0sXHJcbiAgICBpbml0aWFsaXplOiAoKSA9PiBbTWF0aC5yYW5kb20oKSwgTWF0aC5yYW5kb20oKSwgTWF0aC5yYW5kb20oKSAqIE1hdGguUEkgKiAyXSxcclxufSk7XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmV4cG9ydHMuY2lyY2xlID0gdm9pZCAwO1xyXG5jb25zdCBjcmVhdGVBbnRQcm9ncmFtXzEgPSByZXF1aXJlKFwiLi4vY3JlYXRlQW50UHJvZ3JhbVwiKTtcclxuZXhwb3J0cy5jaXJjbGUgPSBjcmVhdGVBbnRQcm9ncmFtXzEuY3JlYXRlQW50UHJvZ3JhbSh7XHJcbiAgICBhbnQ6IHtcclxuICAgICAgICBjb3VudDogNTAwMDAsXHJcbiAgICAgICAgaW50ZW5zaXR5OiAwLjA1LFxyXG4gICAgICAgIHNwZWVkOiAyLFxyXG4gICAgICAgIHN0ZWVyU3BlZWQ6IDEsXHJcbiAgICAgICAgc2Vuc29yU2l6ZTogMixcclxuICAgICAgICBzZW5zb3JBbmdsZTogMC4yLFxyXG4gICAgICAgIHNlbnNvck9mZnNldDogMTAsXHJcbiAgICAgICAgcmFuZG9tQm9yZGVyQm91bmNlOiBmYWxzZSxcclxuICAgIH0sXHJcbiAgICB0cmFpbHM6IHtcclxuICAgICAgICBkaWZmdXNlU3BlZWQ6IDJlLTEsXHJcbiAgICAgICAgZXZhcG9yYXRlU3BlZWQ6IDJlLTMsXHJcbiAgICAgICAgY29sb3I6IFswLjUsIDAuNSwgMV0sXHJcbiAgICB9LFxyXG4gICAgaW5pdGlhbGl6ZTogKCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IGRpciA9IE1hdGgucmFuZG9tKCkgKiBNYXRoLlBJICogMjtcclxuICAgICAgICBjb25zdCBkaXN0ID0gTWF0aC5yYW5kb20oKSAqIDAuMztcclxuICAgICAgICByZXR1cm4gWzAuNSAtIE1hdGguY29zKGRpcikgKiBkaXN0LCAwLjUgLSBNYXRoLnNpbihkaXIpICogZGlzdCwgZGlyXTtcclxuICAgIH0sXHJcbn0pO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xyXG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9KTtcclxufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcclxuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XHJcbiAgICBvW2syXSA9IG1ba107XHJcbn0pKTtcclxudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0KSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XHJcbn0pIDogZnVuY3Rpb24obywgdikge1xyXG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xyXG59KTtcclxudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XHJcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xyXG4gICAgdmFyIHJlc3VsdCA9IHt9O1xyXG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XHJcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5leHBvcnRzLmN1c3RvbSA9IHZvaWQgMDtcclxuY29uc3QgZGF0ID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCJkYXQuZ3VpXCIpKTtcclxuY29uc3QgY3JlYXRlQW50UHJvZ3JhbV8xID0gcmVxdWlyZShcIi4uL2NyZWF0ZUFudFByb2dyYW1cIik7XHJcbmV4cG9ydHMuY3VzdG9tID0gKHNpemUpID0+IHtcclxuICAgIC8vIFRyYWNrIHRoZSB1cGRhdGVyIHRvIHRyYWNrIHdoZW4gcHJvcHMgY2hhbmdlXHJcbiAgICBsZXQgdXBkYXRlQ29uZmlnO1xyXG4gICAgY29uc3QgdXBkYXRlID0gKCkgPT4gdXBkYXRlQ29uZmlnID09PSBudWxsIHx8IHVwZGF0ZUNvbmZpZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogdXBkYXRlQ29uZmlnKCk7XHJcbiAgICBjb25zdCB1cGRhdGVSZXNldCA9ICgpID0+IHVwZGF0ZUNvbmZpZyA9PT0gbnVsbCB8fCB1cGRhdGVDb25maWcgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHVwZGF0ZUNvbmZpZyh0cnVlKTtcclxuICAgIC8vIFRoZSBpbml0aWFsIGNvbmZpZ1xyXG4gICAgY29uc3QgY29uZmlnID0ge1xyXG4gICAgICAgIGFudDoge1xyXG4gICAgICAgICAgICBjb3VudDogNTAwMDAsXHJcbiAgICAgICAgICAgIGludGVuc2l0eTogMC4wNSxcclxuICAgICAgICAgICAgc3BlZWQ6IDIsXHJcbiAgICAgICAgICAgIHN0ZWVyU3BlZWQ6IDEsXHJcbiAgICAgICAgICAgIHNlbnNvclNpemU6IDIsXHJcbiAgICAgICAgICAgIHNlbnNvckFuZ2xlOiAwLjIsXHJcbiAgICAgICAgICAgIHNlbnNvck9mZnNldDogMTAsXHJcbiAgICAgICAgICAgIHJhbmRvbUJvcmRlckJvdW5jZTogZmFsc2UsXHJcbiAgICAgICAgfSxcclxuICAgICAgICB0cmFpbHM6IHtcclxuICAgICAgICAgICAgZGlmZnVzZVNwZWVkOiAyZS0xLFxyXG4gICAgICAgICAgICBldmFwb3JhdGVTcGVlZDogMmUtMyxcclxuICAgICAgICAgICAgY29sb3I6IFswLjUsIDAuNSwgMV0sXHJcbiAgICAgICAgfSxcclxuICAgICAgICBpbml0aWFsaXplOiAoKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGRpciA9IE1hdGgucmFuZG9tKCkgKiBNYXRoLlBJICogMjtcclxuICAgICAgICAgICAgY29uc3QgZGlzdCA9IE1hdGgucmFuZG9tKCkgKiAwLjM7XHJcbiAgICAgICAgICAgIHJldHVybiBbMC41IC0gTWF0aC5jb3MoZGlyKSAqIGRpc3QsIDAuNSAtIE1hdGguc2luKGRpcikgKiBkaXN0LCBkaXJdO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgcmVzdGFydDogdXBkYXRlUmVzZXQsXHJcbiAgICB9O1xyXG4gICAgLy8gQ3JlYXRlIHRoZSBHVUlcclxuICAgIGNvbnN0IGd1aSA9IG5ldyBkYXQuR1VJKHsgbmFtZTogXCJzaGFkZXIgcHJvcHNcIiB9KTtcclxuICAgIGd1aS5hZGQoY29uZmlnLCBcInJlc3RhcnRcIik7XHJcbiAgICAvLyBBZGQgYW50IHByb3BlcnRpZXNcclxuICAgIGNvbnN0IGFudCA9IGd1aS5hZGRGb2xkZXIoXCJhbnRzXCIpO1xyXG4gICAgYW50LmFkZChjb25maWcuYW50LCBcImNvdW50XCIsIDEsIDFlNSwgMSkub25DaGFuZ2UodXBkYXRlUmVzZXQpO1xyXG4gICAgYW50LmFkZChjb25maWcuYW50LCBcImludGVuc2l0eVwiLCAwLCAxKTtcclxuICAgIGFudC5hZGQoY29uZmlnLmFudCwgXCJzcGVlZFwiLCAwLjAxLCA1KS5vbkNoYW5nZSh1cGRhdGUpO1xyXG4gICAgYW50LmFkZChjb25maWcuYW50LCBcInN0ZWVyU3BlZWRcIiwgMWUtMywgMikub25DaGFuZ2UodXBkYXRlKTtcclxuICAgIGFudC5hZGQoY29uZmlnLmFudCwgXCJzZW5zb3JTaXplXCIsIDEsIDEwLCAxKS5vbkNoYW5nZSh1cGRhdGUpO1xyXG4gICAgYW50LmFkZChjb25maWcuYW50LCBcInNlbnNvckFuZ2xlXCIsIDAuMDUsIDIpLm9uQ2hhbmdlKHVwZGF0ZSk7XHJcbiAgICBhbnQuYWRkKGNvbmZpZy5hbnQsIFwic2Vuc29yT2Zmc2V0XCIsIDEsIDEwKS5vbkNoYW5nZSh1cGRhdGUpO1xyXG4gICAgYW50LmFkZChjb25maWcuYW50LCBcInJhbmRvbUJvcmRlckJvdW5jZVwiKS5vbkNoYW5nZSh1cGRhdGUpO1xyXG4gICAgLy8gQWRkIHRyYWlscyBwcm9wZXJ0aWVzXHJcbiAgICBjb25zdCB0cmFpbHMgPSBndWkuYWRkRm9sZGVyKFwidHJhaWxzXCIpO1xyXG4gICAgdHJhaWxzLmFkZChjb25maWcudHJhaWxzLCBcImRpZmZ1c2VTcGVlZFwiLCAxZS0yLCAwLjk5OSkub25DaGFuZ2UodXBkYXRlKTtcclxuICAgIHRyYWlscy5hZGQoY29uZmlnLnRyYWlscywgXCJldmFwb3JhdGVTcGVlZFwiLCAyZS0zLCAwLjEpLm9uQ2hhbmdlKHVwZGF0ZSk7XHJcbiAgICBjb25zdCBpbnRDb2xvciA9IHsgY29sb3I6IFsxMjgsIDEyOCwgMjU1XSB9O1xyXG4gICAgdHJhaWxzLmFkZENvbG9yKGludENvbG9yLCBcImNvbG9yXCIpLm9uQ2hhbmdlKCgpID0+IHtcclxuICAgICAgICBjb25zdCBjID0gaW50Q29sb3IuY29sb3I7XHJcbiAgICAgICAgY29uZmlnLnRyYWlscy5jb2xvciA9IFtjWzBdIC8gMjU1LCBjWzFdIC8gMjU1LCBjWzJdIC8gMjU1XTtcclxuICAgICAgICB1cGRhdGUoKTtcclxuICAgIH0pO1xyXG4gICAgLy8gSW5pdGlhbGl6ZSBvcHRpb25zXHJcbiAgICBjb25zdCBpbml0ID0gZ3VpLmFkZEZvbGRlcihcImluaXRcIik7XHJcbiAgICBjb25zdCBpbml0Q29uZmlnID0geyBpbml0aWFsaXplOiBcImNpcmNsZVwiLCBzaXplOiAwLjMgfTtcclxuICAgIGNvbnN0IHVwZGF0ZUluaXQgPSAoKSA9PiB7XHJcbiAgICAgICAgY29uZmlnLmluaXRpYWxpemUgPSBpbml0T3B0aW9uc1tpbml0Q29uZmlnLmluaXRpYWxpemVdKGluaXRDb25maWcuc2l6ZSk7XHJcbiAgICAgICAgdXBkYXRlUmVzZXQoKTtcclxuICAgIH07XHJcbiAgICBpbml0LmFkZChpbml0Q29uZmlnLCBcImluaXRpYWxpemVcIiwgT2JqZWN0LmtleXMoaW5pdE9wdGlvbnMpKS5vbkNoYW5nZSh1cGRhdGVJbml0KTtcclxuICAgIGluaXQuYWRkKGluaXRDb25maWcsIFwic2l6ZVwiLCAwLCAxKS5vbkNoYW5nZSh1cGRhdGVJbml0KTtcclxuICAgIC8vIFdyYXAgdGhlIG9yaWdpbmFsIHByb2dyYW0gYW5kIGFkZCB0aGUgY29udHJvbHNcclxuICAgIGNvbnN0IHsgY2FudmFzLCBzdGFydCwgc3RvcCB9ID0gY3JlYXRlQW50UHJvZ3JhbV8xLmNyZWF0ZUFudFByb2dyYW0oY29uZmlnLCB1ID0+IHtcclxuICAgICAgICB1cGRhdGVDb25maWcgPSB1O1xyXG4gICAgfSkoc2l6ZSk7XHJcbiAgICBjb25zdCBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xyXG4gICAgZGl2LmFwcGVuZENoaWxkKGNhbnZhcyk7XHJcbiAgICBkaXYuYXBwZW5kQ2hpbGQoZ3VpLmRvbUVsZW1lbnQpO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBjYW52YXM6IGRpdixcclxuICAgICAgICBzdGFydCxcclxuICAgICAgICBzdG9wLFxyXG4gICAgfTtcclxufTtcclxuLy8gVGhlIGluaXRpYWxpemF0aW9uIG9wdGlvbnNcclxuY29uc3QgaW5pdE9wdGlvbnMgPSB7XHJcbiAgICBjaXJjbGU6IHNpemUgPT4gKCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IGRpciA9IE1hdGgucmFuZG9tKCkgKiBNYXRoLlBJICogMjtcclxuICAgICAgICBjb25zdCBkaXN0ID0gKChNYXRoLnJhbmRvbSgpICogMiAtIDEpICogc2l6ZSkgLyAyO1xyXG4gICAgICAgIHJldHVybiBbMC41ICsgTWF0aC5jb3MoZGlyKSAqIGRpc3QsIDAuNSArIE1hdGguc2luKGRpcikgKiBkaXN0LCBkaXJdO1xyXG4gICAgfSxcclxuICAgIGNpcmNsZUluOiBzaXplID0+ICgpID0+IHtcclxuICAgICAgICBjb25zdCBkaXIgPSBNYXRoLnJhbmRvbSgpICogTWF0aC5QSSAqIDI7XHJcbiAgICAgICAgY29uc3QgZGlzdCA9ICgtTWF0aC5yYW5kb20oKSAqIHNpemUpIC8gMjtcclxuICAgICAgICByZXR1cm4gWzAuNSArIE1hdGguY29zKGRpcikgKiBkaXN0LCAwLjUgKyBNYXRoLnNpbihkaXIpICogZGlzdCwgZGlyXTtcclxuICAgIH0sXHJcbiAgICBjaXJjbGVPdXQ6IHNpemUgPT4gKCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IGRpciA9IE1hdGgucmFuZG9tKCkgKiBNYXRoLlBJICogMjtcclxuICAgICAgICBjb25zdCBkaXN0ID0gKE1hdGgucmFuZG9tKCkgKiBzaXplKSAvIDI7XHJcbiAgICAgICAgcmV0dXJuIFswLjUgKyBNYXRoLmNvcyhkaXIpICogZGlzdCwgMC41ICsgTWF0aC5zaW4oZGlyKSAqIGRpc3QsIGRpcl07XHJcbiAgICB9LFxyXG4gICAgY2lyY2xlUmluZzogc2l6ZSA9PiAoKSA9PiB7XHJcbiAgICAgICAgY29uc3QgZGlyID0gTWF0aC5yYW5kb20oKSAqIE1hdGguUEkgKiAyO1xyXG4gICAgICAgIGNvbnN0IGRpc3QgPSAoTWF0aC5yYW5kb20oKSAqIHNpemUpIC8gMjtcclxuICAgICAgICByZXR1cm4gW1xyXG4gICAgICAgICAgICAwLjUgKyBNYXRoLmNvcyhkaXIpICogZGlzdCxcclxuICAgICAgICAgICAgMC41ICsgTWF0aC5zaW4oZGlyKSAqIGRpc3QsXHJcbiAgICAgICAgICAgIGRpciArIE1hdGguUEkgLyAyLFxyXG4gICAgICAgIF07XHJcbiAgICB9LFxyXG4gICAgY2lyY2xlUmluZ0R1YWw6IHNpemUgPT4gKCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IGRpciA9IE1hdGgucmFuZG9tKCkgKiBNYXRoLlBJICogMjtcclxuICAgICAgICBjb25zdCBkaXN0ID0gKE1hdGgucmFuZG9tKCkgKiBzaXplKSAvIDI7XHJcbiAgICAgICAgY29uc3Qgc2lkZSA9IE1hdGgucmFuZG9tKCkgPiAwLjUgPyAxIDogLTE7XHJcbiAgICAgICAgcmV0dXJuIFtcclxuICAgICAgICAgICAgMC41ICsgTWF0aC5jb3MoZGlyKSAqIGRpc3QsXHJcbiAgICAgICAgICAgIDAuNSArIE1hdGguc2luKGRpcikgKiBkaXN0LFxyXG4gICAgICAgICAgICBkaXIgKyAoc2lkZSAqIE1hdGguUEkpIC8gMixcclxuICAgICAgICBdO1xyXG4gICAgfSxcclxuICAgIGNpcmNsZU91dGxpbmU6IHNpemUgPT4gKCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IGRpciA9IE1hdGgucmFuZG9tKCkgKiBNYXRoLlBJICogMjtcclxuICAgICAgICBjb25zdCBkaXN0ID0gKChNYXRoLnJvdW5kKE1hdGgucmFuZG9tKCkpICogMiAtIDEpICogc2l6ZSkgLyAyO1xyXG4gICAgICAgIHJldHVybiBbMC41ICsgTWF0aC5jb3MoZGlyKSAqIGRpc3QsIDAuNSArIE1hdGguc2luKGRpcikgKiBkaXN0LCBkaXJdO1xyXG4gICAgfSxcclxuICAgIGNpcmNsZU91dGxpbmVJbjogc2l6ZSA9PiAoKSA9PiB7XHJcbiAgICAgICAgY29uc3QgZGlyID0gTWF0aC5yYW5kb20oKSAqIE1hdGguUEkgKiAyO1xyXG4gICAgICAgIGNvbnN0IGRpc3QgPSAtc2l6ZSAvIDI7XHJcbiAgICAgICAgcmV0dXJuIFswLjUgKyBNYXRoLmNvcyhkaXIpICogZGlzdCwgMC41ICsgTWF0aC5zaW4oZGlyKSAqIGRpc3QsIGRpcl07XHJcbiAgICB9LFxyXG4gICAgY2lyY2xlT3V0bGluZU91dDogc2l6ZSA9PiAoKSA9PiB7XHJcbiAgICAgICAgY29uc3QgZGlyID0gTWF0aC5yYW5kb20oKSAqIE1hdGguUEkgKiAyO1xyXG4gICAgICAgIGNvbnN0IGRpc3QgPSBzaXplIC8gMjtcclxuICAgICAgICByZXR1cm4gWzAuNSArIE1hdGguY29zKGRpcikgKiBkaXN0LCAwLjUgKyBNYXRoLnNpbihkaXIpICogZGlzdCwgZGlyXTtcclxuICAgIH0sXHJcbiAgICBjaXJjbGVPdXRsaW5lUmluZzogc2l6ZSA9PiAoKSA9PiB7XHJcbiAgICAgICAgY29uc3QgZGlyID0gTWF0aC5yYW5kb20oKSAqIE1hdGguUEkgKiAyO1xyXG4gICAgICAgIGNvbnN0IGRpc3QgPSBzaXplIC8gMjtcclxuICAgICAgICByZXR1cm4gW1xyXG4gICAgICAgICAgICAwLjUgKyBNYXRoLmNvcyhkaXIpICogZGlzdCxcclxuICAgICAgICAgICAgMC41ICsgTWF0aC5zaW4oZGlyKSAqIGRpc3QsXHJcbiAgICAgICAgICAgIGRpciArIE1hdGguUEkgLyAyLFxyXG4gICAgICAgIF07XHJcbiAgICB9LFxyXG4gICAgY2lyY2xlT3V0bGluZVJpbmdEdWFsOiBzaXplID0+ICgpID0+IHtcclxuICAgICAgICBjb25zdCBkaXIgPSBNYXRoLnJhbmRvbSgpICogTWF0aC5QSSAqIDI7XHJcbiAgICAgICAgY29uc3QgZGlzdCA9IHNpemUgLyAyO1xyXG4gICAgICAgIGNvbnN0IHNpZGUgPSBNYXRoLnJhbmRvbSgpID4gMC41ID8gMSA6IC0xO1xyXG4gICAgICAgIHJldHVybiBbXHJcbiAgICAgICAgICAgIDAuNSArIE1hdGguY29zKGRpcikgKiBkaXN0LFxyXG4gICAgICAgICAgICAwLjUgKyBNYXRoLnNpbihkaXIpICogZGlzdCxcclxuICAgICAgICAgICAgZGlyICsgKHNpZGUgKiBNYXRoLlBJKSAvIDIsXHJcbiAgICAgICAgXTtcclxuICAgIH0sXHJcbiAgICBmdWxsOiBzaXplID0+ICgpID0+IFtNYXRoLnJhbmRvbSgpLCBNYXRoLnJhbmRvbSgpLCBNYXRoLnJhbmRvbSgpICogTWF0aC5QSSAqIDJdLFxyXG59O1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5leHBvcnRzLmRpYWdvbmFsID0gdm9pZCAwO1xyXG5jb25zdCBjcmVhdGVBbnRQcm9ncmFtXzEgPSByZXF1aXJlKFwiLi4vY3JlYXRlQW50UHJvZ3JhbVwiKTtcclxuZXhwb3J0cy5kaWFnb25hbCA9IGNyZWF0ZUFudFByb2dyYW1fMS5jcmVhdGVBbnRQcm9ncmFtKHtcclxuICAgIGFudDoge1xyXG4gICAgICAgIGNvdW50OiAxMDAwMCxcclxuICAgICAgICBpbnRlbnNpdHk6IDAuMSxcclxuICAgICAgICBzcGVlZDogMixcclxuICAgICAgICBzdGVlclNwZWVkOiAwLjEsXHJcbiAgICAgICAgc2Vuc29yU2l6ZTogMixcclxuICAgICAgICBzZW5zb3JBbmdsZTogMC4yLFxyXG4gICAgICAgIHNlbnNvck9mZnNldDogMTAsXHJcbiAgICAgICAgcmFuZG9tQm9yZGVyQm91bmNlOiB0cnVlLFxyXG4gICAgfSxcclxuICAgIHRyYWlsczoge1xyXG4gICAgICAgIGRpZmZ1c2VTcGVlZDogMmUtMSxcclxuICAgICAgICBldmFwb3JhdGVTcGVlZDogMWUtMyxcclxuICAgICAgICBjb2xvcjogWzEsIDAsIDBdLFxyXG4gICAgfSxcclxuICAgIGluaXRpYWxpemU6ICgpID0+IHtcclxuICAgICAgICBjb25zdCBkaXIgPSBNYXRoLnJhbmRvbSgpICogTWF0aC5QSSAqIDI7XHJcbiAgICAgICAgY29uc3QgZGlzdCA9IE1hdGgucmFuZG9tKCkgKiAwLjM7XHJcbiAgICAgICAgcmV0dXJuIFswLjUgLSBNYXRoLmNvcyhkaXIpICogZGlzdCwgMC41IC0gTWF0aC5jb3MoZGlyKSAqIGRpc3QsIGRpcl07XHJcbiAgICB9LFxyXG59KTtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuZXhwb3J0cy5uZXJ2ZXMgPSB2b2lkIDA7XHJcbmNvbnN0IGNyZWF0ZUFudFByb2dyYW1fMSA9IHJlcXVpcmUoXCIuLi9jcmVhdGVBbnRQcm9ncmFtXCIpO1xyXG5leHBvcnRzLm5lcnZlcyA9IGNyZWF0ZUFudFByb2dyYW1fMS5jcmVhdGVBbnRQcm9ncmFtKHtcclxuICAgIGFudDoge1xyXG4gICAgICAgIGNvdW50OiA1MDAwMCxcclxuICAgICAgICBpbnRlbnNpdHk6IDAuMDEsXHJcbiAgICAgICAgc3BlZWQ6IDIsXHJcbiAgICAgICAgc3RlZXJTcGVlZDogMSxcclxuICAgICAgICBzZW5zb3JTaXplOiAyLFxyXG4gICAgICAgIHNlbnNvckFuZ2xlOiAwLjIsXHJcbiAgICAgICAgc2Vuc29yT2Zmc2V0OiAxMCxcclxuICAgICAgICByYW5kb21Cb3JkZXJCb3VuY2U6IHRydWUsXHJcbiAgICB9LFxyXG4gICAgdHJhaWxzOiB7XHJcbiAgICAgICAgZGlmZnVzZVNwZWVkOiAxZS0yLFxyXG4gICAgICAgIGV2YXBvcmF0ZVNwZWVkOiAxZS0zLFxyXG4gICAgICAgIGNvbG9yOiBbMC4zLCAwLjQsIDFdLFxyXG4gICAgfSxcclxuICAgIGluaXRpYWxpemU6ICgpID0+IHtcclxuICAgICAgICBjb25zdCBkaXIgPSBNYXRoLnJhbmRvbSgpICogTWF0aC5QSSAqIDI7XHJcbiAgICAgICAgY29uc3QgZGlzdCA9IE1hdGgucmFuZG9tKCkgKiAwLjU7XHJcbiAgICAgICAgcmV0dXJuIFswLjUgLSBNYXRoLmNvcyhkaXIpICogZGlzdCwgMC41IC0gTWF0aC5zaW4oZGlyKSAqIGRpc3QsIGRpcl07XHJcbiAgICB9LFxyXG59KTtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuZXhwb3J0cy5yYW5kb20gPSB2b2lkIDA7XHJcbmNvbnN0IGNyZWF0ZUFudFByb2dyYW1fMSA9IHJlcXVpcmUoXCIuLi9jcmVhdGVBbnRQcm9ncmFtXCIpO1xyXG5leHBvcnRzLnJhbmRvbSA9IGNyZWF0ZUFudFByb2dyYW1fMS5jcmVhdGVBbnRQcm9ncmFtKHtcclxuICAgIGFudDoge1xyXG4gICAgICAgIGNvdW50OiAxMDAwMCxcclxuICAgICAgICBpbnRlbnNpdHk6IDAuMSxcclxuICAgICAgICBzcGVlZDogMSxcclxuICAgICAgICBzdGVlclNwZWVkOiAwLjEsXHJcbiAgICAgICAgc2Vuc29yU2l6ZTogMSxcclxuICAgICAgICBzZW5zb3JBbmdsZTogMC40LFxyXG4gICAgICAgIHNlbnNvck9mZnNldDogMTAsXHJcbiAgICAgICAgcmFuZG9tQm9yZGVyQm91bmNlOiBmYWxzZSxcclxuICAgIH0sXHJcbiAgICB0cmFpbHM6IHtcclxuICAgICAgICBkaWZmdXNlU3BlZWQ6IDJlLTEsXHJcbiAgICAgICAgZXZhcG9yYXRlU3BlZWQ6IDFlLTMsXHJcbiAgICAgICAgY29sb3I6IFswLjUsIDEsIDAuNV0sXHJcbiAgICB9LFxyXG4gICAgaW5pdGlhbGl6ZTogKCkgPT4gW01hdGgucmFuZG9tKCksIE1hdGgucmFuZG9tKCksIE1hdGgucmFuZG9tKCkgKiBNYXRoLlBJICogMl0sXHJcbn0pO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5leHBvcnRzLnJhbmRvbVRpZ2h0ID0gdm9pZCAwO1xyXG5jb25zdCBjcmVhdGVBbnRQcm9ncmFtXzEgPSByZXF1aXJlKFwiLi4vY3JlYXRlQW50UHJvZ3JhbVwiKTtcclxuZXhwb3J0cy5yYW5kb21UaWdodCA9IGNyZWF0ZUFudFByb2dyYW1fMS5jcmVhdGVBbnRQcm9ncmFtKHtcclxuICAgIGFudDoge1xyXG4gICAgICAgIGNvdW50OiA1MDAwMCxcclxuICAgICAgICBpbnRlbnNpdHk6IDAuMDUsXHJcbiAgICAgICAgc3BlZWQ6IDIsXHJcbiAgICAgICAgc3RlZXJTcGVlZDogMC4xLFxyXG4gICAgICAgIHNlbnNvclNpemU6IDIsXHJcbiAgICAgICAgc2Vuc29yQW5nbGU6IDAuMixcclxuICAgICAgICBzZW5zb3JPZmZzZXQ6IDEwLFxyXG4gICAgICAgIHJhbmRvbUJvcmRlckJvdW5jZTogZmFsc2UsXHJcbiAgICB9LFxyXG4gICAgdHJhaWxzOiB7XHJcbiAgICAgICAgZGlmZnVzZVNwZWVkOiAyZS0yLFxyXG4gICAgICAgIGV2YXBvcmF0ZVNwZWVkOiA1ZS0zLFxyXG4gICAgICAgIGNvbG9yOiBbMC41LCAxLCAwLjVdLFxyXG4gICAgfSxcclxuICAgIGluaXRpYWxpemU6ICgpID0+IFtNYXRoLnJhbmRvbSgpLCBNYXRoLnJhbmRvbSgpLCBNYXRoLnJhbmRvbSgpICogTWF0aC5QSSAqIDJdLFxyXG59KTtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuZXhwb3J0cy5yaW5ncyA9IHZvaWQgMDtcclxuY29uc3QgY3JlYXRlQW50UHJvZ3JhbV8xID0gcmVxdWlyZShcIi4uL2NyZWF0ZUFudFByb2dyYW1cIik7XHJcbmV4cG9ydHMucmluZ3MgPSBjcmVhdGVBbnRQcm9ncmFtXzEuY3JlYXRlQW50UHJvZ3JhbSh7XHJcbiAgICBhbnQ6IHtcclxuICAgICAgICBjb3VudDogNTAwMDAsXHJcbiAgICAgICAgaW50ZW5zaXR5OiAwLjEsXHJcbiAgICAgICAgc3BlZWQ6IDAuNSxcclxuICAgICAgICBzdGVlclNwZWVkOiAwLjQsXHJcbiAgICAgICAgc2Vuc29yU2l6ZTogMixcclxuICAgICAgICBzZW5zb3JBbmdsZTogMS4yLFxyXG4gICAgICAgIHNlbnNvck9mZnNldDogMTAsXHJcbiAgICAgICAgcmFuZG9tQm9yZGVyQm91bmNlOiB0cnVlLFxyXG4gICAgfSxcclxuICAgIHRyYWlsczoge1xyXG4gICAgICAgIGRpZmZ1c2VTcGVlZDogMWUtMSxcclxuICAgICAgICBldmFwb3JhdGVTcGVlZDogMWUtMixcclxuICAgICAgICBjb2xvcjogWzEsIDEsIDFdLFxyXG4gICAgfSxcclxuICAgIGluaXRpYWxpemU6ICgpID0+IHtcclxuICAgICAgICBjb25zdCBkaXIgPSBNYXRoLnJhbmRvbSgpICogTWF0aC5QSSAqIDI7XHJcbiAgICAgICAgY29uc3QgZGlzdCA9IE1hdGgucmFuZG9tKCkgKiAwLjI1O1xyXG4gICAgICAgIHJldHVybiBbMC41IC0gTWF0aC5jb3MoZGlyKSAqIGRpc3QsIDAuNSAtIE1hdGguc2luKGRpcikgKiBkaXN0LCBkaXJdO1xyXG4gICAgfSxcclxufSk7XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmV4cG9ydHMuc3F1YXJlID0gdm9pZCAwO1xyXG5jb25zdCBjcmVhdGVBbnRQcm9ncmFtXzEgPSByZXF1aXJlKFwiLi4vY3JlYXRlQW50UHJvZ3JhbVwiKTtcclxuZXhwb3J0cy5zcXVhcmUgPSBjcmVhdGVBbnRQcm9ncmFtXzEuY3JlYXRlQW50UHJvZ3JhbSh7XHJcbiAgICBhbnQ6IHtcclxuICAgICAgICBjb3VudDogNzAwMDAsXHJcbiAgICAgICAgaW50ZW5zaXR5OiAwLjA1LFxyXG4gICAgICAgIHNwZWVkOiAyLFxyXG4gICAgICAgIHN0ZWVyU3BlZWQ6IDAuMDUsXHJcbiAgICAgICAgc2Vuc29yU2l6ZTogMyxcclxuICAgICAgICBzZW5zb3JBbmdsZTogMC42LFxyXG4gICAgICAgIHNlbnNvck9mZnNldDogMjAsXHJcbiAgICAgICAgcmFuZG9tQm9yZGVyQm91bmNlOiBmYWxzZSxcclxuICAgIH0sXHJcbiAgICB0cmFpbHM6IHtcclxuICAgICAgICBkaWZmdXNlU3BlZWQ6IDVlLTIsXHJcbiAgICAgICAgZXZhcG9yYXRlU3BlZWQ6IDVlLTMsXHJcbiAgICAgICAgY29sb3I6IFswLjUsIDAsIDFdLFxyXG4gICAgfSxcclxuICAgIGluaXRpYWxpemU6ICgpID0+IHtcclxuICAgICAgICBjb25zdCBwID0gMC4zO1xyXG4gICAgICAgIGNvbnN0IGF4aXMgPSBNYXRoLnJhbmRvbSgpID4gMC41O1xyXG4gICAgICAgIGNvbnN0IHNpZGUgPSBNYXRoLnJhbmRvbSgpID4gMC41O1xyXG4gICAgICAgIGNvbnN0IHBvcyA9IE1hdGgucmFuZG9tKCk7XHJcbiAgICAgICAgY29uc3QgZGlyID0gTWF0aC5yYW5kb20oKSAqIE1hdGguUEkgKiAyO1xyXG4gICAgICAgIHJldHVybiBbXHJcbiAgICAgICAgICAgIDAuNSArICgoYXhpcyA/IHBvcyA6IHNpZGUgPyAxIDogMCkgKiAyIC0gMSkgKiBwLFxyXG4gICAgICAgICAgICAwLjUgKyAoKCFheGlzID8gcG9zIDogc2lkZSA/IDEgOiAwKSAqIDIgLSAxKSAqIHAsXHJcbiAgICAgICAgICAgIGRpcixcclxuICAgICAgICBdO1xyXG4gICAgfSxcclxufSk7XHJcbiJdLCJzb3VyY2VSb290IjoiIn0=